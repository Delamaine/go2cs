// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o h2_bundle.go -prefix http2 -underscore golang.org/x/net/http2

// Package http2 implements the HTTP/2 protocol.
//
// This package is low-level and intended to be used directly by very
// few people. Most users will use it indirectly through the automatic
// use by the net/http package (from Go 1.6 and later).
// For use in earlier Go versions see ConfigureServer. (Transport support
// requires Go 1.6 or later)
//
// See https://http2.github.io/ for more information on HTTP/2.
//
// See https://http2.golang.org/ for a test server running this code.
//

// package http -- go2cs converted at 2020 August 29 08:33:16 UTC
// import "net/http" ==> using http = go.net.http_package
// Original source: C:\Go\src\net\http\h2_bundle.go
using bufio = go.bufio_package;
using bytes = go.bytes_package;
using gzip = go.compress.gzip_package;
using context = go.context_package;
using rand = go.crypto.rand_package;
using tls = go.crypto.tls_package;
using binary = go.encoding.binary_package;
using errors = go.errors_package;
using fmt = go.fmt_package;
using io = go.io_package;
using ioutil = go.io.ioutil_package;
using log = go.log_package;
using math = go.math_package;
using mathrand = go.math.rand_package;
using net = go.net_package;
using httptrace = go.net.http.httptrace_package;
using textproto = go.net.textproto_package;
using url = go.net.url_package;
using os = go.os_package;
using reflect = go.reflect_package;
using runtime = go.runtime_package;
using sort = go.sort_package;
using strconv = go.strconv_package;
using strings = go.strings_package;
using sync = go.sync_package;
using time = go.time_package;

using hpack = go.golang_org.x.net.http2.hpack_package;
using idna = go.golang_org.x.net.idna_package;
using httplex = go.golang_org.x.net.lex.httplex_package;
using static go.builtin;
using System.Threading;
using System;

namespace go {
namespace net
{
    public static partial class http_package
    {
        // A list of the possible cipher suite ids. Taken from
        // http://www.iana.org/assignments/tls-parameters/tls-parameters.txt
        private static readonly ushort http2cipher_TLS_NULL_WITH_NULL_NULL = 0x0000UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_MD5 = 0x0001UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_SHA = 0x0002UL;
        private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_RC4_128_MD5 = 0x0004UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_RC4_128_SHA = 0x0005UL;
        private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007UL;
        private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_DES_CBC_SHA = 0x0009UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000AUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000BUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000CUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000DUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000EUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000FUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016UL;
        private static readonly ushort http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018UL;
        private static readonly ushort http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA = 0x001AUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001BUL; 
        // Reserved uint16 =  0x001C-1D
        private static readonly ushort http2cipher_TLS_KRB5_WITH_DES_CBC_SHA = 0x001EUL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA = 0x001FUL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_RC4_128_SHA = 0x0020UL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA = 0x0021UL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 = 0x0022UL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = 0x0023UL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_RC4_128_MD5 = 0x0024UL;
        private static readonly ushort http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 = 0x0025UL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = 0x0026UL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = 0x0027UL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA = 0x0028UL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = 0x0029UL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = 0x002AUL;
        private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = 0x002BUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA = 0x002CUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA = 0x002DUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA = 0x002EUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA = 0x002FUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003AUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_SHA256 = 0x003BUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003CUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003DUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 0x003EUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 0x003FUL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 0x0040UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0041UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0042UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0043UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0044UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0045UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = 0x0046UL; 
        // Reserved uint16 =  0x0047-4F
        // Reserved uint16 =  0x0050-58
        // Reserved uint16 =  0x0059-5C
        // Unassigned uint16 =  0x005D-5F
        // Reserved uint16 =  0x0060-66
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 0x0068UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 0x0069UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 0x006AUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006BUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 0x006CUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 0x006DUL; 
        // Unassigned uint16 =  0x006E-83
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0084UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0085UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0086UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0087UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0088UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = 0x0089UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_RC4_128_SHA = 0x008AUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008BUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA = 0x008CUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA = 0x008DUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008EUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008FUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_SEED_CBC_SHA = 0x0096UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA = 0x0097UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA = 0x0098UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA = 0x0099UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA = 0x009AUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA = 0x009BUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009CUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009DUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009EUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009FUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 0x00A0UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 0x00A1UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 0x00A2UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 0x00A3UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 0x00A4UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 0x00A5UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 0x00A6UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 0x00A7UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 = 0x00A8UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 = 0x00A9UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 0x00AAUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 0x00ABUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 0x00ACUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 0x00ADUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 = 0x00AEUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 = 0x00AFUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA256 = 0x00B0UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA384 = 0x00B1UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 0x00B2UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 0x00B3UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 = 0x00B4UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 = 0x00B5UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 0x00B6UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 0x00B7UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 = 0x00B8UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 = 0x00B9UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BAUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BBUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BCUL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BDUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BEUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BFUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C0UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C1UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C2UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C3UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C4UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C5UL; 
        // Unassigned uint16 =  0x00C6-FE
        private static readonly ushort http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FFUL; 
        // Unassigned uint16 =  0x01-55,*
        private static readonly ushort http2cipher_TLS_FALLBACK_SCSV = 0x5600UL; 
        // Unassigned                                   uint16 = 0x5601 - 0xC000
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00AUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00BUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00CUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00DUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00EUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00FUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014UL;
        private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_NULL_SHA = 0xC015UL;
        private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016UL;
        private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017UL;
        private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018UL;
        private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019UL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01AUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01BUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01CUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01DUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01EUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01FUL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020UL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021UL;
        private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02AUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02BUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02CUL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02DUL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02EUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02FUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA = 0xC033UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 0xC034UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 0xC035UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 0xC036UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 0xC037UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 0xC038UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA = 0xC039UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 = 0xC03AUL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 = 0xC03BUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC03CUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC03DUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = 0xC03EUL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = 0xC03FUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC040UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC041UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = 0xC042UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = 0xC043UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC044UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC045UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = 0xC046UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = 0xC047UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = 0xC048UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = 0xC049UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = 0xC04AUL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = 0xC04BUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC04CUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC04DUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC04EUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC04FUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC050UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC051UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC052UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC053UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC054UL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC055UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = 0xC056UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = 0xC057UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = 0xC058UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = 0xC059UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = 0xC05AUL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = 0xC05BUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = 0xC05CUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = 0xC05DUL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = 0xC05EUL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = 0xC05FUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC060UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC061UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC062UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC063UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC064UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC065UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC066UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC067UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC068UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC069UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06AUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06BUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06CUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06DUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06EUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06FUL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC070UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC071UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC072UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC073UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC074UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC075UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC076UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC077UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC078UL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC079UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07AUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07BUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07CUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07DUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07EUL;
        private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07FUL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC080UL;
        private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC081UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC082UL;
        private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC083UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = 0xC084UL;
        private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = 0xC085UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC086UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC087UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC088UL;
        private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC089UL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08AUL;
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08BUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08CUL;
        private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08DUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08EUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08FUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC090UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC091UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC092UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC093UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC094UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC095UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC096UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC097UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC098UL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC099UL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC09AUL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC09BUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CCM = 0xC09CUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CCM = 0xC09DUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM = 0xC09EUL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM = 0xC09FUL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CCM_8 = 0xC0A0UL;
        private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CCM_8 = 0xC0A1UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xC0A2UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xC0A3UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CCM = 0xC0A4UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CCM = 0xC0A5UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM = 0xC0A6UL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM = 0xC0A7UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CCM_8 = 0xC0A8UL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CCM_8 = 0xC0A9UL;
        private static readonly ushort http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8 = 0xC0AAUL;
        private static readonly ushort http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8 = 0xC0ABUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xC0ACUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xC0ADUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xC0AEUL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xC0AFUL; 
        // Unassigned uint16 =  0xC0B0-FF
        // Unassigned uint16 =  0xC1-CB,*
        // Unassigned uint16 =  0xCC00-A7
        private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8UL;
        private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9UL;
        private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAAUL;
        private static readonly ushort http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCABUL;
        private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCACUL;
        private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCADUL;
        private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAEUL;

        // isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.
        // References:
        // https://tools.ietf.org/html/rfc7540#appendix-A
        // Reject cipher suites from Appendix A.
        // "This list includes those cipher suites that do not
        // offer an ephemeral key exchange and those that are
        // based on the TLS null, stream or block cipher type"
        private static bool http2isBadCipher(ushort cipher)
        {

            if (cipher == http2cipher_TLS_NULL_WITH_NULL_NULL || cipher == http2cipher_TLS_RSA_WITH_NULL_MD5 || cipher == http2cipher_TLS_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_RSA_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 || cipher == http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_RC4_128_SHA || cipher == http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 || cipher == http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 || cipher == http2cipher_TLS_KRB5_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_NULL_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_AES_128_CCM || cipher == http2cipher_TLS_RSA_WITH_AES_256_CCM || cipher == http2cipher_TLS_RSA_WITH_AES_128_CCM_8 || cipher == http2cipher_TLS_RSA_WITH_AES_256_CCM_8 || cipher == http2cipher_TLS_PSK_WITH_AES_128_CCM || cipher == http2cipher_TLS_PSK_WITH_AES_256_CCM || cipher == http2cipher_TLS_PSK_WITH_AES_128_CCM_8 || cipher == http2cipher_TLS_PSK_WITH_AES_256_CCM_8) 
                return true;
            else 
                return false;
                    }

        // ClientConnPool manages a pool of HTTP/2 client connections.
        private partial interface http2ClientConnPool
        {
            (ref http2ClientConn, error) GetClientConn(ref Request req, @string addr);
            (ref http2ClientConn, error) MarkDead(ref http2ClientConn _p0);
        }

        // clientConnPoolIdleCloser is the interface implemented by ClientConnPool
        // implementations which can close their idle connections.
        private partial interface http2clientConnPoolIdleCloser : http2ClientConnPool
        {
            void closeIdleConnections();
        }

        private static http2clientConnPoolIdleCloser _ = http2clientConnPoolIdleCloser.As((http2clientConnPool.Value)(null));        private static http2clientConnPoolIdleCloser _ = http2clientConnPoolIdleCloser.As(new http2noDialClientConnPool());

        // TODO: use singleflight for dialing and addConnCalls?
        private partial struct http2clientConnPool
        {
            public ptr<http2Transport> t;
            public sync.Mutex mu; // TODO: maybe switch to RWMutex
// TODO: add support for sharing conns based on cert names
// (e.g. share conn for googleapis.com and appspot.com)
            public map<@string, slice<ref http2ClientConn>> conns; // key is host:port
            public map<@string, ref http2dialCall> dialing; // currently in-flight dials
            public map<ref http2ClientConn, slice<@string>> keys;
            public map<@string, ref http2addConnCall> addConnCalls; // in-flight addConnIfNeede calls
        }

        private static (ref http2ClientConn, error) GetClientConn(this ref http2clientConnPool p, ref Request req, @string addr)
        {
            return p.getClientConn(req, addr, http2dialOnMiss);
        }

        private static readonly var http2dialOnMiss = true;
        private static readonly var http2noDialOnMiss = false;

        private static (ref http2ClientConn, error) getClientConn(this ref http2clientConnPool p, ref Request req, @string addr, bool dialOnMiss)
        {
            if (http2isConnectionCloseRequest(req) && dialOnMiss)
            { 
                // It gets its own connection.
                const var singleUse = true;

                var (cc, err) = p.t.dialClientConn(addr, singleUse);
                if (err != null)
                {
                    return (null, err);
                }
                return (cc, null);
            }
            p.mu.Lock();
            {
                var cc__prev1 = cc;

                foreach (var (_, __cc) in p.conns[addr])
                {
                    cc = __cc;
                    if (cc.CanTakeNewRequest())
                    {
                        p.mu.Unlock();
                        return (cc, null);
                    }
                }

                cc = cc__prev1;
            }

            if (!dialOnMiss)
            {
                p.mu.Unlock();
                return (null, http2ErrNoCachedConn);
            }
            var call = p.getStartDialLocked(addr);
            p.mu.Unlock().Send(call.done);
            return (call.res, call.err);
        }

        // dialCall is an in-flight Transport dial call to a host.
        private partial struct http2dialCall
        {
            public ptr<http2clientConnPool> p;
            public channel<object> done; // closed when done
            public ptr<http2ClientConn> res; // valid after done is closed
            public error err; // valid after done is closed
        }

        // requires p.mu is held.
        private static ref http2dialCall getStartDialLocked(this ref http2clientConnPool p, @string addr)
        {
            {
                var call__prev1 = call;

                var (call, ok) = p.dialing[addr];

                if (ok)
                { 
                    // A dial is already in-flight. Don't start another.
                    return call;
                }

                call = call__prev1;

            }
            http2dialCall call = ref new http2dialCall(p:p,done:make(chanstruct{}));
            if (p.dialing == null)
            {
                p.dialing = make_map<@string, ref http2dialCall>();
            }
            p.dialing[addr] = call;
            go_(() => call.dial(addr));
            return call;
        }

        // run in its own goroutine.
        private static void dial(this ref http2dialCall c, @string addr)
        {
            const var singleUse = false; // shared conn
 // shared conn
            c.res, c.err = c.p.t.dialClientConn(addr, singleUse);
            close(c.done);

            c.p.mu.Lock();
            delete(c.p.dialing, addr);
            if (c.err == null)
            {
                c.p.addConnLocked(addr, c.res);
            }
            c.p.mu.Unlock();
        }

        // addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't
        // already exist. It coalesces concurrent calls with the same key.
        // This is used by the http1 Transport code when it creates a new connection. Because
        // the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know
        // the protocol), it can get into a situation where it has multiple TLS connections.
        // This code decides which ones live or die.
        // The return value used is whether c was used.
        // c is never closed.
        private static (bool, error) addConnIfNeeded(this ref http2clientConnPool p, @string key, ref http2Transport t, ref tls.Conn c)
        {
            p.mu.Lock();
            foreach (var (_, cc) in p.conns[key])
            {
                if (cc.CanTakeNewRequest())
                {
                    p.mu.Unlock();
                    return (false, null);
                }
            }
            var (call, dup) = p.addConnCalls[key];
            if (!dup)
            {
                if (p.addConnCalls == null)
                {
                    p.addConnCalls = make_map<@string, ref http2addConnCall>();
                }
                call = ref new http2addConnCall(p:p,done:make(chanstruct{}),);
                p.addConnCalls[key] = call;
                go_(() => call.run(t, key, c));
            }
            p.mu.Unlock().Send(call.done);
            if (call.err != null)
            {
                return (false, call.err);
            }
            return (!dup, null);
        }

        private partial struct http2addConnCall
        {
            public ptr<http2clientConnPool> p;
            public channel<object> done; // closed when done
            public error err;
        }

        private static void run(this ref http2addConnCall c, ref http2Transport t, @string key, ref tls.Conn tc)
        {
            var (cc, err) = t.NewClientConn(tc);

            var p = c.p;
            p.mu.Lock();
            if (err != null)
            {
                c.err = err;
            }
            else
            {
                p.addConnLocked(key, cc);
            }
            delete(p.addConnCalls, key);
            p.mu.Unlock();
            close(c.done);
        }

        private static void addConn(this ref http2clientConnPool p, @string key, ref http2ClientConn cc)
        {
            p.mu.Lock();
            p.addConnLocked(key, cc);
            p.mu.Unlock();
        }

        // p.mu must be held
        private static void addConnLocked(this ref http2clientConnPool p, @string key, ref http2ClientConn cc)
        {
            foreach (var (_, v) in p.conns[key])
            {
                if (v == cc)
                {
                    return;
                }
            }
            if (p.conns == null)
            {
                p.conns = make_map<@string, slice<ref http2ClientConn>>();
            }
            if (p.keys == null)
            {
                p.keys = make_map<ref http2ClientConn, slice<@string>>();
            }
            p.conns[key] = append(p.conns[key], cc);
            p.keys[cc] = append(p.keys[cc], key);
        }

        private static void MarkDead(this ref http2clientConnPool _p, ref http2ClientConn _cc) => func(_p, _cc, (ref http2clientConnPool p, ref http2ClientConn cc, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            foreach (var (_, key) in p.keys[cc])
            {
                var (vv, ok) = p.conns[key];
                if (!ok)
                {
                    continue;
                }
                var newList = http2filterOutClientConn(vv, cc);
                if (len(newList) > 0L)
                {
                    p.conns[key] = newList;
                }
                else
                {
                    delete(p.conns, key);
                }
            }
            delete(p.keys, cc);
        });

        private static void closeIdleConnections(this ref http2clientConnPool _p) => func(_p, (ref http2clientConnPool p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock()); 
            // TODO: don't close a cc if it was just added to the pool
            // milliseconds ago and has never been used. There's currently
            // a small race window with the HTTP/1 Transport's integration
            // where it can add an idle conn just before using it, and
            // somebody else can concurrently call CloseIdleConns and
            // break some caller's RoundTrip.
            foreach (var (_, vv) in p.conns)
            {
                foreach (var (_, cc) in vv)
                {
                    cc.closeIfIdle();
                }
            }
        });

        private static slice<ref http2ClientConn> http2filterOutClientConn(slice<ref http2ClientConn> @in, ref http2ClientConn exclude)
        {
            var @out = in[..0L];
            foreach (var (_, v) in in)
            {
                if (v != exclude)
                {
                    out = append(out, v);
                }
            } 
            // If we filtered it out, zero out the last item to prevent
            // the GC from seeing it.
            if (len(in) != len(out))
            {
                in[len(in) - 1L] = null;
            }
            return out;
        }

        // noDialClientConnPool is an implementation of http2.ClientConnPool
        // which never dials. We let the HTTP/1.1 client dial and use its TLS
        // connection instead.
        private partial struct http2noDialClientConnPool
        {
            public ref http2clientConnPool http2clientConnPool => ref http2clientConnPool_ptr;
        }

        private static (ref http2ClientConn, error) GetClientConn(this http2noDialClientConnPool p, ref Request req, @string addr)
        {
            return p.getClientConn(req, addr, http2noDialOnMiss);
        }

        private static (ref http2Transport, error) http2configureTransport(ref Transport t1)
        {
            ptr<http2clientConnPool> connPool = @new<http2clientConnPool>();
            http2Transport t2 = ref new http2Transport(ConnPool:http2noDialClientConnPool{connPool},t1:t1,);
            connPool.t = t2;
            {
                var err = http2registerHTTPSProtocol(t1, new http2noDialH2RoundTripper(t2));

                if (err != null)
                {
                    return (null, err);
                }

            }
            if (t1.TLSClientConfig == null)
            {
                t1.TLSClientConfig = @new<tls.Config>();
            }
            if (!http2strSliceContains(t1.TLSClientConfig.NextProtos, "h2"))
            {
                t1.TLSClientConfig.NextProtos = append(new slice<@string>(new @string[] { "h2" }), t1.TLSClientConfig.NextProtos);
            }
            if (!http2strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1"))
            {
                t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1");
            }
            Func<@string, ref tls.Conn, RoundTripper> upgradeFn = (authority, c) =>
            {
                var addr = http2authorityAddr("https", authority);
                {
                    var (used, err) = connPool.addConnIfNeeded(addr, t2, c);

                    if (err != null)
                    {
                        go_(() => c.Close());
                        return new http2erringRoundTripper(err);
                    }
                    else if (!used)
                    { 
                        // Turns out we don't need this c.
                        // For example, two goroutines made requests to the same host
                        // at the same time, both kicking off TCP dials. (since protocol
                        // was unknown)
                        go_(() => c.Close());
                    }

                }
                return t2;
            }
;
            {
                var m = t1.TLSNextProto;

                if (len(m) == 0L)
                {
                    t1.TLSNextProto = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, Func<@string, ref tls.Conn, RoundTripper>>{"h2":upgradeFn,};
                }
                else
                {
                    m["h2"] = upgradeFn;
                }

            }
            return (t2, null);
        }

        // registerHTTPSProtocol calls Transport.RegisterProtocol but
        // converting panics into errors.
        private static error http2registerHTTPSProtocol(ref Transport _t, RoundTripper rt) => func(_t, (ref Transport t, Defer defer, Panic _, Recover __) =>
        {
            defer(() =>
            {
                {
                    var e = recover();

                    if (e != null)
                    {
                        err = fmt.Errorf("%v", e);
                    }

                }
            }());
            t.RegisterProtocol("https", rt);
            return error.As(null);
        });

        // noDialH2RoundTripper is a RoundTripper which only tries to complete the request
        // if there's already has a cached connection to the host.
        private partial struct http2noDialH2RoundTripper
        {
            public ptr<http2Transport> t;
        }

        private static (ref Response, error) RoundTrip(this http2noDialH2RoundTripper rt, ref Request req)
        {
            var (res, err) = rt.t.RoundTrip(req);
            if (http2isNoCachedConnError(err))
            {
                return (null, ErrSkipAltProtocol);
            }
            return (res, err);
        }

        // Buffer chunks are allocated from a pool to reduce pressure on GC.
        // The maximum wasted space per dataBuffer is 2x the largest size class,
        // which happens when the dataBuffer has multiple chunks and there is
        // one unread byte in both the first and last chunks. We use a few size
        // classes to minimize overheads for servers that typically receive very
        // small request bodies.
        //
        // TODO: Benchmark to determine if the pools are necessary. The GC may have
        // improved enough that we can instead allocate chunks like this:
        // make([]byte, max(16<<10, expectedBytesRemaining))
        private static long http2dataChunkSizeClasses = new slice<long>(new long[] { 1<<10, 2<<10, 4<<10, 8<<10, 16<<10 });        private static array<sync.Pool> http2dataChunkPools = new array<sync.Pool>(new sync.Pool[] { {New:func()interface{}{returnmake([]byte,1<<10)}}, {New:func()interface{}{returnmake([]byte,2<<10)}}, {New:func()interface{}{returnmake([]byte,4<<10)}}, {New:func()interface{}{returnmake([]byte,8<<10)}}, {New:func()interface{}{returnmake([]byte,16<<10)}} });

        private static slice<byte> http2getDataBufferChunk(long size)
        {
            long i = 0L;
            while (i < len(http2dataChunkSizeClasses) - 1L)
            {
                if (size <= int64(http2dataChunkSizeClasses[i]))
                {
                    break;
                i++;
                }
            }

            return http2dataChunkPools[i].Get()._<slice<byte>>();
        }

        private static void http2putDataBufferChunk(slice<byte> p) => func((_, panic, __) =>
        {
            foreach (var (i, n) in http2dataChunkSizeClasses)
            {
                if (len(p) == n)
                {
                    http2dataChunkPools[i].Put(p);
                    return;
                }
            }
            panic(fmt.Sprintf("unexpected buffer len=%v", len(p)));
        });

        // dataBuffer is an io.ReadWriter backed by a list of data chunks.
        // Each dataBuffer is used to read DATA frames on a single stream.
        // The buffer is divided into chunks so the server can limit the
        // total memory used by a single connection without limiting the
        // request body size on any single stream.
        private partial struct http2dataBuffer
        {
            public slice<slice<byte>> chunks;
            public long r; // next byte to read is chunks[0][r]
            public long w; // next byte to write is chunks[len(chunks)-1][w]
            public long size; // total buffered bytes
            public long expected; // we expect at least this many bytes in future Write calls (ignored if <= 0)
        }

        private static var http2errReadEmpty = errors.New("read from empty dataBuffer");

        // Read copies bytes from the buffer into p.
        // It is an error to read when no data is available.
        private static (long, error) Read(this ref http2dataBuffer b, slice<byte> p)
        {
            if (b.size == 0L)
            {
                return (0L, http2errReadEmpty);
            }
            long ntotal = default;
            while (len(p) > 0L && b.size > 0L)
            {
                var readFrom = b.bytesFromFirstChunk();
                var n = copy(p, readFrom);
                p = p[n..];
                ntotal += n;
                b.r += n;
                b.size -= n; 
                // If the first chunk has been consumed, advance to the next chunk.
                if (b.r == len(b.chunks[0L]))
                {
                    http2putDataBufferChunk(b.chunks[0L]);
                    var end = len(b.chunks) - 1L;
                    copy(b.chunks[..end], b.chunks[1L..]);
                    b.chunks[end] = null;
                    b.chunks = b.chunks[..end];
                    b.r = 0L;
                }
            }

            return (ntotal, null);
        }

        private static slice<byte> bytesFromFirstChunk(this ref http2dataBuffer b)
        {
            if (len(b.chunks) == 1L)
            {
                return b.chunks[0L][b.r..b.w];
            }
            return b.chunks[0L][b.r..];
        }

        // Len returns the number of bytes of the unread portion of the buffer.
        private static long Len(this ref http2dataBuffer b)
        {
            return b.size;
        }

        // Write appends p to the buffer.
        private static (long, error) Write(this ref http2dataBuffer b, slice<byte> p)
        {
            var ntotal = len(p);
            while (len(p) > 0L)
            { 
                // If the last chunk is empty, allocate a new chunk. Try to allocate
                // enough to fully copy p plus any additional bytes we expect to
                // receive. However, this may allocate less than len(p).
                var want = int64(len(p));
                if (b.expected > want)
                {
                    want = b.expected;
                }
                var chunk = b.lastChunkOrAlloc(want);
                var n = copy(chunk[b.w..], p);
                p = p[n..];
                b.w += n;
                b.size += n;
                b.expected -= int64(n);
            }

            return (ntotal, null);
        }

        private static slice<byte> lastChunkOrAlloc(this ref http2dataBuffer b, long want)
        {
            if (len(b.chunks) != 0L)
            {
                var last = b.chunks[len(b.chunks) - 1L];
                if (b.w < len(last))
                {
                    return last;
                }
            }
            var chunk = http2getDataBufferChunk(want);
            b.chunks = append(b.chunks, chunk);
            b.w = 0L;
            return chunk;
        }

        // An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
        private partial struct http2ErrCode // : uint
        {
        }

        private static readonly http2ErrCode http2ErrCodeNo = 0x0UL;
        private static readonly http2ErrCode http2ErrCodeProtocol = 0x1UL;
        private static readonly http2ErrCode http2ErrCodeInternal = 0x2UL;
        private static readonly http2ErrCode http2ErrCodeFlowControl = 0x3UL;
        private static readonly http2ErrCode http2ErrCodeSettingsTimeout = 0x4UL;
        private static readonly http2ErrCode http2ErrCodeStreamClosed = 0x5UL;
        private static readonly http2ErrCode http2ErrCodeFrameSize = 0x6UL;
        private static readonly http2ErrCode http2ErrCodeRefusedStream = 0x7UL;
        private static readonly http2ErrCode http2ErrCodeCancel = 0x8UL;
        private static readonly http2ErrCode http2ErrCodeCompression = 0x9UL;
        private static readonly http2ErrCode http2ErrCodeConnect = 0xaUL;
        private static readonly http2ErrCode http2ErrCodeEnhanceYourCalm = 0xbUL;
        private static readonly http2ErrCode http2ErrCodeInadequateSecurity = 0xcUL;
        private static readonly http2ErrCode http2ErrCodeHTTP11Required = 0xdUL;

        private static map http2errCodeName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2ErrCode, @string>{http2ErrCodeNo:"NO_ERROR",http2ErrCodeProtocol:"PROTOCOL_ERROR",http2ErrCodeInternal:"INTERNAL_ERROR",http2ErrCodeFlowControl:"FLOW_CONTROL_ERROR",http2ErrCodeSettingsTimeout:"SETTINGS_TIMEOUT",http2ErrCodeStreamClosed:"STREAM_CLOSED",http2ErrCodeFrameSize:"FRAME_SIZE_ERROR",http2ErrCodeRefusedStream:"REFUSED_STREAM",http2ErrCodeCancel:"CANCEL",http2ErrCodeCompression:"COMPRESSION_ERROR",http2ErrCodeConnect:"CONNECT_ERROR",http2ErrCodeEnhanceYourCalm:"ENHANCE_YOUR_CALM",http2ErrCodeInadequateSecurity:"INADEQUATE_SECURITY",http2ErrCodeHTTP11Required:"HTTP_1_1_REQUIRED",};

        private static @string String(this http2ErrCode e)
        {
            {
                var (s, ok) = http2errCodeName[e];

                if (ok)
                {
                    return s;
                }

            }
            return fmt.Sprintf("unknown error code 0x%x", uint32(e));
        }

        // ConnectionError is an error that results in the termination of the
        // entire connection.
        private partial struct http2ConnectionError // : http2ErrCode
        {
        }

        private static @string Error(this http2ConnectionError e)
        {
            return fmt.Sprintf("connection error: %s", http2ErrCode(e));
        }

        // StreamError is an error that only affects one stream within an
        // HTTP/2 connection.
        private partial struct http2StreamError
        {
            public uint StreamID;
            public http2ErrCode Code;
            public error Cause; // optional additional detail
        }

        private static http2StreamError http2streamError(uint id, http2ErrCode code)
        {
            return new http2StreamError(StreamID:id,Code:code);
        }

        private static @string Error(this http2StreamError e)
        {
            if (e.Cause != null)
            {
                return fmt.Sprintf("stream error: stream ID %d; %v; %v", e.StreamID, e.Code, e.Cause);
            }
            return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code);
        }

        // 6.9.1 The Flow Control Window
        // "If a sender receives a WINDOW_UPDATE that causes a flow control
        // window to exceed this maximum it MUST terminate either the stream
        // or the connection, as appropriate. For streams, [...]; for the
        // connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."
        private partial struct http2goAwayFlowError
        {
        }

        private static @string Error(this http2goAwayFlowError _p0)
        {
            return "connection exceeded flow control window size";
        }

        // connError represents an HTTP/2 ConnectionError error code, along
        // with a string (for debugging) explaining why.
        //
        // Errors of this type are only returned by the frame parser functions
        // and converted into ConnectionError(Code), after stashing away
        // the Reason into the Framer's errDetail field, accessible via
        // the (*Framer).ErrorDetail method.
        private partial struct http2connError
        {
            public http2ErrCode Code; // the ConnectionError error code
            public @string Reason; // additional reason
        }

        private static @string Error(this http2connError e)
        {
            return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason);
        }

        private partial struct http2pseudoHeaderError // : @string
        {
        }

        private static @string Error(this http2pseudoHeaderError e)
        {
            return fmt.Sprintf("invalid pseudo-header %q", string(e));
        }

        private partial struct http2duplicatePseudoHeaderError // : @string
        {
        }

        private static @string Error(this http2duplicatePseudoHeaderError e)
        {
            return fmt.Sprintf("duplicate pseudo-header %q", string(e));
        }

        private partial struct http2headerFieldNameError // : @string
        {
        }

        private static @string Error(this http2headerFieldNameError e)
        {
            return fmt.Sprintf("invalid header field name %q", string(e));
        }

        private partial struct http2headerFieldValueError // : @string
        {
        }

        private static @string Error(this http2headerFieldValueError e)
        {
            return fmt.Sprintf("invalid header field value %q", string(e));
        }

        private static var http2errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers");        private static var http2errPseudoAfterRegular = errors.New("pseudo header field after regular");

        // flow is the flow control window's size.
        private partial struct http2flow
        {
            public int n; // conn points to the shared connection-level flow that is
// shared by all streams on that conn. It is nil for the flow
// that's on the conn directly.
            public ptr<http2flow> conn;
        }

        private static void setConnFlow(this ref http2flow f, ref http2flow cf)
        {
            f.conn = cf;

        }

        private static int available(this ref http2flow f)
        {
            var n = f.n;
            if (f.conn != null && f.conn.n < n)
            {
                n = f.conn.n;
            }
            return n;
        }

        private static void take(this ref http2flow _f, int n) => func(_f, (ref http2flow f, Defer _, Panic panic, Recover __) =>
        {
            if (n > f.available())
            {
                panic("internal error: took too much");
            }
            f.n -= n;
            if (f.conn != null)
            {
                f.conn.n -= n;
            }
        });

        // add adds n bytes (positive or negative) to the flow control window.
        // It returns false if the sum would exceed 2^31-1.
        private static bool add(this ref http2flow f, int n)
        {
            long remain = (1L << (int)(31L) - 1L) - f.n;
            if (n > remain)
            {
                return false;
            }
            f.n += n;
            return true;
        }

        private static readonly long http2frameHeaderLen = 9L;



        private static var http2padZeros = make_slice<byte>(255L); // zeros for padding

        // A FrameType is a registered frame type as defined in
        // http://http2.github.io/http2-spec/#rfc.section.11.2
        private partial struct http2FrameType // : byte
        {
        }

        private static readonly http2FrameType http2FrameData = 0x0UL;
        private static readonly http2FrameType http2FrameHeaders = 0x1UL;
        private static readonly http2FrameType http2FramePriority = 0x2UL;
        private static readonly http2FrameType http2FrameRSTStream = 0x3UL;
        private static readonly http2FrameType http2FrameSettings = 0x4UL;
        private static readonly http2FrameType http2FramePushPromise = 0x5UL;
        private static readonly http2FrameType http2FramePing = 0x6UL;
        private static readonly http2FrameType http2FrameGoAway = 0x7UL;
        private static readonly http2FrameType http2FrameWindowUpdate = 0x8UL;
        private static readonly http2FrameType http2FrameContinuation = 0x9UL;

        private static map http2frameName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, @string>{http2FrameData:"DATA",http2FrameHeaders:"HEADERS",http2FramePriority:"PRIORITY",http2FrameRSTStream:"RST_STREAM",http2FrameSettings:"SETTINGS",http2FramePushPromise:"PUSH_PROMISE",http2FramePing:"PING",http2FrameGoAway:"GOAWAY",http2FrameWindowUpdate:"WINDOW_UPDATE",http2FrameContinuation:"CONTINUATION",};

        private static @string String(this http2FrameType t)
        {
            {
                var (s, ok) = http2frameName[t];

                if (ok)
                {
                    return s;
                }

            }
            return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t));
        }

        // Flags is a bitmask of HTTP/2 flags.
        // The meaning of flags varies depending on the frame type.
        private partial struct http2Flags // : byte
        {
        }

        // Has reports whether f contains all (0 or more) flags in v.
        private static bool Has(this http2Flags f, http2Flags v)
        {
            return (f & v) == v;
        }

        // Frame-specific FrameHeader flag bits.
 
        // Data Frame
        private static readonly http2Flags http2FlagDataEndStream = 0x1UL;
        private static readonly http2Flags http2FlagDataPadded = 0x8UL; 

        // Headers Frame
        private static readonly http2Flags http2FlagHeadersEndStream = 0x1UL;
        private static readonly http2Flags http2FlagHeadersEndHeaders = 0x4UL;
        private static readonly http2Flags http2FlagHeadersPadded = 0x8UL;
        private static readonly http2Flags http2FlagHeadersPriority = 0x20UL; 

        // Settings Frame
        private static readonly http2Flags http2FlagSettingsAck = 0x1UL; 

        // Ping Frame
        private static readonly http2Flags http2FlagPingAck = 0x1UL; 

        // Continuation Frame
        private static readonly http2Flags http2FlagContinuationEndHeaders = 0x4UL;

        private static readonly http2Flags http2FlagPushPromiseEndHeaders = 0x4UL;
        private static readonly http2Flags http2FlagPushPromisePadded = 0x8UL;

        private static map http2flagName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, map<http2Flags, @string>>{http2FrameData:{http2FlagDataEndStream:"END_STREAM",http2FlagDataPadded:"PADDED",},http2FrameHeaders:{http2FlagHeadersEndStream:"END_STREAM",http2FlagHeadersEndHeaders:"END_HEADERS",http2FlagHeadersPadded:"PADDED",http2FlagHeadersPriority:"PRIORITY",},http2FrameSettings:{http2FlagSettingsAck:"ACK",},http2FramePing:{http2FlagPingAck:"ACK",},http2FrameContinuation:{http2FlagContinuationEndHeaders:"END_HEADERS",},http2FramePushPromise:{http2FlagPushPromiseEndHeaders:"END_HEADERS",http2FlagPushPromisePadded:"PADDED",},};

        // a frameParser parses a frame given its FrameHeader and payload
        // bytes. The length of payload will always equal fh.Length (which
        // might be 0).
        public delegate  error) http2frameParser(ref http2frameCache,  http2FrameHeader,  slice<byte>,  (http2Frame);

        private static map http2frameParsers = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, http2frameParser>{http2FrameData:http2parseDataFrame,http2FrameHeaders:http2parseHeadersFrame,http2FramePriority:http2parsePriorityFrame,http2FrameRSTStream:http2parseRSTStreamFrame,http2FrameSettings:http2parseSettingsFrame,http2FramePushPromise:http2parsePushPromise,http2FramePing:http2parsePingFrame,http2FrameGoAway:http2parseGoAwayFrame,http2FrameWindowUpdate:http2parseWindowUpdateFrame,http2FrameContinuation:http2parseContinuationFrame,};

        private static http2frameParser http2typeFrameParser(http2FrameType t)
        {
            {
                var f = http2frameParsers[t];

                if (f != null)
                {
                    return f;
                }

            }
            return http2parseUnknownFrame;
        }

        // A FrameHeader is the 9 byte header of all HTTP/2 frames.
        //
        // See http://http2.github.io/http2-spec/#FrameHeader
        private partial struct http2FrameHeader
        {
            public bool valid; // caller can access []byte fields in the Frame

// Type is the 1 byte frame type. There are ten standard frame
// types, but extension frame types may be written by WriteRawFrame
// and will be returned by ReadFrame (as UnknownFrame).
            public http2FrameType Type; // Flags are the 1 byte of 8 potential bit flags per frame.
// They are specific to the frame type.
            public http2Flags Flags; // Length is the length of the frame, not including the 9 byte header.
// The maximum size is one byte less than 16MB (uint24), but only
// frames up to 16KB are allowed without peer agreement.
            public uint Length; // StreamID is which stream this frame is for. Certain frames
// are not stream-specific, in which case this field is 0.
            public uint StreamID;
        }

        // Header returns h. It exists so FrameHeaders can be embedded in other
        // specific frame types and implement the Frame interface.
        private static http2FrameHeader Header(this http2FrameHeader h)
        {
            return h;
        }

        private static @string String(this http2FrameHeader h)
        {
            bytes.Buffer buf = default;
            buf.WriteString("[FrameHeader ");
            h.writeDebug(ref buf);
            buf.WriteByte(']');
            return buf.String();
        }

        private static void writeDebug(this http2FrameHeader h, ref bytes.Buffer buf)
        {
            buf.WriteString(h.Type.String());
            if (h.Flags != 0L)
            {
                buf.WriteString(" flags=");
                long set = 0L;
                for (var i = uint8(0L); i < 8L; i++)
                {
                    if (h.Flags & (1L << (int)(i)) == 0L)
                    {
                        continue;
                    }
                    set++;
                    if (set > 1L)
                    {
                        buf.WriteByte('|');
                    }
                    var name = http2flagName[h.Type][http2Flags(1L << (int)(i))];
                    if (name != "")
                    {
                        buf.WriteString(name);
                    }
                    else
                    {
                        fmt.Fprintf(buf, "0x%x", 1L << (int)(i));
                    }
                }

            }
            if (h.StreamID != 0L)
            {
                fmt.Fprintf(buf, " stream=%d", h.StreamID);
            }
            fmt.Fprintf(buf, " len=%d", h.Length);
        }

        private static void checkValid(this ref http2FrameHeader _h) => func(_h, (ref http2FrameHeader h, Defer _, Panic panic, Recover __) =>
        {
            if (!h.valid)
            {
                panic("Frame accessor called on non-owned Frame");
            }
        });

        private static void invalidate(this ref http2FrameHeader h)
        {
            h.valid = false;

        }

        // frame header bytes.
        // Used only by ReadFrameHeader.
        private static sync.Pool http2fhBytes = new sync.Pool(New:func()interface{}{buf:=make([]byte,http2frameHeaderLen)return&buf},);

        // ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
        // Most users should use Framer.ReadFrame instead.
        private static (http2FrameHeader, error) http2ReadFrameHeader(io.Reader r) => func((defer, _, __) =>
        {
            ref slice<byte> bufp = http2fhBytes.Get()._<ref slice<byte>>();
            defer(http2fhBytes.Put(bufp));
            return http2readFrameHeader(bufp.Value, r);
        });

        private static (http2FrameHeader, error) http2readFrameHeader(slice<byte> buf, io.Reader r)
        {
            var (_, err) = io.ReadFull(r, buf[..http2frameHeaderLen]);
            if (err != null)
            {
                return (new http2FrameHeader(), err);
            }
            return (new http2FrameHeader(Length:(uint32(buf[0])<<16|uint32(buf[1])<<8|uint32(buf[2])),Type:http2FrameType(buf[3]),Flags:http2Flags(buf[4]),StreamID:binary.BigEndian.Uint32(buf[5:])&(1<<31-1),valid:true,), null);
        }

        // A Frame is the base interface implemented by all frame types.
        // Callers will generally type-assert the specific frame type:
        // *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
        //
        // Frames are only valid until the next call to Framer.ReadFrame.
        private partial interface http2Frame
        {
            http2FrameHeader Header(); // invalidate is called by Framer.ReadFrame to make this
// frame's buffers as being invalid, since the subsequent
// frame will reuse them.
            http2FrameHeader invalidate();
        }

        // A Framer reads and writes Frames.
        private partial struct http2Framer
        {
            public io.Reader r;
            public http2Frame lastFrame;
            public error errDetail; // lastHeaderStream is non-zero if the last frame was an
// unfinished HEADERS/CONTINUATION.
            public uint lastHeaderStream;
            public uint maxReadSize;
            public array<byte> headerBuf; // TODO: let getReadBuf be configurable, and use a less memory-pinning
// allocator in server.go to minimize memory pinned for many idle conns.
// Will probably also need to make frame invalidation have a hook too.
            public Func<uint, slice<byte>> getReadBuf;
            public slice<byte> readBuf; // cache for default getReadBuf

            public uint maxWriteSize; // zero means unlimited; TODO: implement

            public io.Writer w;
            public slice<byte> wbuf; // AllowIllegalWrites permits the Framer's Write methods to
// write frames that do not conform to the HTTP/2 spec. This
// permits using the Framer to test other HTTP/2
// implementations' conformance to the spec.
// If false, the Write methods will prefer to return an error
// rather than comply.
            public bool AllowIllegalWrites; // AllowIllegalReads permits the Framer's ReadFrame method
// to return non-compliant frames or frame orders.
// This is for testing and permits using the Framer to test
// other HTTP/2 implementations' conformance to the spec.
// It is not compatible with ReadMetaHeaders.
            public bool AllowIllegalReads; // ReadMetaHeaders if non-nil causes ReadFrame to merge
// HEADERS and CONTINUATION frames together and return
// MetaHeadersFrame instead.
            public ptr<hpack.Decoder> ReadMetaHeaders; // MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
// It's used only if ReadMetaHeaders is set; 0 means a sane default
// (currently 16MB)
// If the limit is hit, MetaHeadersFrame.Truncated is set true.
            public uint MaxHeaderListSize; // TODO: track which type of frame & with which flags was sent
// last. Then return an error (unless AllowIllegalWrites) if
// we're in the middle of a header block and a
// non-Continuation or Continuation on a different stream is
// attempted to be written.

            public bool logReads;
            public bool logWrites;
            public ptr<http2Framer> debugFramer; // only use for logging written writes
            public ptr<bytes.Buffer> debugFramerBuf;
            public Action<@string, object> debugReadLoggerf;
            public Action<@string, object> debugWriteLoggerf;
            public ptr<http2frameCache> frameCache; // nil if frames aren't reused (default)
        }

        private static uint maxHeaderListSize(this ref http2Framer fr)
        {
            if (fr.MaxHeaderListSize == 0L)
            {
                return 16L << (int)(20L); // sane default, per docs
            }
            return fr.MaxHeaderListSize;
        }

        private static void startWrite(this ref http2Framer f, http2FrameType ftype, http2Flags flags, uint streamID)
        { 
            // Write the FrameHeader.
            f.wbuf = append(f.wbuf[..0L], 0L, 0L, 0L, byte(ftype), byte(flags), byte(streamID >> (int)(24L)), byte(streamID >> (int)(16L)), byte(streamID >> (int)(8L)), byte(streamID));
        }

        private static error endWrite(this ref http2Framer f)
        { 
            // Now that we know the final size, fill in the FrameHeader in
            // the space previously reserved for it. Abuse append.
            var length = len(f.wbuf) - http2frameHeaderLen;
            if (length >= (1L << (int)(24L)))
            {
                return error.As(http2ErrFrameTooLarge);
            }
            _ = append(f.wbuf[..0L], byte(length >> (int)(16L)), byte(length >> (int)(8L)), byte(length));
            if (f.logWrites)
            {
                f.logWrite();
            }
            var (n, err) = f.w.Write(f.wbuf);
            if (err == null && n != len(f.wbuf))
            {
                err = io.ErrShortWrite;
            }
            return error.As(err);
        }

        private static void logWrite(this ref http2Framer f)
        {
            if (f.debugFramer == null)
            {
                f.debugFramerBuf = @new<bytes.Buffer>();
                f.debugFramer = http2NewFramer(null, f.debugFramerBuf);
                f.debugFramer.logReads = false; // we log it ourselves, saying "wrote" below
                // Let us read anything, even if we accidentally wrote it
                // in the wrong order:
                f.debugFramer.AllowIllegalReads = true;
            }
            f.debugFramerBuf.Write(f.wbuf);
            var (fr, err) = f.debugFramer.ReadFrame();
            if (err != null)
            {
                f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f);
                return;
            }
            f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, http2summarizeFrame(fr));
        }

        private static void writeByte(this ref http2Framer f, byte v)
        {
            f.wbuf = append(f.wbuf, v);

        }

        private static void writeBytes(this ref http2Framer f, slice<byte> v)
        {
            f.wbuf = append(f.wbuf, v);

        }

        private static void writeUint16(this ref http2Framer f, ushort v)
        {
            f.wbuf = append(f.wbuf, byte(v >> (int)(8L)), byte(v));

        }

        private static void writeUint32(this ref http2Framer f, uint v)
        {
            f.wbuf = append(f.wbuf, byte(v >> (int)(24L)), byte(v >> (int)(16L)), byte(v >> (int)(8L)), byte(v));
        }

        private static readonly long http2minMaxFrameSize = 1L << (int)(14L);
        private static readonly long http2maxFrameSize = 1L << (int)(24L) - 1L;

        // SetReuseFrames allows the Framer to reuse Frames.
        // If called on a Framer, Frames returned by calls to ReadFrame are only
        // valid until the next call to ReadFrame.
        private static void SetReuseFrames(this ref http2Framer fr)
        {
            if (fr.frameCache != null)
            {
                return;
            }
            fr.frameCache = ref new http2frameCache();
        }

        private partial struct http2frameCache
        {
            public http2DataFrame dataFrame;
        }

        private static ref http2DataFrame getDataFrame(this ref http2frameCache fc)
        {
            if (fc == null)
            {
                return ref new http2DataFrame();
            }
            return ref fc.dataFrame;
        }

        // NewFramer returns a Framer that writes frames to w and reads them from r.
        private static ref http2Framer http2NewFramer(io.Writer w, io.Reader r)
        {
            http2Framer fr = ref new http2Framer(w:w,r:r,logReads:http2logFrameReads,logWrites:http2logFrameWrites,debugReadLoggerf:log.Printf,debugWriteLoggerf:log.Printf,);
            fr.getReadBuf = size =>
            {
                if (cap(fr.readBuf) >= int(size))
                {
                    return fr.readBuf[..size];
                }
                fr.readBuf = make_slice<byte>(size);
                return fr.readBuf;
            }
;
            fr.SetMaxReadFrameSize(http2maxFrameSize);
            return fr;
        }

        // SetMaxReadFrameSize sets the maximum size of a frame
        // that will be read by a subsequent call to ReadFrame.
        // It is the caller's responsibility to advertise this
        // limit with a SETTINGS frame.
        private static void SetMaxReadFrameSize(this ref http2Framer fr, uint v)
        {
            if (v > http2maxFrameSize)
            {
                v = http2maxFrameSize;
            }
            fr.maxReadSize = v;
        }

        // ErrorDetail returns a more detailed error of the last error
        // returned by Framer.ReadFrame. For instance, if ReadFrame
        // returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
        // will say exactly what was invalid. ErrorDetail is not guaranteed
        // to return a non-nil value and like the rest of the http2 package,
        // its return value is not protected by an API compatibility promise.
        // ErrorDetail is reset after the next call to ReadFrame.
        private static error ErrorDetail(this ref http2Framer fr)
        {
            return error.As(fr.errDetail);
        }

        // ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
        // sends a frame that is larger than declared with SetMaxReadFrameSize.
        private static var http2ErrFrameTooLarge = errors.New("http2: frame too large");

        // terminalReadFrameError reports whether err is an unrecoverable
        // error from ReadFrame and no other frames should be read.
        private static bool http2terminalReadFrameError(error err)
        {
            {
                http2StreamError (_, ok) = err._<http2StreamError>();

                if (ok)
                {
                    return false;
                }

            }
            return err != null;
        }

        // ReadFrame reads a single frame. The returned Frame is only valid
        // until the next call to ReadFrame.
        //
        // If the frame is larger than previously set with SetMaxReadFrameSize, the
        // returned error is ErrFrameTooLarge. Other errors may be of type
        // ConnectionError, StreamError, or anything else from the underlying
        // reader.
        private static (http2Frame, error) ReadFrame(this ref http2Framer fr)
        {
            fr.errDetail = null;
            if (fr.lastFrame != null)
            {
                fr.lastFrame.invalidate();
            }
            var (fh, err) = http2readFrameHeader(fr.headerBuf[..], fr.r);
            if (err != null)
            {
                return (null, err);
            }
            if (fh.Length > fr.maxReadSize)
            {
                return (null, http2ErrFrameTooLarge);
            }
            var payload = fr.getReadBuf(fh.Length);
            {
                var (_, err) = io.ReadFull(fr.r, payload);

                if (err != null)
                {
                    return (null, err);
                }

            }
            var (f, err) = http2typeFrameParser(fh.Type)(fr.frameCache, fh, payload);
            if (err != null)
            {
                {
                    http2connError (ce, ok) = err._<http2connError>();

                    if (ok)
                    {
                        return (null, fr.connError(ce.Code, ce.Reason));
                    }

                }
                return (null, err);
            }
            {
                var err = fr.checkFrameOrder(f);

                if (err != null)
                {
                    return (null, err);
                }

            }
            if (fr.logReads)
            {
                fr.debugReadLoggerf("http2: Framer %p: read %v", fr, http2summarizeFrame(f));
            }
            if (fh.Type == http2FrameHeaders && fr.ReadMetaHeaders != null)
            {
                return fr.readMetaFrame(f._<ref http2HeadersFrame>());
            }
            return (f, null);
        }

        // connError returns ConnectionError(code) but first
        // stashes away a public reason to the caller can optionally relay it
        // to the peer before hanging up on them. This might help others debug
        // their implementations.
        private static error connError(this ref http2Framer fr, http2ErrCode code, @string reason)
        {
            fr.errDetail = errors.New(reason);
            return error.As(http2ConnectionError(code));
        }

        // checkFrameOrder reports an error if f is an invalid frame to return
        // next from ReadFrame. Mostly it checks whether HEADERS and
        // CONTINUATION frames are contiguous.
        private static error checkFrameOrder(this ref http2Framer fr, http2Frame f)
        {
            var last = fr.lastFrame;
            fr.lastFrame = f;
            if (fr.AllowIllegalReads)
            {
                return error.As(null);
            }
            var fh = f.Header();
            if (fr.lastHeaderStream != 0L)
            {
                if (fh.Type != http2FrameContinuation)
                {
                    return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d", fh.Type, fh.StreamID, last.Header().Type, fr.lastHeaderStream)));
                }
                if (fh.StreamID != fr.lastHeaderStream)
                {
                    return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d", fh.StreamID, fr.lastHeaderStream)));
                }
            }
            else if (fh.Type == http2FrameContinuation)
            {
                return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID)));
            }

            if (fh.Type == http2FrameHeaders || fh.Type == http2FrameContinuation) 
                if (fh.Flags.Has(http2FlagHeadersEndHeaders))
                {
                    fr.lastHeaderStream = 0L;
                }
                else
                {
                    fr.lastHeaderStream = fh.StreamID;
                }
                        return error.As(null);
        }

        // A DataFrame conveys arbitrary, variable-length sequences of octets
        // associated with a stream.
        // See http://http2.github.io/http2-spec/#rfc.section.6.1
        private partial struct http2DataFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public slice<byte> data;
        }

        private static bool StreamEnded(this ref http2DataFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagDataEndStream);
        }

        // Data returns the frame's data octets, not including any padding
        // size byte or padding suffix bytes.
        // The caller must not retain the returned memory past the next
        // call to ReadFrame.
        private static slice<byte> Data(this ref http2DataFrame f)
        {
            f.checkValid();
            return f.data;
        }

        private static (http2Frame, error) http2parseDataFrame(ref http2frameCache fc, http2FrameHeader fh, slice<byte> payload)
        {
            if (fh.StreamID == 0L)
            { 
                // DATA frames MUST be associated with a stream. If a
                // DATA frame is received whose stream identifier
                // field is 0x0, the recipient MUST respond with a
                // connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR.
                return (null, new http2connError(http2ErrCodeProtocol,"DATA frame with stream ID 0"));
            }
            var f = fc.getDataFrame();
            f.http2FrameHeader = fh;

            byte padSize = default;
            if (fh.Flags.Has(http2FlagDataPadded))
            {
                error err = default;
                payload, padSize, err = http2readByte(payload);
                if (err != null)
                {
                    return (null, err);
                }
            }
            if (int(padSize) > len(payload))
            { 
                // If the length of the padding is greater than the
                // length of the frame payload, the recipient MUST
                // treat this as a connection error.
                // Filed: https://github.com/http2/http2-spec/issues/610
                return (null, new http2connError(http2ErrCodeProtocol,"pad size larger than data payload"));
            }
            f.data = payload[..len(payload) - int(padSize)];
            return (f, null);
        }

        private static var http2errStreamID = errors.New("invalid stream ID");        private static var http2errDepStreamID = errors.New("invalid dependent stream ID");        private static var http2errPadLength = errors.New("pad length too large");        private static var http2errPadBytes = errors.New("padding bytes must all be zeros unless AllowIllegalWrites is enabled");

        private static bool http2validStreamIDOrZero(uint streamID)
        {
            return streamID & (1L << (int)(31L)) == 0L;
        }

        private static bool http2validStreamID(uint streamID)
        {
            return streamID != 0L && streamID & (1L << (int)(31L)) == 0L;
        }

        // WriteData writes a DATA frame.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility not to violate the maximum frame size
        // and to not call other Write methods concurrently.
        private static error WriteData(this ref http2Framer f, uint streamID, bool endStream, slice<byte> data)
        {
            return error.As(f.WriteDataPadded(streamID, endStream, data, null));
        }

        // WriteData writes a DATA frame with optional padding.
        //
        // If pad is nil, the padding bit is not sent.
        // The length of pad must not exceed 255 bytes.
        // The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility not to violate the maximum frame size
        // and to not call other Write methods concurrently.
        private static error WriteDataPadded(this ref http2Framer f, uint streamID, bool endStream, slice<byte> data, slice<byte> pad)
        {
            if (!http2validStreamID(streamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            if (len(pad) > 0L)
            {
                if (len(pad) > 255L)
                {
                    return error.As(http2errPadLength);
                }
                if (!f.AllowIllegalWrites)
                {
                    foreach (var (_, b) in pad)
                    {
                        if (b != 0L)
                        { 
                            // "Padding octets MUST be set to zero when sending."
                            return error.As(http2errPadBytes);
                        }
                    }
                }
            }
            http2Flags flags = default;
            if (endStream)
            {
                flags |= http2FlagDataEndStream;
            }
            if (pad != null)
            {
                flags |= http2FlagDataPadded;
            }
            f.startWrite(http2FrameData, flags, streamID);
            if (pad != null)
            {
                f.wbuf = append(f.wbuf, byte(len(pad)));
            }
            f.wbuf = append(f.wbuf, data);
            f.wbuf = append(f.wbuf, pad);
            return error.As(f.endWrite());
        }

        // A SettingsFrame conveys configuration parameters that affect how
        // endpoints communicate, such as preferences and constraints on peer
        // behavior.
        //
        // See http://http2.github.io/http2-spec/#SETTINGS
        private partial struct http2SettingsFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public slice<byte> p;
        }

        private static (http2Frame, error) http2parseSettingsFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            if (fh.Flags.Has(http2FlagSettingsAck) && fh.Length > 0L)
            { 
                // When this (ACK 0x1) bit is set, the payload of the
                // SETTINGS frame MUST be empty. Receipt of a
                // SETTINGS frame with the ACK flag set and a length
                // field value other than 0 MUST be treated as a
                // connection error (Section 5.4.1) of type
                // FRAME_SIZE_ERROR.
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            if (fh.StreamID != 0L)
            { 
                // SETTINGS frames always apply to a connection,
                // never a single stream. The stream identifier for a
                // SETTINGS frame MUST be zero (0x0).  If an endpoint
                // receives a SETTINGS frame whose stream identifier
                // field is anything other than 0x0, the endpoint MUST
                // respond with a connection error (Section 5.4.1) of
                // type PROTOCOL_ERROR.
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            }
            if (len(p) % 6L != 0L)
            { 
                // Expecting even number of 6 byte settings.
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            http2SettingsFrame f = ref new http2SettingsFrame(http2FrameHeader:fh,p:p);
            {
                var (v, ok) = f.Value(http2SettingInitialWindowSize);

                if (ok && v > (1L << (int)(31L)) - 1L)
                { 
                    // Values above the maximum flow control window size of 2^31 - 1 MUST
                    // be treated as a connection error (Section 5.4.1) of type
                    // FLOW_CONTROL_ERROR.
                    return (null, http2ConnectionError(http2ErrCodeFlowControl));
                }

            }
            return (f, null);
        }

        private static bool IsAck(this ref http2SettingsFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagSettingsAck);
        }

        private static (uint, bool) Value(this ref http2SettingsFrame f, http2SettingID s)
        {
            f.checkValid();
            var buf = f.p;
            while (len(buf) > 0L)
            {
                var settingID = http2SettingID(binary.BigEndian.Uint16(buf[..2L]));
                if (settingID == s)
                {
                    return (binary.BigEndian.Uint32(buf[2L..6L]), true);
                }
                buf = buf[6L..];
            }

            return (0L, false);
        }

        // ForeachSetting runs fn for each setting.
        // It stops and returns the first error.
        private static error ForeachSetting(this ref http2SettingsFrame f, Func<http2Setting, error> fn)
        {
            f.checkValid();
            var buf = f.p;
            while (len(buf) > 0L)
            {
                {
                    var err = fn(new http2Setting(http2SettingID(binary.BigEndian.Uint16(buf[:2])),binary.BigEndian.Uint32(buf[2:6]),));

                    if (err != null)
                    {
                        return error.As(err);
                    }

                }
                buf = buf[6L..];
            }

            return error.As(null);
        }

        // WriteSettings writes a SETTINGS frame with zero or more settings
        // specified and the ACK bit not set.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WriteSettings(this ref http2Framer f, params http2Setting[] settings)
        {
            f.startWrite(http2FrameSettings, 0L, 0L);
            foreach (var (_, s) in settings)
            {
                f.writeUint16(uint16(s.ID));
                f.writeUint32(s.Val);
            }
            return error.As(f.endWrite());
        }

        // WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WriteSettingsAck(this ref http2Framer f)
        {
            f.startWrite(http2FrameSettings, http2FlagSettingsAck, 0L);
            return error.As(f.endWrite());
        }

        // A PingFrame is a mechanism for measuring a minimal round trip time
        // from the sender, as well as determining whether an idle connection
        // is still functional.
        // See http://http2.github.io/http2-spec/#rfc.section.6.7
        private partial struct http2PingFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public array<byte> Data;
        }

        private static bool IsAck(this ref http2PingFrame f)
        {
            return f.Flags.Has(http2FlagPingAck);
        }

        private static (http2Frame, error) http2parsePingFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> payload)
        {
            if (len(payload) != 8L)
            {
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            if (fh.StreamID != 0L)
            {
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            }
            http2PingFrame f = ref new http2PingFrame(http2FrameHeader:fh);
            copy(f.Data[..], payload);
            return (f, null);
        }

        private static error WritePing(this ref http2Framer f, bool ack, array<byte> data)
        {
            http2Flags flags = default;
            if (ack)
            {
                flags = http2FlagPingAck;
            }
            f.startWrite(http2FramePing, flags, 0L);
            f.writeBytes(data[..]);
            return error.As(f.endWrite());
        }

        // A GoAwayFrame informs the remote peer to stop creating streams on this connection.
        // See http://http2.github.io/http2-spec/#rfc.section.6.8
        private partial struct http2GoAwayFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public uint LastStreamID;
            public http2ErrCode ErrCode;
            public slice<byte> debugData;
        }

        // DebugData returns any debug data in the GOAWAY frame. Its contents
        // are not defined.
        // The caller must not retain the returned memory past the next
        // call to ReadFrame.
        private static slice<byte> DebugData(this ref http2GoAwayFrame f)
        {
            f.checkValid();
            return f.debugData;
        }

        private static (http2Frame, error) http2parseGoAwayFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            if (fh.StreamID != 0L)
            {
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            }
            if (len(p) < 8L)
            {
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            return (ref new http2GoAwayFrame(http2FrameHeader:fh,LastStreamID:binary.BigEndian.Uint32(p[:4])&(1<<31-1),ErrCode:http2ErrCode(binary.BigEndian.Uint32(p[4:8])),debugData:p[8:],), null);
        }

        private static error WriteGoAway(this ref http2Framer f, uint maxStreamID, http2ErrCode code, slice<byte> debugData)
        {
            f.startWrite(http2FrameGoAway, 0L, 0L);
            f.writeUint32(maxStreamID & (1L << (int)(31L) - 1L));
            f.writeUint32(uint32(code));
            f.writeBytes(debugData);
            return error.As(f.endWrite());
        }

        // An UnknownFrame is the frame type returned when the frame type is unknown
        // or no specific frame type parser exists.
        private partial struct http2UnknownFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public slice<byte> p;
        }

        // Payload returns the frame's payload (after the header).  It is not
        // valid to call this method after a subsequent call to
        // Framer.ReadFrame, nor is it valid to retain the returned slice.
        // The memory is owned by the Framer and is invalidated when the next
        // frame is read.
        private static slice<byte> Payload(this ref http2UnknownFrame f)
        {
            f.checkValid();
            return f.p;
        }

        private static (http2Frame, error) http2parseUnknownFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            return (ref new http2UnknownFrame(fh,p), null);
        }

        // A WindowUpdateFrame is used to implement flow control.
        // See http://http2.github.io/http2-spec/#rfc.section.6.9
        private partial struct http2WindowUpdateFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public uint Increment; // never read with high bit set
        }

        private static (http2Frame, error) http2parseWindowUpdateFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            if (len(p) != 4L)
            {
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            var inc = binary.BigEndian.Uint32(p[..4L]) & 0x7fffffffUL; // mask off high reserved bit
            if (inc == 0L)
            { 
                // A receiver MUST treat the receipt of a
                // WINDOW_UPDATE frame with an flow control window
                // increment of 0 as a stream error (Section 5.4.2) of
                // type PROTOCOL_ERROR; errors on the connection flow
                // control window MUST be treated as a connection
                // error (Section 5.4.1).
                if (fh.StreamID == 0L)
                {
                    return (null, http2ConnectionError(http2ErrCodeProtocol));
                }
                return (null, http2streamError(fh.StreamID, http2ErrCodeProtocol));
            }
            return (ref new http2WindowUpdateFrame(http2FrameHeader:fh,Increment:inc,), null);
        }

        // WriteWindowUpdate writes a WINDOW_UPDATE frame.
        // The increment value must be between 1 and 2,147,483,647, inclusive.
        // If the Stream ID is zero, the window update applies to the
        // connection as a whole.
        private static error WriteWindowUpdate(this ref http2Framer f, uint streamID, uint incr)
        { 
            // "The legal range for the increment to the flow control window is 1 to 2^31-1 (2,147,483,647) octets."
            if ((incr < 1L || incr > 2147483647L) && !f.AllowIllegalWrites)
            {
                return error.As(errors.New("illegal window increment value"));
            }
            f.startWrite(http2FrameWindowUpdate, 0L, streamID);
            f.writeUint32(incr);
            return error.As(f.endWrite());
        }

        // A HeadersFrame is used to open a stream and additionally carries a
        // header block fragment.
        private partial struct http2HeadersFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val; // Priority is set if FlagHeadersPriority is set in the FrameHeader.
            public http2PriorityParam Priority;
            public slice<byte> headerFragBuf; // not owned
        }

        private static slice<byte> HeaderBlockFragment(this ref http2HeadersFrame f)
        {
            f.checkValid();
            return f.headerFragBuf;
        }

        private static bool HeadersEnded(this ref http2HeadersFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndHeaders);
        }

        private static bool StreamEnded(this ref http2HeadersFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndStream);
        }

        private static bool HasPriority(this ref http2HeadersFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagHeadersPriority);
        }

        private static (http2Frame, error) http2parseHeadersFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            http2HeadersFrame hf = ref new http2HeadersFrame(http2FrameHeader:fh,);
            if (fh.StreamID == 0L)
            { 
                // HEADERS frames MUST be associated with a stream. If a HEADERS frame
                // is received whose stream identifier field is 0x0, the recipient MUST
                // respond with a connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR.
                return (null, new http2connError(http2ErrCodeProtocol,"HEADERS frame with stream ID 0"));
            }
            byte padLength = default;
            if (fh.Flags.Has(http2FlagHeadersPadded))
            {
                p, padLength, err = http2readByte(p);

                if (err != null)
                {
                    return;
                }
            }
            if (fh.Flags.Has(http2FlagHeadersPriority))
            {
                uint v = default;
                p, v, err = http2readUint32(p);
                if (err != null)
                {
                    return (null, err);
                }
                hf.Priority.StreamDep = v & 0x7fffffffUL;
                hf.Priority.Exclusive = (v != hf.Priority.StreamDep); // high bit was set
                p, hf.Priority.Weight, err = http2readByte(p);
                if (err != null)
                {
                    return (null, err);
                }
            }
            if (len(p) - int(padLength) <= 0L)
            {
                return (null, http2streamError(fh.StreamID, http2ErrCodeProtocol));
            }
            hf.headerFragBuf = p[..len(p) - int(padLength)];
            return (hf, null);
        }

        // HeadersFrameParam are the parameters for writing a HEADERS frame.
        private partial struct http2HeadersFrameParam
        {
            public uint StreamID; // BlockFragment is part (or all) of a Header Block.
            public slice<byte> BlockFragment; // EndStream indicates that the header block is the last that
// the endpoint will send for the identified stream. Setting
// this flag causes the stream to enter one of "half closed"
// states.
            public bool EndStream; // EndHeaders indicates that this frame contains an entire
// header block and is not followed by any
// CONTINUATION frames.
            public bool EndHeaders; // PadLength is the optional number of bytes of zeros to add
// to this frame.
            public byte PadLength; // Priority, if non-zero, includes stream priority information
// in the HEADER frame.
            public http2PriorityParam Priority;
        }

        // WriteHeaders writes a single HEADERS frame.
        //
        // This is a low-level header writing method. Encoding headers and
        // splitting them into any necessary CONTINUATION frames is handled
        // elsewhere.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WriteHeaders(this ref http2Framer f, http2HeadersFrameParam p)
        {
            if (!http2validStreamID(p.StreamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            http2Flags flags = default;
            if (p.PadLength != 0L)
            {
                flags |= http2FlagHeadersPadded;
            }
            if (p.EndStream)
            {
                flags |= http2FlagHeadersEndStream;
            }
            if (p.EndHeaders)
            {
                flags |= http2FlagHeadersEndHeaders;
            }
            if (!p.Priority.IsZero())
            {
                flags |= http2FlagHeadersPriority;
            }
            f.startWrite(http2FrameHeaders, flags, p.StreamID);
            if (p.PadLength != 0L)
            {
                f.writeByte(p.PadLength);
            }
            if (!p.Priority.IsZero())
            {
                var v = p.Priority.StreamDep;
                if (!http2validStreamIDOrZero(v) && !f.AllowIllegalWrites)
                {
                    return error.As(http2errDepStreamID);
                }
                if (p.Priority.Exclusive)
                {
                    v |= 1L << (int)(31L);
                }
                f.writeUint32(v);
                f.writeByte(p.Priority.Weight);
            }
            f.wbuf = append(f.wbuf, p.BlockFragment);
            f.wbuf = append(f.wbuf, http2padZeros[..p.PadLength]);
            return error.As(f.endWrite());
        }

        // A PriorityFrame specifies the sender-advised priority of a stream.
        // See http://http2.github.io/http2-spec/#rfc.section.6.3
        private partial struct http2PriorityFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public ref http2PriorityParam http2PriorityParam => ref http2PriorityParam_val;
        }

        // PriorityParam are the stream prioritzation parameters.
        private partial struct http2PriorityParam
        {
            public uint StreamDep; // Exclusive is whether the dependency is exclusive.
            public bool Exclusive; // Weight is the stream's zero-indexed weight. It should be
// set together with StreamDep, or neither should be set. Per
// the spec, "Add one to the value to obtain a weight between
// 1 and 256."
            public byte Weight;
        }

        private static bool IsZero(this http2PriorityParam p)
        {
            return p == new http2PriorityParam();
        }

        private static (http2Frame, error) http2parsePriorityFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> payload)
        {
            if (fh.StreamID == 0L)
            {
                return (null, new http2connError(http2ErrCodeProtocol,"PRIORITY frame with stream ID 0"));
            }
            if (len(payload) != 5L)
            {
                return (null, new http2connError(http2ErrCodeFrameSize,fmt.Sprintf("PRIORITY frame payload size was %d; want 5",len(payload))));
            }
            var v = binary.BigEndian.Uint32(payload[..4L]);
            var streamID = v & 0x7fffffffUL; // mask off high bit
            return (ref new http2PriorityFrame(http2FrameHeader:fh,http2PriorityParam:http2PriorityParam{Weight:payload[4],StreamDep:streamID,Exclusive:streamID!=v,},), null);
        }

        // WritePriority writes a PRIORITY frame.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WritePriority(this ref http2Framer f, uint streamID, http2PriorityParam p)
        {
            if (!http2validStreamID(streamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            if (!http2validStreamIDOrZero(p.StreamDep))
            {
                return error.As(http2errDepStreamID);
            }
            f.startWrite(http2FramePriority, 0L, streamID);
            var v = p.StreamDep;
            if (p.Exclusive)
            {
                v |= 1L << (int)(31L);
            }
            f.writeUint32(v);
            f.writeByte(p.Weight);
            return error.As(f.endWrite());
        }

        // A RSTStreamFrame allows for abnormal termination of a stream.
        // See http://http2.github.io/http2-spec/#rfc.section.6.4
        private partial struct http2RSTStreamFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public http2ErrCode ErrCode;
        }

        private static (http2Frame, error) http2parseRSTStreamFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            if (len(p) != 4L)
            {
                return (null, http2ConnectionError(http2ErrCodeFrameSize));
            }
            if (fh.StreamID == 0L)
            {
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            }
            return (ref new http2RSTStreamFrame(fh,http2ErrCode(binary.BigEndian.Uint32(p[:4]))), null);
        }

        // WriteRSTStream writes a RST_STREAM frame.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WriteRSTStream(this ref http2Framer f, uint streamID, http2ErrCode code)
        {
            if (!http2validStreamID(streamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            f.startWrite(http2FrameRSTStream, 0L, streamID);
            f.writeUint32(uint32(code));
            return error.As(f.endWrite());
        }

        // A ContinuationFrame is used to continue a sequence of header block fragments.
        // See http://http2.github.io/http2-spec/#rfc.section.6.10
        private partial struct http2ContinuationFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public slice<byte> headerFragBuf;
        }

        private static (http2Frame, error) http2parseContinuationFrame(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            if (fh.StreamID == 0L)
            {
                return (null, new http2connError(http2ErrCodeProtocol,"CONTINUATION frame with stream ID 0"));
            }
            return (ref new http2ContinuationFrame(fh,p), null);
        }

        private static slice<byte> HeaderBlockFragment(this ref http2ContinuationFrame f)
        {
            f.checkValid();
            return f.headerFragBuf;
        }

        private static bool HeadersEnded(this ref http2ContinuationFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagContinuationEndHeaders);
        }

        // WriteContinuation writes a CONTINUATION frame.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WriteContinuation(this ref http2Framer f, uint streamID, bool endHeaders, slice<byte> headerBlockFragment)
        {
            if (!http2validStreamID(streamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            http2Flags flags = default;
            if (endHeaders)
            {
                flags |= http2FlagContinuationEndHeaders;
            }
            f.startWrite(http2FrameContinuation, flags, streamID);
            f.wbuf = append(f.wbuf, headerBlockFragment);
            return error.As(f.endWrite());
        }

        // A PushPromiseFrame is used to initiate a server stream.
        // See http://http2.github.io/http2-spec/#rfc.section.6.6
        private partial struct http2PushPromiseFrame
        {
            public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
            public uint PromiseID;
            public slice<byte> headerFragBuf; // not owned
        }

        private static slice<byte> HeaderBlockFragment(this ref http2PushPromiseFrame f)
        {
            f.checkValid();
            return f.headerFragBuf;
        }

        private static bool HeadersEnded(this ref http2PushPromiseFrame f)
        {
            return f.http2FrameHeader.Flags.Has(http2FlagPushPromiseEndHeaders);
        }

        private static (http2Frame, error) http2parsePushPromise(ref http2frameCache _, http2FrameHeader fh, slice<byte> p)
        {
            http2PushPromiseFrame pp = ref new http2PushPromiseFrame(http2FrameHeader:fh,);
            if (pp.StreamID == 0L)
            { 
                // PUSH_PROMISE frames MUST be associated with an existing,
                // peer-initiated stream. The stream identifier of a
                // PUSH_PROMISE frame indicates the stream it is associated
                // with. If the stream identifier field specifies the value
                // 0x0, a recipient MUST respond with a connection error
                // (Section 5.4.1) of type PROTOCOL_ERROR.
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            } 
            // The PUSH_PROMISE frame includes optional padding.
            // Padding fields and flags are identical to those defined for DATA frames
            byte padLength = default;
            if (fh.Flags.Has(http2FlagPushPromisePadded))
            {
                p, padLength, err = http2readByte(p);

                if (err != null)
                {
                    return;
                }
            }
            p, pp.PromiseID, err = http2readUint32(p);
            if (err != null)
            {
                return;
            }
            pp.PromiseID = pp.PromiseID & (1L << (int)(31L) - 1L);

            if (int(padLength) > len(p))
            { 
                // like the DATA frame, error out if padding is longer than the body.
                return (null, http2ConnectionError(http2ErrCodeProtocol));
            }
            pp.headerFragBuf = p[..len(p) - int(padLength)];
            return (pp, null);
        }

        // PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
        private partial struct http2PushPromiseParam
        {
            public uint StreamID; // PromiseID is the required Stream ID which this
// Push Promises
            public uint PromiseID; // BlockFragment is part (or all) of a Header Block.
            public slice<byte> BlockFragment; // EndHeaders indicates that this frame contains an entire
// header block and is not followed by any
// CONTINUATION frames.
            public bool EndHeaders; // PadLength is the optional number of bytes of zeros to add
// to this frame.
            public byte PadLength;
        }

        // WritePushPromise writes a single PushPromise Frame.
        //
        // As with Header Frames, This is the low level call for writing
        // individual frames. Continuation frames are handled elsewhere.
        //
        // It will perform exactly one Write to the underlying Writer.
        // It is the caller's responsibility to not call other Write methods concurrently.
        private static error WritePushPromise(this ref http2Framer f, http2PushPromiseParam p)
        {
            if (!http2validStreamID(p.StreamID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            http2Flags flags = default;
            if (p.PadLength != 0L)
            {
                flags |= http2FlagPushPromisePadded;
            }
            if (p.EndHeaders)
            {
                flags |= http2FlagPushPromiseEndHeaders;
            }
            f.startWrite(http2FramePushPromise, flags, p.StreamID);
            if (p.PadLength != 0L)
            {
                f.writeByte(p.PadLength);
            }
            if (!http2validStreamID(p.PromiseID) && !f.AllowIllegalWrites)
            {
                return error.As(http2errStreamID);
            }
            f.writeUint32(p.PromiseID);
            f.wbuf = append(f.wbuf, p.BlockFragment);
            f.wbuf = append(f.wbuf, http2padZeros[..p.PadLength]);
            return error.As(f.endWrite());
        }

        // WriteRawFrame writes a raw frame. This can be used to write
        // extension frames unknown to this package.
        private static error WriteRawFrame(this ref http2Framer f, http2FrameType t, http2Flags flags, uint streamID, slice<byte> payload)
        {
            f.startWrite(t, flags, streamID);
            f.writeBytes(payload);
            return error.As(f.endWrite());
        }

        private static (slice<byte>, byte, error) http2readByte(slice<byte> p)
        {
            if (len(p) == 0L)
            {
                return (null, 0L, io.ErrUnexpectedEOF);
            }
            return (p[1L..], p[0L], null);
        }

        private static (slice<byte>, uint, error) http2readUint32(slice<byte> p)
        {
            if (len(p) < 4L)
            {
                return (null, 0L, io.ErrUnexpectedEOF);
            }
            return (p[4L..], binary.BigEndian.Uint32(p[..4L]), null);
        }

        private partial interface http2streamEnder
        {
            bool StreamEnded();
        }

        private partial interface http2headersEnder
        {
            bool HeadersEnded();
        }

        private partial interface http2headersOrContinuation : http2headersEnder
        {
            slice<byte> HeaderBlockFragment();
        }

        // A MetaHeadersFrame is the representation of one HEADERS frame and
        // zero or more contiguous CONTINUATION frames and the decoding of
        // their HPACK-encoded contents.
        //
        // This type of frame does not appear on the wire and is only returned
        // by the Framer when Framer.ReadMetaHeaders is set.
        private partial struct http2MetaHeadersFrame
        {
            public ref http2HeadersFrame http2HeadersFrame => ref http2HeadersFrame_ptr; // Fields are the fields contained in the HEADERS and
// CONTINUATION frames. The underlying slice is owned by the
// Framer and must not be retained after the next call to
// ReadFrame.
//
// Fields are guaranteed to be in the correct http2 order and
// not have unknown pseudo header fields or invalid header
// field names or values. Required pseudo header fields may be
// missing, however. Use the MetaHeadersFrame.Pseudo accessor
// method access pseudo headers.
            public slice<hpack.HeaderField> Fields; // Truncated is whether the max header list size limit was hit
// and Fields is incomplete. The hpack decoder state is still
// valid, however.
            public bool Truncated;
        }

        // PseudoValue returns the given pseudo header field's value.
        // The provided pseudo field should not contain the leading colon.
        private static @string PseudoValue(this ref http2MetaHeadersFrame mh, @string pseudo)
        {
            foreach (var (_, hf) in mh.Fields)
            {
                if (!hf.IsPseudo())
                {
                    return "";
                }
                if (hf.Name[1L..] == pseudo)
                {
                    return hf.Value;
                }
            }
            return "";
        }

        // RegularFields returns the regular (non-pseudo) header fields of mh.
        // The caller does not own the returned slice.
        private static slice<hpack.HeaderField> RegularFields(this ref http2MetaHeadersFrame mh)
        {
            foreach (var (i, hf) in mh.Fields)
            {
                if (!hf.IsPseudo())
                {
                    return mh.Fields[i..];
                }
            }
            return null;
        }

        // PseudoFields returns the pseudo header fields of mh.
        // The caller does not own the returned slice.
        private static slice<hpack.HeaderField> PseudoFields(this ref http2MetaHeadersFrame mh)
        {
            foreach (var (i, hf) in mh.Fields)
            {
                if (!hf.IsPseudo())
                {
                    return mh.Fields[..i];
                }
            }
            return mh.Fields;
        }

        private static error checkPseudos(this ref http2MetaHeadersFrame mh)
        {
            bool isRequest = default;            bool isResponse = default;

            var pf = mh.PseudoFields();
            foreach (var (i, hf) in pf)
            {
                switch (hf.Name)
                {
                    case ":method": 

                    case ":path": 

                    case ":scheme": 

                    case ":authority": 
                        isRequest = true;
                        break;
                    case ":status": 
                        isResponse = true;
                        break;
                    default: 
                        return error.As(http2pseudoHeaderError(hf.Name));
                        break;
                } 
                // Check for duplicates.
                // This would be a bad algorithm, but N is 4.
                // And this doesn't allocate.
                foreach (var (_, hf2) in pf[..i])
                {
                    if (hf.Name == hf2.Name)
                    {
                        return error.As(http2duplicatePseudoHeaderError(hf.Name));
                    }
                }
            }
            if (isRequest && isResponse)
            {
                return error.As(http2errMixPseudoHeaderTypes);
            }
            return error.As(null);
        }

        private static long maxHeaderStringLen(this ref http2Framer fr)
        {
            var v = fr.maxHeaderListSize();
            if (uint32(int(v)) == v)
            {
                return int(v);
            } 
            // They had a crazy big number for MaxHeaderBytes anyway,
            // so give them unlimited header lengths:
            return 0L;
        }

        // readMetaFrame returns 0 or more CONTINUATION frames from fr and
        // merge them into into the provided hf and returns a MetaHeadersFrame
        // with the decoded hpack values.
        private static (ref http2MetaHeadersFrame, error) readMetaFrame(this ref http2Framer _fr, ref http2HeadersFrame _hf) => func(_fr, _hf, (ref http2Framer fr, ref http2HeadersFrame hf, Defer defer, Panic _, Recover __) =>
        {
            if (fr.AllowIllegalReads)
            {
                return (null, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders"));
            }
            http2MetaHeadersFrame mh = ref new http2MetaHeadersFrame(http2HeadersFrame:hf,);
            var remainSize = fr.maxHeaderListSize();
            bool sawRegular = default;

            error invalid = default; // pseudo header field errors
            var hdec = fr.ReadMetaHeaders;
            hdec.SetEmitEnabled(true);
            hdec.SetMaxStringLength(fr.maxHeaderStringLen());
            hdec.SetEmitFunc(hf =>
            {
                if (http2VerboseLogs && fr.logReads)
                {
                    fr.debugReadLoggerf("http2: decoded hpack field %+v", hf);
                }
                if (!httplex.ValidHeaderFieldValue(hf.Value))
                {
                    invalid = error.As(http2headerFieldValueError(hf.Value));
                }
                var isPseudo = strings.HasPrefix(hf.Name, ":");
                if (isPseudo)
                {
                    if (sawRegular)
                    {
                        invalid = error.As(http2errPseudoAfterRegular);
                    }
                }
                else
                {
                    sawRegular = true;
                    if (!http2validWireHeaderFieldName(hf.Name))
                    {
                        invalid = error.As(http2headerFieldNameError(hf.Name));
                    }
                }
                if (invalid != null)
                {
                    hdec.SetEmitEnabled(false);
                    return;
                }
                var size = hf.Size();
                if (size > remainSize)
                {
                    hdec.SetEmitEnabled(false);
                    mh.Truncated = true;
                    return;
                }
                remainSize -= size;

                mh.Fields = append(mh.Fields, hf);
            }); 
            // Lose reference to MetaHeadersFrame:
            defer(hdec.SetEmitFunc(hf =>
            {
            }));

            http2headersOrContinuation hc = http2headersOrContinuation.As(hf);
            while (true)
            {
                var frag = hc.HeaderBlockFragment();
                {
                    var err__prev1 = err;

                    var (_, err) = hdec.Write(frag);

                    if (err != null)
                    {
                        return (null, http2ConnectionError(http2ErrCodeCompression));
                    }

                    err = err__prev1;

                }

                if (hc.HeadersEnded())
                {
                    break;
                }
                {
                    var err__prev1 = err;

                    var (f, err) = fr.ReadFrame();

                    if (err != null)
                    {
                        return (null, err);
                    }
                    else
                    {
                        hc = http2headersOrContinuation.As(f._<ref http2ContinuationFrame>()); // guaranteed by checkFrameOrder
                    }

                    err = err__prev1;

                }
            }


            mh.http2HeadersFrame.headerFragBuf = null;
            mh.http2HeadersFrame.invalidate();

            {
                var err__prev1 = err;

                var err = hdec.Close();

                if (err != null)
                {
                    return (null, http2ConnectionError(http2ErrCodeCompression));
                }

                err = err__prev1;

            }
            if (invalid != null)
            {
                fr.errDetail = invalid;
                if (http2VerboseLogs)
                {
                    log.Printf("http2: invalid header: %v", invalid);
                }
                return (null, new http2StreamError(mh.StreamID,http2ErrCodeProtocol,invalid));
            }
            {
                var err__prev1 = err;

                err = mh.checkPseudos();

                if (err != null)
                {
                    fr.errDetail = err;
                    if (http2VerboseLogs)
                    {
                        log.Printf("http2: invalid pseudo headers: %v", err);
                    }
                    return (null, new http2StreamError(mh.StreamID,http2ErrCodeProtocol,err));
                }

                err = err__prev1;

            }
            return (mh, null);
        });

        private static @string http2summarizeFrame(http2Frame f)
        {
            bytes.Buffer buf = default;
            f.Header().writeDebug(ref buf);
            switch (f.type())
            {
                case ref http2SettingsFrame f:
                    long n = 0L;
                    f.ForeachSetting(s =>
                    {
                        n++;
                        if (n == 1L)
                        {
                            buf.WriteString(", settings:");
                        }
                        fmt.Fprintf(ref buf, " %v=%v,", s.ID, s.Val);
                        return null;
                    });
                    if (n > 0L)
                    {
                        buf.Truncate(buf.Len() - 1L); // remove trailing comma
                    }
                    break;
                case ref http2DataFrame f:
                    var data = f.Data();
                    const long max = 256L;

                    if (len(data) > max)
                    {
                        data = data[..max];
                    }
                    fmt.Fprintf(ref buf, " data=%q", data);
                    if (len(f.Data()) > max)
                    {
                        fmt.Fprintf(ref buf, " (%d bytes omitted)", len(f.Data()) - max);
                    }
                    break;
                case ref http2WindowUpdateFrame f:
                    if (f.StreamID == 0L)
                    {
                        buf.WriteString(" (conn)");
                    }
                    fmt.Fprintf(ref buf, " incr=%v", f.Increment);
                    break;
                case ref http2PingFrame f:
                    fmt.Fprintf(ref buf, " ping=%q", f.Data[..]);
                    break;
                case ref http2GoAwayFrame f:
                    fmt.Fprintf(ref buf, " LastStreamID=%v ErrCode=%v Debug=%q", f.LastStreamID, f.ErrCode, f.debugData);
                    break;
                case ref http2RSTStreamFrame f:
                    fmt.Fprintf(ref buf, " ErrCode=%v", f.ErrCode);
                    break;
            }
            return buf.String();
        }

        private static time.Duration http2transportExpectContinueTimeout(ref Transport t1)
        {
            return t1.ExpectContinueTimeout;
        }

        private partial interface http2contextContext : context.Context
        {
        }

        private static (http2contextContext, Action) http2serverConnBaseContext(net.Conn c, ref http2ServeConnOpts opts)
        {
            ctx, cancel = context.WithCancel(context.Background());
            ctx = context.WithValue(ctx, LocalAddrContextKey, c.LocalAddr());
            {
                var hs = opts.baseConfig();

                if (hs != null)
                {
                    ctx = context.WithValue(ctx, ServerContextKey, hs);
                }

            }
            return;
        }

        private static (http2contextContext, Action) http2contextWithCancel(http2contextContext ctx)
        {
            return context.WithCancel(ctx);
        }

        private static ref Request http2requestWithContext(ref Request req, http2contextContext ctx)
        {
            return req.WithContext(ctx);
        }

        private partial struct http2clientTrace // : httptrace.ClientTrace
        {
        }

        private static context.Context http2reqContext(ref Request r)
        {
            return r.Context();
        }

        private static time.Duration idleConnTimeout(this ref http2Transport t)
        {
            if (t.t1 != null)
            {
                return t.t1.IdleConnTimeout;
            }
            return 0L;
        }

        private static void http2setResponseUncompressed(ref Response res)
        {
            res.Uncompressed = true;

        }

        private static void http2traceGotConn(ref Request req, ref http2ClientConn cc)
        {
            var trace = httptrace.ContextClientTrace(req.Context());
            if (trace == null || trace.GotConn == null)
            {
                return;
            }
            httptrace.GotConnInfo ci = new httptrace.GotConnInfo(Conn:cc.tconn);
            cc.mu.Lock();
            ci.Reused = cc.nextStreamID > 1L;
            ci.WasIdle = len(cc.streams) == 0L && ci.Reused;
            if (ci.WasIdle && !cc.lastActive.IsZero())
            {
                ci.IdleTime = time.Now().Sub(cc.lastActive);
            }
            cc.mu.Unlock();

            trace.GotConn(ci);
        }

        private static void http2traceWroteHeaders(ref http2clientTrace trace)
        {
            if (trace != null && trace.WroteHeaders != null)
            {
                trace.WroteHeaders();
            }
        }

        private static void http2traceGot100Continue(ref http2clientTrace trace)
        {
            if (trace != null && trace.Got100Continue != null)
            {
                trace.Got100Continue();
            }
        }

        private static void http2traceWait100Continue(ref http2clientTrace trace)
        {
            if (trace != null && trace.Wait100Continue != null)
            {
                trace.Wait100Continue();
            }
        }

        private static void http2traceWroteRequest(ref http2clientTrace trace, error err)
        {
            if (trace != null && trace.WroteRequest != null)
            {
                trace.WroteRequest(new httptrace.WroteRequestInfo(Err:err));
            }
        }

        private static void http2traceFirstResponseByte(ref http2clientTrace trace)
        {
            if (trace != null && trace.GotFirstResponseByte != null)
            {
                trace.GotFirstResponseByte();
            }
        }

        private static ref http2clientTrace http2requestTrace(ref Request req)
        {
            var trace = httptrace.ContextClientTrace(req.Context());
            return (http2clientTrace.Value)(trace);
        }

        // Ping sends a PING frame to the server and waits for the ack.
        private static error Ping(this ref http2ClientConn cc, context.Context ctx)
        {
            return error.As(cc.ping(ctx));
        }

        private static ref tls.Config http2cloneTLSConfig(ref tls.Config c)
        {
            var c2 = c.Clone();
            c2.GetClientCertificate = c.GetClientCertificate; // golang.org/issue/19264
            return c2;
        }

        private static Pusher _ = (http2responseWriter.Value)(null);

        // Push implements http.Pusher.
        private static error Push(this ref http2responseWriter w, @string target, ref PushOptions opts)
        {
            http2pushOptions internalOpts = new http2pushOptions();
            if (opts != null)
            {
                internalOpts.Method = opts.Method;
                internalOpts.Header = opts.Header;
            }
            return error.As(w.push(target, internalOpts));
        }

        private static error http2configureServer18(ref Server h1, ref http2Server h2)
        {
            if (h2.IdleTimeout == 0L)
            {
                if (h1.IdleTimeout != 0L)
                {
                    h2.IdleTimeout = h1.IdleTimeout;
                }
                else
                {
                    h2.IdleTimeout = h1.ReadTimeout;
                }
            }
            return error.As(null);
        }

        private static bool http2shouldLogPanic(object panicValue)
        {
            return panicValue != null && panicValue != ErrAbortHandler;
        }

        private static Func<(io.ReadCloser, error)> http2reqGetBody(ref Request req)
        {
            return req.GetBody;
        }

        private static bool http2reqBodyIsNoBody(io.ReadCloser body)
        {
            return body == NoBody;
        }

        private static io.ReadCloser http2go18httpNoBody()
        {
            return NoBody;
        } // for tests only

        private static error http2configureServer19(ref Server s, ref http2Server conf)
        {
            s.RegisterOnShutdown(conf.state.startGracefulShutdown);
            return error.As(null);
        }

        private static var http2DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1";

        private partial struct http2goroutineLock // : ulong
        {
        }

        private static http2goroutineLock http2newGoroutineLock()
        {
            if (!http2DebugGoroutines)
            {
                return 0L;
            }
            return http2goroutineLock(http2curGoroutineID());
        }

        private static void check(this http2goroutineLock g) => func((_, panic, __) =>
        {
            if (!http2DebugGoroutines)
            {
                return;
            }
            if (http2curGoroutineID() != uint64(g))
            {
                panic("running on the wrong goroutine");
            }
        });

        private static void checkNotOn(this http2goroutineLock g) => func((_, panic, __) =>
        {
            if (!http2DebugGoroutines)
            {
                return;
            }
            if (http2curGoroutineID() == uint64(g))
            {
                panic("running on the wrong goroutine");
            }
        });

        private static slice<byte> http2goroutineSpace = (slice<byte>)"goroutine ";

        private static ulong http2curGoroutineID() => func((defer, panic, _) =>
        {
            ref slice<byte> bp = http2littleBuf.Get()._<ref slice<byte>>();
            defer(http2littleBuf.Put(bp));
            var b = bp.Value;
            b = b[..runtime.Stack(b, false)]; 
            // Parse the 4707 out of "goroutine 4707 ["
            b = bytes.TrimPrefix(b, http2goroutineSpace);
            var i = bytes.IndexByte(b, ' ');
            if (i < 0L)
            {
                panic(fmt.Sprintf("No space found in %q", b));
            }
            b = b[..i];
            var (n, err) = http2parseUintBytes(b, 10L, 64L);
            if (err != null)
            {
                panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err));
            }
            return n;
        });

        private static sync.Pool http2littleBuf = new sync.Pool(New:func()interface{}{buf:=make([]byte,64)return&buf},);

        // parseUintBytes is like strconv.ParseUint, but using a []byte.
        private static (ulong, error) http2parseUintBytes(slice<byte> s, long @base, long bitSize)
        {
            ulong cutoff = default;            ulong maxVal = default;



            if (bitSize == 0L)
            {
                bitSize = int(strconv.IntSize);
            }
            var s0 = s;

            if (len(s) < 1L) 
                err = strconv.ErrSyntax;
                goto Error;
            else if (2L <= base && base <= 36L)             else if (base == 0L) 
                // Look for octal, hex prefix.

                if (s[0L] == '0' && len(s) > 1L && (s[1L] == 'x' || s[1L] == 'X')) 
                    base = 16L;
                    s = s[2L..];
                    if (len(s) < 1L)
                    {
                        err = strconv.ErrSyntax;
                        goto Error;
                    }
                else if (s[0L] == '0') 
                    base = 8L;
                else 
                    base = 10L;
                            else 
                err = errors.New("invalid base " + strconv.Itoa(base));
                goto Error;
                        n = 0L;
            cutoff = http2cutoff64(base);
            maxVal = 1L << (int)(uint(bitSize)) - 1L;

            for (long i = 0L; i < len(s); i++)
            {
                byte v = default;
                var d = s[i];

                if ('0' <= d && d <= '9') 
                    v = d - '0';
                else if ('a' <= d && d <= 'z') 
                    v = d - 'a' + 10L;
                else if ('A' <= d && d <= 'Z') 
                    v = d - 'A' + 10L;
                else 
                    n = 0L;
                    err = strconv.ErrSyntax;
                    goto Error;
                                if (int(v) >= base)
                {
                    n = 0L;
                    err = strconv.ErrSyntax;
                    goto Error;
                }
                if (n >= cutoff)
                { 
                    // n*base overflows
                    n = 1L << (int)(64L) - 1L;
                    err = strconv.ErrRange;
                    goto Error;
                }
                n *= uint64(base);

                var n1 = n + uint64(v);
                if (n1 < n || n1 > maxVal)
                { 
                    // n+v overflows
                    n = 1L << (int)(64L) - 1L;
                    err = strconv.ErrRange;
                    goto Error;
                }
                n = n1;
            }


            return (n, null);

Error:
            return (n, ref new strconv.NumError(Func:"ParseUint",Num:string(s0),Err:err));
        }

        // Return the first number n such that n*base >= 1<<64.
        private static ulong http2cutoff64(long @base)
        {
            if (base < 2L)
            {
                return 0L;
            }
            return (1L << (int)(64L) - 1L) / uint64(base) + 1L;
        }

        private static map http2commonLowerHeader = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, @string>{};        private static map http2commonCanonHeader = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, @string>{};

        private static void init()
        {
            foreach (var (_, v) in new slice<@string>(new @string[] { "accept", "accept-charset", "accept-encoding", "accept-language", "accept-ranges", "age", "access-control-allow-origin", "allow", "authorization", "cache-control", "content-disposition", "content-encoding", "content-language", "content-length", "content-location", "content-range", "content-type", "cookie", "date", "etag", "expect", "expires", "from", "host", "if-match", "if-modified-since", "if-none-match", "if-unmodified-since", "last-modified", "link", "location", "max-forwards", "proxy-authenticate", "proxy-authorization", "range", "referer", "refresh", "retry-after", "server", "set-cookie", "strict-transport-security", "trailer", "transfer-encoding", "user-agent", "vary", "via", "www-authenticate" }))
            {
                var chk = CanonicalHeaderKey(v);
                http2commonLowerHeader[chk] = v;
                http2commonCanonHeader[v] = chk;
            }
        }

        private static @string http2lowerHeader(@string v)
        {
            {
                var (s, ok) = http2commonLowerHeader[v];

                if (ok)
                {
                    return s;
                }

            }
            return strings.ToLower(v);
        }

        private static bool http2VerboseLogs = default;        private static bool http2logFrameWrites = default;        private static bool http2logFrameReads = default;        private static bool http2inTests = default;

        private static void init()
        {
            var e = os.Getenv("GODEBUG");
            if (strings.Contains(e, "http2debug=1"))
            {
                http2VerboseLogs = true;
            }
            if (strings.Contains(e, "http2debug=2"))
            {
                http2VerboseLogs = true;
                http2logFrameWrites = true;
                http2logFrameReads = true;
            }
        }

 
        // ClientPreface is the string that must be sent by new
        // connections from clients.
        private static readonly @string http2ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"; 

        // SETTINGS_MAX_FRAME_SIZE default
        // http://http2.github.io/http2-spec/#rfc.section.6.5.2
        private static readonly long http2initialMaxFrameSize = 16384L; 

        // NextProtoTLS is the NPN/ALPN protocol negotiated during
        // HTTP/2's TLS setup.
        private static readonly @string http2NextProtoTLS = "h2"; 

        // http://http2.github.io/http2-spec/#SettingValues
        private static readonly long http2initialHeaderTableSize = 4096L;

        private static readonly long http2initialWindowSize = 65535L; // 6.9.2 Initial Flow Control Window Size

        private static readonly long http2defaultMaxReadFrameSize = 1L << (int)(20L);

        private static slice<byte> http2clientPreface = (slice<byte>)http2ClientPreface;

        private partial struct http2streamState // : long
        {
        }

        // HTTP/2 stream states.
        //
        // See http://tools.ietf.org/html/rfc7540#section-5.1.
        //
        // For simplicity, the server code merges "reserved (local)" into
        // "half-closed (remote)". This is one less state transition to track.
        // The only downside is that we send PUSH_PROMISEs slightly less
        // liberally than allowable. More discussion here:
        // https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
        //
        // "reserved (remote)" is omitted since the client code does not
        // support server push.
        private static readonly http2streamState http2stateIdle = iota;
        private static readonly var http2stateOpen = 0;
        private static readonly var http2stateHalfClosedLocal = 1;
        private static readonly var http2stateHalfClosedRemote = 2;
        private static readonly var http2stateClosed = 3;

        private static array<@string> http2stateName = new array<@string>(InitKeyedValues<@string>((http2stateIdle, "Idle"), (http2stateOpen, "Open"), (http2stateHalfClosedLocal, "HalfClosedLocal"), (http2stateHalfClosedRemote, "HalfClosedRemote"), (http2stateClosed, "Closed")));

        private static @string String(this http2streamState st)
        {
            return http2stateName[st];
        }

        // Setting is a setting parameter: which setting it is, and its value.
        private partial struct http2Setting
        {
            public http2SettingID ID; // Val is the value.
            public uint Val;
        }

        private static @string String(this http2Setting s)
        {
            return fmt.Sprintf("[%v = %d]", s.ID, s.Val);
        }

        // Valid reports whether the setting is valid.
        private static error Valid(this http2Setting s)
        { 
            // Limits and error codes from 6.5.2 Defined SETTINGS Parameters

            if (s.ID == http2SettingEnablePush) 
                if (s.Val != 1L && s.Val != 0L)
                {
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                }
            else if (s.ID == http2SettingInitialWindowSize) 
                if (s.Val > 1L << (int)(31L) - 1L)
                {
                    return error.As(http2ConnectionError(http2ErrCodeFlowControl));
                }
            else if (s.ID == http2SettingMaxFrameSize) 
                if (s.Val < 16384L || s.Val > 1L << (int)(24L) - 1L)
                {
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                }
                        return error.As(null);
        }

        // A SettingID is an HTTP/2 setting as defined in
        // http://http2.github.io/http2-spec/#iana-settings
        private partial struct http2SettingID // : ushort
        {
        }

        private static readonly http2SettingID http2SettingHeaderTableSize = 0x1UL;
        private static readonly http2SettingID http2SettingEnablePush = 0x2UL;
        private static readonly http2SettingID http2SettingMaxConcurrentStreams = 0x3UL;
        private static readonly http2SettingID http2SettingInitialWindowSize = 0x4UL;
        private static readonly http2SettingID http2SettingMaxFrameSize = 0x5UL;
        private static readonly http2SettingID http2SettingMaxHeaderListSize = 0x6UL;

        private static map http2settingName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2SettingID, @string>{http2SettingHeaderTableSize:"HEADER_TABLE_SIZE",http2SettingEnablePush:"ENABLE_PUSH",http2SettingMaxConcurrentStreams:"MAX_CONCURRENT_STREAMS",http2SettingInitialWindowSize:"INITIAL_WINDOW_SIZE",http2SettingMaxFrameSize:"MAX_FRAME_SIZE",http2SettingMaxHeaderListSize:"MAX_HEADER_LIST_SIZE",};

        private static @string String(this http2SettingID s)
        {
            {
                var (v, ok) = http2settingName[s];

                if (ok)
                {
                    return v;
                }

            }
            return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s));
        }

        private static var http2errInvalidHeaderFieldName = errors.New("http2: invalid header field name");        private static var http2errInvalidHeaderFieldValue = errors.New("http2: invalid header field value");

        // validWireHeaderFieldName reports whether v is a valid header field
        // name (key). See httplex.ValidHeaderName for the base rules.
        //
        // Further, http2 says:
        //   "Just as in HTTP/1.x, header field names are strings of ASCII
        //   characters that are compared in a case-insensitive
        //   fashion. However, header field names MUST be converted to
        //   lowercase prior to their encoding in HTTP/2. "
        private static bool http2validWireHeaderFieldName(@string v)
        {
            if (len(v) == 0L)
            {
                return false;
            }
            foreach (var (_, r) in v)
            {
                if (!httplex.IsTokenRune(r))
                {
                    return false;
                }
                if ('A' <= r && r <= 'Z')
                {
                    return false;
                }
            }
            return true;
        }

        private static map http2httpCodeStringCommon = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<long, @string>{}; // n -> strconv.Itoa(n)

        private static void init()
        {
            for (long i = 100L; i <= 999L; i++)
            {
                {
                    var v = StatusText(i);

                    if (v != "")
                    {
                        http2httpCodeStringCommon[i] = strconv.Itoa(i);
                    }

                }
            }

        }

        private static @string http2httpCodeString(long code)
        {
            {
                var (s, ok) = http2httpCodeStringCommon[code];

                if (ok)
                {
                    return s;
                }

            }
            return strconv.Itoa(code);
        }

        // from pkg io
        private partial interface http2stringWriter
        {
            (long, error) WriteString(@string s);
        }

        // A gate lets two goroutines coordinate their activities.
        private partial struct http2gate // : channel<object>
        {
        }

        private static void Done(this http2gate g)
        {
            g.Send(/* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ struct{}{});

        }

        private static void Wait(this http2gate g)
        {
            g.Receive();

        }

        // A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
        private partial struct http2closeWaiter // : channel<object>
        {
        }

        // Init makes a closeWaiter usable.
        // It exists because so a closeWaiter value can be placed inside a
        // larger struct and have the Mutex and Cond's memory in the same
        // allocation.
        private static void Init(this ref http2closeWaiter cw)
        {
            cw.Value = make_channel<object>();
        }

        // Close marks the closeWaiter as closed and unblocks any waiters.
        private static void Close(this http2closeWaiter cw)
        {
            close(cw);
        }

        // Wait waits for the closeWaiter to become closed.
        private static void Wait(this http2closeWaiter cw)
        {
            cw.Receive();
        }

        // bufferedWriter is a buffered writer that writes to w.
        // Its buffered writer is lazily allocated as needed, to minimize
        // idle memory usage with many connections.
        private partial struct http2bufferedWriter
        {
            public io.Writer w; // immutable
            public ptr<bufio.Writer> bw; // non-nil when data is buffered
        }

        private static ref http2bufferedWriter http2newBufferedWriter(io.Writer w)
        {
            return ref new http2bufferedWriter(w:w);
        }

        // bufWriterPoolBufferSize is the size of bufio.Writer's
        // buffers created using bufWriterPool.
        //
        // TODO: pick a less arbitrary value? this is a bit under
        // (3 x typical 1500 byte MTU) at least. Other than that,
        // not much thought went into it.
        private static readonly long http2bufWriterPoolBufferSize = 4L << (int)(10L);



        private static sync.Pool http2bufWriterPool = new sync.Pool(New:func()interface{}{returnbufio.NewWriterSize(nil,http2bufWriterPoolBufferSize)},);

        private static long Available(this ref http2bufferedWriter w)
        {
            if (w.bw == null)
            {
                return http2bufWriterPoolBufferSize;
            }
            return w.bw.Available();
        }

        private static (long, error) Write(this ref http2bufferedWriter w, slice<byte> p)
        {
            if (w.bw == null)
            {
                ref bufio.Writer bw = http2bufWriterPool.Get()._<ref bufio.Writer>();
                bw.Reset(w.w);
                w.bw = bw;
            }
            return w.bw.Write(p);
        }

        private static error Flush(this ref http2bufferedWriter w)
        {
            var bw = w.bw;
            if (bw == null)
            {
                return error.As(null);
            }
            var err = bw.Flush();
            bw.Reset(null);
            http2bufWriterPool.Put(bw);
            w.bw = null;
            return error.As(err);
        }

        private static uint http2mustUint31(int v) => func((_, panic, __) =>
        {
            if (v < 0L || v > 2147483647L)
            {
                panic("out of range");
            }
            return uint32(v);
        });

        // bodyAllowedForStatus reports whether a given response status code
        // permits a body. See RFC 2616, section 4.4.
        private static bool http2bodyAllowedForStatus(long status)
        {

            if (status >= 100L && status <= 199L) 
                return false;
            else if (status == 204L) 
                return false;
            else if (status == 304L) 
                return false;
                        return true;
        }

        private partial struct http2httpError
        {
            public @string msg;
            public bool timeout;
        }

        private static @string Error(this ref http2httpError e)
        {
            return e.msg;
        }

        private static bool Timeout(this ref http2httpError e)
        {
            return e.timeout;
        }

        private static bool Temporary(this ref http2httpError e)
        {
            return true;
        }

        private static error http2errTimeout = error.As(ref new http2httpError(msg:"http2: timeout awaiting response headers",timeout:true));

        private partial interface http2connectionStater
        {
            tls.ConnectionState ConnectionState();
        }

        private static sync.Pool http2sorterPool = new sync.Pool(New:func()interface{}{returnnew(http2sorter)});

        private partial struct http2sorter
        {
            public slice<@string> v; // owned by sorter
        }

        private static long Len(this ref http2sorter s)
        {
            return len(s.v);
        }

        private static void Swap(this ref http2sorter s, long i, long j)
        {
            s.v[i] = s.v[j];
            s.v[j] = s.v[i];

        }

        private static bool Less(this ref http2sorter s, long i, long j)
        {
            return s.v[i] < s.v[j];
        }

        // Keys returns the sorted keys of h.
        //
        // The returned slice is only valid until s used again or returned to
        // its pool.
        private static slice<@string> Keys(this ref http2sorter s, Header h)
        {
            var keys = s.v[..0L];
            foreach (var (k) in h)
            {
                keys = append(keys, k);
            }
            s.v = keys;
            sort.Sort(s);
            return keys;
        }

        private static void SortStrings(this ref http2sorter s, slice<@string> ss)
        { 
            // Our sorter works on s.v, which sorter owns, so
            // stash it away while we sort the user's buffer.
            var save = s.v;
            s.v = ss;
            sort.Sort(s);
            s.v = save;
        }

        // validPseudoPath reports whether v is a valid :path pseudo-header
        // value. It must be either:
        //
        //     *) a non-empty string starting with '/'
        //     *) the string '*', for OPTIONS requests.
        //
        // For now this is only used a quick check for deciding when to clean
        // up Opaque URLs before sending requests from the Transport.
        // See golang.org/issue/16847
        //
        // We used to enforce that the path also didn't start with "//", but
        // Google's GFE accepts such paths and Chrome sends them, so ignore
        // that part of the spec. See golang.org/issue/19103.
        private static bool http2validPseudoPath(@string v)
        {
            return (len(v) > 0L && v[0L] == '/') || v == "*";
        }

        // pipe is a goroutine-safe io.Reader/io.Writer pair. It's like
        // io.Pipe except there are no PipeReader/PipeWriter halves, and the
        // underlying buffer is an interface. (io.Pipe is always unbuffered)
        private partial struct http2pipe
        {
            public sync.Mutex mu;
            public sync.Cond c; // c.L lazily initialized to &p.mu
            public http2pipeBuffer b; // nil when done reading
            public error err; // read error once empty. non-nil means closed.
            public error breakErr; // immediate read error (caller doesn't see rest of b)
            public channel<object> donec; // closed on error
            public Action readFn; // optional code to run in Read before error
        }

        private partial interface http2pipeBuffer : io.Writer, io.Reader
        {
            long Len();
        }

        private static long Len(this ref http2pipe _p) => func(_p, (ref http2pipe p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.b == null)
            {
                return 0L;
            }
            return p.b.Len();
        });

        // Read waits until data is available and copies bytes
        // from the buffer into p.
        private static (long, error) Read(this ref http2pipe _p, slice<byte> d) => func(_p, (ref http2pipe p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.c.L == null)
            {
                p.c.L = ref p.mu;
            }
            while (true)
            {
                if (p.breakErr != null)
                {
                    return (0L, p.breakErr);
                }
                if (p.b != null && p.b.Len() > 0L)
                {
                    return p.b.Read(d);
                }
                if (p.err != null)
                {
                    if (p.readFn != null)
                    {
                        p.readFn(); // e.g. copy trailers
                        p.readFn = null; // not sticky like p.err
                    }
                    p.b = null;
                    return (0L, p.err);
                }
                p.c.Wait();
            }

        });

        private static var http2errClosedPipeWrite = errors.New("write on closed buffer");

        // Write copies bytes from p into the buffer and wakes a reader.
        // It is an error to write more data than the buffer can hold.
        private static (long, error) Write(this ref http2pipe _p, slice<byte> d) => func(_p, (ref http2pipe p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.c.L == null)
            {
                p.c.L = ref p.mu;
            }
            defer(p.c.Signal());
            if (p.err != null)
            {
                return (0L, http2errClosedPipeWrite);
            }
            if (p.breakErr != null)
            {
                return (len(d), null); // discard when there is no reader
            }
            return p.b.Write(d);
        });

        // CloseWithError causes the next Read (waking up a current blocked
        // Read if needed) to return the provided err after all data has been
        // read.
        //
        // The error must be non-nil.
        private static void CloseWithError(this ref http2pipe p, error err)
        {
            p.closeWithError(ref p.err, err, null);

        }

        // BreakWithError causes the next Read (waking up a current blocked
        // Read if needed) to return the provided err immediately, without
        // waiting for unread data.
        private static void BreakWithError(this ref http2pipe p, error err)
        {
            p.closeWithError(ref p.breakErr, err, null);

        }

        // closeWithErrorAndCode is like CloseWithError but also sets some code to run
        // in the caller's goroutine before returning the error.
        private static void closeWithErrorAndCode(this ref http2pipe p, error err, Action fn)
        {
            p.closeWithError(ref p.err, err, fn);

        }

        private static void closeWithError(this ref http2pipe _p, ref error _dst, error err, Action fn) => func(_p, _dst, (ref http2pipe p, ref error dst, Defer defer, Panic panic, Recover _) =>
        {
            if (err == null)
            {
                panic("err must be non-nil");
            }
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.c.L == null)
            {
                p.c.L = ref p.mu;
            }
            defer(p.c.Signal());
            if (dst != null.Value)
            { 
                // Already been done.
                return;
            }
            p.readFn = fn;
            if (dst == ref p.breakErr)
            {
                p.b = null;
            }
            dst.Value = err;
            p.closeDoneLocked();
        });

        // requires p.mu be held.
        private static void closeDoneLocked(this ref http2pipe p)
        {
            if (p.donec == null)
            {
                return;
            } 
            // Close if unclosed. This isn't racy since we always
            // hold p.mu while closing.
            close(p.donec);
        }

        // Err returns the error (if any) first set by BreakWithError or CloseWithError.
        private static error Err(this ref http2pipe _p) => func(_p, (ref http2pipe p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.breakErr != null)
            {
                return error.As(p.breakErr);
            }
            return error.As(p.err);
        });

        // Done returns a channel which is closed if and when this pipe is closed
        // with CloseWithError.
        private static channel<object> Done(this ref http2pipe _p) => func(_p, (ref http2pipe p, Defer defer, Panic _, Recover __) =>
        {
            p.mu.Lock();
            defer(p.mu.Unlock());
            if (p.donec == null)
            {
                p.donec = make_channel<object>();
                if (p.err != null || p.breakErr != null)
                { 
                    // Already hit an error.
                    p.closeDoneLocked();
                }
            }
            return p.donec;
        });

        private static readonly long http2prefaceTimeout = 10L * time.Second;
        private static readonly long http2firstSettingsTimeout = 2L * time.Second; // should be in-flight with preface anyway
        private static readonly long http2handlerChunkWriteSize = 4L << (int)(10L);
        private static readonly long http2defaultMaxStreams = 250L; // TODO: make this 100 as the GFE seems to?

        private static var http2errClientDisconnected = errors.New("client disconnected");        private static var http2errClosedBody = errors.New("body closed by handler");        private static var http2errHandlerComplete = errors.New("http2: request body closed due to handler exiting");        private static var http2errStreamClosed = errors.New("http2: stream closed");

        private static sync.Pool http2responseWriterStatePool = new sync.Pool(New:func()interface{}{rws:=&http2responseWriterState{}rws.bw=bufio.NewWriterSize(http2chunkWriter{rws},http2handlerChunkWriteSize)returnrws},);

        // Test hooks.
        private static Action http2testHookOnConn = default;        private static Action<ref http2serverConn> http2testHookGetServerConn = default;        private static ref sync.Mutex http2testHookOnPanicMu = default;        private static Func<ref http2serverConn, object, bool> http2testHookOnPanic = default;

        // Server is an HTTP/2 server.
        private partial struct http2Server
        {
            public long MaxHandlers; // MaxConcurrentStreams optionally specifies the number of
// concurrent streams that each client may have open at a
// time. This is unrelated to the number of http.Handler goroutines
// which may be active globally, which is MaxHandlers.
// If zero, MaxConcurrentStreams defaults to at least 100, per
// the HTTP/2 spec's recommendations.
            public uint MaxConcurrentStreams; // MaxReadFrameSize optionally specifies the largest frame
// this server is willing to read. A valid value is between
// 16k and 16M, inclusive. If zero or otherwise invalid, a
// default value is used.
            public uint MaxReadFrameSize; // PermitProhibitedCipherSuites, if true, permits the use of
// cipher suites prohibited by the HTTP/2 spec.
            public bool PermitProhibitedCipherSuites; // IdleTimeout specifies how long until idle clients should be
// closed with a GOAWAY frame. PING frames are not considered
// activity for the purposes of IdleTimeout.
            public time.Duration IdleTimeout; // MaxUploadBufferPerConnection is the size of the initial flow
// control window for each connections. The HTTP/2 spec does not
// allow this to be smaller than 65535 or larger than 2^32-1.
// If the value is outside this range, a default value will be
// used instead.
            public int MaxUploadBufferPerConnection; // MaxUploadBufferPerStream is the size of the initial flow control
// window for each stream. The HTTP/2 spec does not allow this to
// be larger than 2^32-1. If the value is zero or larger than the
// maximum, a default value will be used instead.
            public int MaxUploadBufferPerStream; // NewWriteScheduler constructs a write scheduler for a connection.
// If nil, a default scheduler is chosen.
            public Func<http2WriteScheduler> NewWriteScheduler; // Internal state. This is a pointer (rather than embedded directly)
// so that we don't embed a Mutex in this struct, which will make the
// struct non-copyable, which might break some callers.
            public ptr<http2serverInternalState> state;
        }

        private static int initialConnRecvWindowSize(this ref http2Server s)
        {
            if (s.MaxUploadBufferPerConnection > http2initialWindowSize)
            {
                return s.MaxUploadBufferPerConnection;
            }
            return 1L << (int)(20L);
        }

        private static int initialStreamRecvWindowSize(this ref http2Server s)
        {
            if (s.MaxUploadBufferPerStream > 0L)
            {
                return s.MaxUploadBufferPerStream;
            }
            return 1L << (int)(20L);
        }

        private static uint maxReadFrameSize(this ref http2Server s)
        {
            {
                var v = s.MaxReadFrameSize;

                if (v >= http2minMaxFrameSize && v <= http2maxFrameSize)
                {
                    return v;
                }

            }
            return http2defaultMaxReadFrameSize;
        }

        private static uint maxConcurrentStreams(this ref http2Server s)
        {
            {
                var v = s.MaxConcurrentStreams;

                if (v > 0L)
                {
                    return v;
                }

            }
            return http2defaultMaxStreams;
        }

        private partial struct http2serverInternalState
        {
            public sync.Mutex mu;
        }

        private static void registerConn(this ref http2serverInternalState s, ref http2serverConn sc)
        {
            if (s == null)
            {
                return; // if the Server was used without calling ConfigureServer
            }
            s.mu.Lock();
            s.activeConns[sc] = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ struct{}{};
            s.mu.Unlock();
        }

        private static void unregisterConn(this ref http2serverInternalState s, ref http2serverConn sc)
        {
            if (s == null)
            {
                return; // if the Server was used without calling ConfigureServer
            }
            s.mu.Lock();
            delete(s.activeConns, sc);
            s.mu.Unlock();
        }

        private static void startGracefulShutdown(this ref http2serverInternalState s)
        {
            if (s == null)
            {
                return; // if the Server was used without calling ConfigureServer
            }
            s.mu.Lock();
            foreach (var (sc) in s.activeConns)
            {
                sc.startGracefulShutdown();
            }
            s.mu.Unlock();
        }

        // ConfigureServer adds HTTP/2 support to a net/http Server.
        //
        // The configuration conf may be nil.
        //
        // ConfigureServer must be called before s begins serving.
        private static error http2ConfigureServer(ref Server _s, ref http2Server _conf) => func(_s, _conf, (ref Server s, ref http2Server conf, Defer _, Panic panic, Recover __) =>
        {
            if (s == null)
            {
                panic("nil *http.Server");
            }
            if (conf == null)
            {
                conf = @new<http2Server>();
            }
            conf.state = ref new http2serverInternalState(activeConns:make(map[*http2serverConn]struct{}));
            {
                var err__prev1 = err;

                var err = http2configureServer18(s, conf);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            {
                var err__prev1 = err;

                err = http2configureServer19(s, conf);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }

            if (s.TLSConfig == null)
            {
                s.TLSConfig = @new<tls.Config>();
            }
            else if (s.TLSConfig.CipherSuites != null)
            { 
                // If they already provided a CipherSuite list, return
                // an error if it has a bad order or is missing
                // ECDHE_RSA_WITH_AES_128_GCM_SHA256 or ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.
                var haveRequired = false;
                var sawBad = false;
                foreach (var (i, cs) in s.TLSConfig.CipherSuites)
                {

                    if (cs == tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 || cs == tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) 
                        haveRequired = true;
                                        if (http2isBadCipher(cs))
                    {
                        sawBad = true;
                    }
                    else if (sawBad)
                    {
                        return error.As(fmt.Errorf("http2: TLSConfig.CipherSuites index %d contains an HTTP/2-approved cipher suite (%#04x), but it comes after unapproved cipher suites. With this configuration, clients that don't support previous, approved cipher suites may be given an unapproved one and reject the connection.", i, cs));
                    }
                }
                if (!haveRequired)
                {
                    return error.As(fmt.Errorf("http2: TLSConfig.CipherSuites is missing an HTTP/2-required AES_128_GCM_SHA256 cipher."));
                }
            } 

            // Note: not setting MinVersion to tls.VersionTLS12,
            // as we don't want to interfere with HTTP/1.1 traffic
            // on the user's server. We enforce TLS 1.2 later once
            // we accept a connection. Ideally this should be done
            // during next-proto selection, but using TLS <1.2 with
            // HTTP/2 is still the client's bug.
            s.TLSConfig.PreferServerCipherSuites = true;

            var haveNPN = false;
            foreach (var (_, p) in s.TLSConfig.NextProtos)
            {
                if (p == http2NextProtoTLS)
                {
                    haveNPN = true;
                    break;
                }
            }
            if (!haveNPN)
            {
                s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, http2NextProtoTLS);
            }
            if (s.TLSNextProto == null)
            {
                s.TLSNextProto = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, Action<ref Server, ref tls.Conn, Handler>>{};
            }
            Action<ref Server, ref tls.Conn, Handler> protoHandler = (hs, c, h) =>
            {
                if (http2testHookOnConn != null)
                {
                    http2testHookOnConn();
                }
                conf.ServeConn(c, ref new http2ServeConnOpts(Handler:h,BaseConfig:hs,));
            }
;
            s.TLSNextProto[http2NextProtoTLS] = protoHandler;
            return error.As(null);
        });

        // ServeConnOpts are options for the Server.ServeConn method.
        private partial struct http2ServeConnOpts
        {
            public ptr<Server> BaseConfig; // Handler specifies which handler to use for processing
// requests. If nil, BaseConfig.Handler is used. If BaseConfig
// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
            public Handler Handler;
        }

        private static ref Server baseConfig(this ref http2ServeConnOpts o)
        {
            if (o != null && o.BaseConfig != null)
            {
                return o.BaseConfig;
            }
            return @new<Server>();
        }

        private static Handler handler(this ref http2ServeConnOpts o)
        {
            if (o != null)
            {
                if (o.Handler != null)
                {
                    return o.Handler;
                }
                if (o.BaseConfig != null && o.BaseConfig.Handler != null)
                {
                    return o.BaseConfig.Handler;
                }
            }
            return DefaultServeMux;
        }

        // ServeConn serves HTTP/2 requests on the provided connection and
        // blocks until the connection is no longer readable.
        //
        // ServeConn starts speaking HTTP/2 assuming that c has not had any
        // reads or writes. It writes its initial settings frame and expects
        // to be able to read the preface and settings frame from the
        // client. If c has a ConnectionState method like a *tls.Conn, the
        // ConnectionState is used to verify the TLS ciphersuite and to set
        // the Request.TLS field in Handlers.
        //
        // ServeConn does not support h2c by itself. Any h2c support must be
        // implemented in terms of providing a suitably-behaving net.Conn.
        //
        // The opts parameter is optional. If nil, default values are used.
        private static void ServeConn(this ref http2Server _s, net.Conn c, ref http2ServeConnOpts _opts) => func(_s, _opts, (ref http2Server s, ref http2ServeConnOpts opts, Defer defer, Panic _, Recover __) =>
        {
            var (baseCtx, cancel) = http2serverConnBaseContext(c, opts);
            defer(cancel());

            http2serverConn sc = ref new http2serverConn(srv:s,hs:opts.baseConfig(),conn:c,baseCtx:baseCtx,remoteAddrStr:c.RemoteAddr().String(),bw:http2newBufferedWriter(c),handler:opts.handler(),streams:make(map[uint32]*http2stream),readFrameCh:make(chanhttp2readFrameResult),wantWriteFrameCh:make(chanhttp2FrameWriteRequest,8),serveMsgCh:make(chaninterface{},8),wroteFrameCh:make(chanhttp2frameWriteResult,1),bodyReadCh:make(chanhttp2bodyReadMsg),doneServing:make(chanstruct{}),clientMaxStreams:math.MaxUint32,advMaxStreams:s.maxConcurrentStreams(),initialStreamSendWindowSize:http2initialWindowSize,maxFrameSize:http2initialMaxFrameSize,headerTableSize:http2initialHeaderTableSize,serveG:http2newGoroutineLock(),pushEnabled:true,);

            s.state.registerConn(sc);
            defer(s.state.unregisterConn(sc)); 

            // The net/http package sets the write deadline from the
            // http.Server.WriteTimeout during the TLS handshake, but then
            // passes the connection off to us with the deadline already set.
            // Write deadlines are set per stream in serverConn.newStream.
            // Disarm the net.Conn write deadline here.
            if (sc.hs.WriteTimeout != 0L)
            {
                sc.conn.SetWriteDeadline(new time.Time());
            }
            if (s.NewWriteScheduler != null)
            {
                sc.writeSched = s.NewWriteScheduler();
            }
            else
            {
                sc.writeSched = http2NewRandomWriteScheduler();
            } 

            // These start at the RFC-specified defaults. If there is a higher
            // configured value for inflow, that will be updated when we send a
            // WINDOW_UPDATE shortly after sending SETTINGS.
            sc.flow.add(http2initialWindowSize);
            sc.inflow.add(http2initialWindowSize);
            sc.hpackEncoder = hpack.NewEncoder(ref sc.headerWriteBuf);

            var fr = http2NewFramer(sc.bw, c);
            fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, null);
            fr.MaxHeaderListSize = sc.maxHeaderListSize();
            fr.SetMaxReadFrameSize(s.maxReadFrameSize());
            sc.framer = fr;

            {
                http2connectionStater (tc, ok) = c._<http2connectionStater>();

                if (ok)
                {
                    sc.tlsState = @new<tls.ConnectionState>();
                    sc.tlsState.Value = tc.ConnectionState(); 
                    // 9.2 Use of TLS Features
                    // An implementation of HTTP/2 over TLS MUST use TLS
                    // 1.2 or higher with the restrictions on feature set
                    // and cipher suite described in this section. Due to
                    // implementation limitations, it might not be
                    // possible to fail TLS negotiation. An endpoint MUST
                    // immediately terminate an HTTP/2 connection that
                    // does not meet the TLS requirements described in
                    // this section with a connection error (Section
                    // 5.4.1) of type INADEQUATE_SECURITY.
                    if (sc.tlsState.Version < tls.VersionTLS12)
                    {
                        sc.rejectConn(http2ErrCodeInadequateSecurity, "TLS version too low");
                        return;
                    }
                    if (sc.tlsState.ServerName == "")
                    { 
                        // Client must use SNI, but we don't enforce that anymore,
                        // since it was causing problems when connecting to bare IP
                        // addresses during development.
                        //
                        // TODO: optionally enforce? Or enforce at the time we receive
                        // a new request, and verify the the ServerName matches the :authority?
                        // But that precludes proxy situations, perhaps.
                        //
                        // So for now, do nothing here again.
                    }
                    if (!s.PermitProhibitedCipherSuites && http2isBadCipher(sc.tlsState.CipherSuite))
                    { 
                        // "Endpoints MAY choose to generate a connection error
                        // (Section 5.4.1) of type INADEQUATE_SECURITY if one of
                        // the prohibited cipher suites are negotiated."
                        //
                        // We choose that. In my opinion, the spec is weak
                        // here. It also says both parties must support at least
                        // TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 so there's no
                        // excuses here. If we really must, we could allow an
                        // "AllowInsecureWeakCiphers" option on the server later.
                        // Let's see how it plays out first.
                        sc.rejectConn(http2ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite));
                        return;
                    }
                }

            }

            {
                var hook = http2testHookGetServerConn;

                if (hook != null)
                {
                    hook(sc);
                }

            }
            sc.serve();
        });

        private static void rejectConn(this ref http2serverConn sc, http2ErrCode err, @string debug)
        {
            sc.vlogf("http2: server rejecting conn: %v, %s", err, debug); 
            // ignoring errors. hanging up anyway.
            sc.framer.WriteGoAway(0L, err, (slice<byte>)debug);
            sc.bw.Flush();
            sc.conn.Close();
        }

        private partial struct http2serverConn
        {
            public ptr<http2Server> srv;
            public ptr<Server> hs;
            public net.Conn conn;
            public ptr<http2bufferedWriter> bw; // writing to conn
            public Handler handler;
            public http2contextContext baseCtx;
            public ptr<http2Framer> framer;
            public channel<object> doneServing; // closed when serverConn.serve ends
            public channel<http2readFrameResult> readFrameCh; // written by serverConn.readFrames
            public channel<http2FrameWriteRequest> wantWriteFrameCh; // from handlers -> serve
            public channel<http2frameWriteResult> wroteFrameCh; // from writeFrameAsync -> serve, tickles more frame writes
            public channel<http2bodyReadMsg> bodyReadCh; // from handlers -> serve
            public channel<object> serveMsgCh; // misc messages & code to send to / run on the serve loop
            public http2flow flow; // conn-wide (not stream-specific) outbound flow control
            public http2flow inflow; // conn-wide inbound flow control
            public ptr<tls.ConnectionState> tlsState; // shared by all handlers, like net/http
            public @string remoteAddrStr;
            public http2WriteScheduler writeSched; // Everything following is owned by the serve loop; use serveG.check():
            public http2goroutineLock serveG; // used to verify funcs are on serve()
            public bool pushEnabled;
            public bool sawFirstSettings; // got the initial SETTINGS frame after the preface
            public bool needToSendSettingsAck;
            public long unackedSettings; // how many SETTINGS have we sent without ACKs?
            public uint clientMaxStreams; // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
            public uint advMaxStreams; // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
            public uint curClientStreams; // number of open streams initiated by the client
            public uint curPushedStreams; // number of open streams initiated by server push
            public uint maxClientStreamID; // max ever seen from client (odd), or 0 if there have been no client requests
            public uint maxPushPromiseID; // ID of the last push promise (even), or 0 if there have been no pushes
            public map<uint, ref http2stream> streams;
            public int initialStreamSendWindowSize;
            public int maxFrameSize;
            public uint headerTableSize;
            public uint peerMaxHeaderListSize; // zero means unknown (default)
            public map<@string, @string> canonHeader; // http2-lower-case -> Go-Canonical-Case
            public bool writingFrame; // started writing a frame (on serve goroutine or separate)
            public bool writingFrameAsync; // started a frame on its own goroutine but haven't heard back on wroteFrameCh
            public bool needsFrameFlush; // last frame write wasn't a flush
            public bool inGoAway; // we've started to or sent GOAWAY
            public bool inFrameScheduleLoop; // whether we're in the scheduleFrameWrite loop
            public bool needToSendGoAway; // we need to schedule a GOAWAY frame write
            public http2ErrCode goAwayCode;
            public ptr<time.Timer> shutdownTimer; // nil until used
            public ptr<time.Timer> idleTimer; // nil if unused

// Owned by the writeFrameAsync goroutine:
            public bytes.Buffer headerWriteBuf;
            public ptr<hpack.Encoder> hpackEncoder; // Used by startGracefulShutdown.
            public sync.Once shutdownOnce;
        }

        private static uint maxHeaderListSize(this ref http2serverConn sc)
        {
            var n = sc.hs.MaxHeaderBytes;
            if (n <= 0L)
            {
                n = DefaultMaxHeaderBytes;
            } 
            // http2's count is in a slightly different unit and includes 32 bytes per pair.
            // So, take the net/http.Server value and pad it up a bit, assuming 10 headers.
            const long perFieldOverhead = 32L; // per http2 spec
 // per http2 spec
            const long typicalHeaders = 10L; // conservative
 // conservative
            return uint32(n + typicalHeaders * perFieldOverhead);
        }

        private static uint curOpenStreams(this ref http2serverConn sc)
        {
            sc.serveG.check();
            return sc.curClientStreams + sc.curPushedStreams;
        }

        // stream represents a stream. This is the minimal metadata needed by
        // the serve goroutine. Most of the actual stream state is owned by
        // the http.Handler's goroutine in the responseWriter. Because the
        // responseWriter's responseWriterState is recycled at the end of a
        // handler, this struct intentionally has no pointer to the
        // *responseWriter{,State} itself, as the Handler ending nils out the
        // responseWriter's state field.
        private partial struct http2stream
        {
            public ptr<http2serverConn> sc;
            public uint id;
            public ptr<http2pipe> body; // non-nil if expecting DATA frames
            public http2closeWaiter cw; // closed wait stream transitions to closed state
            public http2contextContext ctx;
            public Action cancelCtx; // owned by serverConn's serve loop:
            public long bodyBytes; // body bytes seen so far
            public long declBodyBytes; // or -1 if undeclared
            public http2flow flow; // limits writing from Handler to client
            public http2flow inflow; // what the client is allowed to POST/etc to us
            public ptr<http2stream> parent; // or nil
            public long numTrailerValues;
            public byte weight;
            public http2streamState state;
            public bool resetQueued; // RST_STREAM queued for write; set by sc.resetStream
            public bool gotTrailerHeader; // HEADER frame for trailers was seen
            public bool wroteHeaders; // whether we wrote headers (not status 100)
            public ptr<time.Timer> writeDeadline; // nil if unused

            public Header trailer; // accumulated trailers
            public Header reqTrailer; // handler's Request.Trailer
        }

        private static ref http2Framer Framer(this ref http2serverConn sc)
        {
            return sc.framer;
        }

        private static error CloseConn(this ref http2serverConn sc)
        {
            return error.As(sc.conn.Close());
        }

        private static error Flush(this ref http2serverConn sc)
        {
            return error.As(sc.bw.Flush());
        }

        private static (ref hpack.Encoder, ref bytes.Buffer) HeaderEncoder(this ref http2serverConn sc)
        {
            return (sc.hpackEncoder, ref sc.headerWriteBuf);
        }

        private static (http2streamState, ref http2stream) state(this ref http2serverConn sc, uint streamID)
        {
            sc.serveG.check(); 
            // http://tools.ietf.org/html/rfc7540#section-5.1
            {
                var (st, ok) = sc.streams[streamID];

                if (ok)
                {
                    return (st.state, st);
                } 
                // "The first use of a new stream identifier implicitly closes all
                // streams in the "idle" state that might have been initiated by
                // that peer with a lower-valued stream identifier. For example, if
                // a client sends a HEADERS frame on stream 7 without ever sending a
                // frame on stream 5, then stream 5 transitions to the "closed"
                // state when the first frame for stream 7 is sent or received."

            } 
            // "The first use of a new stream identifier implicitly closes all
            // streams in the "idle" state that might have been initiated by
            // that peer with a lower-valued stream identifier. For example, if
            // a client sends a HEADERS frame on stream 7 without ever sending a
            // frame on stream 5, then stream 5 transitions to the "closed"
            // state when the first frame for stream 7 is sent or received."
            if (streamID % 2L == 1L)
            {
                if (streamID <= sc.maxClientStreamID)
                {
                    return (http2stateClosed, null);
                }
            }
            else
            {
                if (streamID <= sc.maxPushPromiseID)
                {
                    return (http2stateClosed, null);
                }
            }
            return (http2stateIdle, null);
        }

        // setConnState calls the net/http ConnState hook for this connection, if configured.
        // Note that the net/http package does StateNew and StateClosed for us.
        // There is currently no plan for StateHijacked or hijacking HTTP/2 connections.
        private static void setConnState(this ref http2serverConn sc, ConnState state)
        {
            if (sc.hs.ConnState != null)
            {
                sc.hs.ConnState(sc.conn, state);
            }
        }

        private static void vlogf(this ref http2serverConn sc, @string format, params object[] args)
        {
            if (http2VerboseLogs)
            {
                sc.logf(format, args);
            }
        }

        private static void logf(this ref http2serverConn sc, @string format, params object[] args)
        {
            {
                var lg = sc.hs.ErrorLog;

                if (lg != null)
                {
                    lg.Printf(format, args);
                }
                else
                {
                    log.Printf(format, args);
                }

            }
        }

        // errno returns v's underlying uintptr, else 0.
        //
        // TODO: remove this helper function once http2 can use build
        // tags. See comment in isClosedConnError.
        private static System.UIntPtr http2errno(error v)
        {
            {
                var rv = reflect.ValueOf(v);

                if (rv.Kind() == reflect.Uintptr)
                {
                    return uintptr(rv.Uint());
                }

            }
            return 0L;
        }

        // isClosedConnError reports whether err is an error from use of a closed
        // network connection.
        private static bool http2isClosedConnError(error err)
        {
            if (err == null)
            {
                return false;
            } 

            // TODO: remove this string search and be more like the Windows
            // case below. That might involve modifying the standard library
            // to return better error types.
            var str = err.Error();
            if (strings.Contains(str, "use of closed network connection"))
            {
                return true;
            } 

            // TODO(bradfitz): x/tools/cmd/bundle doesn't really support
            // build tags, so I can't make an http2_windows.go file with
            // Windows-specific stuff. Fix that and move this, once we
            // have a way to bundle this into std's net/http somehow.
            if (runtime.GOOS == "windows")
            {
                {
                    ref net.OpError (oe, ok) = err._<ref net.OpError>();

                    if (ok && oe.Op == "read")
                    {
                        {
                            ref os.SyscallError (se, ok) = oe.Err._<ref os.SyscallError>();

                            if (ok && se.Syscall == "wsarecv")
                            {
                                const long WSAECONNABORTED = 10053L;

                                const long WSAECONNRESET = 10054L;

                                {
                                    var n = http2errno(se.Err);

                                    if (n == WSAECONNRESET || n == WSAECONNABORTED)
                                    {
                                        return true;
                                    }

                                }
                            }

                        }
                    }

                }
            }
            return false;
        }

        private static void condlogf(this ref http2serverConn sc, error err, @string format, params object[] args)
        {
            if (err == null)
            {
                return;
            }
            if (err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err) || err == http2errPrefaceTimeout)
            { 
                // Boring, expected errors.
                sc.vlogf(format, args);
            }
            else
            {
                sc.logf(format, args);
            }
        }

        private static @string canonicalHeader(this ref http2serverConn sc, @string v)
        {
            sc.serveG.check();
            var (cv, ok) = http2commonCanonHeader[v];
            if (ok)
            {
                return cv;
            }
            cv, ok = sc.canonHeader[v];
            if (ok)
            {
                return cv;
            }
            if (sc.canonHeader == null)
            {
                sc.canonHeader = make_map<@string, @string>();
            }
            cv = CanonicalHeaderKey(v);
            sc.canonHeader[v] = cv;
            return cv;
        }

        private partial struct http2readFrameResult
        {
            public http2Frame f; // valid until readMore is called
            public error err; // readMore should be called once the consumer no longer needs or
// retains f. After readMore, f is invalid and more frames can be
// read.
            public Action readMore;
        }

        // readFrames is the loop that reads incoming frames.
        // It takes care to only read one frame at a time, blocking until the
        // consumer is done with the frame.
        // It's run on its own goroutine.
        private static void readFrames(this ref http2serverConn sc)
        {
            var gate = make(http2gate);
            var gateDone = gate.Done;
            while (true)
            {
                var (f, err) = sc.framer.ReadFrame();
                return;
                return;
                if (http2terminalReadFrameError(err))
                {
                    return;
                }
            }

        }

        // frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.
        private partial struct http2frameWriteResult
        {
            public http2FrameWriteRequest wr; // what was written (or attempted)
            public error err; // result of the writeFrame call
        }

        // writeFrameAsync runs in its own goroutine and writes a single frame
        // and then reports when it's done.
        // At most one goroutine can be running writeFrameAsync at a time per
        // serverConn.
        private static void writeFrameAsync(this ref http2serverConn sc, http2FrameWriteRequest wr)
        {
            var err = wr.write.writeFrame(sc);
            sc.wroteFrameCh.Send(new http2frameWriteResult(wr,err));
        }

        private static void closeAllStreamsOnConnClose(this ref http2serverConn sc)
        {
            sc.serveG.check();
            foreach (var (_, st) in sc.streams)
            {
                sc.closeStream(st, http2errClientDisconnected);
            }
        }

        private static void stopShutdownTimer(this ref http2serverConn sc)
        {
            sc.serveG.check();
            {
                var t = sc.shutdownTimer;

                if (t != null)
                {
                    t.Stop();
                }

            }
        }

        private static void notePanic(this ref http2serverConn _sc) => func(_sc, (ref http2serverConn sc, Defer defer, Panic panic, Recover _) =>
        { 
            // Note: this is for serverConn.serve panicking, not http.Handler code.
            if (http2testHookOnPanicMu != null)
            {
                http2testHookOnPanicMu.Lock();
                defer(http2testHookOnPanicMu.Unlock());
            }
            if (http2testHookOnPanic != null)
            {
                {
                    var e = recover();

                    if (e != null)
                    {
                        if (http2testHookOnPanic(sc, e))
                        {
                            panic(e);
                        }
                    }

                }
            }
        });

        private static void serve(this ref http2serverConn _sc) => func(_sc, (ref http2serverConn sc, Defer defer, Panic panic, Recover _) =>
        {
            sc.serveG.check();
            defer(sc.notePanic());
            defer(sc.conn.Close());
            defer(sc.closeAllStreamsOnConnClose());
            defer(sc.stopShutdownTimer());
            defer(close(sc.doneServing)); // unblocks handlers trying to send

            if (http2VerboseLogs)
            {
                sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs);
            }
            sc.writeFrame(new http2FrameWriteRequest(write:http2writeSettings{{http2SettingMaxFrameSize,sc.srv.maxReadFrameSize()},{http2SettingMaxConcurrentStreams,sc.advMaxStreams},{http2SettingMaxHeaderListSize,sc.maxHeaderListSize()},{http2SettingInitialWindowSize,uint32(sc.srv.initialStreamRecvWindowSize())},},));
            sc.unackedSettings++; 

            // Each connection starts with intialWindowSize inflow tokens.
            // If a higher value is configured, we add more tokens.
            {
                var diff = sc.srv.initialConnRecvWindowSize() - http2initialWindowSize;

                if (diff > 0L)
                {
                    sc.sendWindowUpdate(null, int(diff));
                }

            }

            {
                var err = sc.readPreface();

                if (err != null)
                {
                    sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err);
                    return;
                } 
                // Now that we've got the preface, get us out of the
                // "StateNew" state. We can't go directly to idle, though.
                // Active means we read some data and anticipate a request. We'll
                // do another Active when we get a HEADERS frame.

            } 
            // Now that we've got the preface, get us out of the
            // "StateNew" state. We can't go directly to idle, though.
            // Active means we read some data and anticipate a request. We'll
            // do another Active when we get a HEADERS frame.
            sc.setConnState(StateActive);
            sc.setConnState(StateIdle);

            if (sc.srv.IdleTimeout != 0L)
            {
                sc.idleTimer = time.AfterFunc(sc.srv.IdleTimeout, sc.onIdleTimer);
                defer(sc.idleTimer.Stop());
            }
            go_(() => sc.readFrames()); // closed by defer sc.conn.Close above

            var settingsTimer = time.AfterFunc(http2firstSettingsTimeout, sc.onSettingsTimer);
            defer(settingsTimer.Stop());

            long loopNum = 0L;
            while (true)
            {
                loopNum++;
                {
                    http2StreamError (se, ok) = wr.write._<http2StreamError>();

                    if (ok)
                    {
                        sc.resetStream(se);
                        break;
                    }

                }
                sc.writeFrame(wr);
                sc.wroteFrame(res);
                if (!sc.processFrameFromReader(res))
                {
                    return;
                }
                res.readMore();
                if (settingsTimer != null)
                {
                    settingsTimer.Stop();
                    settingsTimer = null;
                }
                sc.noteBodyRead(m.st, m.n);
                switch (msg.type())
                {
                    case Action<long> v:
                        v(loopNum); // for testing
                        break;
                    case ref http2serverMessage v:

                        if (v == http2settingsTimerMsg) 
                            sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr());
                            return;
                        else if (v == http2idleTimerMsg) 
                            sc.vlogf("connection is idle");
                            sc.goAway(http2ErrCodeNo);
                        else if (v == http2shutdownTimerMsg) 
                            sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr());
                            return;
                        else if (v == http2gracefulShutdownMsg) 
                            sc.startGracefulShutdownInternal();
                        else 
                            panic("unknown timer");
                                                break;
                    case ref http2startPushRequest v:
                        sc.startPush(v);
                        break;
                    default:
                    {
                        var v = msg.type();
                        panic(fmt.Sprintf("unexpected type %T", v));
                        break;
                    }
                }
                var sentGoAway = sc.inGoAway && !sc.needToSendGoAway && !sc.writingFrame;
                var gracefulShutdownComplete = sc.goAwayCode == http2ErrCodeNo && sc.curOpenStreams() == 0L;
                if (sentGoAway && sc.shutdownTimer == null && (sc.goAwayCode != http2ErrCodeNo || gracefulShutdownComplete))
                {
                    sc.shutDownIn(http2goAwayTimeout);
                }
            }

        });

        private static void awaitGracefulShutdown(this ref http2serverConn sc, channel<object> sharedCh, channel<object> privateCh)
        {
            close(privateCh);
        }

        private partial struct http2serverMessage // : long
        {
        }

        // Message values sent to serveMsgCh.
        private static ptr<http2serverMessage> http2settingsTimerMsg = @new<http2serverMessage>();        private static ptr<http2serverMessage> http2idleTimerMsg = @new<http2serverMessage>();        private static ptr<http2serverMessage> http2shutdownTimerMsg = @new<http2serverMessage>();        private static ptr<http2serverMessage> http2gracefulShutdownMsg = @new<http2serverMessage>();

        private static void onSettingsTimer(this ref http2serverConn sc)
        {
            sc.sendServeMsg(http2settingsTimerMsg);

        }

        private static void onIdleTimer(this ref http2serverConn sc)
        {
            sc.sendServeMsg(http2idleTimerMsg);

        }

        private static void onShutdownTimer(this ref http2serverConn sc)
        {
            sc.sendServeMsg(http2shutdownTimerMsg);

        }

        private static void sendServeMsg(this ref http2serverConn sc, object msg)
        {
            sc.serveG.checkNotOn(); // NOT
        }

        private static var http2errPrefaceTimeout = errors.New("timeout waiting for client preface");

        // readPreface reads the ClientPreface greeting from the peer or
        // returns errPrefaceTimeout on timeout, or an error if the greeting
        // is invalid.
        private static error readPreface(this ref http2serverConn _sc) => func(_sc, (ref http2serverConn sc, Defer defer, Panic _, Recover __) =>
        {
            var errc = make_channel<error>(1L);
            go_(() => () =>
            { 
                // Read the client preface
                var buf = make_slice<byte>(len(http2ClientPreface));
                {
                    var (_, err) = io.ReadFull(sc.conn, buf);

                    if (err != null)
                    {
                        errc.Send(err);
                    }
                    else if (!bytes.Equal(buf, http2clientPreface))
                    {
                        errc.Send(fmt.Errorf("bogus greeting %q", buf));
                    }
                    else
                    {
                        errc.Send(null);
                    }

                }
            }());
            var timer = time.NewTimer(http2prefaceTimeout); // TODO: configurable on *Server?
            defer(timer.Stop());
            return error.As(http2errPrefaceTimeout);
            if (err == null)
            {
                if (http2VerboseLogs)
                {
                    sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr());
                }
            }
            return error.As(err);
        });

        private static sync.Pool http2errChanPool = new sync.Pool(New:func()interface{}{returnmake(chanerror,1)},);

        private static sync.Pool http2writeDataPool = new sync.Pool(New:func()interface{}{returnnew(http2writeData)},);

        // writeDataFromHandler writes DATA response frames from a handler on
        // the given stream.
        private static error writeDataFromHandler(this ref http2serverConn sc, ref http2stream stream, slice<byte> data, bool endStream)
        {
            channel<error> ch = http2errChanPool.Get()._<channel<error>>();
            ref http2writeData writeArg = http2writeDataPool.Get()._<ref http2writeData>();
            writeArg.Value = new http2writeData(stream.id,data,endStream);
            var err = sc.writeFrameFromHandler(new http2FrameWriteRequest(write:writeArg,stream:stream,done:ch,));
            if (err != null)
            {
                return error.As(err);
            }
            bool frameWriteDone = default; // the frame write is done (successfully or not)
            frameWriteDone = true;
            return error.As(http2errClientDisconnected);
            frameWriteDone = true;
            return error.As(http2errStreamClosed);
            http2errChanPool.Put(ch);
            if (frameWriteDone)
            {
                http2writeDataPool.Put(writeArg);
            }
            return error.As(err);
        }

        // writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts
        // if the connection has gone away.
        //
        // This must not be run from the serve goroutine itself, else it might
        // deadlock writing to sc.wantWriteFrameCh (which is only mildly
        // buffered and is read by serve itself). If you're on the serve
        // goroutine, call writeFrame instead.
        private static error writeFrameFromHandler(this ref http2serverConn sc, http2FrameWriteRequest wr)
        {
            sc.serveG.checkNotOn(); // NOT
            return error.As(null);
            return error.As(http2errClientDisconnected);
        }

        // writeFrame schedules a frame to write and sends it if there's nothing
        // already being written.
        //
        // There is no pushback here (the serve goroutine never blocks). It's
        // the http.Handlers that block, waiting for their previous frames to
        // make it onto the wire
        //
        // If you're not on the serve goroutine, use writeFrameFromHandler instead.
        private static void writeFrame(this ref http2serverConn _sc, http2FrameWriteRequest wr) => func(_sc, (ref http2serverConn sc, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check(); 

            // If true, wr will not be written and wr.done will not be signaled.
            bool ignoreWrite = default; 

            // We are not allowed to write frames on closed streams. RFC 7540 Section
            // 5.1.1 says: "An endpoint MUST NOT send frames other than PRIORITY on
            // a closed stream." Our server never sends PRIORITY, so that exception
            // does not apply.
            //
            // The serverConn might close an open stream while the stream's handler
            // is still running. For example, the server might close a stream when it
            // receives bad data from the client. If this happens, the handler might
            // attempt to write a frame after the stream has been closed (since the
            // handler hasn't yet been notified of the close). In this case, we simply
            // ignore the frame. The handler will notice that the stream is closed when
            // it waits for the frame to be written.
            //
            // As an exception to this rule, we allow sending RST_STREAM after close.
            // This allows us to immediately reject new streams without tracking any
            // state for those streams (except for the queued RST_STREAM frame). This
            // may result in duplicate RST_STREAMs in some cases, but the client should
            // ignore those.
            if (wr.StreamID() != 0L)
            {
                http2StreamError (_, isReset) = wr.write._<http2StreamError>();
                {
                    var (state, _) = sc.state(wr.StreamID());

                    if (state == http2stateClosed && !isReset)
                    {
                        ignoreWrite = true;
                    }

                }
            } 

            // Don't send a 100-continue response if we've already sent headers.
            // See golang.org/issue/14030.
            switch (wr.write.type())
            {
                case ref http2writeResHeaders _:
                    wr.stream.wroteHeaders = true;
                    break;
                case http2write100ContinueHeadersFrame _:
                    if (wr.stream.wroteHeaders)
                    { 
                        // We do not need to notify wr.done because this frame is
                        // never written with wr.done != nil.
                        if (wr.done != null)
                        {
                            panic("wr.done != nil for write100ContinueHeadersFrame");
                        }
                        ignoreWrite = true;
                    }
                    break;

            }

            if (!ignoreWrite)
            {
                sc.writeSched.Push(wr);
            }
            sc.scheduleFrameWrite();
        });

        // startFrameWrite starts a goroutine to write wr (in a separate
        // goroutine since that might block on the network), and updates the
        // serve goroutine's state about the world, updated from info in wr.
        private static void startFrameWrite(this ref http2serverConn _sc, http2FrameWriteRequest wr) => func(_sc, (ref http2serverConn sc, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (sc.writingFrame)
            {
                panic("internal error: can only be writing one frame at a time");
            }
            var st = wr.stream;
            if (st != null)
            {

                if (st.state == http2stateHalfClosedLocal) 
                    switch (wr.write.type())
                    {
                        case http2StreamError _:
                            break;
                        case http2handlerPanicRST _:
                            break;
                        case http2writeWindowUpdate _:
                            break;
                        default:
                        {
                            panic(fmt.Sprintf("internal error: attempt to send frame on a half-closed-local stream: %v", wr));
                            break;
                        }
                    }
                else if (st.state == http2stateClosed) 
                    panic(fmt.Sprintf("internal error: attempt to send frame on a closed stream: %v", wr));
                            }
            {
                ref http2writePushPromise (wpp, ok) = wr.write._<ref http2writePushPromise>();

                if (ok)
                {
                    error err = default;
                    wpp.promisedID, err = wpp.allocatePromisedID();
                    if (err != null)
                    {
                        sc.writingFrameAsync = false;
                        wr.replyToWriter(err);
                        return;
                    }
                }

            }

            sc.writingFrame = true;
            sc.needsFrameFlush = true;
            if (wr.write.staysWithinBuffer(sc.bw.Available()))
            {
                sc.writingFrameAsync = false;
                err = wr.write.writeFrame(sc);
                sc.wroteFrame(new http2frameWriteResult(wr,err));
            }
            else
            {
                sc.writingFrameAsync = true;
                go_(() => sc.writeFrameAsync(wr));
            }
        });

        // errHandlerPanicked is the error given to any callers blocked in a read from
        // Request.Body when the main goroutine panics. Since most handlers read in the
        // the main ServeHTTP goroutine, this will show up rarely.
        private static var http2errHandlerPanicked = errors.New("http2: handler panicked");

        // wroteFrame is called on the serve goroutine with the result of
        // whatever happened on writeFrameAsync.
        private static void wroteFrame(this ref http2serverConn _sc, http2frameWriteResult res) => func(_sc, (ref http2serverConn sc, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (!sc.writingFrame)
            {
                panic("internal error: expected to be already writing a frame");
            }
            sc.writingFrame = false;
            sc.writingFrameAsync = false;

            var wr = res.wr;

            if (http2writeEndsStream(wr.write))
            {
                var st = wr.stream;
                if (st == null)
                {
                    panic("internal error: expecting non-nil stream");
                }

                if (st.state == http2stateOpen) 
                    // Here we would go to stateHalfClosedLocal in
                    // theory, but since our handler is done and
                    // the net/http package provides no mechanism
                    // for closing a ResponseWriter while still
                    // reading data (see possible TODO at top of
                    // this file), we go into closed state here
                    // anyway, after telling the peer we're
                    // hanging up on them. We'll transition to
                    // stateClosed after the RST_STREAM frame is
                    // written.
                    st.state = http2stateHalfClosedLocal; 
                    // Section 8.1: a server MAY request that the client abort
                    // transmission of a request without error by sending a
                    // RST_STREAM with an error code of NO_ERROR after sending
                    // a complete response.
                    sc.resetStream(http2streamError(st.id, http2ErrCodeNo));
                else if (st.state == http2stateHalfClosedRemote) 
                    sc.closeStream(st, http2errHandlerComplete);
                            }
            else
            {
                switch (wr.write.type())
                {
                    case http2StreamError v:
                        {
                            var st__prev2 = st;

                            var (st, ok) = sc.streams[v.StreamID];

                            if (ok)
                            {
                                sc.closeStream(st, v);
                            }

                            st = st__prev2;

                        }
                        break;
                    case http2handlerPanicRST v:
                        sc.closeStream(wr.stream, http2errHandlerPanicked);
                        break;
                }
            } 

            // Reply (if requested) to unblock the ServeHTTP goroutine.
            wr.replyToWriter(res.err);

            sc.scheduleFrameWrite();
        });

        // scheduleFrameWrite tickles the frame writing scheduler.
        //
        // If a frame is already being written, nothing happens. This will be called again
        // when the frame is done being written.
        //
        // If a frame isn't being written we need to send one, the best frame
        // to send is selected, preferring first things that aren't
        // stream-specific (e.g. ACKing settings), and then finding the
        // highest priority stream.
        //
        // If a frame isn't being written and there's nothing else to send, we
        // flush the write buffer.
        private static void scheduleFrameWrite(this ref http2serverConn sc)
        {
            sc.serveG.check();
            if (sc.writingFrame || sc.inFrameScheduleLoop)
            {
                return;
            }
            sc.inFrameScheduleLoop = true;
            while (!sc.writingFrameAsync)
            {
                if (sc.needToSendGoAway)
                {
                    sc.needToSendGoAway = false;
                    sc.startFrameWrite(new http2FrameWriteRequest(write:&http2writeGoAway{maxStreamID:sc.maxClientStreamID,code:sc.goAwayCode,},));
                    continue;
                }
                if (sc.needToSendSettingsAck)
                {
                    sc.needToSendSettingsAck = false;
                    sc.startFrameWrite(new http2FrameWriteRequest(write:http2writeSettingsAck{}));
                    continue;
                }
                if (!sc.inGoAway || sc.goAwayCode == http2ErrCodeNo)
                {
                    {
                        var (wr, ok) = sc.writeSched.Pop();

                        if (ok)
                        {
                            sc.startFrameWrite(wr);
                            continue;
                        }

                    }
                }
                if (sc.needsFrameFlush)
                {
                    sc.startFrameWrite(new http2FrameWriteRequest(write:http2flushFrameWriter{}));
                    sc.needsFrameFlush = false; // after startFrameWrite, since it sets this true
                    continue;
                }
                break;
            }

            sc.inFrameScheduleLoop = false;
        }

        // startGracefulShutdown gracefully shuts down a connection. This
        // sends GOAWAY with ErrCodeNo to tell the client we're gracefully
        // shutting down. The connection isn't closed until all current
        // streams are done.
        //
        // startGracefulShutdown returns immediately; it does not wait until
        // the connection has shut down.
        private static void startGracefulShutdown(this ref http2serverConn sc)
        {
            sc.serveG.checkNotOn(); // NOT
            sc.shutdownOnce.Do(() =>
            {
                sc.sendServeMsg(http2gracefulShutdownMsg);

            });
        }

        // After sending GOAWAY, the connection will close after goAwayTimeout.
        // If we close the connection immediately after sending GOAWAY, there may
        // be unsent data in our kernel receive buffer, which will cause the kernel
        // to send a TCP RST on close() instead of a FIN. This RST will abort the
        // connection immediately, whether or not the client had received the GOAWAY.
        //
        // Ideally we should delay for at least 1 RTT + epsilon so the client has
        // a chance to read the GOAWAY and stop sending messages. Measuring RTT
        // is hard, so we approximate with 1 second. See golang.org/issue/18701.
        //
        // This is a var so it can be shorter in tests, where all requests uses the
        // loopback interface making the expected RTT very small.
        //
        // TODO: configurable?
        private static long http2goAwayTimeout = 1L * time.Second;

        private static void startGracefulShutdownInternal(this ref http2serverConn sc)
        {
            sc.goAway(http2ErrCodeNo);
        }

        private static void goAway(this ref http2serverConn sc, http2ErrCode code)
        {
            sc.serveG.check();
            if (sc.inGoAway)
            {
                return;
            }
            sc.inGoAway = true;
            sc.needToSendGoAway = true;
            sc.goAwayCode = code;
            sc.scheduleFrameWrite();
        }

        private static void shutDownIn(this ref http2serverConn sc, time.Duration d)
        {
            sc.serveG.check();
            sc.shutdownTimer = time.AfterFunc(d, sc.onShutdownTimer);
        }

        private static void resetStream(this ref http2serverConn sc, http2StreamError se)
        {
            sc.serveG.check();
            sc.writeFrame(new http2FrameWriteRequest(write:se));
            {
                var (st, ok) = sc.streams[se.StreamID];

                if (ok)
                {
                    st.resetQueued = true;
                }

            }
        }

        // processFrameFromReader processes the serve loop's read from readFrameCh from the
        // frame-reading goroutine.
        // processFrameFromReader returns whether the connection should be kept open.
        private static bool processFrameFromReader(this ref http2serverConn sc, http2readFrameResult res)
        {
            sc.serveG.check();
            var err = res.err;
            if (err != null)
            {
                if (err == http2ErrFrameTooLarge)
                {
                    sc.goAway(http2ErrCodeFrameSize);
                    return true; // goAway will close the loop
                }
                var clientGone = err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err);
                if (clientGone)
                { 
                    // TODO: could we also get into this state if
                    // the peer does a half close
                    // (e.g. CloseWrite) because they're done
                    // sending frames but they're still wanting
                    // our open replies?  Investigate.
                    // TODO: add CloseWrite to crypto/tls.Conn first
                    // so we have a way to test this? I suppose
                    // just for testing we could have a non-TLS mode.
                    return false;
                }
            }
            else
            {
                var f = res.f;
                if (http2VerboseLogs)
                {
                    sc.vlogf("http2: server read frame %v", http2summarizeFrame(f));
                }
                err = sc.processFrame(f);
                if (err == null)
                {
                    return true;
                }
            }
            switch (err.type())
            {
                case http2StreamError ev:
                    sc.resetStream(ev);
                    return true;
                    break;
                case http2goAwayFlowError ev:
                    sc.goAway(http2ErrCodeFlowControl);
                    return true;
                    break;
                case http2ConnectionError ev:
                    sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev);
                    sc.goAway(http2ErrCode(ev));
                    return true; // goAway will handle shutdown
                    break;
                default:
                {
                    var ev = err.type();
                    if (res.err != null)
                    {
                        sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err);
                    }
                    else
                    {
                        sc.logf("http2: server closing client connection: %v", err);
                    }
                    return false;
                    break;
                }
            }
        }

        private static error processFrame(this ref http2serverConn sc, http2Frame f)
        {
            sc.serveG.check(); 

            // First frame received must be SETTINGS.
            if (!sc.sawFirstSettings)
            {
                {
                    ref http2SettingsFrame (_, ok) = f._<ref http2SettingsFrame>();

                    if (!ok)
                    {
                        return error.As(http2ConnectionError(http2ErrCodeProtocol));
                    }

                }
                sc.sawFirstSettings = true;
            }
            switch (f.type())
            {
                case ref http2SettingsFrame f:
                    return error.As(sc.processSettings(f));
                    break;
                case ref http2MetaHeadersFrame f:
                    return error.As(sc.processHeaders(f));
                    break;
                case ref http2WindowUpdateFrame f:
                    return error.As(sc.processWindowUpdate(f));
                    break;
                case ref http2PingFrame f:
                    return error.As(sc.processPing(f));
                    break;
                case ref http2DataFrame f:
                    return error.As(sc.processData(f));
                    break;
                case ref http2RSTStreamFrame f:
                    return error.As(sc.processResetStream(f));
                    break;
                case ref http2PriorityFrame f:
                    return error.As(sc.processPriority(f));
                    break;
                case ref http2GoAwayFrame f:
                    return error.As(sc.processGoAway(f));
                    break;
                case ref http2PushPromiseFrame f:
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                    break;
                default:
                {
                    var f = f.type();
                    sc.vlogf("http2: server ignoring frame: %v", f.Header());
                    return error.As(null);
                    break;
                }
            }
        }

        private static error processPing(this ref http2serverConn sc, ref http2PingFrame f)
        {
            sc.serveG.check();
            if (f.IsAck())
            { 
                // 6.7 PING: " An endpoint MUST NOT respond to PING frames
                // containing this flag."
                return error.As(null);
            }
            if (f.StreamID != 0L)
            { 
                // "PING frames are not associated with any individual
                // stream. If a PING frame is received with a stream
                // identifier field value other than 0x0, the recipient MUST
                // respond with a connection error (Section 5.4.1) of type
                // PROTOCOL_ERROR."
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            if (sc.inGoAway && sc.goAwayCode != http2ErrCodeNo)
            {
                return error.As(null);
            }
            sc.writeFrame(new http2FrameWriteRequest(write:http2writePingAck{f}));
            return error.As(null);
        }

        private static error processWindowUpdate(this ref http2serverConn sc, ref http2WindowUpdateFrame f)
        {
            sc.serveG.check();

            if (f.StreamID != 0L) // stream-level flow control
                var (state, st) = sc.state(f.StreamID);
                if (state == http2stateIdle)
                { 
                    // Section 5.1: "Receiving any frame other than HEADERS
                    // or PRIORITY on a stream in this state MUST be
                    // treated as a connection error (Section 5.4.1) of
                    // type PROTOCOL_ERROR."
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                }
                if (st == null)
                { 
                    // "WINDOW_UPDATE can be sent by a peer that has sent a
                    // frame bearing the END_STREAM flag. This means that a
                    // receiver could receive a WINDOW_UPDATE frame on a "half
                    // closed (remote)" or "closed" stream. A receiver MUST
                    // NOT treat this as an error, see Section 5.1."
                    return error.As(null);
                }
                if (!st.flow.add(int32(f.Increment)))
                {
                    return error.As(http2streamError(f.StreamID, http2ErrCodeFlowControl));
                }
            else // connection-level flow control
                if (!sc.flow.add(int32(f.Increment)))
                {
                    return error.As(new http2goAwayFlowError());
                }
                        sc.scheduleFrameWrite();
            return error.As(null);
        }

        private static error processResetStream(this ref http2serverConn sc, ref http2RSTStreamFrame f)
        {
            sc.serveG.check();

            var (state, st) = sc.state(f.StreamID);
            if (state == http2stateIdle)
            { 
                // 6.4 "RST_STREAM frames MUST NOT be sent for a
                // stream in the "idle" state. If a RST_STREAM frame
                // identifying an idle stream is received, the
                // recipient MUST treat this as a connection error
                // (Section 5.4.1) of type PROTOCOL_ERROR.
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            if (st != null)
            {
                st.cancelCtx();
                sc.closeStream(st, http2streamError(f.StreamID, f.ErrCode));
            }
            return error.As(null);
        }

        private static void closeStream(this ref http2serverConn _sc, ref http2stream _st, error err) => func(_sc, _st, (ref http2serverConn sc, ref http2stream st, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (st.state == http2stateIdle || st.state == http2stateClosed)
            {
                panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state));
            }
            st.state = http2stateClosed;
            if (st.writeDeadline != null)
            {
                st.writeDeadline.Stop();
            }
            if (st.isPushed())
            {
                sc.curPushedStreams--;
            }
            else
            {
                sc.curClientStreams--;
            }
            delete(sc.streams, st.id);
            if (len(sc.streams) == 0L)
            {
                sc.setConnState(StateIdle);
                if (sc.srv.IdleTimeout != 0L)
                {
                    sc.idleTimer.Reset(sc.srv.IdleTimeout);
                }
                if (http2h1ServerKeepAlivesDisabled(sc.hs))
                {
                    sc.startGracefulShutdownInternal();
                }
            }
            {
                var p = st.body;

                if (p != null)
                { 
                    // Return any buffered unread bytes worth of conn-level flow control.
                    // See golang.org/issue/16481
                    sc.sendWindowUpdate(null, p.Len());

                    p.CloseWithError(err);
                }

            }
            st.cw.Close(); // signals Handler's CloseNotifier, unblocks writes, etc
            sc.writeSched.CloseStream(st.id);
        });

        private static error processSettings(this ref http2serverConn sc, ref http2SettingsFrame f)
        {
            sc.serveG.check();
            if (f.IsAck())
            {
                sc.unackedSettings--;
                if (sc.unackedSettings < 0L)
                { 
                    // Why is the peer ACKing settings we never sent?
                    // The spec doesn't mention this case, but
                    // hang up on them anyway.
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                }
                return error.As(null);
            }
            {
                var err = f.ForeachSetting(sc.processSetting);

                if (err != null)
                {
                    return error.As(err);
                }

            }
            sc.needToSendSettingsAck = true;
            sc.scheduleFrameWrite();
            return error.As(null);
        }

        private static error processSetting(this ref http2serverConn sc, http2Setting s)
        {
            sc.serveG.check();
            {
                var err = s.Valid();

                if (err != null)
                {
                    return error.As(err);
                }

            }
            if (http2VerboseLogs)
            {
                sc.vlogf("http2: server processing setting %v", s);
            }

            if (s.ID == http2SettingHeaderTableSize) 
                sc.headerTableSize = s.Val;
                sc.hpackEncoder.SetMaxDynamicTableSize(s.Val);
            else if (s.ID == http2SettingEnablePush) 
                sc.pushEnabled = s.Val != 0L;
            else if (s.ID == http2SettingMaxConcurrentStreams) 
                sc.clientMaxStreams = s.Val;
            else if (s.ID == http2SettingInitialWindowSize) 
                return error.As(sc.processSettingInitialWindowSize(s.Val));
            else if (s.ID == http2SettingMaxFrameSize) 
                sc.maxFrameSize = int32(s.Val); // the maximum valid s.Val is < 2^31
            else if (s.ID == http2SettingMaxHeaderListSize) 
                sc.peerMaxHeaderListSize = s.Val;
            else 
                // Unknown setting: "An endpoint that receives a SETTINGS
                // frame with any unknown or unsupported identifier MUST
                // ignore that setting."
                if (http2VerboseLogs)
                {
                    sc.vlogf("http2: server ignoring unknown setting %v", s);
                }
                        return error.As(null);
        }

        private static error processSettingInitialWindowSize(this ref http2serverConn sc, uint val)
        {
            sc.serveG.check(); 
            // Note: val already validated to be within range by
            // processSetting's Valid call.

            // "A SETTINGS frame can alter the initial flow control window
            // size for all current streams. When the value of
            // SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
            // adjust the size of all stream flow control windows that it
            // maintains by the difference between the new value and the
            // old value."
            var old = sc.initialStreamSendWindowSize;
            sc.initialStreamSendWindowSize = int32(val);
            var growth = int32(val) - old; // may be negative
            foreach (var (_, st) in sc.streams)
            {
                if (!st.flow.add(growth))
                { 
                    // 6.9.2 Initial Flow Control Window Size
                    // "An endpoint MUST treat a change to
                    // SETTINGS_INITIAL_WINDOW_SIZE that causes any flow
                    // control window to exceed the maximum size as a
                    // connection error (Section 5.4.1) of type
                    // FLOW_CONTROL_ERROR."
                    return error.As(http2ConnectionError(http2ErrCodeFlowControl));
                }
            }
            return error.As(null);
        }

        private static error processData(this ref http2serverConn _sc, ref http2DataFrame _f) => func(_sc, _f, (ref http2serverConn sc, ref http2DataFrame f, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (sc.inGoAway && sc.goAwayCode != http2ErrCodeNo)
            {
                return error.As(null);
            }
            var data = f.Data(); 

            // "If a DATA frame is received whose stream is not in "open"
            // or "half closed (local)" state, the recipient MUST respond
            // with a stream error (Section 5.4.2) of type STREAM_CLOSED."
            var id = f.Header().StreamID;
            var (state, st) = sc.state(id);
            if (id == 0L || state == http2stateIdle)
            { 
                // Section 5.1: "Receiving any frame other than HEADERS
                // or PRIORITY on a stream in this state MUST be
                // treated as a connection error (Section 5.4.1) of
                // type PROTOCOL_ERROR."
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            if (st == null || state != http2stateOpen || st.gotTrailerHeader || st.resetQueued)
            { 
                // This includes sending a RST_STREAM if the stream is
                // in stateHalfClosedLocal (which currently means that
                // the http.Handler returned, so it's done reading &
                // done writing). Try to stop the client from sending
                // more DATA.

                // But still enforce their connection-level flow control,
                // and return any flow control bytes since we're not going
                // to consume them.
                if (sc.inflow.available() < int32(f.Length))
                {
                    return error.As(http2streamError(id, http2ErrCodeFlowControl));
                } 
                // Deduct the flow control from inflow, since we're
                // going to immediately add it back in
                // sendWindowUpdate, which also schedules sending the
                // frames.
                sc.inflow.take(int32(f.Length));
                sc.sendWindowUpdate(null, int(f.Length)); // conn-level

                if (st != null && st.resetQueued)
                { 
                    // Already have a stream error in flight. Don't send another.
                    return error.As(null);
                }
                return error.As(http2streamError(id, http2ErrCodeStreamClosed));
            }
            if (st.body == null)
            {
                panic("internal error: should have a body in this state");
            } 

            // Sender sending more than they'd declared?
            if (st.declBodyBytes != -1L && st.bodyBytes + int64(len(data)) > st.declBodyBytes)
            {
                st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes));
                return error.As(http2streamError(id, http2ErrCodeStreamClosed));
            }
            if (f.Length > 0L)
            { 
                // Check whether the client has flow control quota.
                if (st.inflow.available() < int32(f.Length))
                {
                    return error.As(http2streamError(id, http2ErrCodeFlowControl));
                }
                st.inflow.take(int32(f.Length));

                if (len(data) > 0L)
                {
                    var (wrote, err) = st.body.Write(data);
                    if (err != null)
                    {
                        return error.As(http2streamError(id, http2ErrCodeStreamClosed));
                    }
                    if (wrote != len(data))
                    {
                        panic("internal error: bad Writer");
                    }
                    st.bodyBytes += int64(len(data));
                } 

                // Return any padded flow control now, since we won't
                // refund it later on body reads.
                {
                    var pad = int32(f.Length) - int32(len(data));

                    if (pad > 0L)
                    {
                        sc.sendWindowUpdate32(null, pad);
                        sc.sendWindowUpdate32(st, pad);
                    }

                }
            }
            if (f.StreamEnded())
            {
                st.endStream();
            }
            return error.As(null);
        });

        private static error processGoAway(this ref http2serverConn sc, ref http2GoAwayFrame f)
        {
            sc.serveG.check();
            if (f.ErrCode != http2ErrCodeNo)
            {
                sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f);
            }
            else
            {
                sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f);
            }
            sc.startGracefulShutdownInternal(); 
            // http://tools.ietf.org/html/rfc7540#section-6.8
            // We should not create any new streams, which means we should disable push.
            sc.pushEnabled = false;
            return error.As(null);
        }

        // isPushed reports whether the stream is server-initiated.
        private static bool isPushed(this ref http2stream st)
        {
            return st.id % 2L == 0L;
        }

        // endStream closes a Request.Body's pipe. It is called when a DATA
        // frame says a request body is over (or after trailers).
        private static void endStream(this ref http2stream st)
        {
            var sc = st.sc;
            sc.serveG.check();

            if (st.declBodyBytes != -1L && st.declBodyBytes != st.bodyBytes)
            {
                st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes", st.declBodyBytes, st.bodyBytes));
            }
            else
            {
                st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest);
                st.body.CloseWithError(io.EOF);
            }
            st.state = http2stateHalfClosedRemote;
        }

        // copyTrailersToHandlerRequest is run in the Handler's goroutine in
        // its Request.Body.Read just before it gets io.EOF.
        private static void copyTrailersToHandlerRequest(this ref http2stream st)
        {
            foreach (var (k, vv) in st.trailer)
            {
                {
                    var (_, ok) = st.reqTrailer[k];

                    if (ok)
                    { 
                        // Only copy it over it was pre-declared.
                        st.reqTrailer[k] = vv;
                    }

                }
            }
        }

        // onWriteTimeout is run on its own goroutine (from time.AfterFunc)
        // when the stream's WriteTimeout has fired.
        private static void onWriteTimeout(this ref http2stream st)
        {
            st.sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2streamError(st.id,http2ErrCodeInternal)));
        }

        private static error processHeaders(this ref http2serverConn sc, ref http2MetaHeadersFrame f)
        {
            sc.serveG.check();
            var id = f.StreamID;
            if (sc.inGoAway)
            { 
                // Ignore.
                return error.As(null);
            } 
            // http://tools.ietf.org/html/rfc7540#section-5.1.1
            // Streams initiated by a client MUST use odd-numbered stream
            // identifiers. [...] An endpoint that receives an unexpected
            // stream identifier MUST respond with a connection error
            // (Section 5.4.1) of type PROTOCOL_ERROR.
            if (id % 2L != 1L)
            {
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            } 
            // A HEADERS frame can be used to create a new stream or
            // send a trailer for an open one. If we already have a stream
            // open, let it process its own HEADERS frame (trailers at this
            // point, if it's valid).
            {
                var st__prev1 = st;

                var st = sc.streams[f.StreamID];

                if (st != null)
                {
                    if (st.resetQueued)
                    { 
                        // We're sending RST_STREAM to close the stream, so don't bother
                        // processing this frame.
                        return error.As(null);
                    }
                    return error.As(st.processTrailerHeaders(f));
                } 

                // [...] The identifier of a newly established stream MUST be
                // numerically greater than all streams that the initiating
                // endpoint has opened or reserved. [...]  An endpoint that
                // receives an unexpected stream identifier MUST respond with
                // a connection error (Section 5.4.1) of type PROTOCOL_ERROR.

                st = st__prev1;

            } 

            // [...] The identifier of a newly established stream MUST be
            // numerically greater than all streams that the initiating
            // endpoint has opened or reserved. [...]  An endpoint that
            // receives an unexpected stream identifier MUST respond with
            // a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
            if (id <= sc.maxClientStreamID)
            {
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            sc.maxClientStreamID = id;

            if (sc.idleTimer != null)
            {
                sc.idleTimer.Stop();
            } 

            // http://tools.ietf.org/html/rfc7540#section-5.1.2
            // [...] Endpoints MUST NOT exceed the limit set by their peer. An
            // endpoint that receives a HEADERS frame that causes their
            // advertised concurrent stream limit to be exceeded MUST treat
            // this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR
            // or REFUSED_STREAM.
            if (sc.curClientStreams + 1L > sc.advMaxStreams)
            {
                if (sc.unackedSettings == 0L)
                { 
                    // They should know better.
                    return error.As(http2streamError(id, http2ErrCodeProtocol));
                } 
                // Assume it's a network race, where they just haven't
                // received our last SETTINGS update. But actually
                // this can't happen yet, because we don't yet provide
                // a way for users to adjust server parameters at
                // runtime.
                return error.As(http2streamError(id, http2ErrCodeRefusedStream));
            }
            var initialState = http2stateOpen;
            if (f.StreamEnded())
            {
                initialState = http2stateHalfClosedRemote;
            }
            st = sc.newStream(id, 0L, initialState);

            if (f.HasPriority())
            {
                {
                    var err__prev2 = err;

                    var err = http2checkPriority(f.StreamID, f.Priority);

                    if (err != null)
                    {
                        return error.As(err);
                    }

                    err = err__prev2;

                }
                sc.writeSched.AdjustStream(st.id, f.Priority);
            }
            var (rw, req, err) = sc.newWriterAndRequest(st, f);
            if (err != null)
            {
                return error.As(err);
            }
            st.reqTrailer = req.Trailer;
            if (st.reqTrailer != null)
            {
                st.trailer = make(Header);
            }
            st.body = req.Body._<ref http2requestBody>().pipe; // may be nil
            st.declBodyBytes = req.ContentLength;

            var handler = sc.handler.ServeHTTP;
            if (f.Truncated)
            { 
                // Their header list was too long. Send a 431 error.
                handler = http2handleHeaderListTooLong;
            }            {
                var err__prev2 = err;

                err = http2checkValidHTTP2RequestHeaders(req.Header);


                else if (err != null)
                {
                    handler = http2new400Handler(err);
                } 

                // The net/http package sets the read deadline from the
                // http.Server.ReadTimeout during the TLS handshake, but then
                // passes the connection off to us with the deadline already
                // set. Disarm it here after the request headers are read,
                // similar to how the http1 server works. Here it's
                // technically more like the http1 Server's ReadHeaderTimeout
                // (in Go 1.8), though. That's a more sane option anyway.

                err = err__prev2;

            } 

            // The net/http package sets the read deadline from the
            // http.Server.ReadTimeout during the TLS handshake, but then
            // passes the connection off to us with the deadline already
            // set. Disarm it here after the request headers are read,
            // similar to how the http1 server works. Here it's
            // technically more like the http1 Server's ReadHeaderTimeout
            // (in Go 1.8), though. That's a more sane option anyway.
            if (sc.hs.ReadTimeout != 0L)
            {
                sc.conn.SetReadDeadline(new time.Time());
            }
            go_(() => sc.runHandler(rw, req, handler));
            return error.As(null);
        }

        private static error processTrailerHeaders(this ref http2stream st, ref http2MetaHeadersFrame f)
        {
            var sc = st.sc;
            sc.serveG.check();
            if (st.gotTrailerHeader)
            {
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            st.gotTrailerHeader = true;
            if (!f.StreamEnded())
            {
                return error.As(http2streamError(st.id, http2ErrCodeProtocol));
            }
            if (len(f.PseudoFields()) > 0L)
            {
                return error.As(http2streamError(st.id, http2ErrCodeProtocol));
            }
            if (st.trailer != null)
            {
                foreach (var (_, hf) in f.RegularFields())
                {
                    var key = sc.canonicalHeader(hf.Name);
                    if (!http2ValidTrailerHeader(key))
                    { 
                        // TODO: send more details to the peer somehow. But http2 has
                        // no way to send debug data at a stream level. Discuss with
                        // HTTP folk.
                        return error.As(http2streamError(st.id, http2ErrCodeProtocol));
                    }
                    st.trailer[key] = append(st.trailer[key], hf.Value);
                }
            }
            st.endStream();
            return error.As(null);
        }

        private static error http2checkPriority(uint streamID, http2PriorityParam p)
        {
            if (streamID == p.StreamDep)
            { 
                // Section 5.3.1: "A stream cannot depend on itself. An endpoint MUST treat
                // this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."
                // Section 5.3.3 says that a stream can depend on one of its dependencies,
                // so it's only self-dependencies that are forbidden.
                return error.As(http2streamError(streamID, http2ErrCodeProtocol));
            }
            return error.As(null);
        }

        private static error processPriority(this ref http2serverConn sc, ref http2PriorityFrame f)
        {
            if (sc.inGoAway)
            {
                return error.As(null);
            }
            {
                var err = http2checkPriority(f.StreamID, f.http2PriorityParam);

                if (err != null)
                {
                    return error.As(err);
                }

            }
            sc.writeSched.AdjustStream(f.StreamID, f.http2PriorityParam);
            return error.As(null);
        }

        private static ref http2stream newStream(this ref http2serverConn _sc, uint id, uint pusherID, http2streamState state) => func(_sc, (ref http2serverConn sc, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (id == 0L)
            {
                panic("internal error: cannot create stream with id 0");
            }
            var (ctx, cancelCtx) = http2contextWithCancel(sc.baseCtx);
            http2stream st = ref new http2stream(sc:sc,id:id,state:state,ctx:ctx,cancelCtx:cancelCtx,);
            st.cw.Init();
            st.flow.conn = ref sc.flow; // link to conn-level counter
            st.flow.add(sc.initialStreamSendWindowSize);
            st.inflow.conn = ref sc.inflow; // link to conn-level counter
            st.inflow.add(sc.srv.initialStreamRecvWindowSize());
            if (sc.hs.WriteTimeout != 0L)
            {
                st.writeDeadline = time.AfterFunc(sc.hs.WriteTimeout, st.onWriteTimeout);
            }
            sc.streams[id] = st;
            sc.writeSched.OpenStream(st.id, new http2OpenStreamOptions(PusherID:pusherID));
            if (st.isPushed())
            {
                sc.curPushedStreams++;
            }
            else
            {
                sc.curClientStreams++;
            }
            if (sc.curOpenStreams() == 1L)
            {
                sc.setConnState(StateActive);
            }
            return st;
        });

        private static (ref http2responseWriter, ref Request, error) newWriterAndRequest(this ref http2serverConn sc, ref http2stream st, ref http2MetaHeadersFrame f)
        {
            sc.serveG.check();

            http2requestParam rp = new http2requestParam(method:f.PseudoValue("method"),scheme:f.PseudoValue("scheme"),authority:f.PseudoValue("authority"),path:f.PseudoValue("path"),);

            var isConnect = rp.method == "CONNECT";
            if (isConnect)
            {
                if (rp.path != "" || rp.scheme != "" || rp.authority == "")
                {
                    return (null, null, http2streamError(f.StreamID, http2ErrCodeProtocol));
                }
            }
            else if (rp.method == "" || rp.path == "" || (rp.scheme != "https" && rp.scheme != "http"))
            { 
                // See 8.1.2.6 Malformed Requests and Responses:
                //
                // Malformed requests or responses that are detected
                // MUST be treated as a stream error (Section 5.4.2)
                // of type PROTOCOL_ERROR."
                //
                // 8.1.2.3 Request Pseudo-Header Fields
                // "All HTTP/2 requests MUST include exactly one valid
                // value for the :method, :scheme, and :path
                // pseudo-header fields"
                return (null, null, http2streamError(f.StreamID, http2ErrCodeProtocol));
            }
            var bodyOpen = !f.StreamEnded();
            if (rp.method == "HEAD" && bodyOpen)
            { 
                // HEAD requests can't have bodies
                return (null, null, http2streamError(f.StreamID, http2ErrCodeProtocol));
            }
            rp.header = make(Header);
            foreach (var (_, hf) in f.RegularFields())
            {
                rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value);
            }
            if (rp.authority == "")
            {
                rp.authority = rp.header.Get("Host");
            }
            var (rw, req, err) = sc.newWriterAndRequestNoBody(st, rp);
            if (err != null)
            {
                return (null, null, err);
            }
            if (bodyOpen)
            {
                {
                    var (vv, ok) = rp.header["Content-Length"];

                    if (ok)
                    {
                        req.ContentLength, _ = strconv.ParseInt(vv[0L], 10L, 64L);
                    }
                    else
                    {
                        req.ContentLength = -1L;
                    }

                }
                req.Body._<ref http2requestBody>().pipe = ref new http2pipe(b:&http2dataBuffer{expected:req.ContentLength},);
            }
            return (rw, req, null);
        }

        private partial struct http2requestParam
        {
            public @string method;
            public @string scheme;
            public @string authority;
            public @string path;
            public Header header;
        }

        private static (ref http2responseWriter, ref Request, error) newWriterAndRequestNoBody(this ref http2serverConn sc, ref http2stream st, http2requestParam rp)
        {
            sc.serveG.check();

            ref tls.ConnectionState tlsState = default; // nil if not scheme https
            if (rp.scheme == "https")
            {
                tlsState = sc.tlsState;
            }
            var needsContinue = rp.header.Get("Expect") == "100-continue";
            if (needsContinue)
            {
                rp.header.Del("Expect");
            } 
            // Merge Cookie headers into one "; "-delimited value.
            {
                var cookies = rp.header["Cookie"];

                if (len(cookies) > 1L)
                {
                    rp.header.Set("Cookie", strings.Join(cookies, "; "));
                } 

                // Setup Trailers

            } 

            // Setup Trailers
            Header trailer = default;
            foreach (var (_, v) in rp.header["Trailer"])
            {
                foreach (var (_, key) in strings.Split(v, ","))
                {
                    key = CanonicalHeaderKey(strings.TrimSpace(key));
                    switch (key)
                    {
                        case "Transfer-Encoding": 

                        case "Trailer": 

                        case "Content-Length": 
                            break;
                        default: 
                            if (trailer == null)
                            {
                                trailer = make(Header);
                            }
                            trailer[key] = null;
                            break;
                    }
                }
            }
            delete(rp.header, "Trailer");

            ref url.URL url_ = default;
            @string requestURI = default;
            if (rp.method == "CONNECT")
            {
                url_ = ref new url.URL(Host:rp.authority);
                requestURI = rp.authority; // mimic HTTP/1 server behavior
            }
            else
            {
                error err = default;
                url_, err = url.ParseRequestURI(rp.path);
                if (err != null)
                {
                    return (null, null, http2streamError(st.id, http2ErrCodeProtocol));
                }
                requestURI = rp.path;
            }
            http2requestBody body = ref new http2requestBody(conn:sc,stream:st,needsContinue:needsContinue,);
            Request req = ref new Request(Method:rp.method,URL:url_,RemoteAddr:sc.remoteAddrStr,Header:rp.header,RequestURI:requestURI,Proto:"HTTP/2.0",ProtoMajor:2,ProtoMinor:0,TLS:tlsState,Host:rp.authority,Body:body,Trailer:trailer,);
            req = http2requestWithContext(req, st.ctx);

            ref http2responseWriterState rws = http2responseWriterStatePool.Get()._<ref http2responseWriterState>();
            var bwSave = rws.bw;
            rws.Value = new http2responseWriterState(); // zero all the fields
            rws.conn = sc;
            rws.bw = bwSave;
            rws.bw.Reset(new http2chunkWriter(rws));
            rws.stream = st;
            rws.req = req;
            rws.body = body;

            http2responseWriter rw = ref new http2responseWriter(rws:rws);
            return (rw, req, null);
        }

        // Run on its own goroutine.
        private static void runHandler(this ref http2serverConn _sc, ref http2responseWriter _rw, ref Request _req, Action<ResponseWriter, ref Request> handler) => func(_sc, _rw, _req, (ref http2serverConn sc, ref http2responseWriter rw, ref Request req, Defer defer, Panic _, Recover __) =>
        {
            var didPanic = true;
            defer(() =>
            {
                rw.rws.stream.cancelCtx();
                if (didPanic)
                {
                    var e = recover();
                    sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2handlerPanicRST{rw.rws.stream.id},stream:rw.rws.stream,)); 
                    // Same as net/http:
                    if (http2shouldLogPanic(e))
                    {
                        const long size = 64L << (int)(10L);

                        var buf = make_slice<byte>(size);
                        buf = buf[..runtime.Stack(buf, false)];
                        sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf);
                    }
                    return;
                }
                rw.handlerDone();
            }());
            handler(rw, req);
            didPanic = false;
        });

        private static void http2handleHeaderListTooLong(ResponseWriter w, ref Request r)
        { 
            // 10.5.1 Limits on Header Block Size:
            // .. "A server that receives a larger header block than it is
            // willing to handle can send an HTTP 431 (Request Header Fields Too
            // Large) status code"
            const long statusRequestHeaderFieldsTooLarge = 431L; // only in Go 1.6+
 // only in Go 1.6+
            w.WriteHeader(statusRequestHeaderFieldsTooLarge);
            io.WriteString(w, "<h1>HTTP Error 431</h1><p>Request Header Field(s) Too Large</p>");
        }

        // called from handler goroutines.
        // h may be nil.
        private static error writeHeaders(this ref http2serverConn sc, ref http2stream st, ref http2writeResHeaders headerData)
        {
            sc.serveG.checkNotOn(); // NOT on
            channel<error> errc = default;
            if (headerData.h != null)
            { 
                // If there's a header map (which we don't own), so we have to block on
                // waiting for this frame to be written, so an http.Flush mid-handler
                // writes out the correct value of keys, before a handler later potentially
                // mutates it.
                errc = http2errChanPool.Get()._<channel<error>>();
            }
            {
                var err__prev1 = err;

                var err = sc.writeFrameFromHandler(new http2FrameWriteRequest(write:headerData,stream:st,done:errc,));

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            if (errc != null)
            {
                http2errChanPool.Put(errc);
                return error.As(err);
                return error.As(http2errClientDisconnected);
                return error.As(http2errStreamClosed);
            }
            return error.As(null);
        }

        // called from handler goroutines.
        private static void write100ContinueHeaders(this ref http2serverConn sc, ref http2stream st)
        {
            sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2write100ContinueHeadersFrame{st.id},stream:st,));
        }

        // A bodyReadMsg tells the server loop that the http.Handler read n
        // bytes of the DATA from the client on the given stream.
        private partial struct http2bodyReadMsg
        {
            public ptr<http2stream> st;
            public long n;
        }

        // called from handler goroutines.
        // Notes that the handler for the given stream ID read n bytes of its body
        // and schedules flow control tokens to be sent.
        private static void noteBodyReadFromHandler(this ref http2serverConn sc, ref http2stream st, long n, error err)
        {
            sc.serveG.checkNotOn(); // NOT on
            if (n > 0L)
            {
            }
        }

        private static void noteBodyRead(this ref http2serverConn sc, ref http2stream st, long n)
        {
            sc.serveG.check();
            sc.sendWindowUpdate(null, n); // conn-level
            if (st.state != http2stateHalfClosedRemote && st.state != http2stateClosed)
            { 
                // Don't send this WINDOW_UPDATE if the stream is closed
                // remotely.
                sc.sendWindowUpdate(st, n);
            }
        }

        // st may be nil for conn-level
        private static void sendWindowUpdate(this ref http2serverConn sc, ref http2stream st, long n)
        {
            sc.serveG.check(); 
            // "The legal range for the increment to the flow control
            // window is 1 to 2^31-1 (2,147,483,647) octets."
            // A Go Read call on 64-bit machines could in theory read
            // a larger Read than this. Very unlikely, but we handle it here
            // rather than elsewhere for now.
            const long maxUint31 = 1L << (int)(31L) - 1L;

            while (n >= maxUint31)
            {
                sc.sendWindowUpdate32(st, maxUint31);
                n -= maxUint31;
            }

            sc.sendWindowUpdate32(st, int32(n));
        }

        // st may be nil for conn-level
        private static void sendWindowUpdate32(this ref http2serverConn _sc, ref http2stream _st, int n) => func(_sc, _st, (ref http2serverConn sc, ref http2stream st, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check();
            if (n == 0L)
            {
                return;
            }
            if (n < 0L)
            {
                panic("negative update");
            }
            uint streamID = default;
            if (st != null)
            {
                streamID = st.id;
            }
            sc.writeFrame(new http2FrameWriteRequest(write:http2writeWindowUpdate{streamID:streamID,n:uint32(n)},stream:st,));
            bool ok = default;
            if (st == null)
            {
                ok = sc.inflow.add(n);
            }
            else
            {
                ok = st.inflow.add(n);
            }
            if (!ok)
            {
                panic("internal error; sent too many window updates without decrements?");
            }
        });

        // requestBody is the Handler's Request.Body type.
        // Read and Close may be called concurrently.
        private partial struct http2requestBody
        {
            public ptr<http2stream> stream;
            public ptr<http2serverConn> conn;
            public bool closed; // for use by Close only
            public bool sawEOF; // for use by Read only
            public ptr<http2pipe> pipe; // non-nil if we have a HTTP entity message body
            public bool needsContinue; // need to send a 100-continue
        }

        private static error Close(this ref http2requestBody b)
        {
            if (b.pipe != null && !b.closed)
            {
                b.pipe.BreakWithError(http2errClosedBody);
            }
            b.closed = true;
            return error.As(null);
        }

        private static (long, error) Read(this ref http2requestBody b, slice<byte> p)
        {
            if (b.needsContinue)
            {
                b.needsContinue = false;
                b.conn.write100ContinueHeaders(b.stream);
            }
            if (b.pipe == null || b.sawEOF)
            {
                return (0L, io.EOF);
            }
            n, err = b.pipe.Read(p);
            if (err == io.EOF)
            {
                b.sawEOF = true;
            }
            if (b.conn == null && http2inTests)
            {
                return;
            }
            b.conn.noteBodyReadFromHandler(b.stream, n, err);
            return;
        }

        // responseWriter is the http.ResponseWriter implementation. It's
        // intentionally small (1 pointer wide) to minimize garbage. The
        // responseWriterState pointer inside is zeroed at the end of a
        // request (in handlerDone) and calls on the responseWriter thereafter
        // simply crash (caller's mistake), but the much larger responseWriterState
        // and buffers are reused between multiple requests.
        private partial struct http2responseWriter
        {
            public ptr<http2responseWriterState> rws;
        }

        // Optional http.ResponseWriter interfaces implemented.
        private static CloseNotifier _ = (http2responseWriter.Value)(null);        private static Flusher _ = (http2responseWriter.Value)(null);        private static http2stringWriter _ = http2stringWriter.As((http2responseWriter.Value)(null));

        private partial struct http2responseWriterState
        {
            public ptr<http2stream> stream;
            public ptr<Request> req;
            public ptr<http2requestBody> body; // to close at end of request, if DATA frames didn't
            public ptr<http2serverConn> conn; // TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc
            public ptr<bufio.Writer> bw; // writing to a chunkWriter{this *responseWriterState}

// mutated by http.Handler goroutine:
            public Header handlerHeader; // nil until called
            public Header snapHeader; // snapshot of handlerHeader at WriteHeader time
            public slice<@string> trailers; // set in writeChunk
            public long status; // status code passed to WriteHeader
            public bool wroteHeader; // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
            public bool sentHeader; // have we sent the header frame?
            public bool handlerDone; // handler has finished
            public bool dirty; // a Write failed; don't reuse this responseWriterState

            public long sentContentLen; // non-zero if handler set a Content-Length header
            public long wroteBytes;
            public sync.Mutex closeNotifierMu; // guards closeNotifierCh
            public channel<bool> closeNotifierCh; // nil until first used
        }

        private partial struct http2chunkWriter
        {
            public ptr<http2responseWriterState> rws;
        }

        private static (long, error) Write(this http2chunkWriter cw, slice<byte> p)
        {
            return cw.rws.writeChunk(p);
        }

        private static bool hasTrailers(this ref http2responseWriterState rws)
        {
            return len(rws.trailers) != 0L;
        }

        // declareTrailer is called for each Trailer header when the
        // response header is written. It notes that a header will need to be
        // written in the trailers at the end of the response.
        private static void declareTrailer(this ref http2responseWriterState rws, @string k)
        {
            k = CanonicalHeaderKey(k);
            if (!http2ValidTrailerHeader(k))
            { 
                // Forbidden by RFC 2616 14.40.
                rws.conn.logf("ignoring invalid trailer %q", k);
                return;
            }
            if (!http2strSliceContains(rws.trailers, k))
            {
                rws.trailers = append(rws.trailers, k);
            }
        }

        // writeChunk writes chunks from the bufio.Writer. But because
        // bufio.Writer may bypass its chunking, sometimes p may be
        // arbitrarily large.
        //
        // writeChunk is also responsible (on the first chunk) for sending the
        // HEADER response.
        private static (long, error) writeChunk(this ref http2responseWriterState rws, slice<byte> p)
        {
            if (!rws.wroteHeader)
            {
                rws.writeHeader(200L);
            }
            var isHeadResp = rws.req.Method == "HEAD";
            if (!rws.sentHeader)
            {
                rws.sentHeader = true;
                @string ctype = default;                @string clen = default;

                clen = rws.snapHeader.Get("Content-Length");

                if (clen != "")
                {
                    rws.snapHeader.Del("Content-Length");
                    var (clen64, err) = strconv.ParseInt(clen, 10L, 64L);
                    if (err == null && clen64 >= 0L)
                    {
                        rws.sentContentLen = clen64;
                    }
                    else
                    {
                        clen = "";
                    }
                }
                if (clen == "" && rws.handlerDone && http2bodyAllowedForStatus(rws.status) && (len(p) > 0L || !isHeadResp))
                {
                    clen = strconv.Itoa(len(p));
                }
                var (_, hasContentType) = rws.snapHeader["Content-Type"];
                if (!hasContentType && http2bodyAllowedForStatus(rws.status) && len(p) > 0L)
                {
                    ctype = DetectContentType(p);
                }
                @string date = default;
                {
                    var (_, ok) = rws.snapHeader["Date"];

                    if (!ok)
                    { 
                        // TODO(bradfitz): be faster here, like net/http? measure.
                        date = time.Now().UTC().Format(TimeFormat);
                    }

                }

                foreach (var (_, v) in rws.snapHeader["Trailer"])
                {
                    http2foreachHeaderElement(v, rws.declareTrailer);
                }
                var endStream = (rws.handlerDone && !rws.hasTrailers() && len(p) == 0L) || isHeadResp;
                err = rws.conn.writeHeaders(rws.stream, ref new http2writeResHeaders(streamID:rws.stream.id,httpResCode:rws.status,h:rws.snapHeader,endStream:endStream,contentType:ctype,contentLength:clen,date:date,));
                if (err != null)
                {
                    rws.dirty = true;
                    return (0L, err);
                }
                if (endStream)
                {
                    return (0L, null);
                }
            }
            if (isHeadResp)
            {
                return (len(p), null);
            }
            if (len(p) == 0L && !rws.handlerDone)
            {
                return (0L, null);
            }
            if (rws.handlerDone)
            {
                rws.promoteUndeclaredTrailers();
            }
            endStream = rws.handlerDone && !rws.hasTrailers();
            if (len(p) > 0L || endStream)
            { 
                // only send a 0 byte DATA frame if we're ending the stream.
                {
                    var err = rws.conn.writeDataFromHandler(rws.stream, p, endStream);

                    if (err != null)
                    {
                        rws.dirty = true;
                        return (0L, err);
                    }

                }
            }
            if (rws.handlerDone && rws.hasTrailers())
            {
                err = rws.conn.writeHeaders(rws.stream, ref new http2writeResHeaders(streamID:rws.stream.id,h:rws.handlerHeader,trailers:rws.trailers,endStream:true,));
                if (err != null)
                {
                    rws.dirty = true;
                }
                return (len(p), err);
            }
            return (len(p), null);
        }

        // TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
        // that, if present, signals that the map entry is actually for
        // the response trailers, and not the response headers. The prefix
        // is stripped after the ServeHTTP call finishes and the values are
        // sent in the trailers.
        //
        // This mechanism is intended only for trailers that are not known
        // prior to the headers being written. If the set of trailers is fixed
        // or known before the header is written, the normal Go trailers mechanism
        // is preferred:
        //    https://golang.org/pkg/net/http/#ResponseWriter
        //    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
        private static readonly @string http2TrailerPrefix = "Trailer:";

        // promoteUndeclaredTrailers permits http.Handlers to set trailers
        // after the header has already been flushed. Because the Go
        // ResponseWriter interface has no way to set Trailers (only the
        // Header), and because we didn't want to expand the ResponseWriter
        // interface, and because nobody used trailers, and because RFC 2616
        // says you SHOULD (but not must) predeclare any trailers in the
        // header, the official ResponseWriter rules said trailers in Go must
        // be predeclared, and then we reuse the same ResponseWriter.Header()
        // map to mean both Headers and Trailers. When it's time to write the
        // Trailers, we pick out the fields of Headers that were declared as
        // trailers. That worked for a while, until we found the first major
        // user of Trailers in the wild: gRPC (using them only over http2),
        // and gRPC libraries permit setting trailers mid-stream without
        // predeclarnig them. So: change of plans. We still permit the old
        // way, but we also permit this hack: if a Header() key begins with
        // "Trailer:", the suffix of that key is a Trailer. Because ':' is an
        // invalid token byte anyway, there is no ambiguity. (And it's already
        // filtered out) It's mildly hacky, but not terrible.
        //
        // This method runs after the Handler is done and promotes any Header
        // fields to be trailers.


        // promoteUndeclaredTrailers permits http.Handlers to set trailers
        // after the header has already been flushed. Because the Go
        // ResponseWriter interface has no way to set Trailers (only the
        // Header), and because we didn't want to expand the ResponseWriter
        // interface, and because nobody used trailers, and because RFC 2616
        // says you SHOULD (but not must) predeclare any trailers in the
        // header, the official ResponseWriter rules said trailers in Go must
        // be predeclared, and then we reuse the same ResponseWriter.Header()
        // map to mean both Headers and Trailers. When it's time to write the
        // Trailers, we pick out the fields of Headers that were declared as
        // trailers. That worked for a while, until we found the first major
        // user of Trailers in the wild: gRPC (using them only over http2),
        // and gRPC libraries permit setting trailers mid-stream without
        // predeclarnig them. So: change of plans. We still permit the old
        // way, but we also permit this hack: if a Header() key begins with
        // "Trailer:", the suffix of that key is a Trailer. Because ':' is an
        // invalid token byte anyway, there is no ambiguity. (And it's already
        // filtered out) It's mildly hacky, but not terrible.
        //
        // This method runs after the Handler is done and promotes any Header
        // fields to be trailers.
        private static void promoteUndeclaredTrailers(this ref http2responseWriterState rws)
        {
            foreach (var (k, vv) in rws.handlerHeader)
            {
                if (!strings.HasPrefix(k, http2TrailerPrefix))
                {
                    continue;
                }
                var trailerKey = strings.TrimPrefix(k, http2TrailerPrefix);
                rws.declareTrailer(trailerKey);
                rws.handlerHeader[CanonicalHeaderKey(trailerKey)] = vv;
            }
            if (len(rws.trailers) > 1L)
            {
                ref http2sorter sorter = http2sorterPool.Get()._<ref http2sorter>();
                sorter.SortStrings(rws.trailers);
                http2sorterPool.Put(sorter);
            }
        }

        private static void Flush(this ref http2responseWriter _w) => func(_w, (ref http2responseWriter w, Defer _, Panic panic, Recover __) =>
        {
            var rws = w.rws;
            if (rws == null)
            {
                panic("Header called after Handler finished");
            }
            if (rws.bw.Buffered() > 0L)
            {
                {
                    var err = rws.bw.Flush();

                    if (err != null)
                    { 
                        // Ignore the error. The frame writer already knows.
                        return;
                    }

                }
            }
            else
            { 
                // The bufio.Writer won't call chunkWriter.Write
                // (writeChunk with zero bytes, so we have to do it
                // ourselves to force the HTTP response header and/or
                // final DATA frame (with END_STREAM) to be sent.
                rws.writeChunk(null);
            }
        });

        private static channel<bool> CloseNotify(this ref http2responseWriter _w) => func(_w, (ref http2responseWriter w, Defer _, Panic panic, Recover __) =>
        {
            var rws = w.rws;
            if (rws == null)
            {
                panic("CloseNotify called after Handler finished");
            }
            rws.closeNotifierMu.Lock();
            var ch = rws.closeNotifierCh;
            if (ch == null)
            {
                ch = make_channel<bool>(1L);
                rws.closeNotifierCh = ch;
                var cw = rws.stream.cw;
                go_(() => () =>
                {
                    cw.Wait(); // wait for close
                    ch.Send(true);
                }());
            }
            rws.closeNotifierMu.Unlock();
            return ch;
        });

        private static Header Header(this ref http2responseWriter _w) => func(_w, (ref http2responseWriter w, Defer _, Panic panic, Recover __) =>
        {
            var rws = w.rws;
            if (rws == null)
            {
                panic("Header called after Handler finished");
            }
            if (rws.handlerHeader == null)
            {
                rws.handlerHeader = make(Header);
            }
            return rws.handlerHeader;
        });

        // checkWriteHeaderCode is a copy of net/http's checkWriteHeaderCode.
        private static void http2checkWriteHeaderCode(long code) => func((_, panic, __) =>
        { 
            // Issue 22880: require valid WriteHeader status codes.
            // For now we only enforce that it's three digits.
            // In the future we might block things over 599 (600 and above aren't defined
            // at http://httpwg.org/specs/rfc7231.html#status.codes)
            // and we might block under 200 (once we have more mature 1xx support).
            // But for now any three digits.
            //
            // We used to send "HTTP/1.1 000 0" on the wire in responses but there's
            // no equivalent bogus thing we can realistically send in HTTP/2,
            // so we'll consistently panic instead and help people find their bugs
            // early. (We can't return an error from WriteHeader even if we wanted to.)
            if (code < 100L || code > 999L)
            {
                panic(fmt.Sprintf("invalid WriteHeader code %v", code));
            }
        });

        private static void WriteHeader(this ref http2responseWriter _w, long code) => func(_w, (ref http2responseWriter w, Defer _, Panic panic, Recover __) =>
        {
            var rws = w.rws;
            if (rws == null)
            {
                panic("WriteHeader called after Handler finished");
            }
            rws.writeHeader(code);
        });

        private static void writeHeader(this ref http2responseWriterState rws, long code)
        {
            if (!rws.wroteHeader)
            {
                http2checkWriteHeaderCode(code);
                rws.wroteHeader = true;
                rws.status = code;
                if (len(rws.handlerHeader) > 0L)
                {
                    rws.snapHeader = http2cloneHeader(rws.handlerHeader);
                }
            }
        }

        private static Header http2cloneHeader(Header h)
        {
            var h2 = make(Header, len(h));
            foreach (var (k, vv) in h)
            {
                var vv2 = make_slice<@string>(len(vv));
                copy(vv2, vv);
                h2[k] = vv2;
            }
            return h2;
        }

        // The Life Of A Write is like this:
        //
        // * Handler calls w.Write or w.WriteString ->
        // * -> rws.bw (*bufio.Writer) ->
        // * (Handler might call Flush)
        // * -> chunkWriter{rws}
        // * -> responseWriterState.writeChunk(p []byte)
        // * -> responseWriterState.writeChunk (most of the magic; see comment there)
        private static (long, error) Write(this ref http2responseWriter w, slice<byte> p)
        {
            return w.write(len(p), p, "");
        }

        private static (long, error) WriteString(this ref http2responseWriter w, @string s)
        {
            return w.write(len(s), null, s);
        }

        // either dataB or dataS is non-zero.
        private static (long, error) write(this ref http2responseWriter _w, long lenData, slice<byte> dataB, @string dataS) => func(_w, (ref http2responseWriter w, Defer _, Panic panic, Recover __) =>
        {
            var rws = w.rws;
            if (rws == null)
            {
                panic("Write called after Handler finished");
            }
            if (!rws.wroteHeader)
            {
                w.WriteHeader(200L);
            }
            if (!http2bodyAllowedForStatus(rws.status))
            {
                return (0L, ErrBodyNotAllowed);
            }
            rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)); // only one can be set
            if (rws.sentContentLen != 0L && rws.wroteBytes > rws.sentContentLen)
            { 
                // TODO: send a RST_STREAM
                return (0L, errors.New("http2: handler wrote more than declared Content-Length"));
            }
            if (dataB != null)
            {
                return rws.bw.Write(dataB);
            }
            else
            {
                return rws.bw.WriteString(dataS);
            }
        });

        private static void handlerDone(this ref http2responseWriter w)
        {
            var rws = w.rws;
            var dirty = rws.dirty;
            rws.handlerDone = true;
            w.Flush();
            w.rws = null;
            if (!dirty)
            { 
                // Only recycle the pool if all prior Write calls to
                // the serverConn goroutine completed successfully. If
                // they returned earlier due to resets from the peer
                // there might still be write goroutines outstanding
                // from the serverConn referencing the rws memory. See
                // issue 20704.
                http2responseWriterStatePool.Put(rws);
            }
        }

        // Push errors.
        private static var http2ErrRecursivePush = errors.New("http2: recursive push not allowed");        private static var http2ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS");

        // pushOptions is the internal version of http.PushOptions, which we
        // cannot include here because it's only defined in Go 1.8 and later.
        private partial struct http2pushOptions
        {
            public @string Method;
            public Header Header;
        }

        private static error push(this ref http2responseWriter w, @string target, http2pushOptions opts)
        {
            var st = w.rws.stream;
            var sc = st.sc;
            sc.serveG.checkNotOn(); 

            // No recursive pushes: "PUSH_PROMISE frames MUST only be sent on a peer-initiated stream."
            // http://tools.ietf.org/html/rfc7540#section-6.6
            if (st.isPushed())
            {
                return error.As(http2ErrRecursivePush);
            } 

            // Default options.
            if (opts.Method == "")
            {
                opts.Method = "GET";
            }
            if (opts.Header == null)
            {
                opts.Header = new Header();
            }
            @string wantScheme = "http";
            if (w.rws.req.TLS != null)
            {
                wantScheme = "https";
            } 

            // Validate the request.
            var (u, err) = url.Parse(target);
            if (err != null)
            {
                return error.As(err);
            }
            if (u.Scheme == "")
            {
                if (!strings.HasPrefix(target, "/"))
                {
                    return error.As(fmt.Errorf("target must be an absolute URL or an absolute path: %q", target));
                }
                u.Scheme = wantScheme;
                u.Host = w.rws.req.Host;
            }
            else
            {
                if (u.Scheme != wantScheme)
                {
                    return error.As(fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme));
                }
                if (u.Host == "")
                {
                    return error.As(errors.New("URL must have a host"));
                }
            }
            foreach (var (k) in opts.Header)
            {
                if (strings.HasPrefix(k, ":"))
                {
                    return error.As(fmt.Errorf("promised request headers cannot include pseudo header %q", k));
                } 
                // These headers are meaningful only if the request has a body,
                // but PUSH_PROMISE requests cannot have a body.
                // http://tools.ietf.org/html/rfc7540#section-8.2
                // Also disallow Host, since the promised URL must be absolute.
                switch (strings.ToLower(k))
                {
                    case "content-length": 

                    case "content-encoding": 

                    case "trailer": 

                    case "te": 

                    case "expect": 

                    case "host": 
                        return error.As(fmt.Errorf("promised request headers cannot include %q", k));
                        break;
                }
            }
            {
                var err__prev1 = err;

                var err = http2checkValidHTTP2RequestHeaders(opts.Header);

                if (err != null)
                {
                    return error.As(err);
                } 

                // The RFC effectively limits promised requests to GET and HEAD:
                // "Promised requests MUST be cacheable [GET, HEAD, or POST], and MUST be safe [GET or HEAD]"
                // http://tools.ietf.org/html/rfc7540#section-8.2

                err = err__prev1;

            } 

            // The RFC effectively limits promised requests to GET and HEAD:
            // "Promised requests MUST be cacheable [GET, HEAD, or POST], and MUST be safe [GET or HEAD]"
            // http://tools.ietf.org/html/rfc7540#section-8.2
            if (opts.Method != "GET" && opts.Method != "HEAD")
            {
                return error.As(fmt.Errorf("method %q must be GET or HEAD", opts.Method));
            }
            http2startPushRequest msg = ref new http2startPushRequest(parent:st,method:opts.Method,url:u,header:http2cloneHeader(opts.Header),done:http2errChanPool.Get().(chanerror),);

            return error.As(http2errClientDisconnected);
            return error.As(http2errStreamClosed);
            return error.As(http2errClientDisconnected);
            return error.As(http2errStreamClosed);
            http2errChanPool.Put(msg.done);
            return error.As(err);
        }

        private partial struct http2startPushRequest
        {
            public ptr<http2stream> parent;
            public @string method;
            public ptr<url.URL> url;
            public Header header;
            public channel<error> done;
        }

        private static void startPush(this ref http2serverConn _sc, ref http2startPushRequest _msg) => func(_sc, _msg, (ref http2serverConn sc, ref http2startPushRequest msg, Defer _, Panic panic, Recover __) =>
        {
            sc.serveG.check(); 

            // http://tools.ietf.org/html/rfc7540#section-6.6.
            // PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
            // is in either the "open" or "half-closed (remote)" state.
            if (msg.parent.state != http2stateOpen && msg.parent.state != http2stateHalfClosedRemote)
            { 
                // responseWriter.Push checks that the stream is peer-initiaed.
                msg.done.Send(http2errStreamClosed);
                return;
            } 

            // http://tools.ietf.org/html/rfc7540#section-6.6.
            if (!sc.pushEnabled)
            {
                msg.done.Send(ErrNotSupported);
                return;
            } 

            // PUSH_PROMISE frames must be sent in increasing order by stream ID, so
            // we allocate an ID for the promised stream lazily, when the PUSH_PROMISE
            // is written. Once the ID is allocated, we start the request handler.
            Func<(uint, error)> allocatePromisedID = () =>
            {
                sc.serveG.check(); 

                // Check this again, just in case. Technically, we might have received
                // an updated SETTINGS by the time we got around to writing this frame.
                if (!sc.pushEnabled)
                {
                    return (0L, ErrNotSupported);
                } 
                // http://tools.ietf.org/html/rfc7540#section-6.5.2.
                if (sc.curPushedStreams + 1L > sc.clientMaxStreams)
                {
                    return (0L, http2ErrPushLimitReached);
                } 

                // http://tools.ietf.org/html/rfc7540#section-5.1.1.
                // Streams initiated by the server MUST use even-numbered identifiers.
                // A server that is unable to establish a new stream identifier can send a GOAWAY
                // frame so that the client is forced to open a new connection for new streams.
                if (sc.maxPushPromiseID + 2L >= 1L << (int)(31L))
                {
                    sc.startGracefulShutdownInternal();
                    return (0L, http2ErrPushLimitReached);
                }
                sc.maxPushPromiseID += 2L;
                var promisedID = sc.maxPushPromiseID; 

                // http://tools.ietf.org/html/rfc7540#section-8.2.
                // Strictly speaking, the new stream should start in "reserved (local)", then
                // transition to "half closed (remote)" after sending the initial HEADERS, but
                // we start in "half closed (remote)" for simplicity.
                // See further comments at the definition of stateHalfClosedRemote.
                var promised = sc.newStream(promisedID, msg.parent.id, http2stateHalfClosedRemote);
                var (rw, req, err) = sc.newWriterAndRequestNoBody(promised, new http2requestParam(method:msg.method,scheme:msg.url.Scheme,authority:msg.url.Host,path:msg.url.RequestURI(),header:http2cloneHeader(msg.header),));
                if (err != null)
                { 
                    // Should not happen, since we've already validated msg.url.
                    panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err));
                }
                go_(() => sc.runHandler(rw, req, sc.handler.ServeHTTP));
                return (promisedID, null);
            }
;

            sc.writeFrame(new http2FrameWriteRequest(write:&http2writePushPromise{streamID:msg.parent.id,method:msg.method,url:msg.url,h:msg.header,allocatePromisedID:allocatePromisedID,},stream:msg.parent,done:msg.done,));
        });

        // foreachHeaderElement splits v according to the "#rule" construction
        // in RFC 2616 section 2.1 and calls fn for each non-empty element.
        private static void http2foreachHeaderElement(@string v, Action<@string> fn)
        {
            v = textproto.TrimString(v);
            if (v == "")
            {
                return;
            }
            if (!strings.Contains(v, ","))
            {
                fn(v);
                return;
            }
            foreach (var (_, f) in strings.Split(v, ","))
            {
                f = textproto.TrimString(f);

                if (f != "")
                {
                    fn(f);
                }
            }
        }

        // From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2
        private static @string http2connHeaders = new slice<@string>(new @string[] { "Connection", "Keep-Alive", "Proxy-Connection", "Transfer-Encoding", "Upgrade" });

        // checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,
        // per RFC 7540 Section 8.1.2.2.
        // The returned error is reported to users.
        private static error http2checkValidHTTP2RequestHeaders(Header h)
        {
            foreach (var (_, k) in http2connHeaders)
            {
                {
                    var (_, ok) = h[k];

                    if (ok)
                    {
                        return error.As(fmt.Errorf("request header %q is not valid in HTTP/2", k));
                    }

                }
            }
            var te = h["Te"];
            if (len(te) > 0L && (len(te) > 1L || (te[0L] != "trailers" && te[0L] != "")))
            {
                return error.As(errors.New("request header \"TE\" may only be \"trailers\" in HTTP/2"));
            }
            return error.As(null);
        }

        private static HandlerFunc http2new400Handler(error err)
        {
            return (w, r) =>
            {
                Error(w, err.Error(), StatusBadRequest);
            }
;
        }

        // ValidTrailerHeader reports whether name is a valid header field name to appear
        // in trailers.
        // See: http://tools.ietf.org/html/rfc7230#section-4.1.2
        private static bool http2ValidTrailerHeader(@string name)
        {
            name = CanonicalHeaderKey(name);
            if (strings.HasPrefix(name, "If-") || http2badTrailer[name])
            {
                return false;
            }
            return true;
        }

        private static map http2badTrailer = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, bool>{"Authorization":true,"Cache-Control":true,"Connection":true,"Content-Encoding":true,"Content-Length":true,"Content-Range":true,"Content-Type":true,"Expect":true,"Host":true,"Keep-Alive":true,"Max-Forwards":true,"Pragma":true,"Proxy-Authenticate":true,"Proxy-Authorization":true,"Proxy-Connection":true,"Range":true,"Realm":true,"Te":true,"Trailer":true,"Transfer-Encoding":true,"Www-Authenticate":true,};

        // h1ServerKeepAlivesDisabled reports whether hs has its keep-alives
        // disabled. See comments on h1ServerShutdownChan above for why
        // the code is written this way.
        private static bool http2h1ServerKeepAlivesDisabled(ref Server hs)
        {
            var x = hs;
            public partial interface I
            {
                bool doKeepAlives();
            }
            {
                I (hs, ok) = x._<I>();

                if (ok)
                {
                    return !hs.doKeepAlives();
                }

            }
            return false;
        }

 
        // transportDefaultConnFlow is how many connection-level flow control
        // tokens we give the server at start-up, past the default 64k.
        private static readonly long http2transportDefaultConnFlow = 1L << (int)(30L); 

        // transportDefaultStreamFlow is how many stream-level flow
        // control tokens we announce to the peer, and how many bytes
        // we buffer per stream.
        private static readonly long http2transportDefaultStreamFlow = 4L << (int)(20L); 

        // transportDefaultStreamMinRefresh is the minimum number of bytes we'll send
        // a stream-level WINDOW_UPDATE for at a time.
        private static readonly long http2transportDefaultStreamMinRefresh = 4L << (int)(10L);

        private static readonly @string http2defaultUserAgent = "Go-http-client/2.0";

        // Transport is an HTTP/2 Transport.
        //
        // A Transport internally caches connections to servers. It is safe
        // for concurrent use by multiple goroutines.
        private partial struct http2Transport
        {
            public Func<@string, @string, ref tls.Config, (net.Conn, error)> DialTLS; // TLSClientConfig specifies the TLS configuration to use with
// tls.Client. If nil, the default configuration is used.
            public ptr<tls.Config> TLSClientConfig; // ConnPool optionally specifies an alternate connection pool to use.
// If nil, the default is used.
            public http2ClientConnPool ConnPool; // DisableCompression, if true, prevents the Transport from
// requesting compression with an "Accept-Encoding: gzip"
// request header when the Request contains no existing
// Accept-Encoding value. If the Transport requests gzip on
// its own and gets a gzipped response, it's transparently
// decoded in the Response.Body. However, if the user
// explicitly requested gzip it is not automatically
// uncompressed.
            public bool DisableCompression; // AllowHTTP, if true, permits HTTP/2 requests using the insecure,
// plain-text "http" scheme. Note that this does not enable h2c support.
            public bool AllowHTTP; // MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
// send in the initial settings frame. It is how many bytes
// of response headers are allowed. Unlike the http2 spec, zero here
// means to use a default limit (currently 10MB). If you actually
// want to advertise an ulimited value to the peer, Transport
// interprets the highest possible value here (0xffffffff or 1<<32-1)
// to mean no limit.
            public uint MaxHeaderListSize; // t1, if non-nil, is the standard library Transport using
// this transport. Its settings are used (but not its
// RoundTrip method, etc).
            public ptr<Transport> t1;
            public sync.Once connPoolOnce;
            public http2ClientConnPool connPoolOrDef; // non-nil version of ConnPool
        }

        private static uint maxHeaderListSize(this ref http2Transport t)
        {
            if (t.MaxHeaderListSize == 0L)
            {
                return 10L << (int)(20L);
            }
            if (t.MaxHeaderListSize == 0xffffffffUL)
            {
                return 0L;
            }
            return t.MaxHeaderListSize;
        }

        private static bool disableCompression(this ref http2Transport t)
        {
            return t.DisableCompression || (t.t1 != null && t.t1.DisableCompression);
        }

        private static var http2errTransportVersion = errors.New("http2: ConfigureTransport is only supported starting at Go 1.6");

        // ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
        // It requires Go 1.6 or later and returns an error if the net/http package is too old
        // or if t1 has already been HTTP/2-enabled.
        private static error http2ConfigureTransport(ref Transport t1)
        {
            var (_, err) = http2configureTransport(t1); // in configure_transport.go (go1.6) or not_go16.go
            return error.As(err);
        }

        private static http2ClientConnPool connPool(this ref http2Transport t)
        {
            t.connPoolOnce.Do(t.initConnPool);
            return t.connPoolOrDef;
        }

        private static void initConnPool(this ref http2Transport t)
        {
            if (t.ConnPool != null)
            {
                t.connPoolOrDef = t.ConnPool;
            }
            else
            {
                t.connPoolOrDef = ref new http2clientConnPool(t:t);
            }
        }

        // ClientConn is the state of a single HTTP/2 client connection to an
        // HTTP/2 server.
        private partial struct http2ClientConn
        {
            public ptr<http2Transport> t;
            public net.Conn tconn; // usually *tls.Conn, except specialized impls
            public ptr<tls.ConnectionState> tlsState; // nil only for specialized impls
            public bool singleUse; // whether being used for a single http.Request

// readLoop goroutine fields:
            public channel<object> readerDone; // closed on error
            public error readerErr; // set before readerDone is closed

            public time.Duration idleTimeout; // or 0 for never
            public ptr<time.Timer> idleTimer;
            public sync.Mutex mu; // guards following
            public ptr<sync.Cond> cond; // hold mu; broadcast on flow/closed changes
            public http2flow flow; // our conn-level flow control quota (cs.flow is per stream)
            public http2flow inflow; // peer's conn-level flow control
            public bool closed;
            public bool wantSettingsAck; // we sent a SETTINGS frame and haven't heard back
            public ptr<http2GoAwayFrame> goAway; // if non-nil, the GoAwayFrame we received
            public @string goAwayDebug; // goAway frame's debug data, retained as a string
            public map<uint, ref http2clientStream> streams; // client-initiated
            public uint nextStreamID;
            public long pendingRequests; // requests blocked and waiting to be sent because len(streams) == maxConcurrentStreams
            public map<array<byte>, channel<object>> pings; // in flight ping data to notification channel
            public ptr<bufio.Writer> bw;
            public ptr<bufio.Reader> br;
            public ptr<http2Framer> fr;
            public time.Time lastActive; // Settings from peer: (also guarded by mu)
            public uint maxFrameSize;
            public uint maxConcurrentStreams;
            public ulong peerMaxHeaderListSize;
            public uint initialWindowSize;
            public bytes.Buffer hbuf; // HPACK encoder writes into this
            public ptr<hpack.Encoder> henc;
            public slice<slice<byte>> freeBuf;
            public sync.Mutex wmu; // held while writing; acquire AFTER mu if holding both
            public error werr; // first write error that has occurred
        }

        // clientStream is the state for a single HTTP/2 stream. One of these
        // is created for each Transport.RoundTrip call.
        private partial struct http2clientStream
        {
            public ptr<http2ClientConn> cc;
            public ptr<Request> req;
            public ptr<http2clientTrace> trace; // or nil
            public uint ID;
            public channel<http2resAndError> resc;
            public http2pipe bufPipe; // buffered pipe with the flow-controlled response payload
            public bool startedWrite; // started request body write; guarded by cc.mu
            public bool requestedGzip;
            public Action on100; // optional code to run if get a 100 continue response

            public http2flow flow; // guarded by cc.mu
            public http2flow inflow; // guarded by cc.mu
            public long bytesRemain; // -1 means unknown; owned by transportResponseBody.Read
            public error readErr; // sticky read error; owned by transportResponseBody.Read
            public error stopReqBody; // if non-nil, stop writing req body; guarded by cc.mu
            public bool didReset; // whether we sent a RST_STREAM to the server; guarded by cc.mu

            public channel<object> peerReset; // closed on peer reset
            public error resetErr; // populated before peerReset is closed

            public channel<object> done; // closed when stream remove from cc.streams map; close calls guarded by cc.mu

// owned by clientConnReadLoop:
            public bool firstByte; // got the first response byte
            public bool pastHeaders; // got first MetaHeadersFrame (actual headers)
            public bool pastTrailers; // got optional second MetaHeadersFrame (trailers)

            public Header trailer; // accumulated trailers
            public ptr<Header> resTrailer; // client's Response.Trailer
        }

        // awaitRequestCancel waits for the user to cancel a request or for the done
        // channel to be signaled. A non-nil error is returned only if the request was
        // canceled.
        private static error http2awaitRequestCancel(ref Request req, channel<object> done)
        {
            var ctx = http2reqContext(req);
            if (req.Cancel == null && ctx.Done() == null)
            {
                return error.As(null);
            }
            return error.As(http2errRequestCanceled);
            return error.As(ctx.Err());
            return error.As(null);
        }

        // awaitRequestCancel waits for the user to cancel a request, its context to
        // expire, or for the request to be done (any way it might be removed from the
        // cc.streams map: peer reset, successful completion, TCP connection breakage,
        // etc). If the request is canceled, then cs will be canceled and closed.
        private static void awaitRequestCancel(this ref http2clientStream cs, ref Request req)
        {
            {
                var err = http2awaitRequestCancel(req, cs.done);

                if (err != null)
                {
                    cs.cancelStream();
                    cs.bufPipe.CloseWithError(err);
                }

            }
        }

        private static void cancelStream(this ref http2clientStream cs)
        {
            var cc = cs.cc;
            cc.mu.Lock();
            var didReset = cs.didReset;
            cs.didReset = true;
            cc.mu.Unlock();

            if (!didReset)
            {
                cc.writeStreamReset(cs.ID, http2ErrCodeCancel, null);
                cc.forgetStreamID(cs.ID);
            }
        }

        // checkResetOrDone reports any error sent in a RST_STREAM frame by the
        // server, or errStreamClosed if the stream is complete.
        private static error checkResetOrDone(this ref http2clientStream cs)
        {
            return error.As(cs.resetErr);
            return error.As(http2errStreamClosed);
            return error.As(null);
        }

        private static bool getStartedWrite(this ref http2clientStream _cs) => func(_cs, (ref http2clientStream cs, Defer defer, Panic _, Recover __) =>
        {
            var cc = cs.cc;
            cc.mu.Lock();
            defer(cc.mu.Unlock());
            return cs.startedWrite;
        });

        private static void abortRequestBodyWrite(this ref http2clientStream _cs, error err) => func(_cs, (ref http2clientStream cs, Defer _, Panic panic, Recover __) =>
        {
            if (err == null)
            {
                panic("nil error");
            }
            var cc = cs.cc;
            cc.mu.Lock();
            cs.stopReqBody = err;
            cc.cond.Broadcast();
            cc.mu.Unlock();
        });

        private partial struct http2stickyErrWriter
        {
            public io.Writer w;
            public ptr<error> err;
        }

        private static (long, error) Write(this http2stickyErrWriter sew, slice<byte> p)
        {
            if (sew.err != null.Value)
            {
                return (0L, sew.err.Value);
            }
            n, err = sew.w.Write(p);
            sew.err.Value = err;
            return;
        }

        // noCachedConnError is the concrete type of ErrNoCachedConn, needs to be detected
        // by net/http regardless of whether it's its bundled version (in h2_bundle.go with a rewritten type name)
        // or from a user's x/net/http2. As such, as it has a unique method name (IsHTTP2NoCachedConnError) that
        // net/http sniffs for via func isNoCachedConnError.
        private partial struct http2noCachedConnError
        {
        }

        private static void IsHTTP2NoCachedConnError(this http2noCachedConnError _p0)
        {
        }

        private static @string Error(this http2noCachedConnError _p0)
        {
            return "http2: no cached connection was available";
        }

        // isNoCachedConnError reports whether err is of type noCachedConnError
        // or its equivalent renamed type in net/http2's h2_bundle.go. Both types
        // may coexist in the same running program.
        private static bool http2isNoCachedConnError(error err)
        {
            return ok;
        }

        private static error http2ErrNoCachedConn = error.As(new http2noCachedConnError());

        // RoundTripOpt are options for the Transport.RoundTripOpt method.
        private partial struct http2RoundTripOpt
        {
            public bool OnlyCachedConn;
        }

        private static (ref Response, error) RoundTrip(this ref http2Transport t, ref Request req)
        {
            return t.RoundTripOpt(req, new http2RoundTripOpt());
        }

        // authorityAddr returns a given authority (a host/IP, or host:port / ip:port)
        // and returns a host:port. The port 443 is added if needed.
        private static @string http2authorityAddr(@string scheme, @string authority)
        {
            var (host, port, err) = net.SplitHostPort(authority);
            if (err != null)
            { // authority didn't have a port
                port = "443";
                if (scheme == "http")
                {
                    port = "80";
                }
                host = authority;
            }
            {
                var (a, err) = idna.ToASCII(host);

                if (err == null)
                {
                    host = a;
                } 
                // IPv6 address literal, without a port:

            } 
            // IPv6 address literal, without a port:
            if (strings.HasPrefix(host, "[") && strings.HasSuffix(host, "]"))
            {
                return host + ":" + port;
            }
            return net.JoinHostPort(host, port);
        }

        // RoundTripOpt is like RoundTrip, but takes options.
        private static (ref Response, error) RoundTripOpt(this ref http2Transport t, ref Request req, http2RoundTripOpt opt)
        {
            if (!(req.URL.Scheme == "https" || (req.URL.Scheme == "http" && t.AllowHTTP)))
            {
                return (null, errors.New("http2: unsupported scheme"));
            }
            var addr = http2authorityAddr(req.URL.Scheme, req.URL.Host);
            for (long retry = 0L; >>MARKER:FOREXPRESSION_LEVEL_1<<; retry++)
            {
                var (cc, err) = t.connPool().GetClientConn(req, addr);
                if (err != null)
                {
                    t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err);
                    return (null, err);
                }
                http2traceGotConn(req, cc);
                var (res, gotErrAfterReqBodyWrite, err) = cc.roundTrip(req);
                if (err != null && retry <= 6L)
                {
                    req, err = http2shouldRetryRequest(req, err, gotErrAfterReqBodyWrite);

                    if (err == null)
                    { 
                        // After the first retry, do exponential backoff with 10% jitter.
                        if (retry == 0L)
                        {
                            continue;
                        }
                        var backoff = float64(uint(1L) << (int)((uint(retry) - 1L)));
                        backoff += backoff * (0.1F * mathrand.Float64());
                        continue;
                        return (null, http2reqContext(req).Err());
                    }
                }
                if (err != null)
                {
                    t.vlogf("RoundTrip failure: %v", err);
                    return (null, err);
                }
                return (res, null);
            }

        }

        // CloseIdleConnections closes any connections which were previously
        // connected from previous requests but are now sitting idle.
        // It does not interrupt any connections currently in use.
        private static void CloseIdleConnections(this ref http2Transport t)
        {
            {
                http2clientConnPoolIdleCloser (cp, ok) = t.connPool()._<http2clientConnPoolIdleCloser>();

                if (ok)
                {
                    cp.closeIdleConnections();
                }

            }
        }

        private static var http2errClientConnClosed = errors.New("http2: client conn is closed");        private static var http2errClientConnUnusable = errors.New("http2: client conn not usable");        private static var http2errClientConnGotGoAway = errors.New("http2: Transport received Server's graceful shutdown GOAWAY");

        // shouldRetryRequest is called by RoundTrip when a request fails to get
        // response headers. It is always called with a non-nil error.
        // It returns either a request to retry (either the same request, or a
        // modified clone), or an error if the request can't be replayed.
        private static (ref Request, error) http2shouldRetryRequest(ref Request req, error err, bool afterBodyWrite)
        {
            if (!http2canRetryError(err))
            {
                return (null, err);
            }
            if (!afterBodyWrite)
            {
                return (req, null);
            } 
            // If the Body is nil (or http.NoBody), it's safe to reuse
            // this request and its Body.
            if (req.Body == null || http2reqBodyIsNoBody(req.Body))
            {
                return (req, null);
            } 
            // Otherwise we depend on the Request having its GetBody
            // func defined.
            var getBody = http2reqGetBody(req); // Go 1.8: getBody = req.GetBody
            if (getBody == null)
            {
                return (null, fmt.Errorf("http2: Transport: cannot retry err [%v] after Request.Body was written; define Request.GetBody to avoid this error", err));
            }
            var (body, err) = getBody();
            if (err != null)
            {
                return (null, err);
            }
            var newReq = req.Value;
            newReq.Body = body;
            return (ref newReq, null);
        }

        private static bool http2canRetryError(error err)
        {
            if (err == http2errClientConnUnusable || err == http2errClientConnGotGoAway)
            {
                return true;
            }
            {
                http2StreamError (se, ok) = err._<http2StreamError>();

                if (ok)
                {
                    return se.Code == http2ErrCodeRefusedStream;
                }

            }
            return false;
        }

        private static (ref http2ClientConn, error) dialClientConn(this ref http2Transport t, @string addr, bool singleUse)
        {
            var (host, _, err) = net.SplitHostPort(addr);
            if (err != null)
            {
                return (null, err);
            }
            var (tconn, err) = t.dialTLS()("tcp", addr, t.newTLSConfig(host));
            if (err != null)
            {
                return (null, err);
            }
            return t.newClientConn(tconn, singleUse);
        }

        private static ref tls.Config newTLSConfig(this ref http2Transport t, @string host)
        {
            ptr<tls.Config> cfg = @new<tls.Config>();
            if (t.TLSClientConfig != null)
            {
                cfg.Value = new ptr<ref http2cloneTLSConfig>(t.TLSClientConfig);
            }
            if (!http2strSliceContains(cfg.NextProtos, http2NextProtoTLS))
            {
                cfg.NextProtos = append(new slice<@string>(new @string[] { http2NextProtoTLS }), cfg.NextProtos);
            }
            if (cfg.ServerName == "")
            {
                cfg.ServerName = host;
            }
            return cfg;
        }

        private static Func<@string, @string, ref tls.Config, (net.Conn, error)> dialTLS(this ref http2Transport t)
        {
            if (t.DialTLS != null)
            {
                return t.DialTLS;
            }
            return t.dialTLSDefault;
        }

        private static (net.Conn, error) dialTLSDefault(this ref http2Transport t, @string network, @string addr, ref tls.Config cfg)
        {
            var (cn, err) = tls.Dial(network, addr, cfg);
            if (err != null)
            {
                return (null, err);
            }
            {
                var err__prev1 = err;

                var err = cn.Handshake();

                if (err != null)
                {
                    return (null, err);
                }

                err = err__prev1;

            }
            if (!cfg.InsecureSkipVerify)
            {
                {
                    var err__prev2 = err;

                    err = cn.VerifyHostname(cfg.ServerName);

                    if (err != null)
                    {
                        return (null, err);
                    }

                    err = err__prev2;

                }
            }
            var state = cn.ConnectionState();
            {
                var p = state.NegotiatedProtocol;

                if (p != http2NextProtoTLS)
                {
                    return (null, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, http2NextProtoTLS));
                }

            }
            if (!state.NegotiatedProtocolIsMutual)
            {
                return (null, errors.New("http2: could not negotiate protocol mutually"));
            }
            return (cn, null);
        }

        // disableKeepAlives reports whether connections should be closed as
        // soon as possible after handling the first request.
        private static bool disableKeepAlives(this ref http2Transport t)
        {
            return t.t1 != null && t.t1.DisableKeepAlives;
        }

        private static time.Duration expectContinueTimeout(this ref http2Transport t)
        {
            if (t.t1 == null)
            {
                return 0L;
            }
            return http2transportExpectContinueTimeout(t.t1);
        }

        private static (ref http2ClientConn, error) NewClientConn(this ref http2Transport t, net.Conn c)
        {
            return t.newClientConn(c, false);
        }

        private static (ref http2ClientConn, error) newClientConn(this ref http2Transport t, net.Conn c, bool singleUse)
        {
            http2ClientConn cc = ref new http2ClientConn(t:t,tconn:c,readerDone:make(chanstruct{}),nextStreamID:1,maxFrameSize:16<<10,initialWindowSize:65535,maxConcurrentStreams:1000,peerMaxHeaderListSize:0xffffffffffffffff,streams:make(map[uint32]*http2clientStream),singleUse:singleUse,wantSettingsAck:true,pings:make(map[[8]byte]chanstruct{}),);
            {
                var d = t.idleConnTimeout();

                if (d != 0L)
                {
                    cc.idleTimeout = d;
                    cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout);
                }

            }
            if (http2VerboseLogs)
            {
                t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr());
            }
            cc.cond = sync.NewCond(ref cc.mu);
            cc.flow.add(int32(http2initialWindowSize)); 

            // TODO: adjust this writer size to account for frame size +
            // MTU + crypto/tls record padding.
            cc.bw = bufio.NewWriter(new http2stickyErrWriter(c,&cc.werr));
            cc.br = bufio.NewReader(c);
            cc.fr = http2NewFramer(cc.bw, cc.br);
            cc.fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, null);
            cc.fr.MaxHeaderListSize = t.maxHeaderListSize(); 

            // TODO: SetMaxDynamicTableSize, SetMaxDynamicTableSizeLimit on
            // henc in response to SETTINGS frames?
            cc.henc = hpack.NewEncoder(ref cc.hbuf);

            {
                http2connectionStater (cs, ok) = c._<http2connectionStater>();

                if (ok)
                {
                    var state = cs.ConnectionState();
                    cc.tlsState = ref state;
                }

            }

            http2Setting initialSettings = new slice<http2Setting>(new http2Setting[] { {ID:http2SettingEnablePush,Val:0}, {ID:http2SettingInitialWindowSize,Val:http2transportDefaultStreamFlow} });
            {
                var max = t.maxHeaderListSize();

                if (max != 0L)
                {
                    initialSettings = append(initialSettings, new http2Setting(ID:http2SettingMaxHeaderListSize,Val:max));
                }

            }

            cc.bw.Write(http2clientPreface);
            cc.fr.WriteSettings(initialSettings);
            cc.fr.WriteWindowUpdate(0L, http2transportDefaultConnFlow);
            cc.inflow.add(http2transportDefaultConnFlow + http2initialWindowSize);
            cc.bw.Flush();
            if (cc.werr != null)
            {
                return (null, cc.werr);
            }
            go_(() => cc.readLoop());
            return (cc, null);
        }

        private static void setGoAway(this ref http2ClientConn _cc, ref http2GoAwayFrame _f) => func(_cc, _f, (ref http2ClientConn cc, ref http2GoAwayFrame f, Defer defer, Panic _, Recover __) =>
        {
            cc.mu.Lock();
            defer(cc.mu.Unlock());

            var old = cc.goAway;
            cc.goAway = f; 

            // Merge the previous and current GoAway error frames.
            if (cc.goAwayDebug == "")
            {
                cc.goAwayDebug = string(f.DebugData());
            }
            if (old != null && old.ErrCode != http2ErrCodeNo)
            {
                cc.goAway.ErrCode = old.ErrCode;
            }
            var last = f.LastStreamID;
            foreach (var (streamID, cs) in cc.streams)
            {
                if (streamID > last)
                {
                }
            }
        });

        // CanTakeNewRequest reports whether the connection can take a new request,
        // meaning it has not been closed or received or sent a GOAWAY.
        private static bool CanTakeNewRequest(this ref http2ClientConn _cc) => func(_cc, (ref http2ClientConn cc, Defer defer, Panic _, Recover __) =>
        {
            cc.mu.Lock();
            defer(cc.mu.Unlock());
            return cc.canTakeNewRequestLocked();
        });

        private static bool canTakeNewRequestLocked(this ref http2ClientConn cc)
        {
            if (cc.singleUse && cc.nextStreamID > 1L)
            {
                return false;
            }
            return cc.goAway == null && !cc.closed && int64(cc.nextStreamID) + int64(cc.pendingRequests) < math.MaxInt32;
        }

        // onIdleTimeout is called from a time.AfterFunc goroutine. It will
        // only be called when we're idle, but because we're coming from a new
        // goroutine, there could be a new request coming in at the same time,
        // so this simply calls the synchronized closeIfIdle to shut down this
        // connection. The timer could just call closeIfIdle, but this is more
        // clear.
        private static void onIdleTimeout(this ref http2ClientConn cc)
        {
            cc.closeIfIdle();
        }

        private static void closeIfIdle(this ref http2ClientConn cc)
        {
            cc.mu.Lock();
            if (len(cc.streams) > 0L)
            {
                cc.mu.Unlock();
                return;
            }
            cc.closed = true;
            var nextID = cc.nextStreamID; 
            // TODO: do clients send GOAWAY too? maybe? Just Close:
            cc.mu.Unlock();

            if (http2VerboseLogs)
            {
                cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID - 2L);
            }
            cc.tconn.Close();
        }

        private static readonly long http2maxAllocFrameSize = 512L << (int)(10L);

        // frameBuffer returns a scratch buffer suitable for writing DATA frames.
        // They're capped at the min of the peer's max frame size or 512KB
        // (kinda arbitrarily), but definitely capped so we don't allocate 4GB
        // bufers.


        // frameBuffer returns a scratch buffer suitable for writing DATA frames.
        // They're capped at the min of the peer's max frame size or 512KB
        // (kinda arbitrarily), but definitely capped so we don't allocate 4GB
        // bufers.
        private static slice<byte> frameScratchBuffer(this ref http2ClientConn cc)
        {
            cc.mu.Lock();
            var size = cc.maxFrameSize;
            if (size > http2maxAllocFrameSize)
            {
                size = http2maxAllocFrameSize;
            }
            foreach (var (i, buf) in cc.freeBuf)
            {
                if (len(buf) >= int(size))
                {
                    cc.freeBuf[i] = null;
                    cc.mu.Unlock();
                    return buf[..size];
                }
            }
            cc.mu.Unlock();
            return make_slice<byte>(size);
        }

        private static void putFrameScratchBuffer(this ref http2ClientConn _cc, slice<byte> buf) => func(_cc, (ref http2ClientConn cc, Defer defer, Panic _, Recover __) =>
        {
            cc.mu.Lock();
            defer(cc.mu.Unlock());
            const long maxBufs = 4L; // arbitrary; 4 concurrent requests per conn? investigate.
 // arbitrary; 4 concurrent requests per conn? investigate.
            if (len(cc.freeBuf) < maxBufs)
            {
                cc.freeBuf = append(cc.freeBuf, buf);
                return;
            }
            foreach (var (i, old) in cc.freeBuf)
            {
                if (old == null)
                {
                    cc.freeBuf[i] = buf;
                    return;
                }
            } 
            // forget about it.
        });

        // errRequestCanceled is a copy of net/http's errRequestCanceled because it's not
        // exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.
        private static var http2errRequestCanceled = errors.New("net/http: request canceled");

        private static (@string, error) http2commaSeparatedTrailers(ref Request req)
        {
            var keys = make_slice<@string>(0L, len(req.Trailer));
            foreach (var (k) in req.Trailer)
            {
                k = CanonicalHeaderKey(k);
                switch (k)
                {
                    case "Transfer-Encoding": 

                    case "Trailer": 

                    case "Content-Length": 
                        return ("", ref new http2badStringError("invalid Trailer key",k));
                        break;
                }
                keys = append(keys, k);
            }
            if (len(keys) > 0L)
            {
                sort.Strings(keys);
                return (strings.Join(keys, ","), null);
            }
            return ("", null);
        }

        private static time.Duration responseHeaderTimeout(this ref http2ClientConn cc)
        {
            if (cc.t.t1 != null)
            {
                return cc.t.t1.ResponseHeaderTimeout;
            } 
            // No way to do this (yet?) with just an http2.Transport. Probably
            // no need. Request.Cancel this is the new way. We only need to support
            // this for compatibility with the old http.Transport fields when
            // we're doing transparent http2.
            return 0L;
        }

        // checkConnHeaders checks whether req has any invalid connection-level headers.
        // per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.
        // Certain headers are special-cased as okay but not transmitted later.
        private static error http2checkConnHeaders(ref Request req)
        {
            {
                var v = req.Header.Get("Upgrade");

                if (v != "")
                {
                    return error.As(fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"]));
                }

            }
            {
                var vv__prev1 = vv;

                var vv = req.Header["Transfer-Encoding"];

                if (len(vv) > 0L && (len(vv) > 1L || vv[0L] != "" && vv[0L] != "chunked"))
                {
                    return error.As(fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv));
                }

                vv = vv__prev1;

            }
            {
                var vv__prev1 = vv;

                vv = req.Header["Connection"];

                if (len(vv) > 0L && (len(vv) > 1L || vv[0L] != "" && vv[0L] != "close" && vv[0L] != "keep-alive"))
                {
                    return error.As(fmt.Errorf("http2: invalid Connection request header: %q", vv));
                }

                vv = vv__prev1;

            }
            return error.As(null);
        }

        // actualContentLength returns a sanitized version of
        // req.ContentLength, where 0 actually means zero (not unknown) and -1
        // means unknown.
        private static long http2actualContentLength(ref Request req)
        {
            if (req.Body == null || http2reqBodyIsNoBody(req.Body))
            {
                return 0L;
            }
            if (req.ContentLength != 0L)
            {
                return req.ContentLength;
            }
            return -1L;
        }

        private static (ref Response, error) RoundTrip(this ref http2ClientConn cc, ref Request req)
        {
            var (resp, _, err) = cc.roundTrip(req);
            return (resp, err);
        }

        private static (ref Response, bool, error) roundTrip(this ref http2ClientConn _cc, ref Request _req) => func(_cc, _req, (ref http2ClientConn cc, ref Request req, Defer defer, Panic _, Recover __) =>
        {
            {
                var err__prev1 = err;

                var err = http2checkConnHeaders(req);

                if (err != null)
                {
                    return (null, false, err);
                }

                err = err__prev1;

            }
            if (cc.idleTimer != null)
            {
                cc.idleTimer.Stop();
            }
            var (trailers, err) = http2commaSeparatedTrailers(req);
            if (err != null)
            {
                return (null, false, err);
            }
            var hasTrailers = trailers != "";

            cc.mu.Lock();
            {
                var err__prev1 = err;

                err = cc.awaitOpenSlotForRequest(req);

                if (err != null)
                {
                    cc.mu.Unlock();
                    return (null, false, err);
                }

                err = err__prev1;

            }

            var body = req.Body;
            var contentLen = http2actualContentLength(req);
            var hasBody = contentLen != 0L; 

            // TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?
            bool requestedGzip = default;
            if (!cc.t.disableCompression() && req.Header.Get("Accept-Encoding") == "" && req.Header.Get("Range") == "" && req.Method != "HEAD")
            { 
                // Request gzip only, not deflate. Deflate is ambiguous and
                // not as universally supported anyway.
                // See: http://www.gzip.org/zlib/zlib_faq.html#faq38
                //
                // Note that we don't request this for HEAD requests,
                // due to a bug in nginx:
                //   http://trac.nginx.org/nginx/ticket/358
                //   https://golang.org/issue/5522
                //
                // We don't request gzip if the request is for a range, since
                // auto-decoding a portion of a gzipped document will just fail
                // anyway. See https://golang.org/issue/8923
                requestedGzip = true;
            } 

            // we send: HEADERS{1}, CONTINUATION{0,} + DATA{0,} (DATA is
            // sent by writeRequestBody below, along with any Trailers,
            // again in form HEADERS{1}, CONTINUATION{0,})
            var (hdrs, err) = cc.encodeHeaders(req, requestedGzip, trailers, contentLen);
            if (err != null)
            {
                cc.mu.Unlock();
                return (null, false, err);
            }
            var cs = cc.newStream();
            cs.req = req;
            cs.trace = http2requestTrace(req);
            cs.requestedGzip = requestedGzip;
            var bodyWriter = cc.t.getBodyWriterState(cs, body);
            cs.on100 = bodyWriter.on100;

            cc.wmu.Lock();
            var endStream = !hasBody && !hasTrailers;
            var werr = cc.writeHeaders(cs.ID, endStream, int(cc.maxFrameSize), hdrs);
            cc.wmu.Unlock();
            http2traceWroteHeaders(cs.trace);
            cc.mu.Unlock();

            if (werr != null)
            {
                if (hasBody)
                {
                    req.Body.Close(); // per RoundTripper contract
                    bodyWriter.cancel();
                }
                cc.forgetStreamID(cs.ID); 
                // Don't bother sending a RST_STREAM (our write already failed;
                // no need to keep writing)
                http2traceWroteRequest(cs.trace, werr);
                return (null, false, werr);
            }
            channel<time.Time> respHeaderTimer = default;
            if (hasBody)
            {
                bodyWriter.scheduleBodyWrite();
            }
            else
            {
                http2traceWroteRequest(cs.trace, null);
                {
                    var d__prev2 = d;

                    var d = cc.responseHeaderTimeout();

                    if (d != 0L)
                    {
                        var timer = time.NewTimer(d);
                        defer(timer.Stop());
                        respHeaderTimer = timer.C;
                    }

                    d = d__prev2;

                }
            }
            var readLoopResCh = cs.resc;
            var bodyWritten = false;
            var ctx = http2reqContext(req);

            Func<http2resAndError, (ref Response, bool, error)> handleReadLoopResponse = re =>
            {
                var res = re.res;
                if (re.err != null || res.StatusCode > 299L)
                { 
                    // On error or status code 3xx, 4xx, 5xx, etc abort any
                    // ongoing write, assuming that the server doesn't care
                    // about our request body. If the server replied with 1xx or
                    // 2xx, however, then assume the server DOES potentially
                    // want our body (e.g. full-duplex streaming:
                    // golang.org/issue/13444). If it turns out the server
                    // doesn't, they'll RST_STREAM us soon enough. This is a
                    // heuristic to avoid adding knobs to Transport. Hopefully
                    // we can keep it.
                    bodyWriter.cancel();
                    cs.abortRequestBodyWrite(http2errStopReqBodyWrite);
                }
                if (re.err != null)
                {
                    cc.forgetStreamID(cs.ID);
                    return (null, cs.getStartedWrite(), re.err);
                }
                res.Request = req;
                res.TLS = cc.tlsState;
                return (res, false, null);
            }
;

            while (true)
            {
                return handleReadLoopResponse(re);
                if (!hasBody || bodyWritten)
                {
                    cc.writeStreamReset(cs.ID, http2ErrCodeCancel, null);
                }
                else
                {
                    bodyWriter.cancel();
                    cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel);
                }
                cc.forgetStreamID(cs.ID);
                return (null, cs.getStartedWrite(), http2errTimeout);
                if (!hasBody || bodyWritten)
                {
                    cc.writeStreamReset(cs.ID, http2ErrCodeCancel, null);
                }
                else
                {
                    bodyWriter.cancel();
                    cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel);
                }
                cc.forgetStreamID(cs.ID);
                return (null, cs.getStartedWrite(), ctx.Err());
                if (!hasBody || bodyWritten)
                {
                    cc.writeStreamReset(cs.ID, http2ErrCodeCancel, null);
                }
                else
                {
                    bodyWriter.cancel();
                    cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel);
                }
                cc.forgetStreamID(cs.ID);
                return (null, cs.getStartedWrite(), http2errRequestCanceled);
                return (null, cs.getStartedWrite(), cs.resetErr);
                return handleReadLoopResponse(re);
                if (err != null)
                {
                    return (null, cs.getStartedWrite(), err);
                }
                bodyWritten = true;
                {
                    var d__prev1 = d;

                    d = cc.responseHeaderTimeout();

                    if (d != 0L)
                    {
                        timer = time.NewTimer(d);
                        defer(timer.Stop());
                        respHeaderTimer = timer.C;
                    }

                    d = d__prev1;

                }
            }

        });

        // awaitOpenSlotForRequest waits until len(streams) < maxConcurrentStreams.
        // Must hold cc.mu.
        private static error awaitOpenSlotForRequest(this ref http2ClientConn cc, ref Request req)
        {
            channel<object> waitingForConn = default;
            error waitingForConnErr = default; // guarded by cc.mu
            while (true)
            {
                cc.lastActive = time.Now();
                if (cc.closed || !cc.canTakeNewRequestLocked())
                {
                    return error.As(http2errClientConnUnusable);
                }
                if (int64(len(cc.streams)) + 1L <= int64(cc.maxConcurrentStreams))
                {
                    if (waitingForConn != null)
                    {
                        close(waitingForConn);
                    }
                    return error.As(null);
                } 
                // Unfortunately, we cannot wait on a condition variable and channel at
                // the same time, so instead, we spin up a goroutine to check if the
                // request is canceled while we wait for a slot to open in the connection.
                if (waitingForConn == null)
                {
                    waitingForConn = make_channel<object>();
                    go_(() => () =>
                    {
                        {
                            var err = http2awaitRequestCancel(req, waitingForConn);

                            if (err != null)
                            {
                                cc.mu.Lock();
                                waitingForConnErr = error.As(err);
                                cc.cond.Broadcast();
                                cc.mu.Unlock();
                            }

                        }
                    }());
                }
                cc.pendingRequests++;
                cc.cond.Wait();
                cc.pendingRequests--;
                if (waitingForConnErr != null)
                {
                    return error.As(waitingForConnErr);
                }
            }

        }

        // requires cc.wmu be held
        private static error writeHeaders(this ref http2ClientConn cc, uint streamID, bool endStream, long maxFrameSize, slice<byte> hdrs)
        {
            var first = true; // first frame written (HEADERS is first, then CONTINUATION)
            while (len(hdrs) > 0L && cc.werr == null)
            {
                var chunk = hdrs;
                if (len(chunk) > maxFrameSize)
                {
                    chunk = chunk[..maxFrameSize];
                }
                hdrs = hdrs[len(chunk)..];
                var endHeaders = len(hdrs) == 0L;
                if (first)
                {
                    cc.fr.WriteHeaders(new http2HeadersFrameParam(StreamID:streamID,BlockFragment:chunk,EndStream:endStream,EndHeaders:endHeaders,));
                    first = false;
                }
                else
                {
                    cc.fr.WriteContinuation(streamID, endHeaders, chunk);
                }
            } 
            // TODO(bradfitz): this Flush could potentially block (as
            // could the WriteHeaders call(s) above), which means they
            // wouldn't respond to Request.Cancel being readable. That's
            // rare, but this should probably be in a goroutine.
 
            // TODO(bradfitz): this Flush could potentially block (as
            // could the WriteHeaders call(s) above), which means they
            // wouldn't respond to Request.Cancel being readable. That's
            // rare, but this should probably be in a goroutine.
            cc.bw.Flush();
            return error.As(cc.werr);
        }

        // internal error values; they don't escape to callers
 
        // abort request body write; don't send cancel
        private static var http2errStopReqBodyWrite = errors.New("http2: aborting request body write");        private static var http2errStopReqBodyWriteAndCancel = errors.New("http2: canceling request");

        private static error writeRequestBody(this ref http2clientStream _cs, io.Reader body, io.Closer bodyCloser) => func(_cs, (ref http2clientStream cs, Defer defer, Panic _, Recover __) =>
        {
            var cc = cs.cc;
            var sentEnd = false; // whether we sent the final DATA frame w/ END_STREAM
            var buf = cc.frameScratchBuffer();
            defer(cc.putFrameScratchBuffer(buf));

            defer(() =>
            {
                http2traceWroteRequest(cs.trace, err); 
                // TODO: write h12Compare test showing whether
                // Request.Body is closed by the Transport,
                // and in multiple cases: server replies <=299 and >299
                // while still writing request body
                var cerr = bodyCloser.Close();
                if (err == null)
                {
                    err = cerr;
                }
            }());

            var req = cs.req;
            var hasTrailers = req.Trailer != null;

            bool sawEOF = default;
            while (!sawEOF)
            {
                var (n, err) = body.Read(buf);
                if (err == io.EOF)
                {
                    sawEOF = true;
                    err = null;
                }
                else if (err != null)
                {
                    return error.As(err);
                }
                var remain = buf[..n];
                while (len(remain) > 0L && err == null)
                {
                    int allowed = default;
                    allowed, err = cs.awaitFlowControl(len(remain));

                    if (err == http2errStopReqBodyWrite) 
                        return error.As(err);
                    else if (err == http2errStopReqBodyWriteAndCancel) 
                        cc.writeStreamReset(cs.ID, http2ErrCodeCancel, null);
                        return error.As(err);
                    else if (err != null) 
                        return error.As(err);
                                        cc.wmu.Lock();
                    var data = remain[..allowed];
                    remain = remain[allowed..];
                    sentEnd = sawEOF && len(remain) == 0L && !hasTrailers;
                    err = cc.fr.WriteData(cs.ID, sentEnd, data);
                    if (err == null)
                    { 
                        // TODO(bradfitz): this flush is for latency, not bandwidth.
                        // Most requests won't need this. Make this opt-in or
                        // opt-out?  Use some heuristic on the body type? Nagel-like
                        // timers?  Based on 'n'? Only last chunk of this for loop,
                        // unless flow control tokens are low? For now, always.
                        // If we change this, see comment below.
                        err = cc.bw.Flush();
                    }
                    cc.wmu.Unlock();
                }

                if (err != null)
                {
                    return error.As(err);
                }
            }


            if (sentEnd)
            { 
                // Already sent END_STREAM (which implies we have no
                // trailers) and flushed, because currently all
                // WriteData frames above get a flush. So we're done.
                return error.As(null);
            }
            slice<byte> trls = default;
            if (hasTrailers)
            {
                cc.mu.Lock();
                trls, err = cc.encodeTrailers(req);
                cc.mu.Unlock();
                if (err != null)
                {
                    cc.writeStreamReset(cs.ID, http2ErrCodeInternal, err);
                    cc.forgetStreamID(cs.ID);
                    return error.As(err);
                }
            }
            cc.mu.Lock();
            var maxFrameSize = int(cc.maxFrameSize);
            cc.mu.Unlock();

            cc.wmu.Lock();
            defer(cc.wmu.Unlock()); 

            // Two ways to send END_STREAM: either with trailers, or
            // with an empty DATA frame.
            if (len(trls) > 0L)
            {
                err = cc.writeHeaders(cs.ID, true, maxFrameSize, trls);
            }
            else
            {
                err = cc.fr.WriteData(cs.ID, true, null);
            }
            {
                var ferr = cc.bw.Flush();

                if (ferr != null && err == null)
                {
                    err = ferr;
                }

            }
            return error.As(err);
        });

        // awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow
        // control tokens from the server.
        // It returns either the non-zero number of tokens taken or an error
        // if the stream is dead.
        private static (int, error) awaitFlowControl(this ref http2clientStream _cs, long maxBytes) => func(_cs, (ref http2clientStream cs, Defer defer, Panic _, Recover __) =>
        {
            var cc = cs.cc;
            cc.mu.Lock();
            defer(cc.mu.Unlock());
            while (true)
            {
                if (cc.closed)
                {
                    return (0L, http2errClientConnClosed);
                }
                if (cs.stopReqBody != null)
                {
                    return (0L, cs.stopReqBody);
                }
                {
                    var err = cs.checkResetOrDone();

                    if (err != null)
                    {
                        return (0L, err);
                    }

                }
                {
                    var a = cs.flow.available();

                    if (a > 0L)
                    {
                        var take = a;
                        if (int(take) > maxBytes)
                        {
                            take = int32(maxBytes); // can't truncate int; take is int32
                        }
                        if (take > int32(cc.maxFrameSize))
                        {
                            take = int32(cc.maxFrameSize);
                        }
                        cs.flow.take(take);
                        return (take, null);
                    }

                }
                cc.cond.Wait();
            }

        });

        private partial struct http2badStringError
        {
            public @string what;
            public @string str;
        }

        private static @string Error(this ref http2badStringError e)
        {
            return fmt.Sprintf("%s %q", e.what, e.str);
        }

        // requires cc.mu be held.
        private static (slice<byte>, error) encodeHeaders(this ref http2ClientConn cc, ref Request req, bool addGzipHeader, @string trailers, long contentLength)
        {
            cc.hbuf.Reset();

            var host = req.Host;
            if (host == "")
            {
                host = req.URL.Host;
            }
            var (host, err) = httplex.PunycodeHostPort(host);
            if (err != null)
            {
                return (null, err);
            }
            @string path = default;
            if (req.Method != "CONNECT")
            {
                path = req.URL.RequestURI();
                if (!http2validPseudoPath(path))
                {
                    var orig = path;
                    path = strings.TrimPrefix(path, req.URL.Scheme + "://" + host);
                    if (!http2validPseudoPath(path))
                    {
                        if (req.URL.Opaque != "")
                        {
                            return (null, fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque));
                        }
                        else
                        {
                            return (null, fmt.Errorf("invalid request :path %q", orig));
                        }
                    }
                }
            } 

            // Check for any invalid headers and return an error before we
            // potentially pollute our hpack state. (We want to be able to
            // continue to reuse the hpack encoder for future requests)
            {
                var k__prev1 = k;
                var vv__prev1 = vv;

                foreach (var (__k, __vv) in req.Header)
                {
                    k = __k;
                    vv = __vv;
                    if (!httplex.ValidHeaderFieldName(k))
                    {
                        return (null, fmt.Errorf("invalid HTTP header name %q", k));
                    }
                    {
                        var v__prev2 = v;

                        foreach (var (_, __v) in vv)
                        {
                            v = __v;
                            if (!httplex.ValidHeaderFieldValue(v))
                            {
                                return (null, fmt.Errorf("invalid HTTP header value %q for header %q", v, k));
                            }
                        }

                        v = v__prev2;
                    }

                }

                k = k__prev1;
                vv = vv__prev1;
            }

            Action<Action<@string, @string>> enumerateHeaders = f =>
            { 
                // 8.1.2.3 Request Pseudo-Header Fields
                // The :path pseudo-header field includes the path and query parts of the
                // target URI (the path-absolute production and optionally a '?' character
                // followed by the query production (see Sections 3.3 and 3.4 of
                // [RFC3986]).
                f(":authority", host);
                f(":method", req.Method);
                if (req.Method != "CONNECT")
                {
                    f(":path", path);
                    f(":scheme", req.URL.Scheme);
                }
                if (trailers != "")
                {
                    f("trailer", trailers);
                }
                bool didUA = default;
                {
                    var k__prev1 = k;
                    var vv__prev1 = vv;

                    foreach (var (__k, __vv) in req.Header)
                    {
                        k = __k;
                        vv = __vv;
                        if (strings.EqualFold(k, "host") || strings.EqualFold(k, "content-length"))
                        { 
                            // Host is :authority, already sent.
                            // Content-Length is automatic, set below.
                            continue;
                        }
                        else if (strings.EqualFold(k, "connection") || strings.EqualFold(k, "proxy-connection") || strings.EqualFold(k, "transfer-encoding") || strings.EqualFold(k, "upgrade") || strings.EqualFold(k, "keep-alive"))
                        { 
                            // Per 8.1.2.2 Connection-Specific Header
                            // Fields, don't send connection-specific
                            // fields. We have already checked if any
                            // are error-worthy so just ignore the rest.
                            continue;
                        }
                        else if (strings.EqualFold(k, "user-agent"))
                        { 
                            // Match Go's http1 behavior: at most one
                            // User-Agent. If set to nil or empty string,
                            // then omit it. Otherwise if not mentioned,
                            // include the default (below).
                            didUA = true;
                            if (len(vv) < 1L)
                            {
                                continue;
                            }
                            vv = vv[..1L];
                            if (vv[0L] == "")
                            {
                                continue;
                            }
                        }
                        {
                            var v__prev2 = v;

                            foreach (var (_, __v) in vv)
                            {
                                v = __v;
                                f(k, v);
                            }

                            v = v__prev2;
                        }

                    }

                    k = k__prev1;
                    vv = vv__prev1;
                }

                if (http2shouldSendReqContentLength(req.Method, contentLength))
                {
                    f("content-length", strconv.FormatInt(contentLength, 10L));
                }
                if (addGzipHeader)
                {
                    f("accept-encoding", "gzip");
                }
                if (!didUA)
                {
                    f("user-agent", http2defaultUserAgent);
                }
            } 

            // Do a first pass over the headers counting bytes to ensure
            // we don't exceed cc.peerMaxHeaderListSize. This is done as a
            // separate pass before encoding the headers to prevent
            // modifying the hpack state.
; 

            // Do a first pass over the headers counting bytes to ensure
            // we don't exceed cc.peerMaxHeaderListSize. This is done as a
            // separate pass before encoding the headers to prevent
            // modifying the hpack state.
            var hlSize = uint64(0L);
            enumerateHeaders((name, value) =>
            {
                hpack.HeaderField hf = new hpack.HeaderField(Name:name,Value:value);
                hlSize += uint64(hf.Size());
            });

            if (hlSize > cc.peerMaxHeaderListSize)
            {
                return (null, http2errRequestHeaderListSize);
            } 

            // Header list size is ok. Write the headers.
            enumerateHeaders((name, value) =>
            {
                cc.writeHeader(strings.ToLower(name), value);
            });

            return (cc.hbuf.Bytes(), null);
        }

        // shouldSendReqContentLength reports whether the http2.Transport should send
        // a "content-length" request header. This logic is basically a copy of the net/http
        // transferWriter.shouldSendContentLength.
        // The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).
        // -1 means unknown.
        private static bool http2shouldSendReqContentLength(@string method, long contentLength)
        {
            if (contentLength > 0L)
            {
                return true;
            }
            if (contentLength < 0L)
            {
                return false;
            } 
            // For zero bodies, whether we send a content-length depends on the method.
            // It also kinda doesn't matter for http2 either way, with END_STREAM.
            switch (method)
            {
                case "POST": 

                case "PUT": 

                case "PATCH": 
                    return true;
                    break;
                default: 
                    return false;
                    break;
            }
        }

        // requires cc.mu be held.
        private static (slice<byte>, error) encodeTrailers(this ref http2ClientConn cc, ref Request req)
        {
            cc.hbuf.Reset();

            var hlSize = uint64(0L);
            {
                var k__prev1 = k;
                var vv__prev1 = vv;

                foreach (var (__k, __vv) in req.Trailer)
                {
                    k = __k;
                    vv = __vv;
                    {
                        var v__prev2 = v;

                        foreach (var (_, __v) in vv)
                        {
                            v = __v;
                            hpack.HeaderField hf = new hpack.HeaderField(Name:k,Value:v);
                            hlSize += uint64(hf.Size());
                        }

                        v = v__prev2;
                    }

                }

                k = k__prev1;
                vv = vv__prev1;
            }

            if (hlSize > cc.peerMaxHeaderListSize)
            {
                return (null, http2errRequestHeaderListSize);
            }
            {
                var k__prev1 = k;
                var vv__prev1 = vv;

                foreach (var (__k, __vv) in req.Trailer)
                {
                    k = __k;
                    vv = __vv; 
                    // Transfer-Encoding, etc.. have already been filtered at the
                    // start of RoundTrip
                    var lowKey = strings.ToLower(k);
                    {
                        var v__prev2 = v;

                        foreach (var (_, __v) in vv)
                        {
                            v = __v;
                            cc.writeHeader(lowKey, v);
                        }

                        v = v__prev2;
                    }

                }

                k = k__prev1;
                vv = vv__prev1;
            }

            return (cc.hbuf.Bytes(), null);
        }

        private static void writeHeader(this ref http2ClientConn cc, @string name, @string value)
        {
            if (http2VerboseLogs)
            {
                log.Printf("http2: Transport encoding header %q = %q", name, value);
            }
            cc.henc.WriteField(new hpack.HeaderField(Name:name,Value:value));
        }

        private partial struct http2resAndError
        {
            public ptr<Response> res;
            public error err;
        }

        // requires cc.mu be held.
        private static ref http2clientStream newStream(this ref http2ClientConn cc)
        {
            http2clientStream cs = ref new http2clientStream(cc:cc,ID:cc.nextStreamID,resc:make(chanhttp2resAndError,1),peerReset:make(chanstruct{}),done:make(chanstruct{}),);
            cs.flow.add(int32(cc.initialWindowSize));
            cs.flow.setConnFlow(ref cc.flow);
            cs.inflow.add(http2transportDefaultStreamFlow);
            cs.inflow.setConnFlow(ref cc.inflow);
            cc.nextStreamID += 2L;
            cc.streams[cs.ID] = cs;
            return cs;
        }

        private static void forgetStreamID(this ref http2ClientConn cc, uint id)
        {
            cc.streamByID(id, true);
        }

        private static ref http2clientStream streamByID(this ref http2ClientConn _cc, uint id, bool andRemove) => func(_cc, (ref http2ClientConn cc, Defer defer, Panic _, Recover __) =>
        {
            cc.mu.Lock();
            defer(cc.mu.Unlock());
            var cs = cc.streams[id];
            if (andRemove && cs != null && !cc.closed)
            {
                cc.lastActive = time.Now();
                delete(cc.streams, id);
                if (len(cc.streams) == 0L && cc.idleTimer != null)
                {
                    cc.idleTimer.Reset(cc.idleTimeout);
                }
                close(cs.done); 
                // Wake up checkResetOrDone via clientStream.awaitFlowControl and
                // wake up RoundTrip if there is a pending request.
                cc.cond.Broadcast();
            }
            return cs;
        });

        // clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.
        private partial struct http2clientConnReadLoop
        {
            public ptr<http2ClientConn> cc;
            public bool closeWhenIdle;
        }

        // readLoop runs in its own goroutine and reads and dispatches frames.
        private static void readLoop(this ref http2ClientConn _cc) => func(_cc, (ref http2ClientConn cc, Defer defer, Panic _, Recover __) =>
        {
            http2clientConnReadLoop rl = ref new http2clientConnReadLoop(cc:cc);
            defer(rl.cleanup());
            cc.readerErr = rl.run();
            {
                http2ConnectionError (ce, ok) = cc.readerErr._<http2ConnectionError>();

                if (ok)
                {
                    cc.wmu.Lock();
                    cc.fr.WriteGoAway(0L, http2ErrCode(ce), null);
                    cc.wmu.Unlock();
                }

            }
        });

        // GoAwayError is returned by the Transport when the server closes the
        // TCP connection after sending a GOAWAY frame.
        private partial struct http2GoAwayError
        {
            public uint LastStreamID;
            public http2ErrCode ErrCode;
            public @string DebugData;
        }

        private static @string Error(this http2GoAwayError e)
        {
            return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q", e.LastStreamID, e.ErrCode, e.DebugData);
        }

        private static bool http2isEOFOrNetReadError(error err)
        {
            if (err == io.EOF)
            {
                return true;
            }
            ref net.OpError (ne, ok) = err._<ref net.OpError>();
            return ok && ne.Op == "read";
        }

        private static void cleanup(this ref http2clientConnReadLoop _rl) => func(_rl, (ref http2clientConnReadLoop rl, Defer defer, Panic _, Recover __) =>
        {
            var cc = rl.cc;
            defer(cc.tconn.Close());
            defer(cc.t.connPool().MarkDead(cc));
            defer(close(cc.readerDone));

            if (cc.idleTimer != null)
            {
                cc.idleTimer.Stop();
            } 

            // Close any response bodies if the server closes prematurely.
            // TODO: also do this if we've written the headers but not
            // gotten a response yet.
            var err = cc.readerErr;
            cc.mu.Lock();
            if (cc.goAway != null && http2isEOFOrNetReadError(err))
            {
                err = new http2GoAwayError(LastStreamID:cc.goAway.LastStreamID,ErrCode:cc.goAway.ErrCode,DebugData:cc.goAwayDebug,);
            }
            else if (err == io.EOF)
            {
                err = io.ErrUnexpectedEOF;
            }
            foreach (var (_, cs) in cc.streams)
            {
                cs.bufPipe.CloseWithError(err); // no-op if already closed
                close(cs.done);
            }
            cc.closed = true;
            cc.cond.Broadcast();
            cc.mu.Unlock();
        });

        private static error run(this ref http2clientConnReadLoop rl)
        {
            var cc = rl.cc;
            rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse;
            var gotReply = false; // ever saw a HEADERS reply
            var gotSettings = false;
            while (true)
            {
                var (f, err) = cc.fr.ReadFrame();
                if (err != null)
                {
                    cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err);
                }
                {
                    http2StreamError (se, ok) = err._<http2StreamError>();

                    if (ok)
                    {
                        {
                            var cs = cc.streamByID(se.StreamID, false);

                            if (cs != null)
                            {
                                cs.cc.writeStreamReset(cs.ID, se.Code, err);
                                cs.cc.forgetStreamID(cs.ID);
                                if (se.Cause == null)
                                {
                                    se.Cause = cc.fr.errDetail;
                                }
                                rl.endStreamError(cs, se);
                            }

                        }
                        continue;
                    }
                    else if (err != null)
                    {
                        return error.As(err);
                    }

                }
                if (http2VerboseLogs)
                {
                    cc.vlogf("http2: Transport received %s", http2summarizeFrame(f));
                }
                if (!gotSettings)
                {
                    {
                        ref http2SettingsFrame (_, ok) = f._<ref http2SettingsFrame>();

                        if (!ok)
                        {
                            cc.logf("protocol error: received %T before a SETTINGS frame", f);
                            return error.As(http2ConnectionError(http2ErrCodeProtocol));
                        }

                    }
                    gotSettings = true;
                }
                var maybeIdle = false; // whether frame might transition us to idle

                switch (f.type())
                {
                    case ref http2MetaHeadersFrame f:
                        err = rl.processHeaders(f);
                        maybeIdle = true;
                        gotReply = true;
                        break;
                    case ref http2DataFrame f:
                        err = rl.processData(f);
                        maybeIdle = true;
                        break;
                    case ref http2GoAwayFrame f:
                        err = rl.processGoAway(f);
                        maybeIdle = true;
                        break;
                    case ref http2RSTStreamFrame f:
                        err = rl.processResetStream(f);
                        maybeIdle = true;
                        break;
                    case ref http2SettingsFrame f:
                        err = rl.processSettings(f);
                        break;
                    case ref http2PushPromiseFrame f:
                        err = rl.processPushPromise(f);
                        break;
                    case ref http2WindowUpdateFrame f:
                        err = rl.processWindowUpdate(f);
                        break;
                    case ref http2PingFrame f:
                        err = rl.processPing(f);
                        break;
                    default:
                    {
                        var f = f.type();
                        cc.logf("Transport: unhandled response frame type %T", f);
                        break;
                    }
                }
                if (err != null)
                {
                    if (http2VerboseLogs)
                    {
                        cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, http2summarizeFrame(f), err);
                    }
                    return error.As(err);
                }
                if (rl.closeWhenIdle && gotReply && maybeIdle)
                {
                    cc.closeIfIdle();
                }
            }

        }

        private static error processHeaders(this ref http2clientConnReadLoop _rl, ref http2MetaHeadersFrame _f) => func(_rl, _f, (ref http2clientConnReadLoop rl, ref http2MetaHeadersFrame f, Defer defer, Panic _, Recover __) =>
        {
            var cc = rl.cc;
            var cs = cc.streamByID(f.StreamID, false);
            if (cs == null)
            { 
                // We'd get here if we canceled a request while the
                // server had its response still in flight. So if this
                // was just something we canceled, ignore it.
                return error.As(null);
            }
            if (f.StreamEnded())
            { 
                // Issue 20521: If the stream has ended, streamByID() causes
                // clientStream.done to be closed, which causes the request's bodyWriter
                // to be closed with an errStreamClosed, which may be received by
                // clientConn.RoundTrip before the result of processing these headers.
                // Deferring stream closure allows the header processing to occur first.
                // clientConn.RoundTrip may still receive the bodyWriter error first, but
                // the fix for issue 16102 prioritises any response.
                //
                // Issue 22413: If there is no request body, we should close the
                // stream before writing to cs.resc so that the stream is closed
                // immediately once RoundTrip returns.
                if (cs.req.Body != null)
                {
                    defer(cc.forgetStreamID(f.StreamID));
                }
                else
                {
                    cc.forgetStreamID(f.StreamID);
                }
            }
            if (!cs.firstByte)
            {
                if (cs.trace != null)
                { 
                    // TODO(bradfitz): move first response byte earlier,
                    // when we first read the 9 byte header, not waiting
                    // until all the HEADERS+CONTINUATION frames have been
                    // merged. This works for now.
                    http2traceFirstResponseByte(cs.trace);
                }
                cs.firstByte = true;
            }
            if (!cs.pastHeaders)
            {
                cs.pastHeaders = true;
            }
            else
            {
                return error.As(rl.processTrailers(cs, f));
            }
            var (res, err) = rl.handleResponse(cs, f);
            if (err != null)
            {
                {
                    http2ConnectionError (_, ok) = err._<http2ConnectionError>();

                    if (ok)
                    {
                        return error.As(err);
                    } 
                    // Any other error type is a stream error.

                } 
                // Any other error type is a stream error.
                cs.cc.writeStreamReset(f.StreamID, http2ErrCodeProtocol, err);
                cc.forgetStreamID(cs.ID);
                cs.resc.Send(new http2resAndError(err:err));
                return error.As(null); // return nil from process* funcs to keep conn alive
            }
            if (res == null)
            { 
                // (nil, nil) special case. See handleResponse docs.
                return error.As(null);
            }
            cs.resTrailer = ref res.Trailer;
            cs.resc.Send(new http2resAndError(res:res));
            return error.As(null);
        });

        // may return error types nil, or ConnectionError. Any other error value
        // is a StreamError of type ErrCodeProtocol. The returned error in that case
        // is the detail.
        //
        // As a special case, handleResponse may return (nil, nil) to skip the
        // frame (currently only used for 100 expect continue). This special
        // case is going away after Issue 13851 is fixed.
        private static (ref Response, error) handleResponse(this ref http2clientConnReadLoop rl, ref http2clientStream cs, ref http2MetaHeadersFrame f)
        {
            if (f.Truncated)
            {
                return (null, http2errResponseHeaderListSize);
            }
            var status = f.PseudoValue("status");
            if (status == "")
            {
                return (null, errors.New("malformed response from server: missing status pseudo header"));
            }
            var (statusCode, err) = strconv.Atoi(status);
            if (err != null)
            {
                return (null, errors.New("malformed response from server: malformed non-numeric status pseudo header"));
            }
            if (statusCode == 100L)
            {
                http2traceGot100Continue(cs.trace);
                if (cs.on100 != null)
                {
                    cs.on100(); // forces any write delay timer to fire
                }
                cs.pastHeaders = false; // do it all again
                return (null, null);
            }
            var header = make(Header);
            Response res = ref new Response(Proto:"HTTP/2.0",ProtoMajor:2,Header:header,StatusCode:statusCode,Status:status+" "+StatusText(statusCode),);
            foreach (var (_, hf) in f.RegularFields())
            {
                var key = CanonicalHeaderKey(hf.Name);
                if (key == "Trailer")
                {
                    var t = res.Trailer;
                    if (t == null)
                    {
                        t = make(Header);
                        res.Trailer = t;
                    }
                    http2foreachHeaderElement(hf.Value, v =>
                    {
                        t[CanonicalHeaderKey(v)] = null;
                    }
                else
);
                }                {
                    header[key] = append(header[key], hf.Value);
                }
            }
            var streamEnded = f.StreamEnded();
            var isHead = cs.req.Method == "HEAD";
            if (!streamEnded || isHead)
            {
                res.ContentLength = -1L;
                {
                    var clens = res.Header["Content-Length"];

                    if (len(clens) == 1L)
                    {
                        {
                            var (clen64, err) = strconv.ParseInt(clens[0L], 10L, 64L);

                            if (err == null)
                            {
                                res.ContentLength = clen64;
                            }
                            else
                            { 
                                // TODO: care? unlike http/1, it won't mess up our framing, so it's
                                // more safe smuggling-wise to ignore.
                            }

                        }
                    }
                    else if (len(clens) > 1L)
                    { 
                        // TODO: care? unlike http/1, it won't mess up our framing, so it's
                        // more safe smuggling-wise to ignore.
                    }

                }
            }
            if (streamEnded || isHead)
            {
                res.Body = http2noBody;
                return (res, null);
            }
            cs.bufPipe = new http2pipe(b:&http2dataBuffer{expected:res.ContentLength});
            cs.bytesRemain = res.ContentLength;
            res.Body = new http2transportResponseBody(cs);
            go_(() => cs.awaitRequestCancel(cs.req));

            if (cs.requestedGzip && res.Header.Get("Content-Encoding") == "gzip")
            {
                res.Header.Del("Content-Encoding");
                res.Header.Del("Content-Length");
                res.ContentLength = -1L;
                res.Body = ref new http2gzipReader(body:res.Body);
                http2setResponseUncompressed(res);
            }
            return (res, null);
        }

        private static error processTrailers(this ref http2clientConnReadLoop rl, ref http2clientStream cs, ref http2MetaHeadersFrame f)
        {
            if (cs.pastTrailers)
            { 
                // Too many HEADERS frames for this stream.
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            cs.pastTrailers = true;
            if (!f.StreamEnded())
            { 
                // We expect that any headers for trailers also
                // has END_STREAM.
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            if (len(f.PseudoFields()) > 0L)
            { 
                // No pseudo header fields are defined for trailers.
                // TODO: ConnectionError might be overly harsh? Check.
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            var trailer = make(Header);
            foreach (var (_, hf) in f.RegularFields())
            {
                var key = CanonicalHeaderKey(hf.Name);
                trailer[key] = append(trailer[key], hf.Value);
            }
            cs.trailer = trailer;

            rl.endStream(cs);
            return error.As(null);
        }

        // transportResponseBody is the concrete type of Transport.RoundTrip's
        // Response.Body. It is an io.ReadCloser. On Read, it reads from cs.body.
        // On Close it sends RST_STREAM if EOF wasn't already seen.
        private partial struct http2transportResponseBody
        {
            public ptr<http2clientStream> cs;
        }

        private static (long, error) Read(this http2transportResponseBody b, slice<byte> p) => func((defer, _, __) =>
        {
            var cs = b.cs;
            var cc = cs.cc;

            if (cs.readErr != null)
            {
                return (0L, cs.readErr);
            }
            n, err = b.cs.bufPipe.Read(p);
            if (cs.bytesRemain != -1L)
            {
                if (int64(n) > cs.bytesRemain)
                {
                    n = int(cs.bytesRemain);
                    if (err == null)
                    {
                        err = errors.New("net/http: server replied with more than declared Content-Length; truncated");
                        cc.writeStreamReset(cs.ID, http2ErrCodeProtocol, err);
                    }
                    cs.readErr = err;
                    return (int(cs.bytesRemain), err);
                }
                cs.bytesRemain -= int64(n);
                if (err == io.EOF && cs.bytesRemain > 0L)
                {
                    err = io.ErrUnexpectedEOF;
                    cs.readErr = err;
                    return (n, err);
                }
            }
            if (n == 0L)
            { 
                // No flow control tokens to send back.
                return;
            }
            cc.mu.Lock();
            defer(cc.mu.Unlock());

            int connAdd = default;            int streamAdd = default; 
            // Check the conn-level first, before the stream-level.
 
            // Check the conn-level first, before the stream-level.
            {
                var v__prev1 = v;

                var v = cc.inflow.available();

                if (v < http2transportDefaultConnFlow / 2L)
                {
                    connAdd = http2transportDefaultConnFlow - v;
                    cc.inflow.add(connAdd);
                }

                v = v__prev1;

            }
            if (err == null)
            { // No need to refresh if the stream is over or failed.
                // Consider any buffered body data (read from the conn but not
                // consumed by the client) when computing flow control for this
                // stream.
                v = int(cs.inflow.available()) + cs.bufPipe.Len();
                if (v < http2transportDefaultStreamFlow - http2transportDefaultStreamMinRefresh)
                {
                    streamAdd = int32(http2transportDefaultStreamFlow - v);
                    cs.inflow.add(streamAdd);
                }
            }
            if (connAdd != 0L || streamAdd != 0L)
            {
                cc.wmu.Lock();
                defer(cc.wmu.Unlock());
                if (connAdd != 0L)
                {
                    cc.fr.WriteWindowUpdate(0L, http2mustUint31(connAdd));
                }
                if (streamAdd != 0L)
                {
                    cc.fr.WriteWindowUpdate(cs.ID, http2mustUint31(streamAdd));
                }
                cc.bw.Flush();
            }
            return;
        });

        private static var http2errClosedResponseBody = errors.New("http2: response body closed");

        private static error Close(this http2transportResponseBody b)
        {
            var cs = b.cs;
            var cc = cs.cc;

            var serverSentStreamEnd = cs.bufPipe.Err() == io.EOF;
            var unread = cs.bufPipe.Len();

            if (unread > 0L || !serverSentStreamEnd)
            {
                cc.mu.Lock();
                cc.wmu.Lock();
                if (!serverSentStreamEnd)
                {
                    cc.fr.WriteRSTStream(cs.ID, http2ErrCodeCancel);
                    cs.didReset = true;
                } 
                // Return connection-level flow control.
                if (unread > 0L)
                {
                    cc.inflow.add(int32(unread));
                    cc.fr.WriteWindowUpdate(0L, uint32(unread));
                }
                cc.bw.Flush();
                cc.wmu.Unlock();
                cc.mu.Unlock();
            }
            cs.bufPipe.BreakWithError(http2errClosedResponseBody);
            cc.forgetStreamID(cs.ID);
            return error.As(null);
        }

        private static error processData(this ref http2clientConnReadLoop rl, ref http2DataFrame f)
        {
            var cc = rl.cc;
            var cs = cc.streamByID(f.StreamID, f.StreamEnded());
            var data = f.Data();
            if (cs == null)
            {
                cc.mu.Lock();
                var neverSent = cc.nextStreamID;
                cc.mu.Unlock();
                if (f.StreamID >= neverSent)
                { 
                    // We never asked for this.
                    cc.logf("http2: Transport received unsolicited DATA frame; closing connection");
                    return error.As(http2ConnectionError(http2ErrCodeProtocol));
                } 
                // We probably did ask for this, but canceled. Just ignore it.
                // TODO: be stricter here? only silently ignore things which
                // we canceled, but not things which were closed normally
                // by the peer? Tough without accumulating too much state.

                // But at least return their flow control:
                if (f.Length > 0L)
                {
                    cc.mu.Lock();
                    cc.inflow.add(int32(f.Length));
                    cc.mu.Unlock();

                    cc.wmu.Lock();
                    cc.fr.WriteWindowUpdate(0L, uint32(f.Length));
                    cc.bw.Flush();
                    cc.wmu.Unlock();
                }
                return error.As(null);
            }
            if (!cs.firstByte)
            {
                cc.logf("protocol error: received DATA before a HEADERS frame");
                rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,));
                return error.As(null);
            }
            if (f.Length > 0L)
            {
                if (cs.req.Method == "HEAD" && len(data) > 0L)
                {
                    cc.logf("protocol error: received DATA on a HEAD request");
                    rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,));
                    return error.As(null);
                } 
                // Check connection-level flow control.
                cc.mu.Lock();
                if (cs.inflow.available() >= int32(f.Length))
                {
                    cs.inflow.take(int32(f.Length));
                }
                else
                {
                    cc.mu.Unlock();
                    return error.As(http2ConnectionError(http2ErrCodeFlowControl));
                } 
                // Return any padded flow control now, since we won't
                // refund it later on body reads.
                long refund = default;
                {
                    var pad = int(f.Length) - len(data);

                    if (pad > 0L)
                    {
                        refund += pad;
                    } 
                    // Return len(data) now if the stream is already closed,
                    // since data will never be read.

                } 
                // Return len(data) now if the stream is already closed,
                // since data will never be read.
                var didReset = cs.didReset;
                if (didReset)
                {
                    refund += len(data);
                }
                if (refund > 0L)
                {
                    cc.inflow.add(int32(refund));
                    cc.wmu.Lock();
                    cc.fr.WriteWindowUpdate(0L, uint32(refund));
                    if (!didReset)
                    {
                        cs.inflow.add(int32(refund));
                        cc.fr.WriteWindowUpdate(cs.ID, uint32(refund));
                    }
                    cc.bw.Flush();
                    cc.wmu.Unlock();
                }
                cc.mu.Unlock();

                if (len(data) > 0L && !didReset)
                {
                    {
                        var (_, err) = cs.bufPipe.Write(data);

                        if (err != null)
                        {
                            rl.endStreamError(cs, err);
                            return error.As(err);
                        }

                    }
                }
            }
            if (f.StreamEnded())
            {
                rl.endStream(cs);
            }
            return error.As(null);
        }

        private static var http2errInvalidTrailers = errors.New("http2: invalid trailers");

        private static void endStream(this ref http2clientConnReadLoop rl, ref http2clientStream cs)
        { 
            // TODO: check that any declared content-length matches, like
            // server.go's (*stream).endStream method.
            rl.endStreamError(cs, null);
        }

        private static void endStreamError(this ref http2clientConnReadLoop rl, ref http2clientStream cs, error err)
        {
            Action code = default;
            if (err == null)
            {
                err = io.EOF;
                code = cs.copyTrailers;
            }
            if (http2isConnectionCloseRequest(cs.req))
            {
                rl.closeWhenIdle = true;
            }
            cs.bufPipe.closeWithErrorAndCode(err, code);

        }

        private static void copyTrailers(this ref http2clientStream cs)
        {
            foreach (var (k, vv) in cs.trailer)
            {
                var t = cs.resTrailer;
                if (t == null.Value)
                {
                    t.Value = make(Header);
                }
                (t.Value)[k] = vv;
            }
        }

        private static error processGoAway(this ref http2clientConnReadLoop rl, ref http2GoAwayFrame f)
        {
            var cc = rl.cc;
            cc.t.connPool().MarkDead(cc);
            if (f.ErrCode != 0L)
            { 
                // TODO: deal with GOAWAY more. particularly the error code
                cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode);
            }
            cc.setGoAway(f);
            return error.As(null);
        }

        private static error processSettings(this ref http2clientConnReadLoop _rl, ref http2SettingsFrame _f) => func(_rl, _f, (ref http2clientConnReadLoop rl, ref http2SettingsFrame f, Defer defer, Panic _, Recover __) =>
        {
            var cc = rl.cc;
            cc.mu.Lock();
            defer(cc.mu.Unlock());

            if (f.IsAck())
            {
                if (cc.wantSettingsAck)
                {
                    cc.wantSettingsAck = false;
                    return error.As(null);
                }
                return error.As(http2ConnectionError(http2ErrCodeProtocol));
            }
            var err = f.ForeachSetting(s =>
            {

                if (s.ID == http2SettingMaxFrameSize) 
                    cc.maxFrameSize = s.Val;
                else if (s.ID == http2SettingMaxConcurrentStreams) 
                    cc.maxConcurrentStreams = s.Val;
                else if (s.ID == http2SettingMaxHeaderListSize) 
                    cc.peerMaxHeaderListSize = uint64(s.Val);
                else if (s.ID == http2SettingInitialWindowSize) 
                    // Values above the maximum flow-control
                    // window size of 2^31-1 MUST be treated as a
                    // connection error (Section 5.4.1) of type
                    // FLOW_CONTROL_ERROR.
                    if (s.Val > math.MaxInt32)
                    {
                        return error.As(http2ConnectionError(http2ErrCodeFlowControl));
                    } 

                    // Adjust flow control of currently-open
                    // frames by the difference of the old initial
                    // window size and this one.
                    var delta = int32(s.Val) - int32(cc.initialWindowSize);
                    foreach (var (_, cs) in cc.streams)
                    {
                        cs.flow.add(delta);
                    }
                    cc.cond.Broadcast();

                    cc.initialWindowSize = s.Val;
                else 
                    // TODO(bradfitz): handle more settings? SETTINGS_HEADER_TABLE_SIZE probably.
                    cc.vlogf("Unhandled Setting: %v", s);
                                return error.As(null);
            });
            if (err != null)
            {
                return error.As(err);
            }
            cc.wmu.Lock();
            defer(cc.wmu.Unlock());

            cc.fr.WriteSettingsAck();
            cc.bw.Flush();
            return error.As(cc.werr);
        });

        private static error processWindowUpdate(this ref http2clientConnReadLoop _rl, ref http2WindowUpdateFrame _f) => func(_rl, _f, (ref http2clientConnReadLoop rl, ref http2WindowUpdateFrame f, Defer defer, Panic _, Recover __) =>
        {
            var cc = rl.cc;
            var cs = cc.streamByID(f.StreamID, false);
            if (f.StreamID != 0L && cs == null)
            {
                return error.As(null);
            }
            cc.mu.Lock();
            defer(cc.mu.Unlock());

            var fl = ref cc.flow;
            if (cs != null)
            {
                fl = ref cs.flow;
            }
            if (!fl.add(int32(f.Increment)))
            {
                return error.As(http2ConnectionError(http2ErrCodeFlowControl));
            }
            cc.cond.Broadcast();
            return error.As(null);
        });

        private static error processResetStream(this ref http2clientConnReadLoop rl, ref http2RSTStreamFrame f)
        {
            var cs = rl.cc.streamByID(f.StreamID, true);
            if (cs == null)
            { 
                // TODO: return error if server tries to RST_STEAM an idle stream
                return error.As(null);
            }
            var err = http2streamError(cs.ID, f.ErrCode);
            cs.resetErr = err;
            close(cs.peerReset);
            cs.bufPipe.CloseWithError(err);
            cs.cc.cond.Broadcast(); // wake up checkResetOrDone via clientStream.awaitFlowControl
            return error.As(null);
        }

        // Ping sends a PING frame to the server and waits for the ack.
        // Public implementation is in go17.go and not_go17.go
        private static error ping(this ref http2ClientConn cc, http2contextContext ctx)
        {
            var c = make_channel<object>(); 
            // Generate a random payload
            array<byte> p = new array<byte>(8L);
            while (true)
            {
                {
                    var err__prev1 = err;

                    var (_, err) = rand.Read(p[..]);

                    if (err != null)
                    {
                        return error.As(err);
                    }

                    err = err__prev1;

                }
                cc.mu.Lock(); 
                // check for dup before insert
                {
                    var (_, found) = cc.pings[p];

                    if (!found)
                    {
                        cc.pings[p] = c;
                        cc.mu.Unlock();
                        break;
                    }

                }
                cc.mu.Unlock();
            }

            cc.wmu.Lock();
            {
                var err__prev1 = err;

                var err = cc.fr.WritePing(false, p);

                if (err != null)
                {
                    cc.wmu.Unlock();
                    return error.As(err);
                }

                err = err__prev1;

            }
            {
                var err__prev1 = err;

                err = cc.bw.Flush();

                if (err != null)
                {
                    cc.wmu.Unlock();
                    return error.As(err);
                }

                err = err__prev1;

            }
            cc.wmu.Unlock();
            return error.As(null);
            return error.As(ctx.Err());
            return error.As(cc.readerErr);
        }

        private static error processPing(this ref http2clientConnReadLoop _rl, ref http2PingFrame _f) => func(_rl, _f, (ref http2clientConnReadLoop rl, ref http2PingFrame f, Defer defer, Panic _, Recover __) =>
        {
            if (f.IsAck())
            {
                var cc = rl.cc;
                cc.mu.Lock();
                defer(cc.mu.Unlock()); 
                // If ack, notify listener if any
                {
                    var (c, ok) = cc.pings[f.Data];

                    if (ok)
                    {
                        close(c);
                        delete(cc.pings, f.Data);
                    }

                }
                return error.As(null);
            }
            cc = rl.cc;
            cc.wmu.Lock();
            defer(cc.wmu.Unlock());
            {
                var err = cc.fr.WritePing(true, f.Data);

                if (err != null)
                {
                    return error.As(err);
                }

            }
            return error.As(cc.bw.Flush());
        });

        private static error processPushPromise(this ref http2clientConnReadLoop rl, ref http2PushPromiseFrame f)
        { 
            // We told the peer we don't want them.
            // Spec says:
            // "PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH
            // setting of the peer endpoint is set to 0. An endpoint that
            // has set this setting and has received acknowledgement MUST
            // treat the receipt of a PUSH_PROMISE frame as a connection
            // error (Section 5.4.1) of type PROTOCOL_ERROR."
            return error.As(http2ConnectionError(http2ErrCodeProtocol));
        }

        private static void writeStreamReset(this ref http2ClientConn cc, uint streamID, http2ErrCode code, error err)
        { 
            // TODO: map err to more interesting error codes, once the
            // HTTP community comes up with some. But currently for
            // RST_STREAM there's no equivalent to GOAWAY frame's debug
            // data, and the error codes are all pretty vague ("cancel").
            cc.wmu.Lock();
            cc.fr.WriteRSTStream(streamID, code);
            cc.bw.Flush();
            cc.wmu.Unlock();
        }

        private static var http2errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit");        private static var http2errRequestHeaderListSize = errors.New("http2: request header list larger than peer's advertised limit");        private static var http2errPseudoTrailers = errors.New("http2: invalid pseudo header in trailers");

        private static void logf(this ref http2ClientConn cc, @string format, params object[] args)
        {
            cc.t.logf(format, args);
        }

        private static void vlogf(this ref http2ClientConn cc, @string format, params object[] args)
        {
            cc.t.vlogf(format, args);
        }

        private static void vlogf(this ref http2Transport t, @string format, params object[] args)
        {
            if (http2VerboseLogs)
            {
                t.logf(format, args);
            }
        }

        private static void logf(this ref http2Transport t, @string format, params object[] args)
        {
            log.Printf(format, args);
        }

        private static io.ReadCloser http2noBody = ioutil.NopCloser(bytes.NewReader(null));

        private static bool http2strSliceContains(slice<@string> ss, @string s)
        {
            foreach (var (_, v) in ss)
            {
                if (v == s)
                {
                    return true;
                }
            }
            return false;
        }

        private partial struct http2erringRoundTripper
        {
            public error err;
        }

        private static (ref Response, error) RoundTrip(this http2erringRoundTripper rt, ref Request _p0)
        {
            return (null, rt.err);
        }

        // gzipReader wraps a response body so it can lazily
        // call gzip.NewReader on the first call to Read
        private partial struct http2gzipReader
        {
            public io.ReadCloser body; // underlying Response.Body
            public ptr<gzip.Reader> zr; // lazily-initialized gzip reader
            public error zerr; // sticky error
        }

        private static (long, error) Read(this ref http2gzipReader gz, slice<byte> p)
        {
            if (gz.zerr != null)
            {
                return (0L, gz.zerr);
            }
            if (gz.zr == null)
            {
                gz.zr, err = gzip.NewReader(gz.body);
                if (err != null)
                {
                    gz.zerr = err;
                    return (0L, err);
                }
            }
            return gz.zr.Read(p);
        }

        private static error Close(this ref http2gzipReader gz)
        {
            return error.As(gz.body.Close());
        }

        private partial struct http2errorReader
        {
            public error err;
        }

        private static (long, error) Read(this http2errorReader r, slice<byte> p)
        {
            return (0L, r.err);
        }

        // bodyWriterState encapsulates various state around the Transport's writing
        // of the request body, particularly regarding doing delayed writes of the body
        // when the request contains "Expect: 100-continue".
        private partial struct http2bodyWriterState
        {
            public ptr<http2clientStream> cs;
            public ptr<time.Timer> timer; // if non-nil, we're doing a delayed write
            public ptr<sync.Once> fnonce; // to call fn with
            public Action fn; // the code to run in the goroutine, writing the body
            public channel<error> resc; // result of fn's execution
            public time.Duration delay; // how long we should delay a delayed write for
        }

        private static http2bodyWriterState getBodyWriterState(this ref http2Transport t, ref http2clientStream cs, io.Reader body)
        {
            s.cs = cs;
            if (body == null)
            {
                return;
            }
            var resc = make_channel<error>(1L);
            s.resc = resc;
            s.fn = () =>
            {
                cs.cc.mu.Lock();
                cs.startedWrite = true;
                cs.cc.mu.Unlock();
                resc.Send(cs.writeRequestBody(body, cs.req.Body));
            }
;
            s.delay = t.expectContinueTimeout();
            if (s.delay == 0L || !httplex.HeaderValuesContainsToken(cs.req.Header["Expect"], "100-continue"))
            {
                return;
            }
            s.fnonce = @new<sync.Once>(); 

            // Arm the timer with a very large duration, which we'll
            // intentionally lower later. It has to be large now because
            // we need a handle to it before writing the headers, but the
            // s.delay value is defined to not start until after the
            // request headers were written.
            const long hugeDuration = 365L * 24L * time.Hour;

            s.timer = time.AfterFunc(hugeDuration, () =>
            {
                s.fnonce.Do(s.fn);
            });
            return;
        }

        private static void cancel(this http2bodyWriterState s)
        {
            if (s.timer != null)
            {
                s.timer.Stop();
            }
        }

        private static void on100(this http2bodyWriterState s)
        {
            if (s.timer == null)
            { 
                // If we didn't do a delayed write, ignore the server's
                // bogus 100 continue response.
                return;
            }
            s.timer.Stop();
            go_(() => () =>
            {
                s.fnonce.Do(s.fn);

            }());
        }

        // scheduleBodyWrite starts writing the body, either immediately (in
        // the common case) or after the delay timeout. It should not be
        // called until after the headers have been written.
        private static void scheduleBodyWrite(this http2bodyWriterState s)
        {
            if (s.timer == null)
            { 
                // We're not doing a delayed write (see
                // getBodyWriterState), so just start the writing
                // goroutine immediately.
                go_(() => s.fn());
                return;
            }
            http2traceWait100Continue(s.cs.trace);
            if (s.timer.Stop())
            {
                s.timer.Reset(s.delay);
            }
        }

        // isConnectionCloseRequest reports whether req should use its own
        // connection for a single request and then close the connection.
        private static bool http2isConnectionCloseRequest(ref Request req)
        {
            return req.Close || httplex.HeaderValuesContainsToken(req.Header["Connection"], "close");
        }

        // writeFramer is implemented by any type that is used to write frames.
        private partial interface http2writeFramer
        {
            bool writeFrame(http2writeContext _p0); // staysWithinBuffer reports whether this writer promises that
// it will only write less than or equal to size bytes, and it
// won't Flush the write context.
            bool staysWithinBuffer(long size);
        }

        // writeContext is the interface needed by the various frame writer
        // types below. All the writeFrame methods below are scheduled via the
        // frame writing scheduler (see writeScheduler in writesched.go).
        //
        // This interface is implemented by *serverConn.
        //
        // TODO: decide whether to a) use this in the client code (which didn't
        // end up using this yet, because it has a simpler design, not
        // currently implementing priorities), or b) delete this and
        // make the server code a bit more concrete.
        private partial interface http2writeContext
        {
            (ref hpack.Encoder, ref bytes.Buffer) Framer();
            (ref hpack.Encoder, ref bytes.Buffer) Flush();
            (ref hpack.Encoder, ref bytes.Buffer) CloseConn(); // HeaderEncoder returns an HPACK encoder that writes to the
// returned buffer.
            (ref hpack.Encoder, ref bytes.Buffer) HeaderEncoder();
        }

        // writeEndsStream reports whether w writes a frame that will transition
        // the stream to a half-closed local state. This returns false for RST_STREAM,
        // which closes the entire stream (not just the local half).
        private static bool http2writeEndsStream(http2writeFramer w) => func((_, panic, __) =>
        {
            switch (w.type())
            {
                case ref http2writeData v:
                    return v.endStream;
                    break;
                case ref http2writeResHeaders v:
                    return v.endStream;
                    break;
                case 
                    panic("writeEndsStream called on nil writeFramer");
                    break;
            }
            return false;
        });

        private partial struct http2flushFrameWriter
        {
        }

        private static error writeFrame(this http2flushFrameWriter _p0, http2writeContext ctx)
        {
            return error.As(ctx.Flush());
        }

        private static bool staysWithinBuffer(this http2flushFrameWriter _p0, long max)
        {
            return false;
        }

        private partial struct http2writeSettings // : slice<http2Setting>
        {
        }

        private static bool staysWithinBuffer(this http2writeSettings s, long max)
        {
            const long settingSize = 6L; // uint16 + uint32
 // uint16 + uint32
            return http2frameHeaderLen + settingSize * len(s) <= max;

        }

        private static error writeFrame(this http2writeSettings s, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteSettings((slice<http2Setting>)s));
        }

        private partial struct http2writeGoAway
        {
            public uint maxStreamID;
            public http2ErrCode code;
        }

        private static error writeFrame(this ref http2writeGoAway p, http2writeContext ctx)
        {
            var err = ctx.Framer().WriteGoAway(p.maxStreamID, p.code, null);
            ctx.Flush(); // ignore error: we're hanging up on them anyway
            return error.As(err);
        }

        private static bool staysWithinBuffer(this ref http2writeGoAway _p0, long max)
        {
            return false;
        } // flushes

        private partial struct http2writeData
        {
            public uint streamID;
            public slice<byte> p;
            public bool endStream;
        }

        private static @string String(this ref http2writeData w)
        {
            return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream);
        }

        private static error writeFrame(this ref http2writeData w, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteData(w.streamID, w.endStream, w.p));
        }

        private static bool staysWithinBuffer(this ref http2writeData w, long max)
        {
            return http2frameHeaderLen + len(w.p) <= max;
        }

        // handlerPanicRST is the message sent from handler goroutines when
        // the handler panics.
        private partial struct http2handlerPanicRST
        {
            public uint StreamID;
        }

        private static error writeFrame(this http2handlerPanicRST hp, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteRSTStream(hp.StreamID, http2ErrCodeInternal));
        }

        private static bool staysWithinBuffer(this http2handlerPanicRST hp, long max)
        {
            return http2frameHeaderLen + 4L <= max;
        }

        private static error writeFrame(this http2StreamError se, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteRSTStream(se.StreamID, se.Code));
        }

        private static bool staysWithinBuffer(this http2StreamError se, long max)
        {
            return http2frameHeaderLen + 4L <= max;
        }

        private partial struct http2writePingAck
        {
            public ptr<http2PingFrame> pf;
        }

        private static error writeFrame(this http2writePingAck w, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WritePing(true, w.pf.Data));
        }

        private static bool staysWithinBuffer(this http2writePingAck w, long max)
        {
            return http2frameHeaderLen + len(w.pf.Data) <= max;
        }

        private partial struct http2writeSettingsAck
        {
        }

        private static error writeFrame(this http2writeSettingsAck _p0, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteSettingsAck());
        }

        private static bool staysWithinBuffer(this http2writeSettingsAck _p0, long max)
        {
            return http2frameHeaderLen <= max;
        }

        // splitHeaderBlock splits headerBlock into fragments so that each fragment fits
        // in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true
        // for the first/last fragment, respectively.
        private static error http2splitHeaderBlock(http2writeContext ctx, slice<byte> headerBlock, Func<http2writeContext, slice<byte>, bool, bool, error> fn)
        { 
            // For now we're lazy and just pick the minimum MAX_FRAME_SIZE
            // that all peers must support (16KB). Later we could care
            // more and send larger frames if the peer advertised it, but
            // there's little point. Most headers are small anyway (so we
            // generally won't have CONTINUATION frames), and extra frames
            // only waste 9 bytes anyway.
            const long maxFrameSize = 16384L;



            var first = true;
            while (len(headerBlock) > 0L)
            {
                var frag = headerBlock;
                if (len(frag) > maxFrameSize)
                {
                    frag = frag[..maxFrameSize];
                }
                headerBlock = headerBlock[len(frag)..];
                {
                    var err = fn(ctx, frag, first, len(headerBlock) == 0L);

                    if (err != null)
                    {
                        return error.As(err);
                    }

                }
                first = false;
            }

            return error.As(null);
        }

        // writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
        // for HTTP response headers or trailers from a server handler.
        private partial struct http2writeResHeaders
        {
            public uint streamID;
            public long httpResCode; // 0 means no ":status" line
            public Header h; // may be nil
            public slice<@string> trailers; // if non-nil, which keys of h to write. nil means all.
            public bool endStream;
            public @string date;
            public @string contentType;
            public @string contentLength;
        }

        private static void http2encKV(ref hpack.Encoder enc, @string k, @string v)
        {
            if (http2VerboseLogs)
            {
                log.Printf("http2: server encoding header %q = %q", k, v);
            }
            enc.WriteField(new hpack.HeaderField(Name:k,Value:v));
        }

        private static bool staysWithinBuffer(this ref http2writeResHeaders w, long max)
        { 
            // TODO: this is a common one. It'd be nice to return true
            // here and get into the fast path if we could be clever and
            // calculate the size fast enough, or at least a conservative
            // uppper bound that usually fires. (Maybe if w.h and
            // w.trailers are nil, so we don't need to enumerate it.)
            // Otherwise I'm afraid that just calculating the length to
            // answer this question would be slower than the ~2µs benefit.
            return false;
        }

        private static error writeFrame(this ref http2writeResHeaders _w, http2writeContext ctx) => func(_w, (ref http2writeResHeaders w, Defer _, Panic panic, Recover __) =>
        {
            var (enc, buf) = ctx.HeaderEncoder();
            buf.Reset();

            if (w.httpResCode != 0L)
            {
                http2encKV(enc, ":status", http2httpCodeString(w.httpResCode));
            }
            http2encodeHeaders(enc, w.h, w.trailers);

            if (w.contentType != "")
            {
                http2encKV(enc, "content-type", w.contentType);
            }
            if (w.contentLength != "")
            {
                http2encKV(enc, "content-length", w.contentLength);
            }
            if (w.date != "")
            {
                http2encKV(enc, "date", w.date);
            }
            var headerBlock = buf.Bytes();
            if (len(headerBlock) == 0L && w.trailers == null)
            {
                panic("unexpected empty hpack");
            }
            return error.As(http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock));
        });

        private static error writeHeaderBlock(this ref http2writeResHeaders w, http2writeContext ctx, slice<byte> frag, bool firstFrag, bool lastFrag)
        {
            if (firstFrag)
            {
                return error.As(ctx.Framer().WriteHeaders(new http2HeadersFrameParam(StreamID:w.streamID,BlockFragment:frag,EndStream:w.endStream,EndHeaders:lastFrag,)));
            }
            else
            {
                return error.As(ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag));
            }
        }

        // writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.
        private partial struct http2writePushPromise
        {
            public uint streamID; // pusher stream
            public @string method; // for :method
            public ptr<url.URL> url; // for :scheme, :authority, :path
            public Header h; // Creates an ID for a pushed stream. This runs on serveG just before
// the frame is written. The returned ID is copied to promisedID.
            public Func<(uint, error)> allocatePromisedID;
            public uint promisedID;
        }

        private static bool staysWithinBuffer(this ref http2writePushPromise w, long max)
        { 
            // TODO: see writeResHeaders.staysWithinBuffer
            return false;
        }

        private static error writeFrame(this ref http2writePushPromise _w, http2writeContext ctx) => func(_w, (ref http2writePushPromise w, Defer _, Panic panic, Recover __) =>
        {
            var (enc, buf) = ctx.HeaderEncoder();
            buf.Reset();

            http2encKV(enc, ":method", w.method);
            http2encKV(enc, ":scheme", w.url.Scheme);
            http2encKV(enc, ":authority", w.url.Host);
            http2encKV(enc, ":path", w.url.RequestURI());
            http2encodeHeaders(enc, w.h, null);

            var headerBlock = buf.Bytes();
            if (len(headerBlock) == 0L)
            {
                panic("unexpected empty hpack");
            }
            return error.As(http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock));
        });

        private static error writeHeaderBlock(this ref http2writePushPromise w, http2writeContext ctx, slice<byte> frag, bool firstFrag, bool lastFrag)
        {
            if (firstFrag)
            {
                return error.As(ctx.Framer().WritePushPromise(new http2PushPromiseParam(StreamID:w.streamID,PromiseID:w.promisedID,BlockFragment:frag,EndHeaders:lastFrag,)));
            }
            else
            {
                return error.As(ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag));
            }
        }

        private partial struct http2write100ContinueHeadersFrame
        {
            public uint streamID;
        }

        private static error writeFrame(this http2write100ContinueHeadersFrame w, http2writeContext ctx)
        {
            var (enc, buf) = ctx.HeaderEncoder();
            buf.Reset();
            http2encKV(enc, ":status", "100");
            return error.As(ctx.Framer().WriteHeaders(new http2HeadersFrameParam(StreamID:w.streamID,BlockFragment:buf.Bytes(),EndStream:false,EndHeaders:true,)));
        }

        private static bool staysWithinBuffer(this http2write100ContinueHeadersFrame w, long max)
        { 
            // Sloppy but conservative:
            return 9L + 2L * (len(":status") + len("100")) <= max;
        }

        private partial struct http2writeWindowUpdate
        {
            public uint streamID; // or 0 for conn-level
            public uint n;
        }

        private static bool staysWithinBuffer(this http2writeWindowUpdate wu, long max)
        {
            return http2frameHeaderLen + 4L <= max;
        }

        private static error writeFrame(this http2writeWindowUpdate wu, http2writeContext ctx)
        {
            return error.As(ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n));
        }

        // encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
        // is encoded only only if k is in keys.
        private static void http2encodeHeaders(ref hpack.Encoder _enc, Header h, slice<@string> keys) => func(_enc, (ref hpack.Encoder enc, Defer defer, Panic _, Recover __) =>
        {
            if (keys == null)
            {
                ref http2sorter sorter = http2sorterPool.Get()._<ref http2sorter>(); 
                // Using defer here, since the returned keys from the
                // sorter.Keys method is only valid until the sorter
                // is returned:
                defer(http2sorterPool.Put(sorter));
                keys = sorter.Keys(h);
            }
            foreach (var (_, k) in keys)
            {
                var vv = h[k];
                k = http2lowerHeader(k);
                if (!http2validWireHeaderFieldName(k))
                { 
                    // Skip it as backup paranoia. Per
                    // golang.org/issue/14048, these should
                    // already be rejected at a higher level.
                    continue;
                }
                var isTE = k == "transfer-encoding";
                foreach (var (_, v) in vv)
                {
                    if (!httplex.ValidHeaderFieldValue(v))
                    { 
                        // TODO: return an error? golang.org/issue/14048
                        // For now just omit it.
                        continue;
                    } 
                    // TODO: more of "8.1.2.2 Connection-Specific Header Fields"
                    if (isTE && v != "trailers")
                    {
                        continue;
                    }
                    http2encKV(enc, k, v);
                }
            }
        });

        // WriteScheduler is the interface implemented by HTTP/2 write schedulers.
        // Methods are never called concurrently.
        private partial interface http2WriteScheduler
        {
            (http2FrameWriteRequest, bool) OpenStream(uint streamID, http2OpenStreamOptions options); // CloseStream closes a stream in the write scheduler. Any frames queued on
// this stream should be discarded. It is illegal to call this on a stream
// that is not open -- the call may panic.
            (http2FrameWriteRequest, bool) CloseStream(uint streamID); // AdjustStream adjusts the priority of the given stream. This may be called
// on a stream that has not yet been opened or has been closed. Note that
// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:
// https://tools.ietf.org/html/rfc7540#section-5.1
            (http2FrameWriteRequest, bool) AdjustStream(uint streamID, http2PriorityParam priority); // Push queues a frame in the scheduler. In most cases, this will not be
// called with wr.StreamID()!=0 unless that stream is currently open. The one
// exception is RST_STREAM frames, which may be sent on idle or closed streams.
            (http2FrameWriteRequest, bool) Push(http2FrameWriteRequest wr); // Pop dequeues the next frame to write. Returns false if no frames can
// be written. Frames with a given wr.StreamID() are Pop'd in the same
// order they are Push'd.
            (http2FrameWriteRequest, bool) Pop();
        }

        // OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
        private partial struct http2OpenStreamOptions
        {
            public uint PusherID;
        }

        // FrameWriteRequest is a request to write a frame.
        private partial struct http2FrameWriteRequest
        {
            public http2writeFramer write; // stream is the stream on which this frame will be written.
// nil for non-stream frames like PING and SETTINGS.
            public ptr<http2stream> stream; // done, if non-nil, must be a buffered channel with space for
// 1 message and is sent the return value from write (or an
// earlier error) when the frame has been written.
            public channel<error> done;
        }

        // StreamID returns the id of the stream this frame will be written to.
        // 0 is used for non-stream frames such as PING and SETTINGS.
        private static uint StreamID(this http2FrameWriteRequest wr)
        {
            if (wr.stream == null)
            {
                {
                    http2StreamError (se, ok) = wr.write._<http2StreamError>();

                    if (ok)
                    { 
                        // (*serverConn).resetStream doesn't set
                        // stream because it doesn't necessarily have
                        // one. So special case this type of write
                        // message.
                        return se.StreamID;
                    }

                }
                return 0L;
            }
            return wr.stream.id;
        }

        // DataSize returns the number of flow control bytes that must be consumed
        // to write this entire frame. This is 0 for non-DATA frames.
        private static long DataSize(this http2FrameWriteRequest wr)
        {
            {
                ref http2writeData (wd, ok) = wr.write._<ref http2writeData>();

                if (ok)
                {
                    return len(wd.p);
                }

            }
            return 0L;
        }

        // Consume consumes min(n, available) bytes from this frame, where available
        // is the number of flow control bytes available on the stream. Consume returns
        // 0, 1, or 2 frames, where the integer return value gives the number of frames
        // returned.
        //
        // If flow control prevents consuming any bytes, this returns (_, _, 0). If
        // the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
        // returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and
        // 'rest' contains the remaining bytes. The consumed bytes are deducted from the
        // underlying stream's flow control budget.
        private static (http2FrameWriteRequest, http2FrameWriteRequest, long) Consume(this http2FrameWriteRequest wr, int n)
        {
            http2FrameWriteRequest empty = default; 

            // Non-DATA frames are always consumed whole.
            ref http2writeData (wd, ok) = wr.write._<ref http2writeData>();
            if (!ok || len(wd.p) == 0L)
            {
                return (wr, empty, 1L);
            } 

            // Might need to split after applying limits.
            var allowed = wr.stream.flow.available();
            if (n < allowed)
            {
                allowed = n;
            }
            if (wr.stream.sc.maxFrameSize < allowed)
            {
                allowed = wr.stream.sc.maxFrameSize;
            }
            if (allowed <= 0L)
            {
                return (empty, empty, 0L);
            }
            if (len(wd.p) > int(allowed))
            {
                wr.stream.flow.take(allowed);
                http2FrameWriteRequest consumed = new http2FrameWriteRequest(stream:wr.stream,write:&http2writeData{streamID:wd.streamID,p:wd.p[:allowed],endStream:false,},done:nil,);
                http2FrameWriteRequest rest = new http2FrameWriteRequest(stream:wr.stream,write:&http2writeData{streamID:wd.streamID,p:wd.p[allowed:],endStream:wd.endStream,},done:wr.done,);
                return (consumed, rest, 2L);
            } 

            // The frame is consumed whole.
            // NB: This cast cannot overflow because allowed is <= math.MaxInt32.
            wr.stream.flow.take(int32(len(wd.p)));
            return (wr, empty, 1L);
        }

        // String is for debugging only.
        private static @string String(this http2FrameWriteRequest wr)
        {
            @string des = default;
            {
                fmt.Stringer (s, ok) = wr.write._<fmt.Stringer>();

                if (ok)
                {
                    des = s.String();
                }
                else
                {
                    des = fmt.Sprintf("%T", wr.write);
                }

            }
            return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != null, des);
        }

        // replyToWriter sends err to wr.done and panics if the send must block
        // This does nothing if wr.done is nil.
        private static void replyToWriter(this ref http2FrameWriteRequest _wr, error err) => func(_wr, (ref http2FrameWriteRequest wr, Defer _, Panic panic, Recover __) =>
        {
            if (wr.done == null)
            {
                return;
            }
            panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write));
            wr.write = null; // prevent use (assume it's tainted after wr.done send)
        });

        // writeQueue is used by implementations of WriteScheduler.
        private partial struct http2writeQueue
        {
            public slice<http2FrameWriteRequest> s;
        }

        private static bool empty(this ref http2writeQueue q)
        {
            return len(q.s) == 0L;
        }

        private static void push(this ref http2writeQueue q, http2FrameWriteRequest wr)
        {
            q.s = append(q.s, wr);
        }

        private static http2FrameWriteRequest shift(this ref http2writeQueue _q) => func(_q, (ref http2writeQueue q, Defer _, Panic panic, Recover __) =>
        {
            if (len(q.s) == 0L)
            {
                panic("invalid use of queue");
            }
            var wr = q.s[0L]; 
            // TODO: less copy-happy queue.
            copy(q.s, q.s[1L..]);
            q.s[len(q.s) - 1L] = new http2FrameWriteRequest();
            q.s = q.s[..len(q.s) - 1L];
            return wr;
        });

        // consume consumes up to n bytes from q.s[0]. If the frame is
        // entirely consumed, it is removed from the queue. If the frame
        // is partially consumed, the frame is kept with the consumed
        // bytes removed. Returns true iff any bytes were consumed.
        private static (http2FrameWriteRequest, bool) consume(this ref http2writeQueue q, int n)
        {
            if (len(q.s) == 0L)
            {
                return (new http2FrameWriteRequest(), false);
            }
            var (consumed, rest, numresult) = q.s[0L].Consume(n);
            switch (numresult)
            {
                case 0L: 
                    return (new http2FrameWriteRequest(), false);
                    break;
                case 1L: 
                    q.shift();
                    break;
                case 2L: 
                    q.s[0L] = rest;
                    break;
            }
            return (consumed, true);
        }

        private partial struct http2writeQueuePool // : slice<ref http2writeQueue>
        {
        }

        // put inserts an unused writeQueue into the pool.

        // put inserts an unused writeQueue into the pool.
        private static void put(this ref http2writeQueuePool p, ref http2writeQueue q)
        {
            foreach (var (i) in q.s)
            {
                q.s[i] = new http2FrameWriteRequest();
            }
            q.s = q.s[..0L];
            p.Value = append(p.Value, q);
        }

        // get returns an empty writeQueue.
        private static ref http2writeQueue get(this ref http2writeQueuePool p)
        {
            var ln = len(p.Value);
            if (ln == 0L)
            {
                return @new<http2writeQueue>();
            }
            var x = ln - 1L;
            var q = (p.Value)[x];
            (p.Value)[x] = null;
            p.Value = (p.Value)[..x];
            return q;
        }

        // RFC 7540, Section 5.3.5: the default weight is 16.
        private static readonly long http2priorityDefaultWeight = 15L; // 16 = 15 + 1

        // PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
 // 16 = 15 + 1

        // PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
        private partial struct http2PriorityWriteSchedulerConfig
        {
            public long MaxClosedNodesInTree; // MaxIdleNodesInTree controls the maximum number of idle streams to
// retain in the priority tree. Setting this to zero saves a small amount
// of memory at the cost of performance.
//
// See RFC 7540, Section 5.3.4:
//   Similarly, streams that are in the "idle" state can be assigned
//   priority or become a parent of other streams. This allows for the
//   creation of a grouping node in the dependency tree, which enables
//   more flexible expressions of priority. Idle streams begin with a
//   default priority (Section 5.3.5).
            public long MaxIdleNodesInTree; // ThrottleOutOfOrderWrites enables write throttling to help ensure that
// data is delivered in priority order. This works around a race where
// stream B depends on stream A and both streams are about to call Write
// to queue DATA frames. If B wins the race, a naive scheduler would eagerly
// write as much data from B as possible, but this is suboptimal because A
// is a higher-priority stream. With throttling enabled, we write a small
// amount of data from B to minimize the amount of bandwidth that B can
// steal from A.
            public bool ThrottleOutOfOrderWrites;
        }

        // NewPriorityWriteScheduler constructs a WriteScheduler that schedules
        // frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.
        // If cfg is nil, default options are used.
        private static http2WriteScheduler http2NewPriorityWriteScheduler(ref http2PriorityWriteSchedulerConfig cfg)
        {
            if (cfg == null)
            { 
                // For justification of these defaults, see:
                // https://docs.google.com/document/d/1oLhNg1skaWD4_DtaoCxdSRN5erEXrH-KnLrMwEpOtFY
                cfg = ref new http2PriorityWriteSchedulerConfig(MaxClosedNodesInTree:10,MaxIdleNodesInTree:10,ThrottleOutOfOrderWrites:false,);
            }
            http2priorityWriteScheduler ws = ref new http2priorityWriteScheduler(nodes:make(map[uint32]*http2priorityNode),maxClosedNodesInTree:cfg.MaxClosedNodesInTree,maxIdleNodesInTree:cfg.MaxIdleNodesInTree,enableWriteThrottle:cfg.ThrottleOutOfOrderWrites,);
            ws.nodes[0L] = ref ws.root;
            if (cfg.ThrottleOutOfOrderWrites)
            {
                ws.writeThrottleLimit = 1024L;
            }
            else
            {
                ws.writeThrottleLimit = math.MaxInt32;
            }
            return ws;
        }

        private partial struct http2priorityNodeState // : long
        {
        }

        private static readonly http2priorityNodeState http2priorityNodeOpen = iota;
        private static readonly var http2priorityNodeClosed = 0;
        private static readonly var http2priorityNodeIdle = 1;

        // priorityNode is a node in an HTTP/2 priority tree.
        // Each node is associated with a single stream ID.
        // See RFC 7540, Section 5.3.
        private partial struct http2priorityNode
        {
            public http2writeQueue q; // queue of pending frames to write
            public uint id; // id of the stream, or 0 for the root of the tree
            public byte weight; // the actual weight is weight+1, so the value is in [1,256]
            public http2priorityNodeState state; // open | closed | idle
            public long bytes; // number of bytes written by this node, or 0 if closed
            public long subtreeBytes; // sum(node.bytes) of all nodes in this subtree

// These links form the priority tree.
            public ptr<http2priorityNode> parent;
            public ptr<http2priorityNode> kids; // start of the kids list
            public ptr<http2priorityNode> prev; // doubly-linked list of siblings
            public ptr<http2priorityNode> next; // doubly-linked list of siblings
        }

        private static void setParent(this ref http2priorityNode _n, ref http2priorityNode _parent) => func(_n, _parent, (ref http2priorityNode n, ref http2priorityNode parent, Defer _, Panic panic, Recover __) =>
        {
            if (n == parent)
            {
                panic("setParent to self");
            }
            if (n.parent == parent)
            {
                return;
            } 
            // Unlink from current parent.
            {
                var parent = n.parent;

                if (parent != null)
                {
                    if (n.prev == null)
                    {
                        parent.kids = n.next;
                    }
                    else
                    {
                        n.prev.next = n.next;
                    }
                    if (n.next != null)
                    {
                        n.next.prev = n.prev;
                    }
                } 
                // Link to new parent.
                // If parent=nil, remove n from the tree.
                // Always insert at the head of parent.kids (this is assumed by walkReadyInOrder).

            } 
            // Link to new parent.
            // If parent=nil, remove n from the tree.
            // Always insert at the head of parent.kids (this is assumed by walkReadyInOrder).
            n.parent = parent;
            if (parent == null)
            {
                n.next = null;
                n.prev = null;
            }
            else
            {
                n.next = parent.kids;
                n.prev = null;
                if (n.next != null)
                {
                    n.next.prev = n;
                }
                parent.kids = n;
            }
        });

        private static void addBytes(this ref http2priorityNode n, long b)
        {
            n.bytes += b;
            while (n != null)
            {
                n.subtreeBytes += b;
                n = n.parent;
            }

        }

        // walkReadyInOrder iterates over the tree in priority order, calling f for each node
        // with a non-empty write queue. When f returns true, this funcion returns true and the
        // walk halts. tmp is used as scratch space for sorting.
        //
        // f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true
        // if any ancestor p of n is still open (ignoring the root node).
        private static bool walkReadyInOrder(this ref http2priorityNode n, bool openParent, ref slice<ref http2priorityNode> tmp, Func<ref http2priorityNode, bool, bool> f)
        {
            if (!n.q.empty() && f(n, openParent))
            {
                return true;
            }
            if (n.kids == null)
            {
                return false;
            } 

            // Don't consider the root "open" when updating openParent since
            // we can't send data frames on the root stream (only control frames).
            if (n.id != 0L)
            {
                openParent = openParent || (n.state == http2priorityNodeOpen);
            } 

            // Common case: only one kid or all kids have the same weight.
            // Some clients don't use weights; other clients (like web browsers)
            // use mostly-linear priority trees.
            var w = n.kids.weight;
            var needSort = false;
            {
                var k__prev1 = k;

                var k = n.kids.next;

                while (k != null)
                {
                    if (k.weight != w)
                    {
                        needSort = true;
                        break;
                    k = k.next;
                    }
                }


                k = k__prev1;
            }
            if (!needSort)
            {
                {
                    var k__prev1 = k;

                    k = n.kids;

                    while (k != null)
                    {
                        if (k.walkReadyInOrder(openParent, tmp, f))
                        {
                            return true;
                        k = k.next;
                        }
                    }


                    k = k__prev1;
                }
                return false;
            } 

            // Uncommon case: sort the child nodes. We remove the kids from the parent,
            // then re-insert after sorting so we can reuse tmp for future sort calls.
            tmp.Value = (tmp.Value)[..0L];
            while (n.kids != null)
            {
                tmp.Value = append(tmp.Value, n.kids);
                n.kids.setParent(null);
            }

            sort.Sort(http2sortPriorityNodeSiblings(tmp.Value));
            for (var i = len(tmp.Value) - 1L; i >= 0L; i--)
            {
                (tmp.Value)[i].setParent(n); // setParent inserts at the head of n.kids
            }

            {
                var k__prev1 = k;

                k = n.kids;

                while (k != null)
                {
                    if (k.walkReadyInOrder(openParent, tmp, f))
                    {
                        return true;
                    k = k.next;
                    }
                }


                k = k__prev1;
            }
            return false;
        }

        private partial struct http2sortPriorityNodeSiblings // : slice<ref http2priorityNode>
        {
        }

        private static long Len(this http2sortPriorityNodeSiblings z)
        {
            return len(z);
        }

        private static void Swap(this http2sortPriorityNodeSiblings z, long i, long k)
        {
            z[i] = z[k];
            z[k] = z[i];

        }

        private static bool Less(this http2sortPriorityNodeSiblings z, long i, long k)
        { 
            // Prefer the subtree that has sent fewer bytes relative to its weight.
            // See sections 5.3.2 and 5.3.4.
            var wi = float64(z[i].weight + 1L);
            var bi = float64(z[i].subtreeBytes);
            var wk = float64(z[k].weight + 1L);
            var bk = float64(z[k].subtreeBytes);
            if (bi == 0L && bk == 0L)
            {
                return wi >= wk;
            }
            if (bk == 0L)
            {
                return false;
            }
            return bi / bk <= wi / wk;
        }

        private partial struct http2priorityWriteScheduler
        {
            public http2priorityNode root; // nodes maps stream ids to priority tree nodes.
            public map<uint, ref http2priorityNode> nodes; // maxID is the maximum stream id in nodes.
            public uint maxID; // lists of nodes that have been closed or are idle, but are kept in
// the tree for improved prioritization. When the lengths exceed either
// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.
            public slice<ref http2priorityNode> closedNodes; // From the config.
            public slice<ref http2priorityNode> idleNodes; // From the config.
            public long maxClosedNodesInTree;
            public long maxIdleNodesInTree;
            public int writeThrottleLimit;
            public bool enableWriteThrottle; // tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.
            public slice<ref http2priorityNode> tmp; // pool of empty queues for reuse.
            public http2writeQueuePool queuePool;
        }

        private static void OpenStream(this ref http2priorityWriteScheduler _ws, uint streamID, http2OpenStreamOptions options) => func(_ws, (ref http2priorityWriteScheduler ws, Defer _, Panic panic, Recover __) =>
        { 
            // The stream may be currently idle but cannot be opened or closed.
            {
                var curr = ws.nodes[streamID];

                if (curr != null)
                {
                    if (curr.state != http2priorityNodeIdle)
                    {
                        panic(fmt.Sprintf("stream %d already opened", streamID));
                    }
                    curr.state = http2priorityNodeOpen;
                    return;
                } 

                // RFC 7540, Section 5.3.5:
                //  "All streams are initially assigned a non-exclusive dependency on stream 0x0.
                //  Pushed streams initially depend on their associated stream. In both cases,
                //  streams are assigned a default weight of 16."

            } 

            // RFC 7540, Section 5.3.5:
            //  "All streams are initially assigned a non-exclusive dependency on stream 0x0.
            //  Pushed streams initially depend on their associated stream. In both cases,
            //  streams are assigned a default weight of 16."
            var parent = ws.nodes[options.PusherID];
            if (parent == null)
            {
                parent = ref ws.root;
            }
            http2priorityNode n = ref new http2priorityNode(q:*ws.queuePool.get(),id:streamID,weight:http2priorityDefaultWeight,state:http2priorityNodeOpen,);
            n.setParent(parent);
            ws.nodes[streamID] = n;
            if (streamID > ws.maxID)
            {
                ws.maxID = streamID;
            }
        });

        private static void CloseStream(this ref http2priorityWriteScheduler _ws, uint streamID) => func(_ws, (ref http2priorityWriteScheduler ws, Defer _, Panic panic, Recover __) =>
        {
            if (streamID == 0L)
            {
                panic("violation of WriteScheduler interface: cannot close stream 0");
            }
            if (ws.nodes[streamID] == null)
            {
                panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID));
            }
            if (ws.nodes[streamID].state != http2priorityNodeOpen)
            {
                panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID));
            }
            var n = ws.nodes[streamID];
            n.state = http2priorityNodeClosed;
            n.addBytes(-n.bytes);

            var q = n.q;
            ws.queuePool.put(ref q);
            n.q.s = null;
            if (ws.maxClosedNodesInTree > 0L)
            {
                ws.addClosedOrIdleNode(ref ws.closedNodes, ws.maxClosedNodesInTree, n);
            }
            else
            {
                ws.removeNode(n);
            }
        });

        private static void AdjustStream(this ref http2priorityWriteScheduler _ws, uint streamID, http2PriorityParam priority) => func(_ws, (ref http2priorityWriteScheduler ws, Defer _, Panic panic, Recover __) =>
        {
            if (streamID == 0L)
            {
                panic("adjustPriority on root");
            } 

            // If streamID does not exist, there are two cases:
            // - A closed stream that has been removed (this will have ID <= maxID)
            // - An idle stream that is being used for "grouping" (this will have ID > maxID)
            var n = ws.nodes[streamID];
            if (n == null)
            {
                if (streamID <= ws.maxID || ws.maxIdleNodesInTree == 0L)
                {
                    return;
                }
                ws.maxID = streamID;
                n = ref new http2priorityNode(q:*ws.queuePool.get(),id:streamID,weight:http2priorityDefaultWeight,state:http2priorityNodeIdle,);
                n.setParent(ref ws.root);
                ws.nodes[streamID] = n;
                ws.addClosedOrIdleNode(ref ws.idleNodes, ws.maxIdleNodesInTree, n);
            } 

            // Section 5.3.1: A dependency on a stream that is not currently in the tree
            // results in that stream being given a default priority (Section 5.3.5).
            var parent = ws.nodes[priority.StreamDep];
            if (parent == null)
            {
                n.setParent(ref ws.root);
                n.weight = http2priorityDefaultWeight;
                return;
            } 

            // Ignore if the client tries to make a node its own parent.
            if (n == parent)
            {
                return;
            } 

            // Section 5.3.3:
            //   "If a stream is made dependent on one of its own dependencies, the
            //   formerly dependent stream is first moved to be dependent on the
            //   reprioritized stream's previous parent. The moved dependency retains
            //   its weight."
            //
            // That is: if parent depends on n, move parent to depend on n.parent.
            {
                var x = parent.parent;

                while (x != null)
                {
                    if (x == n)
                    {
                        parent.setParent(n.parent);
                        break;
                    x = x.parent;
                    }
                } 

                // Section 5.3.3: The exclusive flag causes the stream to become the sole
                // dependency of its parent stream, causing other dependencies to become
                // dependent on the exclusive stream.

            } 

            // Section 5.3.3: The exclusive flag causes the stream to become the sole
            // dependency of its parent stream, causing other dependencies to become
            // dependent on the exclusive stream.
            if (priority.Exclusive)
            {
                var k = parent.kids;
                while (k != null)
                {
                    var next = k.next;
                    if (k != n)
                    {
                        k.setParent(n);
                    }
                    k = next;
                }

            }
            n.setParent(parent);
            n.weight = priority.Weight;
        });

        private static void Push(this ref http2priorityWriteScheduler _ws, http2FrameWriteRequest wr) => func(_ws, (ref http2priorityWriteScheduler ws, Defer _, Panic panic, Recover __) =>
        {
            ref http2priorityNode n = default;
            {
                var id = wr.StreamID();

                if (id == 0L)
                {
                    n = ref ws.root;
                }
                else
                {
                    n = ws.nodes[id];
                    if (n == null)
                    { 
                        // id is an idle or closed stream. wr should not be a HEADERS or
                        // DATA frame. However, wr can be a RST_STREAM. In this case, we
                        // push wr onto the root, rather than creating a new priorityNode,
                        // since RST_STREAM is tiny and the stream's priority is unknown
                        // anyway. See issue #17919.
                        if (wr.DataSize() > 0L)
                        {
                            panic("add DATA on non-open stream");
                        }
                        n = ref ws.root;
                    }
                }

            }
            n.q.push(wr);
        });

        private static (http2FrameWriteRequest, bool) Pop(this ref http2priorityWriteScheduler ws)
        {
            ws.root.walkReadyInOrder(false, ref ws.tmp, (n, openParent) =>
            {
                var limit = int32(math.MaxInt32);
                if (openParent)
                {
                    limit = ws.writeThrottleLimit;
                }
                wr, ok = n.q.consume(limit);
                if (!ok)
                {
                    return false;
                }
                n.addBytes(int64(wr.DataSize())); 
                // If B depends on A and B continuously has data available but A
                // does not, gradually increase the throttling limit to allow B to
                // steal more and more bandwidth from A.
                if (openParent)
                {
                    ws.writeThrottleLimit += 1024L;
                    if (ws.writeThrottleLimit < 0L)
                    {
                        ws.writeThrottleLimit = math.MaxInt32;
                    }
                }
                else if (ws.enableWriteThrottle)
                {
                    ws.writeThrottleLimit = 1024L;
                }
                return true;
            });
            return (wr, ok);
        }

        private static void addClosedOrIdleNode(this ref http2priorityWriteScheduler ws, ref slice<ref http2priorityNode> list, long maxSize, ref http2priorityNode n)
        {
            if (maxSize == 0L)
            {
                return;
            }
            if (len(list.Value) == maxSize)
            { 
                // Remove the oldest node, then shift left.
                ws.removeNode((list.Value)[0L]);
                var x = (list.Value)[1L..];
                copy(list.Value, x);
                list.Value = (list.Value)[..len(x)];
            }
            list.Value = append(list.Value, n);
        }

        private static void removeNode(this ref http2priorityWriteScheduler ws, ref http2priorityNode n)
        {
            {
                var k = n.kids;

                while (k != null)
                {
                    k.setParent(n.parent);
                    k = k.next;
                }

            }
            n.setParent(null);
            delete(ws.nodes, n.id);
        }

        // NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
        // priorities. Control frames like SETTINGS and PING are written before DATA
        // frames, but if no control frames are queued and multiple streams have queued
        // HEADERS or DATA frames, Pop selects a ready stream arbitrarily.
        private static http2WriteScheduler http2NewRandomWriteScheduler()
        {
            return ref new http2randomWriteScheduler(sq:make(map[uint32]*http2writeQueue));
        }

        private partial struct http2randomWriteScheduler
        {
            public http2writeQueue zero; // sq contains the stream-specific queues, keyed by stream ID.
// When a stream is idle or closed, it's deleted from the map.
            public map<uint, ref http2writeQueue> sq; // pool of empty queues for reuse.
            public http2writeQueuePool queuePool;
        }

        private static void OpenStream(this ref http2randomWriteScheduler ws, uint streamID, http2OpenStreamOptions options)
        { 
            // no-op: idle streams are not tracked
        }

        private static void CloseStream(this ref http2randomWriteScheduler ws, uint streamID)
        {
            var (q, ok) = ws.sq[streamID];
            if (!ok)
            {
                return;
            }
            delete(ws.sq, streamID);
            ws.queuePool.put(q);
        }

        private static void AdjustStream(this ref http2randomWriteScheduler ws, uint streamID, http2PriorityParam priority)
        { 
            // no-op: priorities are ignored
        }

        private static void Push(this ref http2randomWriteScheduler ws, http2FrameWriteRequest wr)
        {
            var id = wr.StreamID();
            if (id == 0L)
            {
                ws.zero.push(wr);
                return;
            }
            var (q, ok) = ws.sq[id];
            if (!ok)
            {
                q = ws.queuePool.get();
                ws.sq[id] = q;
            }
            q.push(wr);
        }

        private static (http2FrameWriteRequest, bool) Pop(this ref http2randomWriteScheduler ws)
        { 
            // Control frames first.
            if (!ws.zero.empty())
            {
                return (ws.zero.shift(), true);
            } 
            // Iterate over all non-idle streams until finding one that can be consumed.
            foreach (var (_, q) in ws.sq)
            {
                {
                    var (wr, ok) = q.consume(math.MaxInt32);

                    if (ok)
                    {
                        return (wr, true);
                    }

                }
            }
            return (new http2FrameWriteRequest(), false);
        }
    }
}}
