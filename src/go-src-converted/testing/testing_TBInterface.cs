//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generated on 2020 August 29 10:05:56 UTC
// </auto-generated>
//---------------------------------------------------------
using System;
using System.CodeDom.Compiler;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using static go.builtin;
using bytes = go.bytes_package;
using errors = go.errors_package;
using flag = go.flag_package;
using fmt = go.fmt_package;
using race = go.@internal.race_package;
using io = go.io_package;
using os = go.os_package;
using runtime = go.runtime_package;
using debug = go.runtime.debug_package;
using trace = go.runtime.trace_package;
using strconv = go.strconv_package;
using strings = go.strings_package;
using sync = go.sync_package;
using atomic = go.sync.atomic_package;
using time = go.time_package;

#pragma warning disable CS0660, CS0661

namespace go
{
    public static partial class testing_package
    {
        [GeneratedCode("go2cs", "0.1.0.0")]
        public partial interface TB
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static TB As<T>(in T target) => (TB<T>)target!;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static TB As<T>(ptr<T> target_ptr) => (TB<T>)target_ptr;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static TB? As(object target) =>
                typeof(TB<>).CreateInterfaceHandler<TB>(target);
        }

        [GeneratedCode("go2cs", "0.1.0.0")]
        public class TB<T> : TB
        {
            private T m_target;
            private readonly ptr<T>? m_target_ptr;
            private readonly bool m_target_is_ptr;

            public ref T Target
            {
                get
                {
                    if (m_target_is_ptr && !(m_target_ptr is null))
                        return ref m_target_ptr.Value;

                    return ref m_target;
                }
            }

            public TB(in T target) => m_target = target;

            public TB(ptr<T> target_ptr)
            {
                m_target_ptr = target_ptr;
                m_target_is_ptr = true;
            }

            private delegate bool ErrorByRef(ref T value, params object[] args);
            private delegate bool ErrorByVal(T value, params object[] args);

            private static readonly ErrorByRef s_ErrorByRef;
            private static readonly ErrorByVal s_ErrorByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Error(params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_ErrorByRef is null)
                    return s_ErrorByVal!(target, args);

                return s_ErrorByRef(ref target, args);
            }

            private delegate bool ErrorfByRef(ref T value, @string format, params object[] args);
            private delegate bool ErrorfByVal(T value, @string format, params object[] args);

            private static readonly ErrorfByRef s_ErrorfByRef;
            private static readonly ErrorfByVal s_ErrorfByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Errorf(@string format, params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_ErrorfByRef is null)
                    return s_ErrorfByVal!(target, format, args);

                return s_ErrorfByRef(ref target, format, args);
            }

            private delegate bool FailByRef(ref T value);
            private delegate bool FailByVal(T value);

            private static readonly FailByRef s_FailByRef;
            private static readonly FailByVal s_FailByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Fail()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_FailByRef is null)
                    return s_FailByVal!(target);

                return s_FailByRef(ref target);
            }

            private delegate bool FailNowByRef(ref T value);
            private delegate bool FailNowByVal(T value);

            private static readonly FailNowByRef s_FailNowByRef;
            private static readonly FailNowByVal s_FailNowByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool FailNow()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_FailNowByRef is null)
                    return s_FailNowByVal!(target);

                return s_FailNowByRef(ref target);
            }

            private delegate bool FailedByRef(ref T value);
            private delegate bool FailedByVal(T value);

            private static readonly FailedByRef s_FailedByRef;
            private static readonly FailedByVal s_FailedByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Failed()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_FailedByRef is null)
                    return s_FailedByVal!(target);

                return s_FailedByRef(ref target);
            }

            private delegate bool FatalByRef(ref T value, params object[] args);
            private delegate bool FatalByVal(T value, params object[] args);

            private static readonly FatalByRef s_FatalByRef;
            private static readonly FatalByVal s_FatalByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Fatal(params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_FatalByRef is null)
                    return s_FatalByVal!(target, args);

                return s_FatalByRef(ref target, args);
            }

            private delegate bool FatalfByRef(ref T value, @string format, params object[] args);
            private delegate bool FatalfByVal(T value, @string format, params object[] args);

            private static readonly FatalfByRef s_FatalfByRef;
            private static readonly FatalfByVal s_FatalfByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Fatalf(@string format, params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_FatalfByRef is null)
                    return s_FatalfByVal!(target, format, args);

                return s_FatalfByRef(ref target, format, args);
            }

            private delegate bool LogByRef(ref T value, params object[] args);
            private delegate bool LogByVal(T value, params object[] args);

            private static readonly LogByRef s_LogByRef;
            private static readonly LogByVal s_LogByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Log(params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_LogByRef is null)
                    return s_LogByVal!(target, args);

                return s_LogByRef(ref target, args);
            }

            private delegate bool LogfByRef(ref T value, @string format, params object[] args);
            private delegate bool LogfByVal(T value, @string format, params object[] args);

            private static readonly LogfByRef s_LogfByRef;
            private static readonly LogfByVal s_LogfByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Logf(@string format, params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_LogfByRef is null)
                    return s_LogfByVal!(target, format, args);

                return s_LogfByRef(ref target, format, args);
            }

            private delegate bool NameByRef(ref T value);
            private delegate bool NameByVal(T value);

            private static readonly NameByRef s_NameByRef;
            private static readonly NameByVal s_NameByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Name()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_NameByRef is null)
                    return s_NameByVal!(target);

                return s_NameByRef(ref target);
            }

            private delegate bool SkipByRef(ref T value, params object[] args);
            private delegate bool SkipByVal(T value, params object[] args);

            private static readonly SkipByRef s_SkipByRef;
            private static readonly SkipByVal s_SkipByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Skip(params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_SkipByRef is null)
                    return s_SkipByVal!(target, args);

                return s_SkipByRef(ref target, args);
            }

            private delegate bool SkipNowByRef(ref T value);
            private delegate bool SkipNowByVal(T value);

            private static readonly SkipNowByRef s_SkipNowByRef;
            private static readonly SkipNowByVal s_SkipNowByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool SkipNow()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_SkipNowByRef is null)
                    return s_SkipNowByVal!(target);

                return s_SkipNowByRef(ref target);
            }

            private delegate bool SkipfByRef(ref T value, @string format, params object[] args);
            private delegate bool SkipfByVal(T value, @string format, params object[] args);

            private static readonly SkipfByRef s_SkipfByRef;
            private static readonly SkipfByVal s_SkipfByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Skipf(@string format, params object[] args)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_SkipfByRef is null)
                    return s_SkipfByVal!(target, format, args);

                return s_SkipfByRef(ref target, format, args);
            }

            private delegate bool SkippedByRef(ref T value);
            private delegate bool SkippedByVal(T value);

            private static readonly SkippedByRef s_SkippedByRef;
            private static readonly SkippedByVal s_SkippedByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Skipped()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_SkippedByRef is null)
                    return s_SkippedByVal!(target);

                return s_SkippedByRef(ref target);
            }

            private delegate bool HelperByRef(ref T value);
            private delegate bool HelperByVal(T value);

            private static readonly HelperByRef s_HelperByRef;
            private static readonly HelperByVal s_HelperByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Helper()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_HelperByRef is null)
                    return s_HelperByVal!(target);

                return s_HelperByRef(ref target);
            }

            private delegate bool privateByRef(ref T value);
            private delegate bool privateByVal(T value);

            private static readonly privateByRef s_privateByRef;
            private static readonly privateByVal s_privateByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool private()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.Value;
                if (s_privateByRef is null)
                    return s_privateByVal!(target);

                return s_privateByRef(ref target);
            }
            
            public string ToString(string format, IFormatProvider formatProvider) => format;

            [DebuggerStepperBoundary]
            static TB()
            {
                Type targetType = typeof(T);
                Type targetTypeByRef = targetType.MakeByRefType();
                MethodInfo extensionMethod;

               extensionMethod = targetTypeByRef.GetExtensionMethod("Error");

                if (!(extensionMethod is null))
                    s_ErrorByRef = extensionMethod.CreateStaticDelegate(typeof(ErrorByRef)) as ErrorByRef;

                if (s_ErrorByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Error");

                    if (!(extensionMethod is null))
                        s_ErrorByVal = extensionMethod.CreateStaticDelegate(typeof(ErrorByVal)) as ErrorByVal;
                }

                if (s_ErrorByRef is null && s_ErrorByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Error method", new Exception("Error"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Errorf");

                if (!(extensionMethod is null))
                    s_ErrorfByRef = extensionMethod.CreateStaticDelegate(typeof(ErrorfByRef)) as ErrorfByRef;

                if (s_ErrorfByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Errorf");

                    if (!(extensionMethod is null))
                        s_ErrorfByVal = extensionMethod.CreateStaticDelegate(typeof(ErrorfByVal)) as ErrorfByVal;
                }

                if (s_ErrorfByRef is null && s_ErrorfByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Errorf method", new Exception("Errorf"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Fail");

                if (!(extensionMethod is null))
                    s_FailByRef = extensionMethod.CreateStaticDelegate(typeof(FailByRef)) as FailByRef;

                if (s_FailByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Fail");

                    if (!(extensionMethod is null))
                        s_FailByVal = extensionMethod.CreateStaticDelegate(typeof(FailByVal)) as FailByVal;
                }

                if (s_FailByRef is null && s_FailByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Fail method", new Exception("Fail"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("FailNow");

                if (!(extensionMethod is null))
                    s_FailNowByRef = extensionMethod.CreateStaticDelegate(typeof(FailNowByRef)) as FailNowByRef;

                if (s_FailNowByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("FailNow");

                    if (!(extensionMethod is null))
                        s_FailNowByVal = extensionMethod.CreateStaticDelegate(typeof(FailNowByVal)) as FailNowByVal;
                }

                if (s_FailNowByRef is null && s_FailNowByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.FailNow method", new Exception("FailNow"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Failed");

                if (!(extensionMethod is null))
                    s_FailedByRef = extensionMethod.CreateStaticDelegate(typeof(FailedByRef)) as FailedByRef;

                if (s_FailedByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Failed");

                    if (!(extensionMethod is null))
                        s_FailedByVal = extensionMethod.CreateStaticDelegate(typeof(FailedByVal)) as FailedByVal;
                }

                if (s_FailedByRef is null && s_FailedByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Failed method", new Exception("Failed"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Fatal");

                if (!(extensionMethod is null))
                    s_FatalByRef = extensionMethod.CreateStaticDelegate(typeof(FatalByRef)) as FatalByRef;

                if (s_FatalByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Fatal");

                    if (!(extensionMethod is null))
                        s_FatalByVal = extensionMethod.CreateStaticDelegate(typeof(FatalByVal)) as FatalByVal;
                }

                if (s_FatalByRef is null && s_FatalByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Fatal method", new Exception("Fatal"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Fatalf");

                if (!(extensionMethod is null))
                    s_FatalfByRef = extensionMethod.CreateStaticDelegate(typeof(FatalfByRef)) as FatalfByRef;

                if (s_FatalfByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Fatalf");

                    if (!(extensionMethod is null))
                        s_FatalfByVal = extensionMethod.CreateStaticDelegate(typeof(FatalfByVal)) as FatalfByVal;
                }

                if (s_FatalfByRef is null && s_FatalfByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Fatalf method", new Exception("Fatalf"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Log");

                if (!(extensionMethod is null))
                    s_LogByRef = extensionMethod.CreateStaticDelegate(typeof(LogByRef)) as LogByRef;

                if (s_LogByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Log");

                    if (!(extensionMethod is null))
                        s_LogByVal = extensionMethod.CreateStaticDelegate(typeof(LogByVal)) as LogByVal;
                }

                if (s_LogByRef is null && s_LogByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Log method", new Exception("Log"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Logf");

                if (!(extensionMethod is null))
                    s_LogfByRef = extensionMethod.CreateStaticDelegate(typeof(LogfByRef)) as LogfByRef;

                if (s_LogfByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Logf");

                    if (!(extensionMethod is null))
                        s_LogfByVal = extensionMethod.CreateStaticDelegate(typeof(LogfByVal)) as LogfByVal;
                }

                if (s_LogfByRef is null && s_LogfByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Logf method", new Exception("Logf"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Name");

                if (!(extensionMethod is null))
                    s_NameByRef = extensionMethod.CreateStaticDelegate(typeof(NameByRef)) as NameByRef;

                if (s_NameByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Name");

                    if (!(extensionMethod is null))
                        s_NameByVal = extensionMethod.CreateStaticDelegate(typeof(NameByVal)) as NameByVal;
                }

                if (s_NameByRef is null && s_NameByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Name method", new Exception("Name"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Skip");

                if (!(extensionMethod is null))
                    s_SkipByRef = extensionMethod.CreateStaticDelegate(typeof(SkipByRef)) as SkipByRef;

                if (s_SkipByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Skip");

                    if (!(extensionMethod is null))
                        s_SkipByVal = extensionMethod.CreateStaticDelegate(typeof(SkipByVal)) as SkipByVal;
                }

                if (s_SkipByRef is null && s_SkipByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Skip method", new Exception("Skip"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("SkipNow");

                if (!(extensionMethod is null))
                    s_SkipNowByRef = extensionMethod.CreateStaticDelegate(typeof(SkipNowByRef)) as SkipNowByRef;

                if (s_SkipNowByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("SkipNow");

                    if (!(extensionMethod is null))
                        s_SkipNowByVal = extensionMethod.CreateStaticDelegate(typeof(SkipNowByVal)) as SkipNowByVal;
                }

                if (s_SkipNowByRef is null && s_SkipNowByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.SkipNow method", new Exception("SkipNow"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Skipf");

                if (!(extensionMethod is null))
                    s_SkipfByRef = extensionMethod.CreateStaticDelegate(typeof(SkipfByRef)) as SkipfByRef;

                if (s_SkipfByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Skipf");

                    if (!(extensionMethod is null))
                        s_SkipfByVal = extensionMethod.CreateStaticDelegate(typeof(SkipfByVal)) as SkipfByVal;
                }

                if (s_SkipfByRef is null && s_SkipfByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Skipf method", new Exception("Skipf"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Skipped");

                if (!(extensionMethod is null))
                    s_SkippedByRef = extensionMethod.CreateStaticDelegate(typeof(SkippedByRef)) as SkippedByRef;

                if (s_SkippedByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Skipped");

                    if (!(extensionMethod is null))
                        s_SkippedByVal = extensionMethod.CreateStaticDelegate(typeof(SkippedByVal)) as SkippedByVal;
                }

                if (s_SkippedByRef is null && s_SkippedByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Skipped method", new Exception("Skipped"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("Helper");

                if (!(extensionMethod is null))
                    s_HelperByRef = extensionMethod.CreateStaticDelegate(typeof(HelperByRef)) as HelperByRef;

                if (s_HelperByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("Helper");

                    if (!(extensionMethod is null))
                        s_HelperByVal = extensionMethod.CreateStaticDelegate(typeof(HelperByVal)) as HelperByVal;
                }

                if (s_HelperByRef is null && s_HelperByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.Helper method", new Exception("Helper"));

               extensionMethod = targetTypeByRef.GetExtensionMethod("private");

                if (!(extensionMethod is null))
                    s_privateByRef = extensionMethod.CreateStaticDelegate(typeof(privateByRef)) as privateByRef;

                if (s_privateByRef is null)
                {
                    extensionMethod = targetType.GetExtensionMethod("private");

                    if (!(extensionMethod is null))
                        s_privateByVal = extensionMethod.CreateStaticDelegate(typeof(privateByVal)) as privateByVal;
                }

                if (s_privateByRef is null && s_privateByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement TB.private method", new Exception("private"));
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator TB<T>(in ptr<T> target_ptr) => new TB<T>(target_ptr);

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator TB<T>(in T target) => new TB<T>(target);

            // Enable comparisons between nil and TB<T> interface instance
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(TB<T> value, NilType nil) => Activator.CreateInstance<TB<T>>().Equals(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(TB<T> value, NilType nil) => !(value == nil);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(NilType nil, TB<T> value) => value == nil;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(NilType nil, TB<T> value) => value != nil;
        }
    }
}

namespace go
{
    public static class testing_TBExtensions
    {
        private static readonly ConcurrentDictionary<Type, MethodInfo> s_conversionOperators = new ConcurrentDictionary<Type, MethodInfo>();

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static T _<T>(this go.testing_package.TB target)
        {
            try
            {
                return ((go.testing_package.TB<T>)target).Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(typeof(T))}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _<T>(this go.testing_package.TB target, out T result)
        {
            try
            {
                result = target._<T>();
                return true;
            }
            catch (PanicException)
            {
                result = default!;
                return false;
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static object? _(this go.testing_package.TB target, Type type)
        {
            try
            {
                MethodInfo? conversionOperator = s_conversionOperators.GetOrAdd(type, _ => typeof(go.testing_package.TB<>).GetExplicitGenericConversionOperator(type));

                if (conversionOperator is null)
                    throw new PanicException($"interface conversion: failed to create converter for {GetGoTypeName(target.GetType())} to {GetGoTypeName(type)}");

                dynamic? result = conversionOperator.Invoke(null, new object[] { target });
                return result?.Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(type)}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _(this go.testing_package.TB target, Type type, out object? result)
        {
            try
            {
                result = target._(type);
                return true;
            }
            catch (PanicException)
            {
                result = type.IsValueType ? Activator.CreateInstance(type) : null;
                return false;
            }
        }
    }
}