// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package runtime -- go2cs converted at 2020 August 29 08:21:05 UTC
// import "runtime" ==> using runtime = go.runtime_package
// Original source: C:\Go\src\runtime\symtab.go
using atomic = go.runtime.@internal.atomic_package;
using sys = go.runtime.@internal.sys_package;
using @unsafe = go.@unsafe_package;
using static go.builtin;

namespace go
{
    public static unsafe partial class runtime_package
    {
        // Frames may be used to get function/file/line information for a
        // slice of PC values returned by Callers.
        public partial struct Frames
        {
            public slice<System.UIntPtr> callers; // stackExpander expands callers into a sequence of Frames,
// tracking the necessary state across PCs.
            public stackExpander stackExpander; // elideWrapper indicates that, if the next frame is an
// autogenerated wrapper function, it should be elided from
// the stack.
            public bool elideWrapper;
        }

        // Frame is the information returned by Frames for each call frame.
        public partial struct Frame
        {
            public System.UIntPtr PC; // Func is the Func value of this call frame. This may be nil
// for non-Go code or fully inlined functions.
            public ptr<Func> Func; // Function is the package path-qualified function name of
// this call frame. If non-empty, this string uniquely
// identifies a single function in the program.
// This may be the empty string if not known.
// If Func is not nil then Function == Func.Name().
            public @string Function; // File and Line are the file name and line number of the
// location in this frame. For non-leaf frames, this will be
// the location of a call. These may be the empty string and
// zero, respectively, if not known.
            public @string File;
            public long Line; // Entry point program counter for the function; may be zero
// if not known. If Func is not nil then Entry ==
// Func.Entry().
            public System.UIntPtr Entry;
        }

        // stackExpander expands a call stack of PCs into a sequence of
        // Frames. It tracks state across PCs necessary to perform this
        // expansion.
        //
        // This is the core of the Frames implementation, but is a separate
        // internal API to make it possible to use within the runtime without
        // heap-allocating the PC slice. The only difference with the public
        // Frames API is that the caller is responsible for threading the PC
        // slice between expansion steps in this API. If escape analysis were
        // smarter, we may not need this (though it may have to be a lot
        // smarter).
        private partial struct stackExpander
        {
            public pcExpander pcExpander; // If previous caller in iteration was a panic, then the next
// PC in the call stack is the address of the faulting
// instruction instead of the return address of the call.
            public bool wasPanic; // skip > 0 indicates that skip frames in the expansion of the
// first PC should be skipped over and callers[1] should also
// be skipped.
            public long skip;
        }

        // CallersFrames takes a slice of PC values returned by Callers and
        // prepares to return function/file/line information.
        // Do not change the slice until you are done with the Frames.
        public static ref Frames CallersFrames(slice<System.UIntPtr> callers)
        {
            Frames ci = ref new Frames();
            ci.callers = ci.stackExpander.init(callers);
            return ci;
        }

        private static slice<System.UIntPtr> init(this ref stackExpander se, slice<System.UIntPtr> callers)
        {
            if (len(callers) >= 1L)
            {
                var pc = callers[0L];
                var s = pc - skipPC;
                if (s >= 0L && s < sizeofSkipFunction)
                { 
                    // Ignore skip frame callers[0] since this means the caller trimmed the PC slice.
                    return callers[1L..];
                }
            }
            if (len(callers) >= 2L)
            {
                pc = callers[1L];
                s = pc - skipPC;
                if (s > 0L && s < sizeofSkipFunction)
                { 
                    // Skip the first s inlined frames when we expand the first PC.
                    se.skip = int(s);
                }
            }
            return callers;
        }

        // Next returns frame information for the next caller.
        // If more is false, there are no more callers (the Frame value is valid).
        private static (Frame, bool) Next(this ref Frames ci)
        {
            ci.callers, frame, more = ci.stackExpander.next(ci.callers, ci.elideWrapper);
            ci.elideWrapper = elideWrapperCalling(frame.Function);
            return;
        }

        private static (slice<System.UIntPtr>, Frame, bool) next(this ref stackExpander se, slice<System.UIntPtr> callers, bool elideWrapper)
        {
            ncallers = callers;
again:

            if (!se.pcExpander.more)
            { 
                // Expand the next PC.
                if (len(ncallers) == 0L)
                {
                    se.wasPanic = false;
                    return (ncallers, new Frame(), false);
                }
                se.pcExpander.init(ncallers[0L], se.wasPanic);
                ncallers = ncallers[1L..];
                se.wasPanic = se.pcExpander.funcInfo.valid() && se.pcExpander.funcInfo.funcID == funcID_sigpanic;
                if (se.skip > 0L)
                {
                    while (se.skip > 0L)
                    {
                        se.pcExpander.next();
                        se.skip--;
                    }

                    se.skip = 0L; 
                    // Drop skipPleaseUseCallersFrames.
                    ncallers = ncallers[1L..];
                }
                if (!se.pcExpander.more)
                { 
                    // No symbolic information for this PC.
                    // However, we return at least one frame for
                    // every PC, so return an invalid frame.
                    return (ncallers, new Frame(), len(ncallers) > 0L);
                }
            }
            frame = se.pcExpander.next();
            if (elideWrapper && frame.File == "<autogenerated>")
            { 
                // Ignore autogenerated functions such as pointer
                // method forwarding functions. These are an
                // implementation detail that doesn't reflect the
                // source code.
                goto again;
            }
            return (ncallers, frame, se.pcExpander.more || len(ncallers) > 0L);
        }

        // A pcExpander expands a single PC into a sequence of Frames.
        private partial struct pcExpander
        {
            public bool more; // pc is the pc being expanded.
            public System.UIntPtr pc; // frames is a pre-expanded set of Frames to return from the
// iterator. If this is set, then this is everything that will
// be returned from the iterator.
            public slice<Frame> frames; // funcInfo is the funcInfo of the function containing pc.
            public funcInfo funcInfo; // inlTree is the inlining tree of the function containing pc.
            public ptr<array<inlinedCall>> inlTree; // file and line are the file name and line number of the next
// frame.
            public @string file;
            public int line; // inlIndex is the inlining index of the next frame, or -1 if
// the next frame is an outermost frame.
            public int inlIndex;
        }

        // init initializes this pcExpander to expand pc. It sets ex.more if
        // pc expands to any Frames.
        //
        // A pcExpander can be reused by calling init again.
        //
        // If pc was a "call" to sigpanic, panicCall should be true. In this
        // case, pc is treated as the address of a faulting instruction
        // instead of the return address of a call.
        private static void init(this ref pcExpander ex, System.UIntPtr pc, bool panicCall)
        {
            ex.more = false;

            ex.funcInfo = findfunc(pc);
            if (!ex.funcInfo.valid())
            {
                if (cgoSymbolizer != null)
                { 
                    // Pre-expand cgo frames. We could do this
                    // incrementally, too, but there's no way to
                    // avoid allocation in this case anyway.
                    ex.frames = expandCgoFrames(pc);
                    ex.more = len(ex.frames) > 0L;
                }
                return;
            }
            ex.more = true;
            var entry = ex.funcInfo.entry;
            ex.pc = pc;
            if (ex.pc > entry && !panicCall)
            {
                ex.pc--;
            } 

            // file and line are the innermost position at pc.
            ex.file, ex.line = funcline1(ex.funcInfo, ex.pc, false); 

            // Get inlining tree at pc
            var inldata = funcdata(ex.funcInfo, _FUNCDATA_InlTree);
            if (inldata != null)
            {
                ex.inlTree = new ptr<ref array<inlinedCall>>(inldata);
                ex.inlIndex = pcdatavalue(ex.funcInfo, _PCDATA_InlTreeIndex, ex.pc, null);
            }
            else
            {
                ex.inlTree = null;
                ex.inlIndex = -1L;
            }
        }

        // next returns the next Frame in the expansion of pc and sets ex.more
        // if there are more Frames to follow.
        private static Frame next(this ref pcExpander ex)
        {
            if (!ex.more)
            {
                return new Frame();
            }
            if (len(ex.frames) > 0L)
            { 
                // Return pre-expended frame.
                var frame = ex.frames[0L];
                ex.frames = ex.frames[1L..];
                ex.more = len(ex.frames) > 0L;
                return frame;
            }
            if (ex.inlIndex >= 0L)
            { 
                // Return inner inlined frame.
                var call = ex.inlTree[ex.inlIndex];
                frame = new Frame(PC:ex.pc,Func:nil,Function:funcnameFromNameoff(ex.funcInfo,call.func_),File:ex.file,Line:int(ex.line),Entry:ex.funcInfo.entry,);
                ex.file = funcfile(ex.funcInfo, call.file);
                ex.line = call.line;
                ex.inlIndex = call.parent;
                return frame;
            } 

            // No inlining or pre-expanded frames.
            ex.more = false;
            return new Frame(PC:ex.pc,Func:ex.funcInfo._Func(),Function:funcname(ex.funcInfo),File:ex.file,Line:int(ex.line),Entry:ex.funcInfo.entry,);
        }

        // expandCgoFrames expands frame information for pc, known to be
        // a non-Go function, using the cgoSymbolizer hook. expandCgoFrames
        // returns nil if pc could not be expanded.
        private static slice<Frame> expandCgoFrames(System.UIntPtr pc)
        {
            cgoSymbolizerArg arg = new cgoSymbolizerArg(pc:pc);
            callCgoSymbolizer(ref arg);

            if (arg.file == null && arg.funcName == null)
            { 
                // No useful information from symbolizer.
                return null;
            }
            slice<Frame> frames = default;
            while (true)
            {
                frames = append(frames, new Frame(PC:pc,Func:nil,Function:gostring(arg.funcName),File:gostring(arg.file),Line:int(arg.lineno),Entry:arg.entry,));
                if (arg.more == 0L)
                {
                    break;
                }
                callCgoSymbolizer(ref arg);
            } 

            // No more frames for this PC. Tell the symbolizer we are done.
            // We don't try to maintain a single cgoSymbolizerArg for the
            // whole use of Frames, because there would be no good way to tell
            // the symbolizer when we are done.
 

            // No more frames for this PC. Tell the symbolizer we are done.
            // We don't try to maintain a single cgoSymbolizerArg for the
            // whole use of Frames, because there would be no good way to tell
            // the symbolizer when we are done.
            arg.pc = 0L;
            callCgoSymbolizer(ref arg);

            return frames;
        }

        // NOTE: Func does not expose the actual unexported fields, because we return *Func
        // values to users, and we want to keep them from being able to overwrite the data
        // with (say) *f = Func{}.
        // All code operating on a *Func must call raw() to get the *_func
        // or funcInfo() to get the funcInfo instead.

        // A Func represents a Go function in the running binary.
        public partial struct Func
        {
        }

        private static ref _func raw(this ref Func f)
        {
            return (_func.Value)(@unsafe.Pointer(f));
        }

        private static funcInfo funcInfo(this ref Func f)
        {
            var fn = f.raw();
            return new funcInfo(fn,findmoduledatap(fn.entry));
        }

        // PCDATA and FUNCDATA table indexes.
        //
        // See funcdata.h and ../cmd/internal/obj/funcdata.go.
        private static readonly long _PCDATA_StackMapIndex = 0L;
        private static readonly long _PCDATA_InlTreeIndex = 1L;
        private static readonly long _FUNCDATA_ArgsPointerMaps = 0L;
        private static readonly long _FUNCDATA_LocalsPointerMaps = 1L;
        private static readonly long _FUNCDATA_InlTree = 2L;
        private static readonly ulong _ArgsSizeUnknown = -0x80000000UL;

        // A FuncID identifies particular functions that need to be treated
        // specially by the runtime.
        // Note that in some situations involving plugins, there may be multiple
        // copies of a particular special runtime function.
        // Note: this list must match the list in cmd/internal/objabi/funcid.go.
        private partial struct funcID // : uint
        {
        }

        private static readonly funcID funcID_normal = iota; // not a special function
        private static readonly var funcID_goexit = 0;
        private static readonly var funcID_jmpdefer = 1;
        private static readonly var funcID_mcall = 2;
        private static readonly var funcID_morestack = 3;
        private static readonly var funcID_mstart = 4;
        private static readonly var funcID_rt0_go = 5;
        private static readonly var funcID_asmcgocall = 6;
        private static readonly var funcID_sigpanic = 7;
        private static readonly var funcID_runfinq = 8;
        private static readonly var funcID_bgsweep = 9;
        private static readonly var funcID_forcegchelper = 10;
        private static readonly var funcID_timerproc = 11;
        private static readonly var funcID_gcBgMarkWorker = 12;
        private static readonly var funcID_systemstack_switch = 13;
        private static readonly var funcID_systemstack = 14;
        private static readonly var funcID_cgocallback_gofunc = 15;
        private static readonly var funcID_gogo = 16;
        private static readonly var funcID_externalthreadhandler = 17;

        // moduledata records information about the layout of the executable
        // image. It is written by the linker. Any changes here must be
        // matched changes to the code in cmd/internal/ld/symtab.go:symtab.
        // moduledata is stored in statically allocated non-pointer memory;
        // none of the pointers here are visible to the garbage collector.
        private partial struct moduledata
        {
            public slice<byte> pclntable;
            public slice<functab> ftab;
            public slice<uint> filetab;
            public System.UIntPtr findfunctab;
            public System.UIntPtr minpc;
            public System.UIntPtr maxpc;
            public System.UIntPtr text;
            public System.UIntPtr etext;
            public System.UIntPtr noptrdata;
            public System.UIntPtr enoptrdata;
            public System.UIntPtr data;
            public System.UIntPtr edata;
            public System.UIntPtr bss;
            public System.UIntPtr ebss;
            public System.UIntPtr noptrbss;
            public System.UIntPtr enoptrbss;
            public System.UIntPtr end;
            public System.UIntPtr gcdata;
            public System.UIntPtr gcbss;
            public System.UIntPtr types;
            public System.UIntPtr etypes;
            public slice<textsect> textsectmap;
            public slice<int> typelinks; // offsets from types
            public slice<ref itab> itablinks;
            public slice<ptabEntry> ptab;
            public @string pluginpath;
            public slice<modulehash> pkghashes;
            public @string modulename;
            public slice<modulehash> modulehashes;
            public byte hasmain; // 1 if module contains the main function, 0 otherwise

            public bitvector gcdatamask;
            public bitvector gcbssmask;
            public map<typeOff, ref _type> typemap; // offset to *_rtype in previous module

            public bool bad; // module failed to load and should be ignored

            public ptr<moduledata> next;
        }

        // A modulehash is used to compare the ABI of a new module or a
        // package in a new module with the loaded program.
        //
        // For each shared library a module links against, the linker creates an entry in the
        // moduledata.modulehashes slice containing the name of the module, the abi hash seen
        // at link time and a pointer to the runtime abi hash. These are checked in
        // moduledataverify1 below.
        //
        // For each loaded plugin, the pkghashes slice has a modulehash of the
        // newly loaded package that can be used to check the plugin's version of
        // a package against any previously loaded version of the package.
        // This is done in plugin.lastmoduleinit.
        private partial struct modulehash
        {
            public @string modulename;
            public @string linktimehash;
            public ptr<@string> runtimehash;
        }

        // pinnedTypemaps are the map[typeOff]*_type from the moduledata objects.
        //
        // These typemap objects are allocated at run time on the heap, but the
        // only direct reference to them is in the moduledata, created by the
        // linker and marked SNOPTRDATA so it is ignored by the GC.
        //
        // To make sure the map isn't collected, we keep a second reference here.
        private static slice<map<typeOff, ref _type>> pinnedTypemaps = default;

        private static moduledata firstmoduledata = default; // linker symbol
        private static ref moduledata lastmoduledatap = default; // linker symbol
        private static ref slice<ref moduledata> modulesSlice = default; // see activeModules

        // activeModules returns a slice of active modules.
        //
        // A module is active once its gcdatamask and gcbssmask have been
        // assembled and it is usable by the GC.
        //
        // This is nosplit/nowritebarrier because it is called by the
        // cgo pointer checking code.
        //go:nosplit
        //go:nowritebarrier
        private static slice<ref moduledata> activeModules()
        {
            ref slice<ref moduledata> p = new ptr<ref slice<ref moduledata>>(atomic.Loadp(@unsafe.Pointer(ref modulesSlice)));
            if (p == null)
            {
                return null;
            }
            return p.Value;
        }

        // modulesinit creates the active modules slice out of all loaded modules.
        //
        // When a module is first loaded by the dynamic linker, an .init_array
        // function (written by cmd/link) is invoked to call addmoduledata,
        // appending to the module to the linked list that starts with
        // firstmoduledata.
        //
        // There are two times this can happen in the lifecycle of a Go
        // program. First, if compiled with -linkshared, a number of modules
        // built with -buildmode=shared can be loaded at program initialization.
        // Second, a Go program can load a module while running that was built
        // with -buildmode=plugin.
        //
        // After loading, this function is called which initializes the
        // moduledata so it is usable by the GC and creates a new activeModules
        // list.
        //
        // Only one goroutine may call modulesinit at a time.
        private static void modulesinit()
        {
            var modules = @new<slice<ref moduledata>>();
            {
                var md__prev1 = md;

                var md = ref firstmoduledata;

                while (md != null)
                {
                    if (md.bad)
                    {
                        continue;
                    md = md.next;
                    }
                    modules.Value = append(modules.Value, md);
                    if (md.gcdatamask == (new bitvector()))
                    {
                        md.gcdatamask = progToPointerMask((byte.Value)(@unsafe.Pointer(md.gcdata)), md.edata - md.data);
                        md.gcbssmask = progToPointerMask((byte.Value)(@unsafe.Pointer(md.gcbss)), md.ebss - md.bss);
                    }
                } 

                // Modules appear in the moduledata linked list in the order they are
                // loaded by the dynamic loader, with one exception: the
                // firstmoduledata itself the module that contains the runtime. This
                // is not always the first module (when using -buildmode=shared, it
                // is typically libstd.so, the second module). The order matters for
                // typelinksinit, so we swap the first module with whatever module
                // contains the main function.
                //
                // See Issue #18729.


                md = md__prev1;
            } 

            // Modules appear in the moduledata linked list in the order they are
            // loaded by the dynamic loader, with one exception: the
            // firstmoduledata itself the module that contains the runtime. This
            // is not always the first module (when using -buildmode=shared, it
            // is typically libstd.so, the second module). The order matters for
            // typelinksinit, so we swap the first module with whatever module
            // contains the main function.
            //
            // See Issue #18729.
            {
                var md__prev1 = md;

                foreach (var (__i, __md) in modules.Value)
                {
                    i = __i;
                    md = __md;
                    if (md.hasmain != 0L)
                    {
                        (modules.Value)[0L] = md;
                        (modules.Value)[i] = ref firstmoduledata;
                        break;
                    }
                }

                md = md__prev1;
            }

            atomicstorep(@unsafe.Pointer(ref modulesSlice), @unsafe.Pointer(modules));
        }

        private partial struct functab
        {
            public System.UIntPtr entry;
            public System.UIntPtr funcoff;
        }

        // Mapping information for secondary text sections

        private partial struct textsect
        {
            public System.UIntPtr vaddr; // prelinked section vaddr
            public System.UIntPtr length; // section length
            public System.UIntPtr baseaddr; // relocated section address
        }

        private static readonly long minfunc = 16L; // minimum function size
 // minimum function size
        private static readonly long pcbucketsize = 256L * minfunc; // size of bucket in the pc->func lookup table

        // findfunctab is an array of these structures.
        // Each bucket represents 4096 bytes of the text segment.
        // Each subbucket represents 256 bytes of the text segment.
        // To find a function given a pc, locate the bucket and subbucket for
        // that pc. Add together the idx and subbucket value to obtain a
        // function index. Then scan the functab array starting at that
        // index to find the target function.
        // This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead.
 // size of bucket in the pc->func lookup table

        // findfunctab is an array of these structures.
        // Each bucket represents 4096 bytes of the text segment.
        // Each subbucket represents 256 bytes of the text segment.
        // To find a function given a pc, locate the bucket and subbucket for
        // that pc. Add together the idx and subbucket value to obtain a
        // function index. Then scan the functab array starting at that
        // index to find the target function.
        // This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead.
        private partial struct findfuncbucket
        {
            public uint idx;
            public array<byte> subbuckets;
        }

        private static void moduledataverify()
        {
            {
                var datap = ref firstmoduledata;

                while (datap != null)
                {
                    moduledataverify1(datap);
                    datap = datap.next;
                }

            }
        }

        private static readonly var debugPcln = false;



        private static void moduledataverify1(ref moduledata datap)
        { 
            // See golang.org/s/go12symtab for header: 0xfffffffb,
            // two zero bytes, a byte giving the PC quantum,
            // and a byte giving the pointer width in bytes.
            *(ptr<ptr<array<byte>>>) pcln = new ptr<*(ptr<ptr<array<byte>>>)>(@unsafe.Pointer(ref datap.pclntable));
            *(ptr<ptr<array<uint>>>) pcln32 = new ptr<*(ptr<ptr<array<uint>>>)>(@unsafe.Pointer(ref datap.pclntable));
            if (pcln32[0L] != 0xfffffffbUL || pcln[4L] != 0L || pcln[5L] != 0L || pcln[6L] != sys.PCQuantum || pcln[7L] != sys.PtrSize)
            {
                println("runtime: function symbol table header:", hex(pcln32[0L]), hex(pcln[4L]), hex(pcln[5L]), hex(pcln[6L]), hex(pcln[7L]));
                throw("invalid function symbol table\n");
            } 

            // ftab is lookup table for function by program counter.
            var nftab = len(datap.ftab) - 1L;
            for (long i = 0L; i < nftab; i++)
            { 
                // NOTE: ftab[nftab].entry is legal; it is the address beyond the final function.
                if (datap.ftab[i].entry > datap.ftab[i + 1L].entry)
                {
                    funcInfo f1 = new funcInfo((*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])),datap);
                    funcInfo f2 = new funcInfo((*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])),datap);
                    @string f2name = "end";
                    if (i + 1L < nftab)
                    {
                        f2name = funcname(f2);
                    }
                    println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i + 1L].entry), f2name);
                    for (long j = 0L; j <= i; j++)
                    {
                        print("\t", hex(datap.ftab[j].entry), " ", funcname(new funcInfo((*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])),datap)), "\n");
                    }

                    throw("invalid runtime symbol table");
                }
            }


            if (datap.minpc != datap.ftab[0L].entry || datap.maxpc != datap.ftab[nftab].entry)
            {
                throw("minpc or maxpc invalid");
            }
            foreach (var (_, modulehash) in datap.modulehashes)
            {
                if (modulehash.linktimehash != modulehash.runtimehash.Value)
                {
                    println("abi mismatch detected between", datap.modulename, "and", modulehash.modulename);
                    throw("abi mismatch");
                }
            }
        }

        // FuncForPC returns a *Func describing the function that contains the
        // given program counter address, or else nil.
        //
        // If pc represents multiple functions because of inlining, it returns
        // the *Func describing the outermost function.
        public static ref Func FuncForPC(System.UIntPtr pc)
        {
            return findfunc(pc)._Func();
        }

        // Name returns the name of the function.
        private static @string Name(this ref Func f)
        {
            if (f == null)
            {
                return "";
            }
            return funcname(f.funcInfo());
        }

        // Entry returns the entry address of the function.
        private static System.UIntPtr Entry(this ref Func f)
        {
            return f.raw().entry;
        }

        // FileLine returns the file name and line number of the
        // source code corresponding to the program counter pc.
        // The result will not be accurate if pc is not a program
        // counter within f.
        private static (@string, long) FileLine(this ref Func f, System.UIntPtr pc)
        { 
            // Pass strict=false here, because anyone can call this function,
            // and they might just be wrong about targetpc belonging to f.
            var (file, line32) = funcline1(f.funcInfo(), pc, false);
            return (file, int(line32));
        }

        private static ref moduledata findmoduledatap(System.UIntPtr pc)
        {
            {
                var datap = ref firstmoduledata;

                while (datap != null)
                {
                    if (datap.minpc <= pc && pc < datap.maxpc)
                    {
                        return datap;
                    datap = datap.next;
                    }
                }

            }
            return null;
        }

        private partial struct funcInfo
        {
            public ref _func _func => ref _func_ptr;
            public ptr<moduledata> datap;
        }

        private static bool valid(this funcInfo f)
        {
            return f._func != null;
        }

        private static ref Func _Func(this funcInfo f)
        {
            return (Func.Value)(@unsafe.Pointer(f._func));
        }

        private static funcInfo findfunc(System.UIntPtr pc)
        {
            var datap = findmoduledatap(pc);
            if (datap == null)
            {
                return new funcInfo();
            }
            const var nsub = uintptr(len(new findfuncbucket().subbuckets));



            var x = pc - datap.minpc;
            var b = x / pcbucketsize;
            var i = x % pcbucketsize / (pcbucketsize / nsub);

            var ffb = (findfuncbucket.Value)(add(@unsafe.Pointer(datap.findfunctab), b * @unsafe.Sizeof(new findfuncbucket())));
            var idx = ffb.idx + uint32(ffb.subbuckets[i]); 

            // If the idx is beyond the end of the ftab, set it to the end of the table and search backward.
            // This situation can occur if multiple text sections are generated to handle large text sections
            // and the linker has inserted jump tables between them.

            if (idx >= uint32(len(datap.ftab)))
            {
                idx = uint32(len(datap.ftab) - 1L);
            }
            if (pc < datap.ftab[idx].entry)
            { 
                // With multiple text sections, the idx might reference a function address that
                // is higher than the pc being searched, so search backward until the matching address is found.

                while (datap.ftab[idx].entry > pc && idx > 0L)
                {
                    idx--;
                }
            else

                if (idx == 0L)
                {
                    throw("findfunc: bad findfunctab entry idx");
                }
            }            { 
                // linear search to find func with pc >= entry.
                while (datap.ftab[idx + 1L].entry <= pc)
                {
                    idx++;
                }

            }
            return new funcInfo((*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff])),datap);
        }

        private partial struct pcvalueCache
        {
            public array<pcvalueCacheEnt> entries;
        }

        private partial struct pcvalueCacheEnt
        {
            public System.UIntPtr targetpc;
            public int off; // val is the value of this cached pcvalue entry.
            public int val;
        }

        private static int pcvalue(funcInfo f, int off, System.UIntPtr targetpc, ref pcvalueCache cache, bool strict)
        {
            if (off == 0L)
            {
                return -1L;
            } 

            // Check the cache. This speeds up walks of deep stacks, which
            // tend to have the same recursive functions over and over.
            //
            // This cache is small enough that full associativity is
            // cheaper than doing the hashing for a less associative
            // cache.
            if (cache != null)
            {
                foreach (var (i) in cache.entries)
                { 
                    // We check off first because we're more
                    // likely to have multiple entries with
                    // different offsets for the same targetpc
                    // than the other way around, so we'll usually
                    // fail in the first clause.
                    var ent = ref cache.entries[i];
                    if (ent.off == off && ent.targetpc == targetpc)
                    {
                        return ent.val;
                    }
                }
            }
            if (!f.valid())
            {
                if (strict && panicking == 0L)
                {
                    print("runtime: no module data for ", hex(f.entry), "\n");
                    throw("no module data");
                }
                return -1L;
            }
            var datap = f.datap;
            var p = datap.pclntable[off..];
            var pc = f.entry;
            var val = int32(-1L);
            while (true)
            {
                bool ok = default;
                p, ok = step(p, ref pc, ref val, pc == f.entry);
                if (!ok)
                {
                    break;
                }
                if (targetpc < pc)
                { 
                    // Replace a random entry in the cache. Random
                    // replacement prevents a performance cliff if
                    // a recursive stack's cycle is slightly
                    // larger than the cache.
                    if (cache != null)
                    {
                        var ci = fastrandn(uint32(len(cache.entries)));
                        cache.entries[ci] = new pcvalueCacheEnt(targetpc:targetpc,off:off,val:val,);
                    }
                    return val;
                }
            } 

            // If there was a table, it should have covered all program counters.
            // If not, something is wrong.
 

            // If there was a table, it should have covered all program counters.
            // If not, something is wrong.
            if (panicking != 0L || !strict)
            {
                return -1L;
            }
            print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n");

            p = datap.pclntable[off..];
            pc = f.entry;
            val = -1L;
            while (true)
            {
                ok = default;
                p, ok = step(p, ref pc, ref val, pc == f.entry);
                if (!ok)
                {
                    break;
                }
                print("\tvalue=", val, " until pc=", hex(pc), "\n");
            }


            throw("invalid runtime symbol table");
            return -1L;
        }

        private static ref byte cfuncname(funcInfo f)
        {
            if (!f.valid() || f.nameoff == 0L)
            {
                return null;
            }
            return ref f.datap.pclntable[f.nameoff];
        }

        private static @string funcname(funcInfo f)
        {
            return gostringnocopy(cfuncname(f));
        }

        private static @string funcnameFromNameoff(funcInfo f, int nameoff)
        {
            var datap = f.datap;
            if (!f.valid())
            {
                return "";
            }
            var cstr = ref datap.pclntable[nameoff];
            return gostringnocopy(cstr);
        }

        private static @string funcfile(funcInfo f, int fileno)
        {
            var datap = f.datap;
            if (!f.valid())
            {
                return "?";
            }
            return gostringnocopy(ref datap.pclntable[datap.filetab[fileno]]);
        }

        private static (@string, int) funcline1(funcInfo f, System.UIntPtr targetpc, bool strict)
        {
            var datap = f.datap;
            if (!f.valid())
            {
                return ("?", 0L);
            }
            var fileno = int(pcvalue(f, f.pcfile, targetpc, null, strict));
            line = pcvalue(f, f.pcln, targetpc, null, strict);
            if (fileno == -1L || line == -1L || fileno >= len(datap.filetab))
            { 
                // print("looking for ", hex(targetpc), " in ", funcname(f), " got file=", fileno, " line=", lineno, "\n")
                return ("?", 0L);
            }
            file = gostringnocopy(ref datap.pclntable[datap.filetab[fileno]]);
            return;
        }

        private static (@string, int) funcline(funcInfo f, System.UIntPtr targetpc)
        {
            return funcline1(f, targetpc, true);
        }

        private static int funcspdelta(funcInfo f, System.UIntPtr targetpc, ref pcvalueCache cache)
        {
            var x = pcvalue(f, f.pcsp, targetpc, cache, true);
            if (x & (sys.PtrSize - 1L) != 0L)
            {
                print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n");
            }
            return x;
        }

        private static int pcdatavalue(funcInfo f, int table, System.UIntPtr targetpc, ref pcvalueCache cache)
        {
            if (table < 0L || table >= f.npcdata)
            {
                return -1L;
            }
            *(*int) off = add(@unsafe.Pointer(ref f.nfuncdata), @unsafe.Sizeof(f.nfuncdata) + uintptr(table) * 4L).Value;
            return pcvalue(f, off, targetpc, cache, true);
        }

        private static unsafe.Pointer funcdata(funcInfo f, int i)
        {
            if (i < 0L || i >= f.nfuncdata)
            {
                return null;
            }
            var p = add(@unsafe.Pointer(ref f.nfuncdata), @unsafe.Sizeof(f.nfuncdata) + uintptr(f.npcdata) * 4L);
            if (sys.PtrSize == 8L && uintptr(p) & 4L != 0L)
            {
                if (uintptr(@unsafe.Pointer(f._func)) & 4L != 0L)
                {
                    println("runtime: misaligned func", f._func);
                }
                p = add(p, 4L);
            }
            return add(p, uintptr(i) * sys.PtrSize).Value;
        }

        // step advances to the next pc, value pair in the encoded table.
        private static (slice<byte>, bool) step(slice<byte> p, ref System.UIntPtr pc, ref int val, bool first)
        { 
            // For both uvdelta and pcdelta, the common case (~70%)
            // is that they are a single byte. If so, avoid calling readvarint.
            var uvdelta = uint32(p[0L]);
            if (uvdelta == 0L && !first)
            {
                return (null, false);
            }
            var n = uint32(1L);
            if (uvdelta & 0x80UL != 0L)
            {
                n, uvdelta = readvarint(p);
            }
            p = p[n..];
            if (uvdelta & 1L != 0L)
            {
                uvdelta = ~(uvdelta >> (int)(1L));
            }
            else
            {
                uvdelta >>= 1L;
            }
            var vdelta = int32(uvdelta);
            var pcdelta = uint32(p[0L]);
            n = 1L;
            if (pcdelta & 0x80UL != 0L)
            {
                n, pcdelta = readvarint(p);
            }
            p = p[n..];
            pc.Value += uintptr(pcdelta * sys.PCQuantum);
            val.Value += vdelta;
            return (p, true);
        }

        // readvarint reads a varint from p.
        private static (uint, uint) readvarint(slice<byte> p)
        {
            uint v = default;            uint shift = default;            uint n = default;

            while (true)
            {
                var b = p[n];
                n++;
                v |= uint32(b & 0x7FUL) << (int)((shift & 31L));
                if (b & 0x80UL == 0L)
                {
                    break;
                }
                shift += 7L;
            }

            return (n, v);
        }

        private partial struct stackmap
        {
            public int n; // number of bitmaps
            public int nbit; // number of bits in each bitmap
            public array<byte> bytedata; // bitmaps, each starting on a byte boundary
        }

        //go:nowritebarrier
        private static bitvector stackmapdata(ref stackmap stkmap, int n)
        {
            if (n < 0L || n >= stkmap.n)
            {
                throw("stackmapdata: index out of range");
            }
            return new bitvector(stkmap.nbit,(*byte)(add(unsafe.Pointer(&stkmap.bytedata),uintptr(n*((stkmap.nbit+7)>>3)))));
        }

        // inlinedCall is the encoding of entries in the FUNCDATA_InlTree table.
        private partial struct inlinedCall
        {
            public int parent; // index of parent in the inltree, or < 0
            public int file; // fileno index into filetab
            public int line; // line number of the call site
            public int func_; // offset into pclntab for name of called function
        }
    }
}
