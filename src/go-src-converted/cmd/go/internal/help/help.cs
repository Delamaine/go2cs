// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package help implements the ``go help'' command.
// package help -- go2cs converted at 2020 August 29 10:00:39 UTC
// import "cmd/go/internal/help" ==> using help = go.cmd.go.@internal.help_package
// Original source: C:\Go\src\cmd\go\internal\help\help.go
using bufio = go.bufio_package;
using bytes = go.bytes_package;
using fmt = go.fmt_package;
using io = go.io_package;
using os = go.os_package;
using strings = go.strings_package;
using template = go.text.template_package;
using unicode = go.unicode_package;
using utf8 = go.unicode.utf8_package;

using @base = go.cmd.go.@internal.@base_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace go {
namespace @internal
{
    public static partial class help_package
    {
        // Help implements the 'help' command.
        public static void Help(slice<@string> args)
        {
            if (len(args) == 0L)
            {
                PrintUsage(os.Stdout); 
                // not exit 2: succeeded at 'go help'.
                return;
            }
            if (len(args) != 1L)
            {
                fmt.Fprintf(os.Stderr, "usage: go help command\n\nToo many arguments given.\n");
                os.Exit(2L); // failed at 'go help'
            }
            var arg = args[0L]; 

            // 'go help documentation' generates doc.go.
            if (arg == "documentation")
            {
                fmt.Println("// Copyright 2011 The Go Authors. All rights reserved.");
                fmt.Println("// Use of this source code is governed by a BSD-style");
                fmt.Println("// license that can be found in the LICENSE file.");
                fmt.Println();
                fmt.Println("// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.");
                fmt.Println("// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.");
                fmt.Println();
                ptr<object> buf = @new<bytes.Buffer>();
                PrintUsage(buf);
                base.Command usage = ref new base.Command(Long:buf.String());
                tmpl(ref new commentWriter(W:os.Stdout), documentationTemplate, append(new slice<ref base.Command>(new ref base.Command[] { usage }), @base.Commands));
                fmt.Println("package main");
                return;
            }
            foreach (var (_, cmd) in @base.Commands)
            {
                if (cmd.Name() == arg)
                {
                    tmpl(os.Stdout, helpTemplate, cmd); 
                    // not exit 2: succeeded at 'go help cmd'.
                    return;
                }
            }            fmt.Fprintf(os.Stderr, "Unknown help topic %#q. Run 'go help'.\n", arg);
            os.Exit(2L); // failed at 'go help cmd'
        }

        private static @string usageTemplate = @"Go is a tool for managing Go source code.

Usage:

	go command [arguments]

The commands are:
{{range .}}{{if .Runnable}}
	{{.Name | printf ""%-11s""}} {{.Short}}{{end}}{{end}}

Use ""go help [command]"" for more information about a command.

Additional help topics:
{{range .}}{{if not .Runnable}}
	{{.Name | printf ""%-11s""}} {{.Short}}{{end}}{{end}}

Use ""go help [topic]"" for more information about that topic.

";

        private static @string helpTemplate = "{{if .Runnable}}usage: go {{.UsageLine}}\n\n{{end}}{{.Long | trim}}\n";

        private static @string documentationTemplate = "{{range .}}{{if .Short}}{{.Short | capitalize}}\n\n{{end}}{{if .Runnable}}Usage:\n\n\t" +
    "go {{.UsageLine}}\n\n{{end}}{{.Long | trim}}\n\n\n{{end}}";

        // commentWriter writes a Go comment to the underlying io.Writer,
        // using line comment form (//).
        private partial struct commentWriter
        {
            public io.Writer W;
            public bool wroteSlashes; // Wrote "//" at the beginning of the current line.
        }

        private static (long, error) Write(this ref commentWriter c, slice<byte> p)
        {
            long n = default;
            foreach (var (i, b) in p)
            {
                if (!c.wroteSlashes)
                {
                    @string s = "//";
                    if (b != '\n')
                    {
                        s = "// ";
                    }
                    {
                        var (_, err) = io.WriteString(c.W, s);

                        if (err != null)
                        {
                            return (n, err);
                        }

                    }
                    c.wroteSlashes = true;
                }
                var (n0, err) = c.W.Write(p[i..i + 1L]);
                n += n0;
                if (err != null)
                {
                    return (n, err);
                }
                if (b == '\n')
                {
                    c.wroteSlashes = false;
                }
            }
            return (len(p), null);
        }

        // An errWriter wraps a writer, recording whether a write error occurred.
        private partial struct errWriter
        {
            public io.Writer w;
            public error err;
        }

        private static (long, error) Write(this ref errWriter w, slice<byte> b)
        {
            var (n, err) = w.w.Write(b);
            if (err != null)
            {
                w.err = err;
            }
            return (n, err);
        }

        // tmpl executes the given template text on data, writing the result to w.
        private static void tmpl(io.Writer w, @string text, object data) => func((_, panic, __) =>
        {
            var t = template.New("top");
            t.Funcs(new template.FuncMap("trim":strings.TrimSpace,"capitalize":capitalize));
            template.Must(t.Parse(text));
            errWriter ew = ref new errWriter(w:w);
            var err = t.Execute(ew, data);
            if (ew.err != null)
            { 
                // I/O error writing. Ignore write on closed pipe.
                if (strings.Contains(ew.err.Error(), "pipe"))
                {
                    os.Exit(1L);
                }
                @base.Fatalf("writing output: %v", ew.err);
            }
            if (err != null)
            {
                panic(err);
            }
        });

        private static @string capitalize(@string s)
        {
            if (s == "")
            {
                return s;
            }
            var (r, n) = utf8.DecodeRuneInString(s);
            return string(unicode.ToTitle(r)) + s[n..];
        }

        public static void PrintUsage(io.Writer w)
        {
            var bw = bufio.NewWriter(w);
            tmpl(bw, usageTemplate, @base.Commands);
            bw.Flush();
        }
    }
}}}}
