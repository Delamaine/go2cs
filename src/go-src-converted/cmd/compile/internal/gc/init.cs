// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package gc -- go2cs converted at 2020 August 29 09:27:12 UTC
// import "cmd/compile/internal/gc" ==> using gc = go.cmd.compile.@internal.gc_package
// Original source: C:\Go\src\cmd\compile\internal\gc\init.go
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class gc_package
    {
        // A function named init is a special case.
        // It is called by the initialization before main is run.
        // To make it unique within a package and also uncallable,
        // the name, normally "pkg.init", is altered to "pkg.init.0".
        private static long renameinitgen = default;

        private static ref types.Sym renameinit()
        {
            var s = lookupN("init.", renameinitgen);
            renameinitgen++;
            return s;
        }

        // anyinit reports whether there any interesting init statements.
        private static bool anyinit(slice<ref Node> n)
        {
            foreach (var (_, ln) in n)
            {

                if (ln.Op == ODCLFUNC || ln.Op == ODCLCONST || ln.Op == ODCLTYPE || ln.Op == OEMPTY)                 else if (ln.Op == OAS) 
                    if (!isblank(ln.Left) || !candiscard(ln.Right))
                    {
                        return true;
                    }
                else 
                    return true;
                            } 

            // is this main
            if (localpkg.Name == "main")
            {
                return true;
            } 

            // is there an explicit init function
            if (renameinitgen > 0L)
            {
                return true;
            } 

            // are there any imported init functions
            foreach (var (_, s) in types.InitSyms)
            {
                if (s.Def != null)
                {
                    return true;
                }
            } 

            // then none
            return false;
        }

        // fninit hand-crafts package initialization code.
        //
        //      var initdone· uint8                             (1)
        //      func init() {                                   (2)
        //              if initdone· > 1 {                      (3)
        //                      return                          (3a)
        //              }
        //              if initdone· == 1 {                     (4)
        //                      throw()                         (4a)
        //              }
        //              initdone· = 1                           (5)
        //              // over all matching imported symbols
        //                      <pkg>.init()                    (6)
        //              { <init stmts> }                        (7)
        //              init.<n>() // if any                    (8)
        //              initdone· = 2                           (9)
        //              return                                  (10)
        //      }
        private static void fninit(slice<ref Node> n)
        {
            lineno = autogeneratedPos;
            var nf = initfix(n);
            if (!anyinit(nf))
            {
                return;
            }
            slice<ref Node> r = default; 

            // (1)
            var gatevar = newname(lookup("initdone·"));
            addvar(gatevar, types.Types[TUINT8], PEXTERN); 

            // (2)
            var initsym = lookup("init");
            var fn = dclfunc(initsym, nod(OTFUNC, null, null)); 

            // (3)
            var a = nod(OIF, null, null);
            a.Left = nod(OGT, gatevar, nodintconst(1L));
            a.SetLikely(true);
            r = append(r, a); 
            // (3a)
            a.Nbody.Set1(nod(ORETURN, null, null)); 

            // (4)
            var b = nod(OIF, null, null);
            b.Left = nod(OEQ, gatevar, nodintconst(1L)); 
            // this actually isn't likely, but code layout is better
            // like this: no JMP needed after the call.
            b.SetLikely(true);
            r = append(r, b); 
            // (4a)
            b.Nbody.Set1(nod(OCALL, syslook("throwinit"), null)); 

            // (5)
            a = nod(OAS, gatevar, nodintconst(1L));

            r = append(r, a); 

            // (6)
            {
                var s__prev1 = s;

                foreach (var (_, __s) in types.InitSyms)
                {
                    s = __s;
                    if (s.Def != null && s != initsym)
                    {
                        var n = asNode(s.Def);
                        n.checkInitFuncSignature();
                        a = nod(OCALL, n, null);
                        r = append(r, a);
                    }
                } 

                // (7)

                s = s__prev1;
            }

            r = append(r, nf); 

            // (8)

            // maxInlineInitCalls is the threshold at which we switch
            // from generating calls inline to generating a static array
            // of functions and calling them in a loop.
            // See CL 41500 for more discussion.
            const long maxInlineInitCalls = 500L;



            if (renameinitgen < maxInlineInitCalls)
            { 
                // Not many init functions. Just call them all directly.
                {
                    long i__prev1 = i;

                    for (long i = 0L; i < renameinitgen; i++)
                    {
                        var s = lookupN("init.", i);
                        n = asNode(s.Def);
                        n.checkInitFuncSignature();
                        a = nod(OCALL, n, null);
                        r = append(r, a);
                    }
            else


                    i = i__prev1;
                }
            }            { 
                // Lots of init functions.
                // Set up an array of functions and loop to call them.
                // This is faster to compile and similar at runtime.

                // Build type [renameinitgen]func().
                var typ = types.NewArray(functype(null, null, null), int64(renameinitgen)); 

                // Make and fill array.
                var fnarr = staticname(typ);
                fnarr.Name.SetReadonly(true);
                {
                    long i__prev1 = i;

                    for (i = 0L; i < renameinitgen; i++)
                    {
                        s = lookupN("init.", i);
                        var lhs = nod(OINDEX, fnarr, nodintconst(int64(i)));
                        var rhs = asNode(s.Def);
                        rhs.checkInitFuncSignature();
                        var @as = nod(OAS, lhs, rhs);
                        as = typecheck(as, Etop);
                        genAsStatic(as);
                    } 

                    // Generate a loop that calls each function in turn.
                    // for i := 0; i < renameinitgen; i++ {
                    //   fnarr[i]()
                    // }


                    i = i__prev1;
                } 

                // Generate a loop that calls each function in turn.
                // for i := 0; i < renameinitgen; i++ {
                //   fnarr[i]()
                // }
                i = temp(types.Types[TINT]);
                var fnidx = nod(OINDEX, fnarr, i);
                fnidx.SetBounded(true);

                var zero = nod(OAS, i, nodintconst(0L));
                var cond = nod(OLT, i, nodintconst(int64(renameinitgen)));
                var incr = nod(OAS, i, nod(OADD, i, nodintconst(1L)));
                var body = nod(OCALL, fnidx, null);

                var loop = nod(OFOR, cond, incr);
                loop.Nbody.Set1(body);
                loop.Ninit.Set1(zero);

                loop = typecheck(loop, Etop);
                loop = walkstmt(loop);
                r = append(r, loop);
            } 

            // (9)
            a = nod(OAS, gatevar, nodintconst(2L));

            r = append(r, a); 

            // (10)
            a = nod(ORETURN, null, null);

            r = append(r, a);
            exportsym(fn.Func.Nname);

            fn.Nbody.Set(r);
            funcbody();

            Curfn = fn;
            fn = typecheck(fn, Etop);
            typecheckslice(r, Etop);
            Curfn = null;
            funccompile(fn);
        }

        private static void checkInitFuncSignature(this ref Node n)
        {
            if (n.Type.NumRecvs() + n.Type.NumParams() + n.Type.NumResults() > 0L)
            {
                Fatalf("init function cannot have receiver, params, or results: %v (%v)", n, n.Type);
            }
        }
    }
}}}}
