// Code generated from gen/S390X.rules; DO NOT EDIT.
// generated with: cd gen; go run *.go

// package ssa -- go2cs converted at 2020 August 29 09:24:03 UTC
// import "cmd/compile/internal/ssa" ==> using ssa = go.cmd.compile.@internal.ssa_package
// Original source: C:\Go\src\cmd\compile\internal\ssa\rewriteS390X.go
using math = go.math_package;
using obj = go.cmd.@internal.obj_package;
using objabi = go.cmd.@internal.objabi_package;
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        private static var _ = math.MinInt8; // in case not otherwise used
        private static var _ = obj.ANOP; // in case not otherwise used
        private static var _ = objabi.GOROOT; // in case not otherwise used
        private static var _ = types.TypeMem; // in case not otherwise used

        private static bool rewriteValueS390X(ref Value v)
        {

            if (v.Op == OpAdd16) 
                return rewriteValueS390X_OpAdd16_0(v);
            else if (v.Op == OpAdd32) 
                return rewriteValueS390X_OpAdd32_0(v);
            else if (v.Op == OpAdd32F) 
                return rewriteValueS390X_OpAdd32F_0(v);
            else if (v.Op == OpAdd64) 
                return rewriteValueS390X_OpAdd64_0(v);
            else if (v.Op == OpAdd64F) 
                return rewriteValueS390X_OpAdd64F_0(v);
            else if (v.Op == OpAdd8) 
                return rewriteValueS390X_OpAdd8_0(v);
            else if (v.Op == OpAddPtr) 
                return rewriteValueS390X_OpAddPtr_0(v);
            else if (v.Op == OpAddr) 
                return rewriteValueS390X_OpAddr_0(v);
            else if (v.Op == OpAnd16) 
                return rewriteValueS390X_OpAnd16_0(v);
            else if (v.Op == OpAnd32) 
                return rewriteValueS390X_OpAnd32_0(v);
            else if (v.Op == OpAnd64) 
                return rewriteValueS390X_OpAnd64_0(v);
            else if (v.Op == OpAnd8) 
                return rewriteValueS390X_OpAnd8_0(v);
            else if (v.Op == OpAndB) 
                return rewriteValueS390X_OpAndB_0(v);
            else if (v.Op == OpAtomicAdd32) 
                return rewriteValueS390X_OpAtomicAdd32_0(v);
            else if (v.Op == OpAtomicAdd64) 
                return rewriteValueS390X_OpAtomicAdd64_0(v);
            else if (v.Op == OpAtomicCompareAndSwap32) 
                return rewriteValueS390X_OpAtomicCompareAndSwap32_0(v);
            else if (v.Op == OpAtomicCompareAndSwap64) 
                return rewriteValueS390X_OpAtomicCompareAndSwap64_0(v);
            else if (v.Op == OpAtomicExchange32) 
                return rewriteValueS390X_OpAtomicExchange32_0(v);
            else if (v.Op == OpAtomicExchange64) 
                return rewriteValueS390X_OpAtomicExchange64_0(v);
            else if (v.Op == OpAtomicLoad32) 
                return rewriteValueS390X_OpAtomicLoad32_0(v);
            else if (v.Op == OpAtomicLoad64) 
                return rewriteValueS390X_OpAtomicLoad64_0(v);
            else if (v.Op == OpAtomicLoadPtr) 
                return rewriteValueS390X_OpAtomicLoadPtr_0(v);
            else if (v.Op == OpAtomicStore32) 
                return rewriteValueS390X_OpAtomicStore32_0(v);
            else if (v.Op == OpAtomicStore64) 
                return rewriteValueS390X_OpAtomicStore64_0(v);
            else if (v.Op == OpAtomicStorePtrNoWB) 
                return rewriteValueS390X_OpAtomicStorePtrNoWB_0(v);
            else if (v.Op == OpAvg64u) 
                return rewriteValueS390X_OpAvg64u_0(v);
            else if (v.Op == OpBitLen64) 
                return rewriteValueS390X_OpBitLen64_0(v);
            else if (v.Op == OpBswap32) 
                return rewriteValueS390X_OpBswap32_0(v);
            else if (v.Op == OpBswap64) 
                return rewriteValueS390X_OpBswap64_0(v);
            else if (v.Op == OpCeil) 
                return rewriteValueS390X_OpCeil_0(v);
            else if (v.Op == OpClosureCall) 
                return rewriteValueS390X_OpClosureCall_0(v);
            else if (v.Op == OpCom16) 
                return rewriteValueS390X_OpCom16_0(v);
            else if (v.Op == OpCom32) 
                return rewriteValueS390X_OpCom32_0(v);
            else if (v.Op == OpCom64) 
                return rewriteValueS390X_OpCom64_0(v);
            else if (v.Op == OpCom8) 
                return rewriteValueS390X_OpCom8_0(v);
            else if (v.Op == OpConst16) 
                return rewriteValueS390X_OpConst16_0(v);
            else if (v.Op == OpConst32) 
                return rewriteValueS390X_OpConst32_0(v);
            else if (v.Op == OpConst32F) 
                return rewriteValueS390X_OpConst32F_0(v);
            else if (v.Op == OpConst64) 
                return rewriteValueS390X_OpConst64_0(v);
            else if (v.Op == OpConst64F) 
                return rewriteValueS390X_OpConst64F_0(v);
            else if (v.Op == OpConst8) 
                return rewriteValueS390X_OpConst8_0(v);
            else if (v.Op == OpConstBool) 
                return rewriteValueS390X_OpConstBool_0(v);
            else if (v.Op == OpConstNil) 
                return rewriteValueS390X_OpConstNil_0(v);
            else if (v.Op == OpConvert) 
                return rewriteValueS390X_OpConvert_0(v);
            else if (v.Op == OpCtz32) 
                return rewriteValueS390X_OpCtz32_0(v);
            else if (v.Op == OpCtz64) 
                return rewriteValueS390X_OpCtz64_0(v);
            else if (v.Op == OpCvt32Fto32) 
                return rewriteValueS390X_OpCvt32Fto32_0(v);
            else if (v.Op == OpCvt32Fto64) 
                return rewriteValueS390X_OpCvt32Fto64_0(v);
            else if (v.Op == OpCvt32Fto64F) 
                return rewriteValueS390X_OpCvt32Fto64F_0(v);
            else if (v.Op == OpCvt32to32F) 
                return rewriteValueS390X_OpCvt32to32F_0(v);
            else if (v.Op == OpCvt32to64F) 
                return rewriteValueS390X_OpCvt32to64F_0(v);
            else if (v.Op == OpCvt64Fto32) 
                return rewriteValueS390X_OpCvt64Fto32_0(v);
            else if (v.Op == OpCvt64Fto32F) 
                return rewriteValueS390X_OpCvt64Fto32F_0(v);
            else if (v.Op == OpCvt64Fto64) 
                return rewriteValueS390X_OpCvt64Fto64_0(v);
            else if (v.Op == OpCvt64to32F) 
                return rewriteValueS390X_OpCvt64to32F_0(v);
            else if (v.Op == OpCvt64to64F) 
                return rewriteValueS390X_OpCvt64to64F_0(v);
            else if (v.Op == OpDiv16) 
                return rewriteValueS390X_OpDiv16_0(v);
            else if (v.Op == OpDiv16u) 
                return rewriteValueS390X_OpDiv16u_0(v);
            else if (v.Op == OpDiv32) 
                return rewriteValueS390X_OpDiv32_0(v);
            else if (v.Op == OpDiv32F) 
                return rewriteValueS390X_OpDiv32F_0(v);
            else if (v.Op == OpDiv32u) 
                return rewriteValueS390X_OpDiv32u_0(v);
            else if (v.Op == OpDiv64) 
                return rewriteValueS390X_OpDiv64_0(v);
            else if (v.Op == OpDiv64F) 
                return rewriteValueS390X_OpDiv64F_0(v);
            else if (v.Op == OpDiv64u) 
                return rewriteValueS390X_OpDiv64u_0(v);
            else if (v.Op == OpDiv8) 
                return rewriteValueS390X_OpDiv8_0(v);
            else if (v.Op == OpDiv8u) 
                return rewriteValueS390X_OpDiv8u_0(v);
            else if (v.Op == OpEq16) 
                return rewriteValueS390X_OpEq16_0(v);
            else if (v.Op == OpEq32) 
                return rewriteValueS390X_OpEq32_0(v);
            else if (v.Op == OpEq32F) 
                return rewriteValueS390X_OpEq32F_0(v);
            else if (v.Op == OpEq64) 
                return rewriteValueS390X_OpEq64_0(v);
            else if (v.Op == OpEq64F) 
                return rewriteValueS390X_OpEq64F_0(v);
            else if (v.Op == OpEq8) 
                return rewriteValueS390X_OpEq8_0(v);
            else if (v.Op == OpEqB) 
                return rewriteValueS390X_OpEqB_0(v);
            else if (v.Op == OpEqPtr) 
                return rewriteValueS390X_OpEqPtr_0(v);
            else if (v.Op == OpFloor) 
                return rewriteValueS390X_OpFloor_0(v);
            else if (v.Op == OpGeq16) 
                return rewriteValueS390X_OpGeq16_0(v);
            else if (v.Op == OpGeq16U) 
                return rewriteValueS390X_OpGeq16U_0(v);
            else if (v.Op == OpGeq32) 
                return rewriteValueS390X_OpGeq32_0(v);
            else if (v.Op == OpGeq32F) 
                return rewriteValueS390X_OpGeq32F_0(v);
            else if (v.Op == OpGeq32U) 
                return rewriteValueS390X_OpGeq32U_0(v);
            else if (v.Op == OpGeq64) 
                return rewriteValueS390X_OpGeq64_0(v);
            else if (v.Op == OpGeq64F) 
                return rewriteValueS390X_OpGeq64F_0(v);
            else if (v.Op == OpGeq64U) 
                return rewriteValueS390X_OpGeq64U_0(v);
            else if (v.Op == OpGeq8) 
                return rewriteValueS390X_OpGeq8_0(v);
            else if (v.Op == OpGeq8U) 
                return rewriteValueS390X_OpGeq8U_0(v);
            else if (v.Op == OpGetCallerSP) 
                return rewriteValueS390X_OpGetCallerSP_0(v);
            else if (v.Op == OpGetClosurePtr) 
                return rewriteValueS390X_OpGetClosurePtr_0(v);
            else if (v.Op == OpGetG) 
                return rewriteValueS390X_OpGetG_0(v);
            else if (v.Op == OpGreater16) 
                return rewriteValueS390X_OpGreater16_0(v);
            else if (v.Op == OpGreater16U) 
                return rewriteValueS390X_OpGreater16U_0(v);
            else if (v.Op == OpGreater32) 
                return rewriteValueS390X_OpGreater32_0(v);
            else if (v.Op == OpGreater32F) 
                return rewriteValueS390X_OpGreater32F_0(v);
            else if (v.Op == OpGreater32U) 
                return rewriteValueS390X_OpGreater32U_0(v);
            else if (v.Op == OpGreater64) 
                return rewriteValueS390X_OpGreater64_0(v);
            else if (v.Op == OpGreater64F) 
                return rewriteValueS390X_OpGreater64F_0(v);
            else if (v.Op == OpGreater64U) 
                return rewriteValueS390X_OpGreater64U_0(v);
            else if (v.Op == OpGreater8) 
                return rewriteValueS390X_OpGreater8_0(v);
            else if (v.Op == OpGreater8U) 
                return rewriteValueS390X_OpGreater8U_0(v);
            else if (v.Op == OpHmul32) 
                return rewriteValueS390X_OpHmul32_0(v);
            else if (v.Op == OpHmul32u) 
                return rewriteValueS390X_OpHmul32u_0(v);
            else if (v.Op == OpHmul64) 
                return rewriteValueS390X_OpHmul64_0(v);
            else if (v.Op == OpHmul64u) 
                return rewriteValueS390X_OpHmul64u_0(v);
            else if (v.Op == OpITab) 
                return rewriteValueS390X_OpITab_0(v);
            else if (v.Op == OpInterCall) 
                return rewriteValueS390X_OpInterCall_0(v);
            else if (v.Op == OpIsInBounds) 
                return rewriteValueS390X_OpIsInBounds_0(v);
            else if (v.Op == OpIsNonNil) 
                return rewriteValueS390X_OpIsNonNil_0(v);
            else if (v.Op == OpIsSliceInBounds) 
                return rewriteValueS390X_OpIsSliceInBounds_0(v);
            else if (v.Op == OpLeq16) 
                return rewriteValueS390X_OpLeq16_0(v);
            else if (v.Op == OpLeq16U) 
                return rewriteValueS390X_OpLeq16U_0(v);
            else if (v.Op == OpLeq32) 
                return rewriteValueS390X_OpLeq32_0(v);
            else if (v.Op == OpLeq32F) 
                return rewriteValueS390X_OpLeq32F_0(v);
            else if (v.Op == OpLeq32U) 
                return rewriteValueS390X_OpLeq32U_0(v);
            else if (v.Op == OpLeq64) 
                return rewriteValueS390X_OpLeq64_0(v);
            else if (v.Op == OpLeq64F) 
                return rewriteValueS390X_OpLeq64F_0(v);
            else if (v.Op == OpLeq64U) 
                return rewriteValueS390X_OpLeq64U_0(v);
            else if (v.Op == OpLeq8) 
                return rewriteValueS390X_OpLeq8_0(v);
            else if (v.Op == OpLeq8U) 
                return rewriteValueS390X_OpLeq8U_0(v);
            else if (v.Op == OpLess16) 
                return rewriteValueS390X_OpLess16_0(v);
            else if (v.Op == OpLess16U) 
                return rewriteValueS390X_OpLess16U_0(v);
            else if (v.Op == OpLess32) 
                return rewriteValueS390X_OpLess32_0(v);
            else if (v.Op == OpLess32F) 
                return rewriteValueS390X_OpLess32F_0(v);
            else if (v.Op == OpLess32U) 
                return rewriteValueS390X_OpLess32U_0(v);
            else if (v.Op == OpLess64) 
                return rewriteValueS390X_OpLess64_0(v);
            else if (v.Op == OpLess64F) 
                return rewriteValueS390X_OpLess64F_0(v);
            else if (v.Op == OpLess64U) 
                return rewriteValueS390X_OpLess64U_0(v);
            else if (v.Op == OpLess8) 
                return rewriteValueS390X_OpLess8_0(v);
            else if (v.Op == OpLess8U) 
                return rewriteValueS390X_OpLess8U_0(v);
            else if (v.Op == OpLoad) 
                return rewriteValueS390X_OpLoad_0(v);
            else if (v.Op == OpLsh16x16) 
                return rewriteValueS390X_OpLsh16x16_0(v);
            else if (v.Op == OpLsh16x32) 
                return rewriteValueS390X_OpLsh16x32_0(v);
            else if (v.Op == OpLsh16x64) 
                return rewriteValueS390X_OpLsh16x64_0(v);
            else if (v.Op == OpLsh16x8) 
                return rewriteValueS390X_OpLsh16x8_0(v);
            else if (v.Op == OpLsh32x16) 
                return rewriteValueS390X_OpLsh32x16_0(v);
            else if (v.Op == OpLsh32x32) 
                return rewriteValueS390X_OpLsh32x32_0(v);
            else if (v.Op == OpLsh32x64) 
                return rewriteValueS390X_OpLsh32x64_0(v);
            else if (v.Op == OpLsh32x8) 
                return rewriteValueS390X_OpLsh32x8_0(v);
            else if (v.Op == OpLsh64x16) 
                return rewriteValueS390X_OpLsh64x16_0(v);
            else if (v.Op == OpLsh64x32) 
                return rewriteValueS390X_OpLsh64x32_0(v);
            else if (v.Op == OpLsh64x64) 
                return rewriteValueS390X_OpLsh64x64_0(v);
            else if (v.Op == OpLsh64x8) 
                return rewriteValueS390X_OpLsh64x8_0(v);
            else if (v.Op == OpLsh8x16) 
                return rewriteValueS390X_OpLsh8x16_0(v);
            else if (v.Op == OpLsh8x32) 
                return rewriteValueS390X_OpLsh8x32_0(v);
            else if (v.Op == OpLsh8x64) 
                return rewriteValueS390X_OpLsh8x64_0(v);
            else if (v.Op == OpLsh8x8) 
                return rewriteValueS390X_OpLsh8x8_0(v);
            else if (v.Op == OpMod16) 
                return rewriteValueS390X_OpMod16_0(v);
            else if (v.Op == OpMod16u) 
                return rewriteValueS390X_OpMod16u_0(v);
            else if (v.Op == OpMod32) 
                return rewriteValueS390X_OpMod32_0(v);
            else if (v.Op == OpMod32u) 
                return rewriteValueS390X_OpMod32u_0(v);
            else if (v.Op == OpMod64) 
                return rewriteValueS390X_OpMod64_0(v);
            else if (v.Op == OpMod64u) 
                return rewriteValueS390X_OpMod64u_0(v);
            else if (v.Op == OpMod8) 
                return rewriteValueS390X_OpMod8_0(v);
            else if (v.Op == OpMod8u) 
                return rewriteValueS390X_OpMod8u_0(v);
            else if (v.Op == OpMove) 
                return rewriteValueS390X_OpMove_0(v) || rewriteValueS390X_OpMove_10(v);
            else if (v.Op == OpMul16) 
                return rewriteValueS390X_OpMul16_0(v);
            else if (v.Op == OpMul32) 
                return rewriteValueS390X_OpMul32_0(v);
            else if (v.Op == OpMul32F) 
                return rewriteValueS390X_OpMul32F_0(v);
            else if (v.Op == OpMul64) 
                return rewriteValueS390X_OpMul64_0(v);
            else if (v.Op == OpMul64F) 
                return rewriteValueS390X_OpMul64F_0(v);
            else if (v.Op == OpMul8) 
                return rewriteValueS390X_OpMul8_0(v);
            else if (v.Op == OpNeg16) 
                return rewriteValueS390X_OpNeg16_0(v);
            else if (v.Op == OpNeg32) 
                return rewriteValueS390X_OpNeg32_0(v);
            else if (v.Op == OpNeg32F) 
                return rewriteValueS390X_OpNeg32F_0(v);
            else if (v.Op == OpNeg64) 
                return rewriteValueS390X_OpNeg64_0(v);
            else if (v.Op == OpNeg64F) 
                return rewriteValueS390X_OpNeg64F_0(v);
            else if (v.Op == OpNeg8) 
                return rewriteValueS390X_OpNeg8_0(v);
            else if (v.Op == OpNeq16) 
                return rewriteValueS390X_OpNeq16_0(v);
            else if (v.Op == OpNeq32) 
                return rewriteValueS390X_OpNeq32_0(v);
            else if (v.Op == OpNeq32F) 
                return rewriteValueS390X_OpNeq32F_0(v);
            else if (v.Op == OpNeq64) 
                return rewriteValueS390X_OpNeq64_0(v);
            else if (v.Op == OpNeq64F) 
                return rewriteValueS390X_OpNeq64F_0(v);
            else if (v.Op == OpNeq8) 
                return rewriteValueS390X_OpNeq8_0(v);
            else if (v.Op == OpNeqB) 
                return rewriteValueS390X_OpNeqB_0(v);
            else if (v.Op == OpNeqPtr) 
                return rewriteValueS390X_OpNeqPtr_0(v);
            else if (v.Op == OpNilCheck) 
                return rewriteValueS390X_OpNilCheck_0(v);
            else if (v.Op == OpNot) 
                return rewriteValueS390X_OpNot_0(v);
            else if (v.Op == OpOffPtr) 
                return rewriteValueS390X_OpOffPtr_0(v);
            else if (v.Op == OpOr16) 
                return rewriteValueS390X_OpOr16_0(v);
            else if (v.Op == OpOr32) 
                return rewriteValueS390X_OpOr32_0(v);
            else if (v.Op == OpOr64) 
                return rewriteValueS390X_OpOr64_0(v);
            else if (v.Op == OpOr8) 
                return rewriteValueS390X_OpOr8_0(v);
            else if (v.Op == OpOrB) 
                return rewriteValueS390X_OpOrB_0(v);
            else if (v.Op == OpRound) 
                return rewriteValueS390X_OpRound_0(v);
            else if (v.Op == OpRound32F) 
                return rewriteValueS390X_OpRound32F_0(v);
            else if (v.Op == OpRound64F) 
                return rewriteValueS390X_OpRound64F_0(v);
            else if (v.Op == OpRoundToEven) 
                return rewriteValueS390X_OpRoundToEven_0(v);
            else if (v.Op == OpRsh16Ux16) 
                return rewriteValueS390X_OpRsh16Ux16_0(v);
            else if (v.Op == OpRsh16Ux32) 
                return rewriteValueS390X_OpRsh16Ux32_0(v);
            else if (v.Op == OpRsh16Ux64) 
                return rewriteValueS390X_OpRsh16Ux64_0(v);
            else if (v.Op == OpRsh16Ux8) 
                return rewriteValueS390X_OpRsh16Ux8_0(v);
            else if (v.Op == OpRsh16x16) 
                return rewriteValueS390X_OpRsh16x16_0(v);
            else if (v.Op == OpRsh16x32) 
                return rewriteValueS390X_OpRsh16x32_0(v);
            else if (v.Op == OpRsh16x64) 
                return rewriteValueS390X_OpRsh16x64_0(v);
            else if (v.Op == OpRsh16x8) 
                return rewriteValueS390X_OpRsh16x8_0(v);
            else if (v.Op == OpRsh32Ux16) 
                return rewriteValueS390X_OpRsh32Ux16_0(v);
            else if (v.Op == OpRsh32Ux32) 
                return rewriteValueS390X_OpRsh32Ux32_0(v);
            else if (v.Op == OpRsh32Ux64) 
                return rewriteValueS390X_OpRsh32Ux64_0(v);
            else if (v.Op == OpRsh32Ux8) 
                return rewriteValueS390X_OpRsh32Ux8_0(v);
            else if (v.Op == OpRsh32x16) 
                return rewriteValueS390X_OpRsh32x16_0(v);
            else if (v.Op == OpRsh32x32) 
                return rewriteValueS390X_OpRsh32x32_0(v);
            else if (v.Op == OpRsh32x64) 
                return rewriteValueS390X_OpRsh32x64_0(v);
            else if (v.Op == OpRsh32x8) 
                return rewriteValueS390X_OpRsh32x8_0(v);
            else if (v.Op == OpRsh64Ux16) 
                return rewriteValueS390X_OpRsh64Ux16_0(v);
            else if (v.Op == OpRsh64Ux32) 
                return rewriteValueS390X_OpRsh64Ux32_0(v);
            else if (v.Op == OpRsh64Ux64) 
                return rewriteValueS390X_OpRsh64Ux64_0(v);
            else if (v.Op == OpRsh64Ux8) 
                return rewriteValueS390X_OpRsh64Ux8_0(v);
            else if (v.Op == OpRsh64x16) 
                return rewriteValueS390X_OpRsh64x16_0(v);
            else if (v.Op == OpRsh64x32) 
                return rewriteValueS390X_OpRsh64x32_0(v);
            else if (v.Op == OpRsh64x64) 
                return rewriteValueS390X_OpRsh64x64_0(v);
            else if (v.Op == OpRsh64x8) 
                return rewriteValueS390X_OpRsh64x8_0(v);
            else if (v.Op == OpRsh8Ux16) 
                return rewriteValueS390X_OpRsh8Ux16_0(v);
            else if (v.Op == OpRsh8Ux32) 
                return rewriteValueS390X_OpRsh8Ux32_0(v);
            else if (v.Op == OpRsh8Ux64) 
                return rewriteValueS390X_OpRsh8Ux64_0(v);
            else if (v.Op == OpRsh8Ux8) 
                return rewriteValueS390X_OpRsh8Ux8_0(v);
            else if (v.Op == OpRsh8x16) 
                return rewriteValueS390X_OpRsh8x16_0(v);
            else if (v.Op == OpRsh8x32) 
                return rewriteValueS390X_OpRsh8x32_0(v);
            else if (v.Op == OpRsh8x64) 
                return rewriteValueS390X_OpRsh8x64_0(v);
            else if (v.Op == OpRsh8x8) 
                return rewriteValueS390X_OpRsh8x8_0(v);
            else if (v.Op == OpS390XADD) 
                return rewriteValueS390X_OpS390XADD_0(v) || rewriteValueS390X_OpS390XADD_10(v);
            else if (v.Op == OpS390XADDW) 
                return rewriteValueS390X_OpS390XADDW_0(v) || rewriteValueS390X_OpS390XADDW_10(v);
            else if (v.Op == OpS390XADDWconst) 
                return rewriteValueS390X_OpS390XADDWconst_0(v);
            else if (v.Op == OpS390XADDWload) 
                return rewriteValueS390X_OpS390XADDWload_0(v);
            else if (v.Op == OpS390XADDconst) 
                return rewriteValueS390X_OpS390XADDconst_0(v);
            else if (v.Op == OpS390XADDload) 
                return rewriteValueS390X_OpS390XADDload_0(v);
            else if (v.Op == OpS390XAND) 
                return rewriteValueS390X_OpS390XAND_0(v) || rewriteValueS390X_OpS390XAND_10(v);
            else if (v.Op == OpS390XANDW) 
                return rewriteValueS390X_OpS390XANDW_0(v) || rewriteValueS390X_OpS390XANDW_10(v);
            else if (v.Op == OpS390XANDWconst) 
                return rewriteValueS390X_OpS390XANDWconst_0(v);
            else if (v.Op == OpS390XANDWload) 
                return rewriteValueS390X_OpS390XANDWload_0(v);
            else if (v.Op == OpS390XANDconst) 
                return rewriteValueS390X_OpS390XANDconst_0(v);
            else if (v.Op == OpS390XANDload) 
                return rewriteValueS390X_OpS390XANDload_0(v);
            else if (v.Op == OpS390XCMP) 
                return rewriteValueS390X_OpS390XCMP_0(v);
            else if (v.Op == OpS390XCMPU) 
                return rewriteValueS390X_OpS390XCMPU_0(v);
            else if (v.Op == OpS390XCMPUconst) 
                return rewriteValueS390X_OpS390XCMPUconst_0(v);
            else if (v.Op == OpS390XCMPW) 
                return rewriteValueS390X_OpS390XCMPW_0(v);
            else if (v.Op == OpS390XCMPWU) 
                return rewriteValueS390X_OpS390XCMPWU_0(v);
            else if (v.Op == OpS390XCMPWUconst) 
                return rewriteValueS390X_OpS390XCMPWUconst_0(v);
            else if (v.Op == OpS390XCMPWconst) 
                return rewriteValueS390X_OpS390XCMPWconst_0(v);
            else if (v.Op == OpS390XCMPconst) 
                return rewriteValueS390X_OpS390XCMPconst_0(v);
            else if (v.Op == OpS390XCPSDR) 
                return rewriteValueS390X_OpS390XCPSDR_0(v);
            else if (v.Op == OpS390XFADD) 
                return rewriteValueS390X_OpS390XFADD_0(v);
            else if (v.Op == OpS390XFADDS) 
                return rewriteValueS390X_OpS390XFADDS_0(v);
            else if (v.Op == OpS390XFMOVDload) 
                return rewriteValueS390X_OpS390XFMOVDload_0(v);
            else if (v.Op == OpS390XFMOVDloadidx) 
                return rewriteValueS390X_OpS390XFMOVDloadidx_0(v);
            else if (v.Op == OpS390XFMOVDstore) 
                return rewriteValueS390X_OpS390XFMOVDstore_0(v);
            else if (v.Op == OpS390XFMOVDstoreidx) 
                return rewriteValueS390X_OpS390XFMOVDstoreidx_0(v);
            else if (v.Op == OpS390XFMOVSload) 
                return rewriteValueS390X_OpS390XFMOVSload_0(v);
            else if (v.Op == OpS390XFMOVSloadidx) 
                return rewriteValueS390X_OpS390XFMOVSloadidx_0(v);
            else if (v.Op == OpS390XFMOVSstore) 
                return rewriteValueS390X_OpS390XFMOVSstore_0(v);
            else if (v.Op == OpS390XFMOVSstoreidx) 
                return rewriteValueS390X_OpS390XFMOVSstoreidx_0(v);
            else if (v.Op == OpS390XFNEG) 
                return rewriteValueS390X_OpS390XFNEG_0(v);
            else if (v.Op == OpS390XFNEGS) 
                return rewriteValueS390X_OpS390XFNEGS_0(v);
            else if (v.Op == OpS390XFSUB) 
                return rewriteValueS390X_OpS390XFSUB_0(v);
            else if (v.Op == OpS390XFSUBS) 
                return rewriteValueS390X_OpS390XFSUBS_0(v);
            else if (v.Op == OpS390XLDGR) 
                return rewriteValueS390X_OpS390XLDGR_0(v);
            else if (v.Op == OpS390XLEDBR) 
                return rewriteValueS390X_OpS390XLEDBR_0(v);
            else if (v.Op == OpS390XLGDR) 
                return rewriteValueS390X_OpS390XLGDR_0(v);
            else if (v.Op == OpS390XLoweredRound32F) 
                return rewriteValueS390X_OpS390XLoweredRound32F_0(v);
            else if (v.Op == OpS390XLoweredRound64F) 
                return rewriteValueS390X_OpS390XLoweredRound64F_0(v);
            else if (v.Op == OpS390XMOVBZload) 
                return rewriteValueS390X_OpS390XMOVBZload_0(v);
            else if (v.Op == OpS390XMOVBZloadidx) 
                return rewriteValueS390X_OpS390XMOVBZloadidx_0(v);
            else if (v.Op == OpS390XMOVBZreg) 
                return rewriteValueS390X_OpS390XMOVBZreg_0(v) || rewriteValueS390X_OpS390XMOVBZreg_10(v);
            else if (v.Op == OpS390XMOVBload) 
                return rewriteValueS390X_OpS390XMOVBload_0(v);
            else if (v.Op == OpS390XMOVBloadidx) 
                return rewriteValueS390X_OpS390XMOVBloadidx_0(v);
            else if (v.Op == OpS390XMOVBreg) 
                return rewriteValueS390X_OpS390XMOVBreg_0(v);
            else if (v.Op == OpS390XMOVBstore) 
                return rewriteValueS390X_OpS390XMOVBstore_0(v) || rewriteValueS390X_OpS390XMOVBstore_10(v);
            else if (v.Op == OpS390XMOVBstoreconst) 
                return rewriteValueS390X_OpS390XMOVBstoreconst_0(v);
            else if (v.Op == OpS390XMOVBstoreidx) 
                return rewriteValueS390X_OpS390XMOVBstoreidx_0(v) || rewriteValueS390X_OpS390XMOVBstoreidx_10(v) || rewriteValueS390X_OpS390XMOVBstoreidx_20(v) || rewriteValueS390X_OpS390XMOVBstoreidx_30(v);
            else if (v.Op == OpS390XMOVDEQ) 
                return rewriteValueS390X_OpS390XMOVDEQ_0(v);
            else if (v.Op == OpS390XMOVDGE) 
                return rewriteValueS390X_OpS390XMOVDGE_0(v);
            else if (v.Op == OpS390XMOVDGT) 
                return rewriteValueS390X_OpS390XMOVDGT_0(v);
            else if (v.Op == OpS390XMOVDLE) 
                return rewriteValueS390X_OpS390XMOVDLE_0(v);
            else if (v.Op == OpS390XMOVDLT) 
                return rewriteValueS390X_OpS390XMOVDLT_0(v);
            else if (v.Op == OpS390XMOVDNE) 
                return rewriteValueS390X_OpS390XMOVDNE_0(v);
            else if (v.Op == OpS390XMOVDaddridx) 
                return rewriteValueS390X_OpS390XMOVDaddridx_0(v);
            else if (v.Op == OpS390XMOVDload) 
                return rewriteValueS390X_OpS390XMOVDload_0(v);
            else if (v.Op == OpS390XMOVDloadidx) 
                return rewriteValueS390X_OpS390XMOVDloadidx_0(v);
            else if (v.Op == OpS390XMOVDnop) 
                return rewriteValueS390X_OpS390XMOVDnop_0(v) || rewriteValueS390X_OpS390XMOVDnop_10(v);
            else if (v.Op == OpS390XMOVDreg) 
                return rewriteValueS390X_OpS390XMOVDreg_0(v) || rewriteValueS390X_OpS390XMOVDreg_10(v);
            else if (v.Op == OpS390XMOVDstore) 
                return rewriteValueS390X_OpS390XMOVDstore_0(v);
            else if (v.Op == OpS390XMOVDstoreconst) 
                return rewriteValueS390X_OpS390XMOVDstoreconst_0(v);
            else if (v.Op == OpS390XMOVDstoreidx) 
                return rewriteValueS390X_OpS390XMOVDstoreidx_0(v);
            else if (v.Op == OpS390XMOVHBRstore) 
                return rewriteValueS390X_OpS390XMOVHBRstore_0(v);
            else if (v.Op == OpS390XMOVHBRstoreidx) 
                return rewriteValueS390X_OpS390XMOVHBRstoreidx_0(v) || rewriteValueS390X_OpS390XMOVHBRstoreidx_10(v);
            else if (v.Op == OpS390XMOVHZload) 
                return rewriteValueS390X_OpS390XMOVHZload_0(v);
            else if (v.Op == OpS390XMOVHZloadidx) 
                return rewriteValueS390X_OpS390XMOVHZloadidx_0(v);
            else if (v.Op == OpS390XMOVHZreg) 
                return rewriteValueS390X_OpS390XMOVHZreg_0(v);
            else if (v.Op == OpS390XMOVHload) 
                return rewriteValueS390X_OpS390XMOVHload_0(v);
            else if (v.Op == OpS390XMOVHloadidx) 
                return rewriteValueS390X_OpS390XMOVHloadidx_0(v);
            else if (v.Op == OpS390XMOVHreg) 
                return rewriteValueS390X_OpS390XMOVHreg_0(v) || rewriteValueS390X_OpS390XMOVHreg_10(v);
            else if (v.Op == OpS390XMOVHstore) 
                return rewriteValueS390X_OpS390XMOVHstore_0(v) || rewriteValueS390X_OpS390XMOVHstore_10(v);
            else if (v.Op == OpS390XMOVHstoreconst) 
                return rewriteValueS390X_OpS390XMOVHstoreconst_0(v);
            else if (v.Op == OpS390XMOVHstoreidx) 
                return rewriteValueS390X_OpS390XMOVHstoreidx_0(v) || rewriteValueS390X_OpS390XMOVHstoreidx_10(v);
            else if (v.Op == OpS390XMOVWBRstore) 
                return rewriteValueS390X_OpS390XMOVWBRstore_0(v);
            else if (v.Op == OpS390XMOVWBRstoreidx) 
                return rewriteValueS390X_OpS390XMOVWBRstoreidx_0(v);
            else if (v.Op == OpS390XMOVWZload) 
                return rewriteValueS390X_OpS390XMOVWZload_0(v);
            else if (v.Op == OpS390XMOVWZloadidx) 
                return rewriteValueS390X_OpS390XMOVWZloadidx_0(v);
            else if (v.Op == OpS390XMOVWZreg) 
                return rewriteValueS390X_OpS390XMOVWZreg_0(v) || rewriteValueS390X_OpS390XMOVWZreg_10(v);
            else if (v.Op == OpS390XMOVWload) 
                return rewriteValueS390X_OpS390XMOVWload_0(v);
            else if (v.Op == OpS390XMOVWloadidx) 
                return rewriteValueS390X_OpS390XMOVWloadidx_0(v);
            else if (v.Op == OpS390XMOVWreg) 
                return rewriteValueS390X_OpS390XMOVWreg_0(v) || rewriteValueS390X_OpS390XMOVWreg_10(v);
            else if (v.Op == OpS390XMOVWstore) 
                return rewriteValueS390X_OpS390XMOVWstore_0(v) || rewriteValueS390X_OpS390XMOVWstore_10(v);
            else if (v.Op == OpS390XMOVWstoreconst) 
                return rewriteValueS390X_OpS390XMOVWstoreconst_0(v);
            else if (v.Op == OpS390XMOVWstoreidx) 
                return rewriteValueS390X_OpS390XMOVWstoreidx_0(v) || rewriteValueS390X_OpS390XMOVWstoreidx_10(v);
            else if (v.Op == OpS390XMULLD) 
                return rewriteValueS390X_OpS390XMULLD_0(v);
            else if (v.Op == OpS390XMULLDconst) 
                return rewriteValueS390X_OpS390XMULLDconst_0(v);
            else if (v.Op == OpS390XMULLDload) 
                return rewriteValueS390X_OpS390XMULLDload_0(v);
            else if (v.Op == OpS390XMULLW) 
                return rewriteValueS390X_OpS390XMULLW_0(v);
            else if (v.Op == OpS390XMULLWconst) 
                return rewriteValueS390X_OpS390XMULLWconst_0(v);
            else if (v.Op == OpS390XMULLWload) 
                return rewriteValueS390X_OpS390XMULLWload_0(v);
            else if (v.Op == OpS390XNEG) 
                return rewriteValueS390X_OpS390XNEG_0(v);
            else if (v.Op == OpS390XNEGW) 
                return rewriteValueS390X_OpS390XNEGW_0(v);
            else if (v.Op == OpS390XNOT) 
                return rewriteValueS390X_OpS390XNOT_0(v);
            else if (v.Op == OpS390XNOTW) 
                return rewriteValueS390X_OpS390XNOTW_0(v);
            else if (v.Op == OpS390XOR) 
                return rewriteValueS390X_OpS390XOR_0(v) || rewriteValueS390X_OpS390XOR_10(v) || rewriteValueS390X_OpS390XOR_20(v) || rewriteValueS390X_OpS390XOR_30(v) || rewriteValueS390X_OpS390XOR_40(v) || rewriteValueS390X_OpS390XOR_50(v) || rewriteValueS390X_OpS390XOR_60(v) || rewriteValueS390X_OpS390XOR_70(v) || rewriteValueS390X_OpS390XOR_80(v) || rewriteValueS390X_OpS390XOR_90(v) || rewriteValueS390X_OpS390XOR_100(v) || rewriteValueS390X_OpS390XOR_110(v) || rewriteValueS390X_OpS390XOR_120(v) || rewriteValueS390X_OpS390XOR_130(v) || rewriteValueS390X_OpS390XOR_140(v) || rewriteValueS390X_OpS390XOR_150(v);
            else if (v.Op == OpS390XORW) 
                return rewriteValueS390X_OpS390XORW_0(v) || rewriteValueS390X_OpS390XORW_10(v) || rewriteValueS390X_OpS390XORW_20(v) || rewriteValueS390X_OpS390XORW_30(v) || rewriteValueS390X_OpS390XORW_40(v) || rewriteValueS390X_OpS390XORW_50(v) || rewriteValueS390X_OpS390XORW_60(v) || rewriteValueS390X_OpS390XORW_70(v) || rewriteValueS390X_OpS390XORW_80(v) || rewriteValueS390X_OpS390XORW_90(v);
            else if (v.Op == OpS390XORWconst) 
                return rewriteValueS390X_OpS390XORWconst_0(v);
            else if (v.Op == OpS390XORWload) 
                return rewriteValueS390X_OpS390XORWload_0(v);
            else if (v.Op == OpS390XORconst) 
                return rewriteValueS390X_OpS390XORconst_0(v);
            else if (v.Op == OpS390XORload) 
                return rewriteValueS390X_OpS390XORload_0(v);
            else if (v.Op == OpS390XSLD) 
                return rewriteValueS390X_OpS390XSLD_0(v);
            else if (v.Op == OpS390XSLW) 
                return rewriteValueS390X_OpS390XSLW_0(v);
            else if (v.Op == OpS390XSRAD) 
                return rewriteValueS390X_OpS390XSRAD_0(v);
            else if (v.Op == OpS390XSRADconst) 
                return rewriteValueS390X_OpS390XSRADconst_0(v);
            else if (v.Op == OpS390XSRAW) 
                return rewriteValueS390X_OpS390XSRAW_0(v);
            else if (v.Op == OpS390XSRAWconst) 
                return rewriteValueS390X_OpS390XSRAWconst_0(v);
            else if (v.Op == OpS390XSRD) 
                return rewriteValueS390X_OpS390XSRD_0(v);
            else if (v.Op == OpS390XSRDconst) 
                return rewriteValueS390X_OpS390XSRDconst_0(v);
            else if (v.Op == OpS390XSRW) 
                return rewriteValueS390X_OpS390XSRW_0(v);
            else if (v.Op == OpS390XSTM2) 
                return rewriteValueS390X_OpS390XSTM2_0(v);
            else if (v.Op == OpS390XSTMG2) 
                return rewriteValueS390X_OpS390XSTMG2_0(v);
            else if (v.Op == OpS390XSUB) 
                return rewriteValueS390X_OpS390XSUB_0(v);
            else if (v.Op == OpS390XSUBEWcarrymask) 
                return rewriteValueS390X_OpS390XSUBEWcarrymask_0(v);
            else if (v.Op == OpS390XSUBEcarrymask) 
                return rewriteValueS390X_OpS390XSUBEcarrymask_0(v);
            else if (v.Op == OpS390XSUBW) 
                return rewriteValueS390X_OpS390XSUBW_0(v);
            else if (v.Op == OpS390XSUBWconst) 
                return rewriteValueS390X_OpS390XSUBWconst_0(v);
            else if (v.Op == OpS390XSUBWload) 
                return rewriteValueS390X_OpS390XSUBWload_0(v);
            else if (v.Op == OpS390XSUBconst) 
                return rewriteValueS390X_OpS390XSUBconst_0(v);
            else if (v.Op == OpS390XSUBload) 
                return rewriteValueS390X_OpS390XSUBload_0(v);
            else if (v.Op == OpS390XXOR) 
                return rewriteValueS390X_OpS390XXOR_0(v) || rewriteValueS390X_OpS390XXOR_10(v);
            else if (v.Op == OpS390XXORW) 
                return rewriteValueS390X_OpS390XXORW_0(v) || rewriteValueS390X_OpS390XXORW_10(v);
            else if (v.Op == OpS390XXORWconst) 
                return rewriteValueS390X_OpS390XXORWconst_0(v);
            else if (v.Op == OpS390XXORWload) 
                return rewriteValueS390X_OpS390XXORWload_0(v);
            else if (v.Op == OpS390XXORconst) 
                return rewriteValueS390X_OpS390XXORconst_0(v);
            else if (v.Op == OpS390XXORload) 
                return rewriteValueS390X_OpS390XXORload_0(v);
            else if (v.Op == OpSelect0) 
                return rewriteValueS390X_OpSelect0_0(v);
            else if (v.Op == OpSelect1) 
                return rewriteValueS390X_OpSelect1_0(v);
            else if (v.Op == OpSignExt16to32) 
                return rewriteValueS390X_OpSignExt16to32_0(v);
            else if (v.Op == OpSignExt16to64) 
                return rewriteValueS390X_OpSignExt16to64_0(v);
            else if (v.Op == OpSignExt32to64) 
                return rewriteValueS390X_OpSignExt32to64_0(v);
            else if (v.Op == OpSignExt8to16) 
                return rewriteValueS390X_OpSignExt8to16_0(v);
            else if (v.Op == OpSignExt8to32) 
                return rewriteValueS390X_OpSignExt8to32_0(v);
            else if (v.Op == OpSignExt8to64) 
                return rewriteValueS390X_OpSignExt8to64_0(v);
            else if (v.Op == OpSlicemask) 
                return rewriteValueS390X_OpSlicemask_0(v);
            else if (v.Op == OpSqrt) 
                return rewriteValueS390X_OpSqrt_0(v);
            else if (v.Op == OpStaticCall) 
                return rewriteValueS390X_OpStaticCall_0(v);
            else if (v.Op == OpStore) 
                return rewriteValueS390X_OpStore_0(v);
            else if (v.Op == OpSub16) 
                return rewriteValueS390X_OpSub16_0(v);
            else if (v.Op == OpSub32) 
                return rewriteValueS390X_OpSub32_0(v);
            else if (v.Op == OpSub32F) 
                return rewriteValueS390X_OpSub32F_0(v);
            else if (v.Op == OpSub64) 
                return rewriteValueS390X_OpSub64_0(v);
            else if (v.Op == OpSub64F) 
                return rewriteValueS390X_OpSub64F_0(v);
            else if (v.Op == OpSub8) 
                return rewriteValueS390X_OpSub8_0(v);
            else if (v.Op == OpSubPtr) 
                return rewriteValueS390X_OpSubPtr_0(v);
            else if (v.Op == OpTrunc) 
                return rewriteValueS390X_OpTrunc_0(v);
            else if (v.Op == OpTrunc16to8) 
                return rewriteValueS390X_OpTrunc16to8_0(v);
            else if (v.Op == OpTrunc32to16) 
                return rewriteValueS390X_OpTrunc32to16_0(v);
            else if (v.Op == OpTrunc32to8) 
                return rewriteValueS390X_OpTrunc32to8_0(v);
            else if (v.Op == OpTrunc64to16) 
                return rewriteValueS390X_OpTrunc64to16_0(v);
            else if (v.Op == OpTrunc64to32) 
                return rewriteValueS390X_OpTrunc64to32_0(v);
            else if (v.Op == OpTrunc64to8) 
                return rewriteValueS390X_OpTrunc64to8_0(v);
            else if (v.Op == OpXor16) 
                return rewriteValueS390X_OpXor16_0(v);
            else if (v.Op == OpXor32) 
                return rewriteValueS390X_OpXor32_0(v);
            else if (v.Op == OpXor64) 
                return rewriteValueS390X_OpXor64_0(v);
            else if (v.Op == OpXor8) 
                return rewriteValueS390X_OpXor8_0(v);
            else if (v.Op == OpZero) 
                return rewriteValueS390X_OpZero_0(v) || rewriteValueS390X_OpZero_10(v);
            else if (v.Op == OpZeroExt16to32) 
                return rewriteValueS390X_OpZeroExt16to32_0(v);
            else if (v.Op == OpZeroExt16to64) 
                return rewriteValueS390X_OpZeroExt16to64_0(v);
            else if (v.Op == OpZeroExt32to64) 
                return rewriteValueS390X_OpZeroExt32to64_0(v);
            else if (v.Op == OpZeroExt8to16) 
                return rewriteValueS390X_OpZeroExt8to16_0(v);
            else if (v.Op == OpZeroExt8to32) 
                return rewriteValueS390X_OpZeroExt8to32_0(v);
            else if (v.Op == OpZeroExt8to64) 
                return rewriteValueS390X_OpZeroExt8to64_0(v);
                        return false;
        }
        private static bool rewriteValueS390X_OpAdd16_0(ref Value v)
        { 
            // match: (Add16 x y)
            // cond:
            // result: (ADDW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAdd32_0(ref Value v)
        { 
            // match: (Add32 x y)
            // cond:
            // result: (ADDW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAdd32F_0(ref Value v)
        { 
            // match: (Add32F x y)
            // cond:
            // result: (FADDS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFADDS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAdd64_0(ref Value v)
        { 
            // match: (Add64 x y)
            // cond:
            // result: (ADD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAdd64F_0(ref Value v)
        { 
            // match: (Add64F x y)
            // cond:
            // result: (FADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAdd8_0(ref Value v)
        { 
            // match: (Add8 x y)
            // cond:
            // result: (ADDW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAddPtr_0(ref Value v)
        { 
            // match: (AddPtr x y)
            // cond:
            // result: (ADD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAddr_0(ref Value v)
        { 
            // match: (Addr {sym} base)
            // cond:
            // result: (MOVDaddr {sym} base)
            while (true)
            {
                var sym = v.Aux;
                var @base = v.Args[0L];
                v.reset(OpS390XMOVDaddr);
                v.Aux = sym;
                v.AddArg(base);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAnd16_0(ref Value v)
        { 
            // match: (And16 x y)
            // cond:
            // result: (ANDW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAnd32_0(ref Value v)
        { 
            // match: (And32 x y)
            // cond:
            // result: (ANDW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAnd64_0(ref Value v)
        { 
            // match: (And64 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAnd8_0(ref Value v)
        { 
            // match: (And8 x y)
            // cond:
            // result: (ANDW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAndB_0(ref Value v)
        { 
            // match: (AndB x y)
            // cond:
            // result: (ANDW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicAdd32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicAdd32 ptr val mem)
            // cond:
            // result: (AddTupleFirst32 val (LAA ptr val mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XAddTupleFirst32);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpS390XLAA, types.NewTuple(typ.UInt32, types.TypeMem));
                v0.AddArg(ptr);
                v0.AddArg(val);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicAdd64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicAdd64 ptr val mem)
            // cond:
            // result: (AddTupleFirst64 val (LAAG ptr val mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XAddTupleFirst64);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpS390XLAAG, types.NewTuple(typ.UInt64, types.TypeMem));
                v0.AddArg(ptr);
                v0.AddArg(val);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicCompareAndSwap32_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap32 ptr old new_ mem)
            // cond:
            // result: (LoweredAtomicCas32 ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpS390XLoweredAtomicCas32);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicCompareAndSwap64_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap64 ptr old new_ mem)
            // cond:
            // result: (LoweredAtomicCas64 ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpS390XLoweredAtomicCas64);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicExchange32_0(ref Value v)
        { 
            // match: (AtomicExchange32 ptr val mem)
            // cond:
            // result: (LoweredAtomicExchange32 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XLoweredAtomicExchange32);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicExchange64_0(ref Value v)
        { 
            // match: (AtomicExchange64 ptr val mem)
            // cond:
            // result: (LoweredAtomicExchange64 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XLoweredAtomicExchange64);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicLoad32_0(ref Value v)
        { 
            // match: (AtomicLoad32 ptr mem)
            // cond:
            // result: (MOVWZatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XMOVWZatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicLoad64_0(ref Value v)
        { 
            // match: (AtomicLoad64 ptr mem)
            // cond:
            // result: (MOVDatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XMOVDatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicLoadPtr_0(ref Value v)
        { 
            // match: (AtomicLoadPtr ptr mem)
            // cond:
            // result: (MOVDatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XMOVDatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicStore32_0(ref Value v)
        { 
            // match: (AtomicStore32 ptr val mem)
            // cond:
            // result: (MOVWatomicstore ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVWatomicstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicStore64_0(ref Value v)
        { 
            // match: (AtomicStore64 ptr val mem)
            // cond:
            // result: (MOVDatomicstore ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVDatomicstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAtomicStorePtrNoWB_0(ref Value v)
        { 
            // match: (AtomicStorePtrNoWB ptr val mem)
            // cond:
            // result: (MOVDatomicstore ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVDatomicstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpAvg64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Avg64u <t> x y)
            // cond:
            // result: (ADD (SRDconst <t> (SUB <t> x y) [1]) y)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XADD);
                var v0 = b.NewValue0(v.Pos, OpS390XSRDconst, t);
                v0.AuxInt = 1L;
                var v1 = b.NewValue0(v.Pos, OpS390XSUB, t);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpBitLen64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (BitLen64 x)
            // cond:
            // result: (SUB (MOVDconst [64]) (FLOGR x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XSUB);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 64L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XFLOGR, typ.UInt64);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpBswap32_0(ref Value v)
        { 
            // match: (Bswap32 x)
            // cond:
            // result: (MOVWBR x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVWBR);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpBswap64_0(ref Value v)
        { 
            // match: (Bswap64 x)
            // cond:
            // result: (MOVDBR x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVDBR);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCeil_0(ref Value v)
        { 
            // match: (Ceil x)
            // cond:
            // result: (FIDBR [6] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFIDBR);
                v.AuxInt = 6L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpClosureCall_0(ref Value v)
        { 
            // match: (ClosureCall [argwid] entry closure mem)
            // cond:
            // result: (CALLclosure [argwid] entry closure mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[2L];
                var entry = v.Args[0L];
                var closure = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XCALLclosure);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(closure);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCom16_0(ref Value v)
        { 
            // match: (Com16 x)
            // cond:
            // result: (NOTW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNOTW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCom32_0(ref Value v)
        { 
            // match: (Com32 x)
            // cond:
            // result: (NOTW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNOTW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCom64_0(ref Value v)
        { 
            // match: (Com64 x)
            // cond:
            // result: (NOT x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNOT);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCom8_0(ref Value v)
        { 
            // match: (Com8 x)
            // cond:
            // result: (NOTW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNOTW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst16_0(ref Value v)
        { 
            // match: (Const16 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst32_0(ref Value v)
        { 
            // match: (Const32 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst32F_0(ref Value v)
        { 
            // match: (Const32F [val])
            // cond:
            // result: (FMOVSconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XFMOVSconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst64_0(ref Value v)
        { 
            // match: (Const64 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst64F_0(ref Value v)
        { 
            // match: (Const64F [val])
            // cond:
            // result: (FMOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XFMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConst8_0(ref Value v)
        { 
            // match: (Const8 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConstBool_0(ref Value v)
        { 
            // match: (ConstBool [b])
            // cond:
            // result: (MOVDconst [b])
            while (true)
            {
                var b = v.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = b;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConstNil_0(ref Value v)
        { 
            // match: (ConstNil)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            }

        }
        private static bool rewriteValueS390X_OpConvert_0(ref Value v)
        { 
            // match: (Convert <t> x mem)
            // cond:
            // result: (MOVDconvert <t> x mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XMOVDconvert);
                v.Type = t;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCtz32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz32 <t> x)
            // cond:
            // result: (SUB (MOVDconst [64]) (FLOGR (MOVWZreg (ANDW <t> (SUBWconst <t> [1] x) (NOTW <t> x)))))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpS390XSUB);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 64L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XFLOGR, typ.UInt64);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XANDW, t);
                var v4 = b.NewValue0(v.Pos, OpS390XSUBWconst, t);
                v4.AuxInt = 1L;
                v4.AddArg(x);
                v3.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpS390XNOTW, t);
                v5.AddArg(x);
                v3.AddArg(v5);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCtz64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz64 <t> x)
            // cond:
            // result: (SUB (MOVDconst [64]) (FLOGR (AND <t> (SUBconst <t> [1] x) (NOT <t> x))))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpS390XSUB);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 64L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XFLOGR, typ.UInt64);
                var v2 = b.NewValue0(v.Pos, OpS390XAND, t);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBconst, t);
                v3.AuxInt = 1L;
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XNOT, t);
                v4.AddArg(x);
                v2.AddArg(v4);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt32Fto32_0(ref Value v)
        { 
            // match: (Cvt32Fto32 x)
            // cond:
            // result: (CFEBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCFEBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt32Fto64_0(ref Value v)
        { 
            // match: (Cvt32Fto64 x)
            // cond:
            // result: (CGEBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCGEBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt32Fto64F_0(ref Value v)
        { 
            // match: (Cvt32Fto64F x)
            // cond:
            // result: (LDEBR x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XLDEBR);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt32to32F_0(ref Value v)
        { 
            // match: (Cvt32to32F x)
            // cond:
            // result: (CEFBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCEFBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt32to64F_0(ref Value v)
        { 
            // match: (Cvt32to64F x)
            // cond:
            // result: (CDFBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCDFBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt64Fto32_0(ref Value v)
        { 
            // match: (Cvt64Fto32 x)
            // cond:
            // result: (CFDBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCFDBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt64Fto32F_0(ref Value v)
        { 
            // match: (Cvt64Fto32F x)
            // cond:
            // result: (LEDBR x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XLEDBR);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt64Fto64_0(ref Value v)
        { 
            // match: (Cvt64Fto64 x)
            // cond:
            // result: (CGDBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCGDBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt64to32F_0(ref Value v)
        { 
            // match: (Cvt64to32F x)
            // cond:
            // result: (CEGBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCEGBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpCvt64to64F_0(ref Value v)
        { 
            // match: (Cvt64to64F x)
            // cond:
            // result: (CDGBRA x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XCDGBRA);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16 x y)
            // cond:
            // result: (DIVW  (MOVHreg x) (MOVHreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16u x y)
            // cond:
            // result: (DIVWU (MOVHZreg x) (MOVHZreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32 x y)
            // cond:
            // result: (DIVW  (MOVWreg x) y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv32F_0(ref Value v)
        { 
            // match: (Div32F x y)
            // cond:
            // result: (FDIVS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFDIVS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32u x y)
            // cond:
            // result: (DIVWU (MOVWZreg x) y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv64_0(ref Value v)
        { 
            // match: (Div64 x y)
            // cond:
            // result: (DIVD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv64F_0(ref Value v)
        { 
            // match: (Div64F x y)
            // cond:
            // result: (FDIV x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFDIV);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv64u_0(ref Value v)
        { 
            // match: (Div64u x y)
            // cond:
            // result: (DIVDU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVDU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8 x y)
            // cond:
            // result: (DIVW  (MOVBreg x) (MOVBreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpDiv8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8u x y)
            // cond:
            // result: (DIVWU (MOVBZreg x) (MOVBZreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XDIVWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq16 x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq32 x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq32F x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq64 x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq64F x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq8 x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqB x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpEqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqPtr x y)
            // cond:
            // result: (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDEQ);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpFloor_0(ref Value v)
        { 
            // match: (Floor x)
            // cond:
            // result: (FIDBR [7] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFIDBR);
                v.AuxInt = 7L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16 x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16U x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVHZreg x) (MOVHZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq32 x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq32F x y)
            // cond:
            // result: (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGEnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq32U x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq64 x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq64F x y)
            // cond:
            // result: (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGEnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq64U x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8 x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8U x y)
            // cond:
            // result: (MOVDGE (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVBZreg x) (MOVBZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGetCallerSP_0(ref Value v)
        { 
            // match: (GetCallerSP)
            // cond:
            // result: (LoweredGetCallerSP)
            while (true)
            {
                v.reset(OpS390XLoweredGetCallerSP);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGetClosurePtr_0(ref Value v)
        { 
            // match: (GetClosurePtr)
            // cond:
            // result: (LoweredGetClosurePtr)
            while (true)
            {
                v.reset(OpS390XLoweredGetClosurePtr);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGetG_0(ref Value v)
        { 
            // match: (GetG mem)
            // cond:
            // result: (LoweredGetG mem)
            while (true)
            {
                var mem = v.Args[0L];
                v.reset(OpS390XLoweredGetG);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16 x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16U x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVHZreg x) (MOVHZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater32 x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater32F x y)
            // cond:
            // result: (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGTnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater32U x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater64 x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater64F x y)
            // cond:
            // result: (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGTnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater64U x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8 x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpGreater8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8U x y)
            // cond:
            // result: (MOVDGT (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVBZreg x) (MOVBZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpHmul32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Hmul32 x y)
            // cond:
            // result: (SRDconst [32] (MULLD (MOVWreg x) (MOVWreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRDconst);
                v.AuxInt = 32L;
                var v0 = b.NewValue0(v.Pos, OpS390XMULLD, typ.Int64);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVWreg, typ.Int64);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWreg, typ.Int64);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpHmul32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Hmul32u x y)
            // cond:
            // result: (SRDconst [32] (MULLD (MOVWZreg x) (MOVWZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRDconst);
                v.AuxInt = 32L;
                var v0 = b.NewValue0(v.Pos, OpS390XMULLD, typ.Int64);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpHmul64_0(ref Value v)
        { 
            // match: (Hmul64 x y)
            // cond:
            // result: (MULHD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULHD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpHmul64u_0(ref Value v)
        { 
            // match: (Hmul64u x y)
            // cond:
            // result: (MULHDU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULHDU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpITab_0(ref Value v)
        { 
            // match: (ITab (Load ptr mem))
            // cond:
            // result: (MOVDload ptr mem)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var ptr = v_0.Args[0L];
                var mem = v_0.Args[1L];
                v.reset(OpS390XMOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpInterCall_0(ref Value v)
        { 
            // match: (InterCall [argwid] entry mem)
            // cond:
            // result: (CALLinter [argwid] entry mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[1L];
                var entry = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XCALLinter);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpIsInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (IsInBounds idx len)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPU idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(idx);
                v2.AddArg(len);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpIsNonNil_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (IsNonNil p)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMPconst p [0]))
            while (true)
            {
                var p = v.Args[0L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPconst, types.TypeFlags);
                v2.AuxInt = 0L;
                v2.AddArg(p);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpIsSliceInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (IsSliceInBounds idx len)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPU idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(idx);
                v2.AddArg(len);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16 x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16U x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVHZreg x) (MOVHZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq32 x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq32F x y)
            // cond:
            // result: (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMPS y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGEnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(y);
                v2.AddArg(x);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq32U x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq64 x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq64F x y)
            // cond:
            // result: (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMP y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGEnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(y);
                v2.AddArg(x);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq64U x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8 x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8U x y)
            // cond:
            // result: (MOVDLE (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVBZreg x) (MOVBZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16 x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16U x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVHZreg x) (MOVHZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less32 x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less32F x y)
            // cond:
            // result: (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMPS y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGTnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(y);
                v2.AddArg(x);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less32U x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less64 x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less64F x y)
            // cond:
            // result: (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) (FCMP y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDGTnoinv);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(y);
                v2.AddArg(x);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less64U x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8 x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLess8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8U x y)
            // cond:
            // result: (MOVDLT (MOVDconst [0]) (MOVDconst [1]) (CMPU (MOVBZreg x) (MOVBZreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDLT);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPU, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLoad_0(ref Value v)
        { 
            // match: (Load <t> ptr mem)
            // cond: (is64BitInt(t) || isPtr(t))
            // result: (MOVDload ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(is64BitInt(t) || isPtr(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && isSigned(t)
            // result: (MOVWload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && isSigned(t)
            // result: (MOVWload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVWload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && !isSigned(t)
            // result: (MOVWZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && !isSigned(t)
            // result: (MOVWZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && isSigned(t)
            // result: (MOVHload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && isSigned(t)
            // result: (MOVHload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVHload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && !isSigned(t)
            // result: (MOVHZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && !isSigned(t)
            // result: (MOVHZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVBload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVBload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is8BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVBload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (t.IsBoolean() || (is8BitInt(t) && !isSigned(t)))
            // result: (MOVBZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (t.IsBoolean() || (is8BitInt(t) && !isSigned(t)))
            // result: (MOVBZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsBoolean() || (is8BitInt(t) && !isSigned(t))))
                {
                    break;
                }
                v.reset(OpS390XMOVBZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (FMOVSload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (FMOVSload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitFloat(t)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (FMOVDload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (FMOVDload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is64BitFloat(t)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpLsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x16 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x32 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x64 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x8 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x16 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x32 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x64 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x8 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x16 <t> x y)
            // cond:
            // result: (AND (SLD <t> x y) (SUBEcarrymask <t> (CMPWUconst (MOVHZreg y) [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSLD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x32 <t> x y)
            // cond:
            // result: (AND (SLD <t> x y) (SUBEcarrymask <t> (CMPWUconst y [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSLD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x64 <t> x y)
            // cond:
            // result: (AND (SLD <t> x y) (SUBEcarrymask <t> (CMPUconst y [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSLD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x8 <t> x y)
            // cond:
            // result: (AND (SLD <t> x y) (SUBEcarrymask <t> (CMPWUconst (MOVBZreg y) [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSLD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x16 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x32 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x64 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpLsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x8 <t> x y)
            // cond:
            // result: (ANDW (SLW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16 x y)
            // cond:
            // result: (MODW  (MOVHreg x) (MOVHreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16u x y)
            // cond:
            // result: (MODWU (MOVHZreg x) (MOVHZreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32 x y)
            // cond:
            // result: (MODW  (MOVWreg x) y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32u x y)
            // cond:
            // result: (MODWU (MOVWZreg x) y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod64_0(ref Value v)
        { 
            // match: (Mod64 x y)
            // cond:
            // result: (MODD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod64u_0(ref Value v)
        { 
            // match: (Mod64u x y)
            // cond:
            // result: (MODDU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODDU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8 x y)
            // cond:
            // result: (MODW  (MOVBreg x) (MOVBreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMod8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8u x y)
            // cond:
            // result: (MODWU (MOVBZreg x) (MOVBZreg y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMODWU);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMove_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [0] _ _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[2L];
                var mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBZload src mem) mem)
 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, typ.UInt8);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVHstore dst (MOVHZload src mem) mem)
 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVHstore dst (MOVHZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVHstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWZload src mem) mem)
 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVWstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVDstore dst (MOVDload src mem) mem)
 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVDstore dst (MOVDload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVDstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [16] dst src mem)
            // cond:
            // result: (MOVDstore [8] dst (MOVDload [8] src mem)         (MOVDstore dst (MOVDload src mem) mem))
 
            // match: (Move [16] dst src mem)
            // cond:
            // result: (MOVDstore [8] dst (MOVDload [8] src mem)         (MOVDstore dst (MOVDload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVDstore);
                v.AuxInt = 8L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v0.AuxInt = 8L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDstore, types.TypeMem);
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [24] dst src mem)
            // cond:
            // result: (MOVDstore [16] dst (MOVDload [16] src mem)             (MOVDstore [8] dst (MOVDload [8] src mem)                 (MOVDstore dst (MOVDload src mem) mem)))
 
            // match: (Move [24] dst src mem)
            // cond:
            // result: (MOVDstore [16] dst (MOVDload [16] src mem)             (MOVDstore [8] dst (MOVDload [8] src mem)                 (MOVDstore dst (MOVDload src mem) mem)))
            while (true)
            {
                if (v.AuxInt != 24L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVDstore);
                v.AuxInt = 16L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v0.AuxInt = 16L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVDstore, types.TypeMem);
                v1.AuxInt = 8L;
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v2.AuxInt = 8L;
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVDstore, types.TypeMem);
                v3.AddArg(dst);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v4.AddArg(src);
                v4.AddArg(mem);
                v3.AddArg(v4);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBZload [2] src mem)         (MOVHstore dst (MOVHZload src mem) mem))
 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBZload [2] src mem)         (MOVHstore dst (MOVHZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AuxInt = 2L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, typ.UInt8);
                v0.AuxInt = 2L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, typ.UInt8);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVHstore [4] dst (MOVHZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVHstore [4] dst (MOVHZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVHstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpMove_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [7] dst src mem)
            // cond:
            // result: (MOVBstore [6] dst (MOVBZload [6] src mem)         (MOVHstore [4] dst (MOVHZload [4] src mem)             (MOVWstore dst (MOVWZload src mem) mem)))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AuxInt = 6L;
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, typ.UInt8);
                v0.AuxInt = 6L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHstore, types.TypeMem);
                v1.AuxInt = 4L;
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = 4L;
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVWstore, types.TypeMem);
                v3.AddArg(dst);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v4.AddArg(src);
                v4.AddArg(mem);
                v3.AddArg(v4);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 0 && s <= 256
            // result: (MVC [makeValAndOff(s, 0)] dst src mem)
 
            // match: (Move [s] dst src mem)
            // cond: s > 0 && s <= 256
            // result: (MVC [makeValAndOff(s, 0)] dst src mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 0L && s <= 256L))
                {
                    break;
                }
                v.reset(OpS390XMVC);
                v.AuxInt = makeValAndOff(s, 0L);
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 256 && s <= 512
            // result: (MVC [makeValAndOff(s-256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem))
 
            // match: (Move [s] dst src mem)
            // cond: s > 256 && s <= 512
            // result: (MVC [makeValAndOff(s-256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 256L && s <= 512L))
                {
                    break;
                }
                v.reset(OpS390XMVC);
                v.AuxInt = makeValAndOff(s - 256L, 256L);
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v0.AuxInt = makeValAndOff(256L, 0L);
                v0.AddArg(dst);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 512 && s <= 768
            // result: (MVC [makeValAndOff(s-512, 512)] dst src (MVC [makeValAndOff(256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem)))
 
            // match: (Move [s] dst src mem)
            // cond: s > 512 && s <= 768
            // result: (MVC [makeValAndOff(s-512, 512)] dst src (MVC [makeValAndOff(256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem)))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 512L && s <= 768L))
                {
                    break;
                }
                v.reset(OpS390XMVC);
                v.AuxInt = makeValAndOff(s - 512L, 512L);
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v0.AuxInt = makeValAndOff(256L, 256L);
                v0.AddArg(dst);
                v0.AddArg(src);
                v1 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v1.AuxInt = makeValAndOff(256L, 0L);
                v1.AddArg(dst);
                v1.AddArg(src);
                v1.AddArg(mem);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 768 && s <= 1024
            // result: (MVC [makeValAndOff(s-768, 768)] dst src (MVC [makeValAndOff(256, 512)] dst src (MVC [makeValAndOff(256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem))))
 
            // match: (Move [s] dst src mem)
            // cond: s > 768 && s <= 1024
            // result: (MVC [makeValAndOff(s-768, 768)] dst src (MVC [makeValAndOff(256, 512)] dst src (MVC [makeValAndOff(256, 256)] dst src (MVC [makeValAndOff(256, 0)] dst src mem))))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 768L && s <= 1024L))
                {
                    break;
                }
                v.reset(OpS390XMVC);
                v.AuxInt = makeValAndOff(s - 768L, 768L);
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v0.AuxInt = makeValAndOff(256L, 512L);
                v0.AddArg(dst);
                v0.AddArg(src);
                v1 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v1.AuxInt = makeValAndOff(256L, 256L);
                v1.AddArg(dst);
                v1.AddArg(src);
                v2 = b.NewValue0(v.Pos, OpS390XMVC, types.TypeMem);
                v2.AuxInt = makeValAndOff(256L, 0L);
                v2.AddArg(dst);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 1024
            // result: (LoweredMove [s%256] dst src (ADDconst <src.Type> src [(s/256)*256]) mem)
 
            // match: (Move [s] dst src mem)
            // cond: s > 1024
            // result: (LoweredMove [s%256] dst src (ADDconst <src.Type> src [(s/256)*256]) mem)
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 1024L))
                {
                    break;
                }
                v.reset(OpS390XLoweredMove);
                v.AuxInt = s % 256L;
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpS390XADDconst, src.Type);
                v0.AuxInt = (s / 256L) * 256L;
                v0.AddArg(src);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpMul16_0(ref Value v)
        { 
            // match: (Mul16 x y)
            // cond:
            // result: (MULLW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMul32_0(ref Value v)
        { 
            // match: (Mul32 x y)
            // cond:
            // result: (MULLW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMul32F_0(ref Value v)
        { 
            // match: (Mul32F x y)
            // cond:
            // result: (FMULS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFMULS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMul64_0(ref Value v)
        { 
            // match: (Mul64 x y)
            // cond:
            // result: (MULLD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULLD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMul64F_0(ref Value v)
        { 
            // match: (Mul64F x y)
            // cond:
            // result: (FMUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpMul8_0(ref Value v)
        { 
            // match: (Mul8 x y)
            // cond:
            // result: (MULLW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neg16 x)
            // cond:
            // result: (NEGW (MOVHreg x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNEGW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg32_0(ref Value v)
        { 
            // match: (Neg32 x)
            // cond:
            // result: (NEGW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNEGW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg32F_0(ref Value v)
        { 
            // match: (Neg32F x)
            // cond:
            // result: (FNEGS x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFNEGS);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg64_0(ref Value v)
        { 
            // match: (Neg64 x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg64F_0(ref Value v)
        { 
            // match: (Neg64F x)
            // cond:
            // result: (FNEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFNEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeg8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neg8 x)
            // cond:
            // result: (NEGW (MOVBreg x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XNEGW);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq16 x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVHreg x) (MOVHreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq32 x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPW, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq32F x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMPS, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq64 x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq64F x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XFCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq8 x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (NeqB x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMP (MOVBreg x) (MOVBreg y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v3.AddArg(x);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v4.AddArg(y);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNeqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (NeqPtr x y)
            // cond:
            // result: (MOVDNE (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XMOVDNE);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v1.AuxInt = 1L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpS390XCMP, types.TypeFlags);
                v2.AddArg(x);
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNilCheck_0(ref Value v)
        { 
            // match: (NilCheck ptr mem)
            // cond:
            // result: (LoweredNilCheck ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpS390XLoweredNilCheck);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpNot_0(ref Value v)
        { 
            // match: (Not x)
            // cond:
            // result: (XORWconst [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XXORWconst);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOffPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OffPtr [off] ptr:(SP))
            // cond:
            // result: (MOVDaddr [off] ptr)
            while (true)
            {
                var off = v.AuxInt;
                var ptr = v.Args[0L];
                if (ptr.Op != OpSP)
                {
                    break;
                }
                v.reset(OpS390XMOVDaddr);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            } 
            // match: (OffPtr [off] ptr)
            // cond: is32Bit(off)
            // result: (ADDconst [off] ptr)
 
            // match: (OffPtr [off] ptr)
            // cond: is32Bit(off)
            // result: (ADDconst [off] ptr)
            while (true)
            {
                off = v.AuxInt;
                ptr = v.Args[0L];
                if (!(is32Bit(off)))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            } 
            // match: (OffPtr [off] ptr)
            // cond:
            // result: (ADD (MOVDconst [off]) ptr)
 
            // match: (OffPtr [off] ptr)
            // cond:
            // result: (ADD (MOVDconst [off]) ptr)
            while (true)
            {
                off = v.AuxInt;
                ptr = v.Args[0L];
                v.reset(OpS390XADD);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = off;
                v.AddArg(v0);
                v.AddArg(ptr);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOr16_0(ref Value v)
        { 
            // match: (Or16 x y)
            // cond:
            // result: (ORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOr32_0(ref Value v)
        { 
            // match: (Or32 x y)
            // cond:
            // result: (ORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOr64_0(ref Value v)
        { 
            // match: (Or64 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOr8_0(ref Value v)
        { 
            // match: (Or8 x y)
            // cond:
            // result: (ORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpOrB_0(ref Value v)
        { 
            // match: (OrB x y)
            // cond:
            // result: (ORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRound_0(ref Value v)
        { 
            // match: (Round x)
            // cond:
            // result: (FIDBR [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFIDBR);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRound32F_0(ref Value v)
        { 
            // match: (Round32F x)
            // cond:
            // result: (LoweredRound32F x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XLoweredRound32F);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRound64F_0(ref Value v)
        { 
            // match: (Round64F x)
            // cond:
            // result: (LoweredRound64F x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XLoweredRound64F);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRoundToEven_0(ref Value v)
        { 
            // match: (RoundToEven x)
            // cond:
            // result: (FIDBR [4] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFIDBR);
                v.AuxInt = 4L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux16 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVHZreg x) y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [15])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 15L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux32 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVHZreg x) y) (SUBEWcarrymask <t> (CMPWUconst y [15])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 15L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux64 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVHZreg x) y) (SUBEWcarrymask <t> (CMPUconst y [15])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v3.AuxInt = 15L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux8 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVHZreg x) y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [15])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 15L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x16 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVHreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVHZreg y) [15])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 15L;
                var v5 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v5.AddArg(y);
                v4.AddArg(v5);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x32 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVHreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst y [15])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 15L;
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x64 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVHreg x) (OR <y.Type> y (NOT <y.Type> (SUBEcarrymask <y.Type> (CMPUconst y [15])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XOR, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOT, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v4.AuxInt = 15L;
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x8 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVHreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVBZreg y) [15])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 15L;
                var v5 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v5.AddArg(y);
                v4.AddArg(v5);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux16 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux32 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> x y) (SUBEWcarrymask <t> (CMPWUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux64 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> x y) (SUBEWcarrymask <t> (CMPUconst y [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux8 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> x y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [31])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 31L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x16 <t> x y)
            // cond:
            // result: (SRAW <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVHZreg y) [31])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 31L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x32 <t> x y)
            // cond:
            // result: (SRAW <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst y [31])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 31L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x64 <t> x y)
            // cond:
            // result: (SRAW <t> x (OR <y.Type> y (NOT <y.Type> (SUBEcarrymask <y.Type> (CMPUconst y [31])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOT, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v3.AuxInt = 31L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x8 <t> x y)
            // cond:
            // result: (SRAW <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVBZreg y) [31])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 31L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux16 <t> x y)
            // cond:
            // result: (AND (SRD <t> x y) (SUBEcarrymask <t> (CMPWUconst (MOVHZreg y) [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSRD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux32 <t> x y)
            // cond:
            // result: (AND (SRD <t> x y) (SUBEcarrymask <t> (CMPWUconst y [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSRD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux64 <t> x y)
            // cond:
            // result: (AND (SRD <t> x y) (SUBEcarrymask <t> (CMPUconst y [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSRD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux8 <t> x y)
            // cond:
            // result: (AND (SRD <t> x y) (SUBEcarrymask <t> (CMPWUconst (MOVBZreg y) [63])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XAND);
                var v0 = b.NewValue0(v.Pos, OpS390XSRD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v2.AuxInt = 63L;
                var v3 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x16 <t> x y)
            // cond:
            // result: (SRAD <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVHZreg y) [63])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAD);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 63L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x32 <t> x y)
            // cond:
            // result: (SRAD <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst y [63])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAD);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 63L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x64 <t> x y)
            // cond:
            // result: (SRAD <t> x (OR <y.Type> y (NOT <y.Type> (SUBEcarrymask <y.Type> (CMPUconst y [63])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAD);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOT, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v3.AuxInt = 63L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x8 <t> x y)
            // cond:
            // result: (SRAD <t> x (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVBZreg y) [63])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAD);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 63L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux16 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVBZreg x) y) (SUBEWcarrymask <t> (CMPWUconst (MOVHZreg y) [7])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 7L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux32 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVBZreg x) y) (SUBEWcarrymask <t> (CMPWUconst y [7])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 7L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux64 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVBZreg x) y) (SUBEWcarrymask <t> (CMPUconst y [7])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v3.AuxInt = 7L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux8 <t> x y)
            // cond:
            // result: (ANDW (SRW <t> (MOVBZreg x) y) (SUBEWcarrymask <t> (CMPWUconst (MOVBZreg y) [7])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XANDW);
                var v0 = b.NewValue0(v.Pos, OpS390XSRW, t);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, t);
                var v3 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v3.AuxInt = 7L;
                var v4 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x16 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVBreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVHZreg y) [7])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 7L;
                var v5 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v5.AddArg(y);
                v4.AddArg(v5);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x32 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVBreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst y [7])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 7L;
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x64 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVBreg x) (OR <y.Type> y (NOT <y.Type> (SUBEcarrymask <y.Type> (CMPUconst y [7])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XOR, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOT, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v4.AuxInt = 7L;
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpRsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x8 <t> x y)
            // cond:
            // result: (SRAW <t> (MOVBreg x) (ORW <y.Type> y (NOTW <y.Type> (SUBEWcarrymask <y.Type> (CMPWUconst (MOVBZreg y) [7])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSRAW);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XORW, y.Type);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpS390XNOTW, y.Type);
                var v3 = b.NewValue0(v.Pos, OpS390XSUBEWcarrymask, y.Type);
                var v4 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v4.AuxInt = 7L;
                var v5 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.UInt64);
                v5.AddArg(y);
                v4.AddArg(v5);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpS390XADD_0(ref Value v)
        { 
            // match: (ADD x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
 
            // match: (ADD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (ADD (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (ADD (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD idx (MOVDaddr [c] {s} ptr))
            // cond: ptr.Op != OpSB && idx.Op != OpSB
            // result: (MOVDaddridx [c] {s} ptr idx)
 
            // match: (ADD idx (MOVDaddr [c] {s} ptr))
            // cond: ptr.Op != OpSB && idx.Op != OpSB
            // result: (MOVDaddridx [c] {s} ptr idx)
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                c = v_1.AuxInt;
                var s = v_1.Aux;
                var ptr = v_1.Args[0L];
                if (!(ptr.Op != OpSB && idx.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(idx);
                return true;
            } 
            // match: (ADD (MOVDaddr [c] {s} ptr) idx)
            // cond: ptr.Op != OpSB && idx.Op != OpSB
            // result: (MOVDaddridx [c] {s} ptr idx)
 
            // match: (ADD (MOVDaddr [c] {s} ptr) idx)
            // cond: ptr.Op != OpSB && idx.Op != OpSB
            // result: (MOVDaddridx [c] {s} ptr idx)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                c = v_0.AuxInt;
                s = v_0.Aux;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                if (!(ptr.Op != OpSB && idx.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(idx);
                return true;
            } 
            // match: (ADD x (NEG y))
            // cond:
            // result: (SUB x y)
 
            // match: (ADD x (NEG y))
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XNEG)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (NEG y) x)
            // cond:
            // result: (SUB x y)
 
            // match: (ADD (NEG y) x)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XNEG)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpS390XSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
 
            // match: (ADD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
 
            // match: (ADD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADD_10(ref Value v)
        { 
            // match: (ADD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                var x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
 
            // match: (ADD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDW_0(ref Value v)
        { 
            // match: (ADDW x (MOVDconst [c]))
            // cond:
            // result: (ADDWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XADDWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDW (MOVDconst [c]) x)
            // cond:
            // result: (ADDWconst [int64(int32(c))] x)
 
            // match: (ADDW (MOVDconst [c]) x)
            // cond:
            // result: (ADDWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XADDWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (ADDW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (ADDW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDW x (NEGW y))
            // cond:
            // result: (SUBW x y)
 
            // match: (ADDW x (NEGW y))
            // cond:
            // result: (SUBW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XNEGW)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSUBW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDW (NEGW y) x)
            // cond:
            // result: (SUBW x y)
 
            // match: (ADDW (NEGW y) x)
            // cond:
            // result: (SUBW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XNEGW)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpS390XSUBW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDW_10(ref Value v)
        { 
            // match: (ADDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
 
            // match: (ADDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ADDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDWconst_0(ref Value v)
        { 
            // match: (ADDWconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [int64(int32(c+d))])
 
            // match: (ADDWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [int64(int32(c+d))])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int32(c + d));
                return true;
            } 
            // match: (ADDWconst [c] (ADDWconst [d] x))
            // cond:
            // result: (ADDWconst [int64(int32(c+d))] x)
 
            // match: (ADDWconst [c] (ADDWconst [d] x))
            // cond:
            // result: (ADDWconst [int64(int32(c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpS390XADDWconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDWload_0(ref Value v)
        { 
            // match: (ADDWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ADDWload  [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ADDWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ADDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ADDWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XADDWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDconst_0(ref Value v)
        { 
            // match: (ADDconst [c] (MOVDaddr [d] {s} x:(SB)))
            // cond: ((c+d)&1 == 0) && is32Bit(c+d)
            // result: (MOVDaddr [c+d] {s} x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var s = v_0.Aux;
                var x = v_0.Args[0L];
                if (x.Op != OpSB)
                {
                    break;
                }
                if (!(((c + d) & 1L == 0L) && is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddr);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (MOVDaddr [d] {s} x))
            // cond: x.Op != OpSB && is20Bit(c+d)
            // result: (MOVDaddr [c+d] {s} x)
 
            // match: (ADDconst [c] (MOVDaddr [d] {s} x))
            // cond: x.Op != OpSB && is20Bit(c+d)
            // result: (MOVDaddr [c+d] {s} x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                x = v_0.Args[0L];
                if (!(x.Op != OpSB && is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddr);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (MOVDaddridx [d] {s} x y))
            // cond: is20Bit(c+d)
            // result: (MOVDaddridx [c+d] {s} x y)
 
            // match: (ADDconst [c] (MOVDaddridx [d] {s} x y))
            // cond: is20Bit(c+d)
            // result: (MOVDaddridx [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c+d])
 
            // match: (ADDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c+d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c + d;
                return true;
            } 
            // match: (ADDconst [c] (ADDconst [d] x))
            // cond: is32Bit(c+d)
            // result: (ADDconst [c+d] x)
 
            // match: (ADDconst [c] (ADDconst [d] x))
            // cond: is32Bit(c+d)
            // result: (ADDconst [c+d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = c + d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XADDload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (ADD   x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XADD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ADDload   [off1+off2] {sym} x ptr mem)
 
            // match: (ADDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ADDload   [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ADDload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ADDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ADDload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XADDload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XAND_0(ref Value v)
        { 
            // match: (AND x (MOVDconst [c]))
            // cond: is32Bit(c) && c < 0
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c) && c < 0L))
                {
                    break;
                }
                v.reset(OpS390XANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [c]) x)
            // cond: is32Bit(c) && c < 0
            // result: (ANDconst [c] x)
 
            // match: (AND (MOVDconst [c]) x)
            // cond: is32Bit(c) && c < 0
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c) && c < 0L))
                {
                    break;
                }
                v.reset(OpS390XANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND x (MOVDconst [0xFF]))
            // cond:
            // result: (MOVBZreg x)
 
            // match: (AND x (MOVDconst [0xFF]))
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0xFFUL)
                {
                    break;
                }
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [0xFF]) x)
            // cond:
            // result: (MOVBZreg x)
 
            // match: (AND (MOVDconst [0xFF]) x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0xFFUL)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND x (MOVDconst [0xFFFF]))
            // cond:
            // result: (MOVHZreg x)
 
            // match: (AND x (MOVDconst [0xFFFF]))
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0xFFFFUL)
                {
                    break;
                }
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [0xFFFF]) x)
            // cond:
            // result: (MOVHZreg x)
 
            // match: (AND (MOVDconst [0xFFFF]) x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0xFFFFUL)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND x (MOVDconst [0xFFFFFFFF]))
            // cond:
            // result: (MOVWZreg x)
 
            // match: (AND x (MOVDconst [0xFFFFFFFF]))
            // cond:
            // result: (MOVWZreg x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0xFFFFFFFFUL)
                {
                    break;
                }
                v.reset(OpS390XMOVWZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [0xFFFFFFFF]) x)
            // cond:
            // result: (MOVWZreg x)
 
            // match: (AND (MOVDconst [0xFFFFFFFF]) x)
            // cond:
            // result: (MOVWZreg x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0xFFFFFFFFUL)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpS390XMOVWZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (AND (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (AND (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (AND (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c & d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XAND_10(ref Value v)
        { 
            // match: (AND x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (AND <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
 
            // match: (AND <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (AND <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
 
            // match: (AND <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (AND <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
 
            // match: (AND <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (AND <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
 
            // match: (AND <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDW_0(ref Value v)
        { 
            // match: (ANDW x (MOVDconst [c]))
            // cond:
            // result: (ANDWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XANDWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDW (MOVDconst [c]) x)
            // cond:
            // result: (ANDWconst [int64(int32(c))] x)
 
            // match: (ANDW (MOVDconst [c]) x)
            // cond:
            // result: (ANDWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XANDWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDW x x)
            // cond:
            // result: x
 
            // match: (ANDW x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
 
            // match: (ANDW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDW_10(ref Value v)
        { 
            // match: (ANDW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ANDWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDWconst_0(ref Value v)
        { 
            // match: (ANDWconst [c] (ANDWconst [d] x))
            // cond:
            // result: (ANDWconst [c & d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XANDWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpS390XANDWconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDWconst [0xFF] x)
            // cond:
            // result: (MOVBZreg x)
 
            // match: (ANDWconst [0xFF] x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                if (v.AuxInt != 0xFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDWconst [0xFFFF] x)
            // cond:
            // result: (MOVHZreg x)
 
            // match: (ANDWconst [0xFFFF] x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                if (v.AuxInt != 0xFFFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDWconst [c] _)
            // cond: int32(c)==0
            // result: (MOVDconst [0])
 
            // match: (ANDWconst [c] _)
            // cond: int32(c)==0
            // result: (MOVDconst [0])
            while (true)
            {
                c = v.AuxInt;
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDWconst [c] x)
            // cond: int32(c)==-1
            // result: x
 
            // match: (ANDWconst [c] x)
            // cond: int32(c)==-1
            // result: x
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (ANDWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c & d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDWload_0(ref Value v)
        { 
            // match: (ANDWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ANDWload  [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ANDWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ANDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ANDWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XANDWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDconst_0(ref Value v)
        { 
            // match: (ANDconst [c] (ANDconst [d] x))
            // cond:
            // result: (ANDconst [c & d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XANDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpS390XANDconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (ANDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDconst [-1] x)
            // cond:
            // result: x
 
            // match: (ANDconst [-1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (ANDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c & d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XANDload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (AND   x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XAND);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ANDload   [off1+off2] {sym} x ptr mem)
 
            // match: (ANDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ANDload   [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ANDload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ANDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ANDload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XANDload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMP_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMP x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (CMPconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XCMPconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMP (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (InvertFlags (CMPconst x [c]))
 
            // match: (CMP (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (InvertFlags (CMPconst x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpS390XCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPU_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPU x (MOVDconst [c]))
            // cond: isU32Bit(c)
            // result: (CMPUconst x [int64(int32(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XCMPUconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPU (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (InvertFlags (CMPUconst x [int64(int32(c))]))
 
            // match: (CMPU (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (InvertFlags (CMPUconst x [int64(int32(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpS390XCMPUconst, types.TypeFlags);
                v0.AuxInt = int64(int32(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPUconst_0(ref Value v)
        { 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)==uint64(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(uint64(x) == uint64(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagEQ);
                return true;
            } 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)<uint64(y)
            // result: (FlagLT)
 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)<uint64(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint64(x) < uint64(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)>uint64(y)
            // result: (FlagGT)
 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)>uint64(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint64(x) > uint64(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPW_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPW x (MOVDconst [c]))
            // cond:
            // result: (CMPWconst x [int64(int32(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XCMPWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPW (MOVDconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWconst x [int64(int32(c))]))
 
            // match: (CMPW (MOVDconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWconst x [int64(int32(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpS390XCMPWconst, types.TypeFlags);
                v0.AuxInt = int64(int32(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPWU_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPWU x (MOVDconst [c]))
            // cond:
            // result: (CMPWUconst x [int64(int32(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XCMPWUconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPWU (MOVDconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWUconst x [int64(int32(c))]))
 
            // match: (CMPWU (MOVDconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWUconst x [int64(int32(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpS390XCMPWUconst, types.TypeFlags);
                v0.AuxInt = int64(int32(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPWUconst_0(ref Value v)
        { 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)==uint32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(uint32(x) == uint32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagEQ);
                return true;
            } 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)<uint32(y)
            // result: (FlagLT)
 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)<uint32(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)>uint32(y)
            // result: (FlagGT)
 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)>uint32(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPWconst_0(ref Value v)
        { 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)==int32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagEQ);
                return true;
            } 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)<int32(y)
            // result: (FlagLT)
 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)<int32(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)>int32(y)
            // result: (FlagGT)
 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)>int32(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y)))
                {
                    break;
                }
                v.reset(OpS390XFlagGT);
                return true;
            } 
            // match: (CMPWconst (SRWconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n)
            // result: (FlagLT)
 
            // match: (CMPWconst (SRWconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n)
            // result: (FlagLT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                if (!(0L <= n && 0L < c && c <= 32L && (1L << (int)(uint64(32L - c))) <= uint64(n)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPWconst (ANDWconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT)
 
            // match: (CMPWconst (ANDWconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XANDWconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= int32(m) && int32(m) < int32(n)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCMPconst_0(ref Value v)
        { 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: x==y
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(x == y))
                {
                    break;
                }
                v.reset(OpS390XFlagEQ);
                return true;
            } 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: x<y
            // result: (FlagLT)
 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: x<y
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x < y))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: x>y
            // result: (FlagGT)
 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: x>y
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x > y))
                {
                    break;
                }
                v.reset(OpS390XFlagGT);
                return true;
            } 
            // match: (CMPconst (MOVBZreg _) [c])
            // cond: 0xFF < c
            // result: (FlagLT)
 
            // match: (CMPconst (MOVBZreg _) [c])
            // cond: 0xFF < c
            // result: (FlagLT)
            while (true)
            {
                var c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                if (!(0xFFUL < c))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPconst (MOVHZreg _) [c])
            // cond: 0xFFFF < c
            // result: (FlagLT)
 
            // match: (CMPconst (MOVHZreg _) [c])
            // cond: 0xFFFF < c
            // result: (FlagLT)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                if (!(0xFFFFUL < c))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPconst (MOVWZreg _) [c])
            // cond: 0xFFFFFFFF < c
            // result: (FlagLT)
 
            // match: (CMPconst (MOVWZreg _) [c])
            // cond: 0xFFFFFFFF < c
            // result: (FlagLT)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                if (!(0xFFFFFFFFUL < c))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPconst (SRDconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 64 && (1<<uint64(64-c)) <= uint64(n)
            // result: (FlagLT)
 
            // match: (CMPconst (SRDconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 64 && (1<<uint64(64-c)) <= uint64(n)
            // result: (FlagLT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                if (!(0L <= n && 0L < c && c <= 64L && (1L << (int)(uint64(64L - c))) <= uint64(n)))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            } 
            // match: (CMPconst (ANDconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT)
 
            // match: (CMPconst (ANDconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XANDconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= m && m < n))
                {
                    break;
                }
                v.reset(OpS390XFlagLT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XCPSDR_0(ref Value v)
        { 
            // match: (CPSDR y (FMOVDconst [c]))
            // cond: c & -1<<63 == 0
            // result: (LPDFR y)
            while (true)
            {
                _ = v.Args[1L];
                var y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(c & -1L << (int)(63L) == 0L))
                {
                    break;
                }
                v.reset(OpS390XLPDFR);
                v.AddArg(y);
                return true;
            } 
            // match: (CPSDR y (FMOVDconst [c]))
            // cond: c & -1<<63 != 0
            // result: (LNDFR y)
 
            // match: (CPSDR y (FMOVDconst [c]))
            // cond: c & -1<<63 != 0
            // result: (LNDFR y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & -1L << (int)(63L) != 0L))
                {
                    break;
                }
                v.reset(OpS390XLNDFR);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFADD_0(ref Value v)
        { 
            // match: (FADD (FMUL y z) x)
            // cond:
            // result: (FMADD x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var z = v_0.Args[1L];
                var x = v.Args[1L];
                v.reset(OpS390XFMADD);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (FADD x (FMUL y z))
            // cond:
            // result: (FMADD x y z)
 
            // match: (FADD x (FMUL y z))
            // cond:
            // result: (FMADD x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMUL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpS390XFMADD);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFADDS_0(ref Value v)
        { 
            // match: (FADDS (FMULS y z) x)
            // cond:
            // result: (FMADDS x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFMULS)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var z = v_0.Args[1L];
                var x = v.Args[1L];
                v.reset(OpS390XFMADDS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (FADDS x (FMULS y z))
            // cond:
            // result: (FMADDS x y z)
 
            // match: (FADDS x (FMULS y z))
            // cond:
            // result: (FMADDS x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMULS)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpS390XFMADDS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVDload_0(ref Value v)
        { 
            // match: (FMOVDload [off] {sym} ptr1 (MOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (LDGR x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XLDGR);
                v.AddArg(x);
                return true;
            } 
            // match: (FMOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: x
 
            // match: (FMOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: x
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                ptr2 = v_1.Args[0L];
                x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVDload [off1+off2] {sym} ptr mem)
 
            // match: (FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVDload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (FMOVDload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (FMOVDload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVDloadidx [off] {sym} ptr idx mem)
 
            // match: (FMOVDload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVDloadidx [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XFMOVDloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVDloadidx_0(ref Value v)
        { 
            // match: (FMOVDloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDloadidx [c+d] {sym} ptr idx mem)
 
            // match: (FMOVDloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVDstore_0(ref Value v)
        { 
            // match: (FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVDstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (FMOVDstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (FMOVDstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVDstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVDstoreidx [off] {sym} ptr idx val mem)
 
            // match: (FMOVDstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVDstoreidx [off] {sym} ptr idx val mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVDstoreidx_0(ref Value v)
        { 
            // match: (FMOVDstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDstoreidx [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDstoreidx [c+d] {sym} ptr idx val mem)
 
            // match: (FMOVDstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVDstoreidx [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVSload_0(ref Value v)
        { 
            // match: (FMOVSload [off] {sym} ptr1 (FMOVSstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: x
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMOVSstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVSload [off1+off2] {sym} ptr mem)
 
            // match: (FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVSload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (FMOVSload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (FMOVSload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVSloadidx [off] {sym} ptr idx mem)
 
            // match: (FMOVSload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVSloadidx [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XFMOVSloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVSloadidx_0(ref Value v)
        { 
            // match: (FMOVSloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSloadidx [c+d] {sym} ptr idx mem)
 
            // match: (FMOVSloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVSstore_0(ref Value v)
        { 
            // match: (FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (FMOVSstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (FMOVSstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (FMOVSstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (FMOVSstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVSstoreidx [off] {sym} ptr idx val mem)
 
            // match: (FMOVSstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (FMOVSstoreidx [off] {sym} ptr idx val mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFMOVSstoreidx_0(ref Value v)
        { 
            // match: (FMOVSstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSstoreidx [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSstoreidx [c+d] {sym} ptr idx val mem)
 
            // match: (FMOVSstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (FMOVSstoreidx [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFNEG_0(ref Value v)
        { 
            // match: (FNEG (LPDFR x))
            // cond:
            // result: (LNDFR x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLPDFR)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpS390XLNDFR);
                v.AddArg(x);
                return true;
            } 
            // match: (FNEG (LNDFR x))
            // cond:
            // result: (LPDFR x)
 
            // match: (FNEG (LNDFR x))
            // cond:
            // result: (LPDFR x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLNDFR)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpS390XLPDFR);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFNEGS_0(ref Value v)
        { 
            // match: (FNEGS (LPDFR x))
            // cond:
            // result: (LNDFR x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLPDFR)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpS390XLNDFR);
                v.AddArg(x);
                return true;
            } 
            // match: (FNEGS (LNDFR x))
            // cond:
            // result: (LPDFR x)
 
            // match: (FNEGS (LNDFR x))
            // cond:
            // result: (LPDFR x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLNDFR)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpS390XLPDFR);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFSUB_0(ref Value v)
        { 
            // match: (FSUB (FMUL y z) x)
            // cond:
            // result: (FMSUB x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var z = v_0.Args[1L];
                var x = v.Args[1L];
                v.reset(OpS390XFMSUB);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XFSUBS_0(ref Value v)
        { 
            // match: (FSUBS (FMULS y z) x)
            // cond:
            // result: (FMSUBS x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFMULS)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var z = v_0.Args[1L];
                var x = v.Args[1L];
                v.reset(OpS390XFMSUBS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XLDGR_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (LDGR <t> (SRDconst [1] (SLDconst [1] x)))
            // cond:
            // result: (LPDFR (LDGR <t> x))
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                v.reset(OpS390XLPDFR);
                var v0 = b.NewValue0(v.Pos, OpS390XLDGR, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (LDGR <t> (OR (MOVDconst [-1<<63]) x))
            // cond:
            // result: (LNDFR (LDGR <t> x))
 
            // match: (LDGR <t> (OR (MOVDconst [-1<<63]) x))
            // cond:
            // result: (LNDFR (LDGR <t> x))
            while (true)
            {
                t = v.Type;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XOR)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                x = v_0.Args[1L];
                v.reset(OpS390XLNDFR);
                v0 = b.NewValue0(v.Pos, OpS390XLDGR, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (LDGR <t> (OR x (MOVDconst [-1<<63])))
            // cond:
            // result: (LNDFR (LDGR <t> x))
 
            // match: (LDGR <t> (OR x (MOVDconst [-1<<63])))
            // cond:
            // result: (LNDFR (LDGR <t> x))
            while (true)
            {
                t = v.Type;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XOR)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v.reset(OpS390XLNDFR);
                v0 = b.NewValue0(v.Pos, OpS390XLDGR, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (LDGR <t> x:(ORload <t1> [off] {sym} (MOVDconst [-1<<63]) ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (LNDFR <t> (LDGR <t> (MOVDload <t1> [off] {sym} ptr mem)))
 
            // match: (LDGR <t> x:(ORload <t1> [off] {sym} (MOVDconst [-1<<63]) ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (LNDFR <t> (LDGR <t> (MOVDload <t1> [off] {sym} ptr mem)))
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XORload)
                {
                    break;
                }
                var t1 = x.Type;
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[2L];
                var x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (x_0.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                var ptr = x.Args[1L];
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XLNDFR, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XLDGR, t);
                var v2 = b.NewValue0(v.Pos, OpS390XMOVDload, t1);
                v2.AuxInt = off;
                v2.Aux = sym;
                v2.AddArg(ptr);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                return true;
            } 
            // match: (LDGR (LGDR x))
            // cond:
            // result: x
 
            // match: (LDGR (LGDR x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLGDR)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XLEDBR_0(ref Value v)
        { 
            // match: (LEDBR (LPDFR (LDEBR x)))
            // cond:
            // result: (LPDFR x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLPDFR)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XLDEBR)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                v.reset(OpS390XLPDFR);
                v.AddArg(x);
                return true;
            } 
            // match: (LEDBR (LNDFR (LDEBR x)))
            // cond:
            // result: (LNDFR x)
 
            // match: (LEDBR (LNDFR (LDEBR x)))
            // cond:
            // result: (LNDFR x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLNDFR)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XLDEBR)
                {
                    break;
                }
                x = v_0_0.Args[0L];
                v.reset(OpS390XLNDFR);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XLGDR_0(ref Value v)
        { 
            // match: (LGDR (LDGR x))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLDGR)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XLoweredRound32F_0(ref Value v)
        { 
            // match: (LoweredRound32F x:(FMOVSconst))
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XFMOVSconst)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XLoweredRound64F_0(ref Value v)
        { 
            // match: (LoweredRound64F x:(FMOVDconst))
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XFMOVDconst)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBZload_0(ref Value v)
        { 
            // match: (MOVBZload [off] {sym} ptr1 (MOVBstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVBZreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBZload [off1+off2] {sym} ptr mem)
 
            // match: (MOVBZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBZload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVBZload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVBZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBZloadidx [off] {sym} ptr idx mem)
 
            // match: (MOVBZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBZloadidx [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBZloadidx_0(ref Value v)
        { 
            // match: (MOVBZloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVBZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVBZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVBZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVBZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBZreg_0(ref Value v)
        { 
            // match: (MOVBZreg x:(MOVDLT (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVDLT)
                {
                    break;
                }
                _ = x.Args[2L];
                var x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = x_0.AuxInt;
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDLE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDLE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDLE)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDGT (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDGT (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDGT)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDGE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDGE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDGE)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDEQ (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDEQ (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDEQ)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDNE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDNE (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDNE)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDGTnoinv (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDGTnoinv (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDGTnoinv)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVDGEnoinv (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVDGEnoinv (MOVDconst [c]) (MOVDconst [d]) _))
            // cond: int64(uint8(c)) == c && int64(uint8(d)) == d
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDGEnoinv)
                {
                    break;
                }
                _ = x.Args[2L];
                x_0 = x.Args[0L];
                if (x_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = x_0.AuxInt;
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = x_1.AuxInt;
                if (!(int64(uint8(c)) == c && int64(uint8(d)) == d))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(Arg <t>))
            // cond: is8BitInt(t) && !isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVBZreg x:(Arg <t>))
            // cond: is8BitInt(t) && !isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!(is8BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBZreg_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBZreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint8(c))])
 
            // match: (MOVBZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(uint8(c));
                return true;
            } 
            // match: (MOVBZreg x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBZreg x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBZreg x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBZreg x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBZreg x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVBZreg x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBZreg x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVBZreg x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBload_0(ref Value v)
        { 
            // match: (MOVBload [off] {sym} ptr1 (MOVBstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVBreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVBload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVBload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVBload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBloadidx  [off] {sym} ptr idx mem)
 
            // match: (MOVBload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBloadidx  [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBloadidx_0(ref Value v)
        { 
            // match: (MOVBloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVBloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBreg x:(MOVBload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg x:(Arg <t>))
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVBreg x:(Arg <t>))
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!(is8BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVBreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int8(c))])
 
            // match: (MOVBreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (MOVBreg x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBreg x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBreg x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBreg x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBreg x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVBreg x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBreg x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVBreg x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstore_0(ref Value v)
        { 
            // match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVBreg)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBZreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBZreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVBstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is20Bit(off) && ptr.Op != OpSB
            // result: (MOVBstoreconst [makeValAndOff(int64(int8(c)),off)] {sym} ptr mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is20Bit(off) && ptr.Op != OpSB
            // result: (MOVBstoreconst [makeValAndOff(int64(int8(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(is20Bit(off) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = makeValAndOff(int64(int8(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVBstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVBstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBstoreidx  [off] {sym} ptr idx val mem)
 
            // match: (MOVBstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBstoreidx  [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRDconst [8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w mem)
 
            // match: (MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRDconst [8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w0:(SRDconst [j] w) x:(MOVBstore [i-1] {s} p (SRDconst [j+8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w0 mem)
 
            // match: (MOVBstore [i] {s} p w0:(SRDconst [j] w) x:(MOVBstore [i-1] {s} p (SRDconst [j+8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w0 = v.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_1.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRWconst [8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w mem)
 
            // match: (MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRWconst [8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                w = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstore_10(ref Value v)
        { 
            // match: (MOVBstore [i] {s} p w0:(SRWconst [j] w) x:(MOVBstore [i-1] {s} p (SRWconst [j+8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHstore [i-1] {s} p w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w0 = v.Args[1L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                var w = w0.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_1.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p (SRDconst [8] w) x:(MOVBstore [i-1] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w mem)
 
            // match: (MOVBstore [i] {s} p (SRDconst [8] w) x:(MOVBstore [i-1] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p (SRDconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRDconst [j-8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w0 mem)
 
            // match: (MOVBstore [i] {s} p (SRDconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRDconst [j-8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p (SRWconst [8] w) x:(MOVBstore [i-1] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w mem)
 
            // match: (MOVBstore [i] {s} p (SRWconst [8] w) x:(MOVBstore [i-1] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p (SRWconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRWconst [j-8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w0 mem)
 
            // match: (MOVBstore [i] {s} p (SRWconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRWconst [j-8] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVHBRstore [i-1] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstoreconst_0(ref Value v)
        { 
            // match: (MOVBstoreconst [sc] {s} (ADDconst [off] ptr) mem)
            // cond: is20Bit(ValAndOff(sc).Off()+off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(ValAndOff(sc).Off() + off)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVBstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVHstoreconst [makeValAndOff(ValAndOff(c).Val()&0xff | ValAndOff(a).Val()<<8, ValAndOff(a).Off())] {s} p mem)
 
            // match: (MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVHstoreconst [makeValAndOff(ValAndOff(c).Val()&0xff | ValAndOff(a).Val()<<8, ValAndOff(a).Off())] {s} p mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                var x = v.Args[1L];
                if (x.Op != OpS390XMOVBstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(p.Op != OpSB && x.Uses == 1L && ValAndOff(a).Off() + 1L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = makeValAndOff(ValAndOff(c).Val() & 0xffUL | ValAndOff(a).Val() << (int)(8L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstoreidx_0(ref Value v)
        { 
            // match: (MOVBstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVBstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVBstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVBstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVBstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVBstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var w = v.Args[2L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstoreidx_10(ref Value v)
        { 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var idx = v.Args[0L];
                var p = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                var w = w0.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRDconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p (SRWconst [j+8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 8L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstoreidx_20(ref Value v)
        { 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRDconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVBstoreidx_30(ref Value v)
        { 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var idx = v.Args[0L];
                var p = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [8] w) x:(MOVBstoreidx [i-1] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} p idx w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVBstoreidx [i-1] {s} idx p w0:(SRWconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVHBRstoreidx [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVBstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVHBRstoreidx);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDEQ_0(ref Value v)
        { 
            // match: (MOVDEQ x y (InvertFlags cmp))
            // cond:
            // result: (MOVDEQ x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDEQ);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDEQ _ x (FlagEQ))
            // cond:
            // result: x
 
            // match: (MOVDEQ _ x (FlagEQ))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDEQ y _ (FlagLT))
            // cond:
            // result: y
 
            // match: (MOVDEQ y _ (FlagLT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDEQ y _ (FlagGT))
            // cond:
            // result: y
 
            // match: (MOVDEQ y _ (FlagGT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDGE_0(ref Value v)
        { 
            // match: (MOVDGE x y (InvertFlags cmp))
            // cond:
            // result: (MOVDLE x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDLE);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDGE _ x (FlagEQ))
            // cond:
            // result: x
 
            // match: (MOVDGE _ x (FlagEQ))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDGE y _ (FlagLT))
            // cond:
            // result: y
 
            // match: (MOVDGE y _ (FlagLT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDGE _ x (FlagGT))
            // cond:
            // result: x
 
            // match: (MOVDGE _ x (FlagGT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDGT_0(ref Value v)
        { 
            // match: (MOVDGT x y (InvertFlags cmp))
            // cond:
            // result: (MOVDLT x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDLT);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDGT y _ (FlagEQ))
            // cond:
            // result: y
 
            // match: (MOVDGT y _ (FlagEQ))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDGT y _ (FlagLT))
            // cond:
            // result: y
 
            // match: (MOVDGT y _ (FlagLT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDGT _ x (FlagGT))
            // cond:
            // result: x
 
            // match: (MOVDGT _ x (FlagGT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDLE_0(ref Value v)
        { 
            // match: (MOVDLE x y (InvertFlags cmp))
            // cond:
            // result: (MOVDGE x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDGE);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDLE _ x (FlagEQ))
            // cond:
            // result: x
 
            // match: (MOVDLE _ x (FlagEQ))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDLE _ x (FlagLT))
            // cond:
            // result: x
 
            // match: (MOVDLE _ x (FlagLT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDLE y _ (FlagGT))
            // cond:
            // result: y
 
            // match: (MOVDLE y _ (FlagGT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDLT_0(ref Value v)
        { 
            // match: (MOVDLT x y (InvertFlags cmp))
            // cond:
            // result: (MOVDGT x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDGT);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDLT y _ (FlagEQ))
            // cond:
            // result: y
 
            // match: (MOVDLT y _ (FlagEQ))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDLT _ x (FlagLT))
            // cond:
            // result: x
 
            // match: (MOVDLT _ x (FlagLT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDLT y _ (FlagGT))
            // cond:
            // result: y
 
            // match: (MOVDLT y _ (FlagGT))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDNE_0(ref Value v)
        { 
            // match: (MOVDNE x y (InvertFlags cmp))
            // cond:
            // result: (MOVDNE x y cmp)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XInvertFlags)
                {
                    break;
                }
                var cmp = v_2.Args[0L];
                v.reset(OpS390XMOVDNE);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(cmp);
                return true;
            } 
            // match: (MOVDNE y _ (FlagEQ))
            // cond:
            // result: y
 
            // match: (MOVDNE y _ (FlagEQ))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[2L];
                y = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDNE _ x (FlagLT))
            // cond:
            // result: x
 
            // match: (MOVDNE _ x (FlagLT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDNE _ x (FlagGT))
            // cond:
            // result: x
 
            // match: (MOVDNE _ x (FlagGT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDaddridx_0(ref Value v)
        { 
            // match: (MOVDaddridx [c] {s} (ADDconst [d] x) y)
            // cond: is20Bit(c+d) && x.Op != OpSB
            // result: (MOVDaddridx [c+d] {s} x y)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(is20Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDaddridx [c] {s} x (ADDconst [d] y))
            // cond: is20Bit(c+d) && y.Op != OpSB
            // result: (MOVDaddridx [c+d] {s} x y)
 
            // match: (MOVDaddridx [c] {s} x (ADDconst [d] y))
            // cond: is20Bit(c+d) && y.Op != OpSB
            // result: (MOVDaddridx [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(is20Bit(c + d) && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDaddridx [off1] {sym1} (MOVDaddr [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (MOVDaddridx [off1] {sym1} (MOVDaddr [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                y = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MOVDaddridx [off1] {sym1} x (MOVDaddr [off2] {sym2} y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && y.Op != OpSB
            // result: (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (MOVDaddridx [off1] {sym1} x (MOVDaddr [off2] {sym2} y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && y.Op != OpSB
            // result: (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                y = v_1.Args[0L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDaddridx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDload_0(ref Value v)
        { 
            // match: (MOVDload [off] {sym} ptr1 (MOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVDreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (LGDR x)
 
            // match: (MOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (LGDR x)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                ptr2 = v_1.Args[0L];
                x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XLGDR);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVDload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVDload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%8 == 0 && (off1+off2)%8 == 0))
            // result: (MOVDload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVDload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%8 == 0 && (off1+off2)%8 == 0))
            // result: (MOVDload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 8L == 0L && (off1 + off2) % 8L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVDloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVDload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVDloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVDloadidx  [off] {sym} ptr idx mem)
 
            // match: (MOVDload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVDloadidx  [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDloadidx_0(ref Value v)
        { 
            // match: (MOVDloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVDloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVDloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVDloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVDloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDnop_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVDnop <t> x)
            // cond: t.Compare(x.Type) == types.CMPeq
            // result: x
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (!(t.Compare(x.Type) == types.CMPeq))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDnop (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c])
 
            // match: (MOVDnop (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDnop <t> x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDnop_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVDnop <t> x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBloadidx)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[2L];
                var ptr = x.Args[0L];
                var idx = x.Args[1L];
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDnop <t> x:(MOVDloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDnop <t> x:(MOVDloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVDreg <t> x)
            // cond: t.Compare(x.Type) == types.CMPeq
            // result: x
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (!(t.Compare(x.Type) == types.CMPeq))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c])
 
            // match: (MOVDreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (MOVDreg x)
            // cond: x.Uses == 1
            // result: (MOVDnop x)
 
            // match: (MOVDreg x)
            // cond: x.Uses == 1
            // result: (MOVDnop x)
            while (true)
            {
                x = v.Args[0L];
                if (!(x.Uses == 1L))
                {
                    break;
                }
                v.reset(OpS390XMOVDnop);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVBZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload  <t> [off] {sym} ptr mem)
 
            // match: (MOVDreg <t> x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload  <t> [off] {sym} ptr mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDreg_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVDreg <t> x:(MOVBZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[2L];
                var ptr = x.Args[0L];
                var idx = x.Args[1L];
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVBZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVBloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVBloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVDreg <t> x:(MOVDloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDloadidx  <t> [off] {sym} ptr idx mem)
 
            // match: (MOVDreg <t> x:(MOVDloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDloadidx  <t> [off] {sym} ptr idx mem)
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (x.Op != OpS390XMOVDloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDstore_0(ref Value v)
        { 
            // match: (MOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVDstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVDstoreconst [makeValAndOff(c,off)] {sym} ptr mem)
 
            // match: (MOVDstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVDstoreconst [makeValAndOff(c,off)] {sym} ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreconst);
                v.AuxInt = makeValAndOff(c, off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%8 == 0 && (off1+off2)%8 == 0))
            // result: (MOVDstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVDstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%8 == 0 && (off1+off2)%8 == 0))
            // result: (MOVDstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 8L == 0L && (off1 + off2) % 8L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVDstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVDstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVDstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVDstoreidx  [off] {sym} ptr idx val mem)
 
            // match: (MOVDstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVDstoreidx  [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [i] {s} p w1 x:(MOVDstore [i-8] {s} p w0 mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && is20Bit(i-8)   && clobber(x)
            // result: (STMG2 [i-8] {s} p w0 w1 mem)
 
            // match: (MOVDstore [i] {s} p w1 x:(MOVDstore [i-8] {s} p w0 mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && is20Bit(i-8)   && clobber(x)
            // result: (STMG2 [i-8] {s} p w0 w1 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w1 = v.Args[1L];
                var x = v.Args[2L];
                if (x.Op != OpS390XMOVDstore)
                {
                    break;
                }
                if (x.AuxInt != i - 8L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && is20Bit(i - 8L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTMG2);
                v.AuxInt = i - 8L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [i] {s} p w2 x:(STMG2 [i-16] {s} p w0 w1 mem))
            // cond: x.Uses == 1   && is20Bit(i-16)   && clobber(x)
            // result: (STMG3 [i-16] {s} p w0 w1 w2 mem)
 
            // match: (MOVDstore [i] {s} p w2 x:(STMG2 [i-16] {s} p w0 w1 mem))
            // cond: x.Uses == 1   && is20Bit(i-16)   && clobber(x)
            // result: (STMG3 [i-16] {s} p w0 w1 w2 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w2 = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XSTMG2)
                {
                    break;
                }
                if (x.AuxInt != i - 16L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                w1 = x.Args[2L];
                mem = x.Args[3L];
                if (!(x.Uses == 1L && is20Bit(i - 16L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTMG3);
                v.AuxInt = i - 16L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [i] {s} p w3 x:(STMG3 [i-24] {s} p w0 w1 w2 mem))
            // cond: x.Uses == 1   && is20Bit(i-24)   && clobber(x)
            // result: (STMG4 [i-24] {s} p w0 w1 w2 w3 mem)
 
            // match: (MOVDstore [i] {s} p w3 x:(STMG3 [i-24] {s} p w0 w1 w2 mem))
            // cond: x.Uses == 1   && is20Bit(i-24)   && clobber(x)
            // result: (STMG4 [i-24] {s} p w0 w1 w2 w3 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w3 = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XSTMG3)
                {
                    break;
                }
                if (x.AuxInt != i - 24L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[4L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                w1 = x.Args[2L];
                w2 = x.Args[3L];
                mem = x.Args[4L];
                if (!(x.Uses == 1L && is20Bit(i - 24L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTMG4);
                v.AuxInt = i - 24L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(w3);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDstoreconst_0(ref Value v)
        { 
            // match: (MOVDstoreconst [sc] {s} (ADDconst [off] ptr) mem)
            // cond: isU12Bit(ValAndOff(sc).Off()+off)
            // result: (MOVDstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(isU12Bit(ValAndOff(sc).Off() + off)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVDstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVDstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVDstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVDstoreidx_0(ref Value v)
        { 
            // match: (MOVDstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVDstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVDstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVDstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVDstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHBRstore_0(ref Value v)
        { 
            // match: (MOVHBRstore [i] {s} p (SRDconst [16] w) x:(MOVHBRstore [i-2] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 16L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpS390XMOVHBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstore [i] {s} p (SRDconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w0 mem)
 
            // match: (MOVHBRstore [i] {s} p (SRDconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstore [i] {s} p (SRWconst [16] w) x:(MOVHBRstore [i-2] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w mem)
 
            // match: (MOVHBRstore [i] {s} p (SRWconst [16] w) x:(MOVHBRstore [i-2] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 16L)
                {
                    break;
                }
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstore [i] {s} p (SRWconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w0 mem)
 
            // match: (MOVHBRstore [i] {s} p (SRWconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstore [i-2] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHBRstoreidx_0(ref Value v)
        { 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRDconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHBRstoreidx_10(ref Value v)
        { 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var idx = v.Args[0L];
                var p = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [16] w) x:(MOVHBRstoreidx [i-2] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} p idx (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} p idx w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHBRstoreidx [i] {s} idx p (SRWconst [j] w) x:(MOVHBRstoreidx [i-2] {s} idx p w0:(SRWconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWBRstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWBRstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHZload_0(ref Value v)
        { 
            // match: (MOVHZload [off] {sym} ptr1 (MOVHstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVHZreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHZload [off1+off2] {sym} ptr mem)
 
            // match: (MOVHZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHZload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVHZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 2L == 0L && (off1 + off2) % 2L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVHZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVHZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHZloadidx [off] {sym} ptr idx mem)
 
            // match: (MOVHZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHZloadidx [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHZloadidx_0(ref Value v)
        { 
            // match: (MOVHZloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVHZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVHZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVHZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVHZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHZreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVHZreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHZreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t)) && !isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVHZreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t)) && !isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!((is8BitInt(t) || is16BitInt(t)) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHZreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHZreg x:(MOVHZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint16(c))])
 
            // match: (MOVHZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(uint16(c));
                return true;
            } 
            // match: (MOVHZreg x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVHZreg x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVHZreg x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVHZreg x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVHZreg x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHload_0(ref Value v)
        { 
            // match: (MOVHload [off] {sym} ptr1 (MOVHstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVHreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVHload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVHload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 2L == 0L && (off1 + off2) % 2L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVHload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHloadidx  [off] {sym} ptr idx mem)
 
            // match: (MOVHload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHloadidx  [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHloadidx_0(ref Value v)
        { 
            // match: (MOVHloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVHloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVHloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVHloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVHloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVHreg x:(MOVBload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t)) && isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t)) && isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!((is8BitInt(t) || is16BitInt(t)) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVHreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int16(c))])
 
            // match: (MOVHreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int16(c));
                return true;
            } 
            // match: (MOVHreg x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVHreg x:(MOVHZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVHreg x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVHreg x:(MOVHload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHreg_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVHreg x:(MOVHZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[2L];
                var ptr = x.Args[0L];
                var idx = x.Args[1L];
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVHreg x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVHreg x:(MOVHloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVHloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVHloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHstore_0(ref Value v)
        { 
            // match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVHreg)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVHZreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVHZreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVHstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVHstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVHstoreconst [makeValAndOff(int64(int16(c)),off)] {sym} ptr mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVHstoreconst [makeValAndOff(int64(int16(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(isU12Bit(off) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = makeValAndOff(int64(int16(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVHstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%2 == 0 && (off1+off2)%2 == 0))
            // result: (MOVHstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 2L == 0L && (off1 + off2) % 2L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVHstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVHstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHstoreidx  [off] {sym} ptr idx val mem)
 
            // match: (MOVHstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVHstoreidx  [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRDconst [16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w mem)
 
            // match: (MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRDconst [16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [i] {s} p w0:(SRDconst [j] w) x:(MOVHstore [i-2] {s} p (SRDconst [j+16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w0 mem)
 
            // match: (MOVHstore [i] {s} p w0:(SRDconst [j] w) x:(MOVHstore [i-2] {s} p (SRDconst [j+16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w0 = v.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_1.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRWconst [16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w mem)
 
            // match: (MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRWconst [16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                w = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHstore_10(ref Value v)
        { 
            // match: (MOVHstore [i] {s} p w0:(SRWconst [j] w) x:(MOVHstore [i-2] {s} p (SRWconst [j+16] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-2] {s} p w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w0 = v.Args[1L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                var w = w0.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpS390XMOVHstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_1.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHstoreconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVHstoreconst [sc] {s} (ADDconst [off] ptr) mem)
            // cond: isU12Bit(ValAndOff(sc).Off()+off)
            // result: (MOVHstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(isU12Bit(ValAndOff(sc).Off() + off)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVHstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVHstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVHstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreconst [c] {s} p x:(MOVHstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstore [ValAndOff(a).Off()] {s} p (MOVDconst [int64(int32(ValAndOff(c).Val()&0xffff | ValAndOff(a).Val()<<16))]) mem)
 
            // match: (MOVHstoreconst [c] {s} p x:(MOVHstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstore [ValAndOff(a).Off()] {s} p (MOVDconst [int64(int32(ValAndOff(c).Val()&0xffff | ValAndOff(a).Val()<<16))]) mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                var x = v.Args[1L];
                if (x.Op != OpS390XMOVHstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(p.Op != OpSB && x.Uses == 1L && ValAndOff(a).Off() + 2L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = ValAndOff(a).Off();
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = int64(int32(ValAndOff(c).Val() & 0xffffUL | ValAndOff(a).Val() << (int)(16L)));
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHstoreidx_0(ref Value v)
        { 
            // match: (MOVHstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVHstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVHstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVHstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVHstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVHstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var w = v.Args[2L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVHstoreidx_10(ref Value v)
        { 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var idx = v.Args[0L];
                var p = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                var w = w0.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRDconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} p idx w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} p idx (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
 
            // match: (MOVHstoreidx [i] {s} idx p w0:(SRWconst [j] w) x:(MOVHstoreidx [i-2] {s} idx p (SRWconst [j+16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRWconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVHstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRWconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 16L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWBRstore_0(ref Value v)
        { 
            // match: (MOVWBRstore [i] {s} p (SRDconst [32] w) x:(MOVWBRstore [i-4] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstore [i-4] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpS390XMOVWBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstore [i] {s} p (SRDconst [j] w) x:(MOVWBRstore [i-4] {s} p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstore [i-4] {s} p w0 mem)
 
            // match: (MOVWBRstore [i] {s} p (SRDconst [j] w) x:(MOVWBRstore [i-4] {s} p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstore [i-4] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVWBRstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWBRstoreidx_0(ref Value v)
        { 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [32] w) x:(MOVWBRstoreidx [i-4] {s} idx p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} p idx w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} p idx w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} idx p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWBRstoreidx [i] {s} p idx (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} idx p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} p idx w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} p idx w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} idx p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWBRstoreidx [i] {s} idx p (SRDconst [j] w) x:(MOVWBRstoreidx [i-4] {s} idx p w0:(SRDconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDBRstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWBRstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                w0 = x.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDBRstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWZload_0(ref Value v)
        { 
            // match: (MOVWZload [off] {sym} ptr1 (MOVWstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVWZreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVWstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWZload [off1+off2] {sym} ptr mem)
 
            // match: (MOVWZload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWZload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVWZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWZload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 4L == 0L && (off1 + off2) % 4L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVWZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWZload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWZloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWZloadidx [off] {sym} ptr idx mem)
 
            // match: (MOVWZload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWZloadidx [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWZloadidx_0(ref Value v)
        { 
            // match: (MOVWZloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVWZloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVWZloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
 
            // match: (MOVWZloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVWZloadidx [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWZloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWZreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWZreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(MOVWZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(MOVWZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && !isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && !isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!((is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(MOVHZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(MOVHZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg x:(MOVWZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWZreg x:(MOVWZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint32(c))])
 
            // match: (MOVWZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(uint32(c));
                return true;
            } 
            // match: (MOVWZreg x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWZreg x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWZreg x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWZreg x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWZreg_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWZreg x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[2L];
                var ptr = x.Args[0L];
                var idx = x.Args[1L];
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWZreg x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVWZreg x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWZloadidx <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWload_0(ref Value v)
        { 
            // match: (MOVWload [off] {sym} ptr1 (MOVWstore [off] {sym} ptr2 x _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MOVWreg x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVWstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVWload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVWload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 4L == 0L && (off1 + off2) % 4L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWload [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWloadidx  [off] {sym} ptr idx mem)
 
            // match: (MOVWload [off] {sym} (ADD ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWloadidx  [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWloadidx_0(ref Value v)
        { 
            // match: (MOVWloadidx [c] {sym} (ADDconst [d] ptr) idx mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx [c] {sym} idx (ADDconst [d] ptr) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx [c] {sym} ptr (ADDconst [d] idx) mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx [c] {sym} (ADDconst [d] idx) ptr mem)
            // cond: is20Bit(c+d)
            // result: (MOVWloadidx  [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWloadidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWreg_0(ref Value v)
        { 
            // match: (MOVWreg x:(MOVBload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVBload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVBZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVHload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVHload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVHZload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVWload _ _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVWload _ _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && isSigned(t)
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(Arg <t>))
            // cond: (is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && isSigned(t)
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpArg)
                {
                    break;
                }
                var t = x.Type;
                if (!((is8BitInt(t) || is16BitInt(t) || is32BitInt(t)) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVBreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVBZreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVBZreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
 
            // match: (MOVWreg x:(MOVHreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVHreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWreg_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWreg x:(MOVWreg _))
            // cond:
            // result: (MOVDreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpS390XMOVWreg)
                {
                    break;
                }
                v.reset(OpS390XMOVDreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int32(c))])
 
            // match: (MOVWreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int32(c));
                return true;
            } 
            // match: (MOVWreg x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWreg x:(MOVWZload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWreg x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWreg x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload  <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWreg x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVWreg x:(MOVWZloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWreg x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVWreg x:(MOVWloadidx [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx  <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpS390XMOVWloadidx)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpS390XMOVWloadidx, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWstore_0(ref Value v)
        { 
            // match: (MOVWstore [off] {sym} ptr (MOVWreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVWreg)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpS390XMOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVWZreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVWZreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpS390XMOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVWstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is20Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVWstoreconst [makeValAndOff(int64(int32(c)),off)] {sym} ptr mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB
            // result: (MOVWstoreconst [makeValAndOff(int64(int32(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(is16Bit(c) && isU12Bit(off) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreconst);
                v.AuxInt = makeValAndOff(int64(int32(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVWstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment()%4 == 0 && (off1+off2)%4 == 0))
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var t = v_0.Type;
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && (@base.Op != OpSB || (t.IsPtr() && t.ElemType().Alignment() % 4L == 0L && (off1 + off2) % 4L == 0L))))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVWstore [off1] {sym1} (MOVDaddridx [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddridx)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWstoreidx  [off] {sym} ptr idx val mem)
 
            // match: (MOVWstore [off] {sym} (ADD ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWstoreidx  [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p (SRDconst [32] w) x:(MOVWstore [i-4] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVDstore [i-4] {s} p w mem)
 
            // match: (MOVWstore [i] {s} p (SRDconst [32] w) x:(MOVWstore [i-4] {s} p w mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVDstore [i-4] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVWstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p w0:(SRDconst [j] w) x:(MOVWstore [i-4] {s} p (SRDconst [j+32] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVDstore [i-4] {s} p w0 mem)
 
            // match: (MOVWstore [i] {s} p w0:(SRDconst [j] w) x:(MOVWstore [i-4] {s} p (SRDconst [j+32] w) mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && clobber(x)
            // result: (MOVDstore [i-4] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w0 = v.Args[1L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVWstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var x_1 = x.Args[1L];
                if (x_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_1.AuxInt != j + 32L)
                {
                    break;
                }
                if (w != x_1.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p w1 x:(MOVWstore [i-4] {s} p w0 mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && is20Bit(i-4)   && clobber(x)
            // result: (STM2 [i-4] {s} p w0 w1 mem)
 
            // match: (MOVWstore [i] {s} p w1 x:(MOVWstore [i-4] {s} p w0 mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && is20Bit(i-4)   && clobber(x)
            // result: (STM2 [i-4] {s} p w0 w1 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w1 = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XMOVWstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                mem = x.Args[2L];
                if (!(p.Op != OpSB && x.Uses == 1L && is20Bit(i - 4L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTM2);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWstore_10(ref Value v)
        { 
            // match: (MOVWstore [i] {s} p w2 x:(STM2 [i-8] {s} p w0 w1 mem))
            // cond: x.Uses == 1   && is20Bit(i-8)   && clobber(x)
            // result: (STM3 [i-8] {s} p w0 w1 w2 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w2 = v.Args[1L];
                var x = v.Args[2L];
                if (x.Op != OpS390XSTM2)
                {
                    break;
                }
                if (x.AuxInt != i - 8L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                var w1 = x.Args[2L];
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && is20Bit(i - 8L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTM3);
                v.AuxInt = i - 8L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p w3 x:(STM3 [i-12] {s} p w0 w1 w2 mem))
            // cond: x.Uses == 1   && is20Bit(i-12)   && clobber(x)
            // result: (STM4 [i-12] {s} p w0 w1 w2 w3 mem)
 
            // match: (MOVWstore [i] {s} p w3 x:(STM3 [i-12] {s} p w0 w1 w2 mem))
            // cond: x.Uses == 1   && is20Bit(i-12)   && clobber(x)
            // result: (STM4 [i-12] {s} p w0 w1 w2 w3 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var w3 = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpS390XSTM3)
                {
                    break;
                }
                if (x.AuxInt != i - 12L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[4L];
                if (p != x.Args[0L])
                {
                    break;
                }
                w0 = x.Args[1L];
                w1 = x.Args[2L];
                w2 = x.Args[3L];
                mem = x.Args[4L];
                if (!(x.Uses == 1L && is20Bit(i - 12L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTM4);
                v.AuxInt = i - 12L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(w3);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWstoreconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVWstoreconst [sc] {s} (ADDconst [off] ptr) mem)
            // cond: isU12Bit(ValAndOff(sc).Off()+off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(isU12Bit(ValAndOff(sc).Off() + off)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVWstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem)
            // cond: ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB && canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVDstore [ValAndOff(a).Off()] {s} p (MOVDconst [ValAndOff(c).Val()&0xffffffff | ValAndOff(a).Val()<<32]) mem)
 
            // match: (MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem))
            // cond: p.Op != OpSB   && x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVDstore [ValAndOff(a).Off()] {s} p (MOVDconst [ValAndOff(c).Val()&0xffffffff | ValAndOff(a).Val()<<32]) mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                var x = v.Args[1L];
                if (x.Op != OpS390XMOVWstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(p.Op != OpSB && x.Uses == 1L && ValAndOff(a).Off() + 4L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AuxInt = ValAndOff(a).Off();
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = ValAndOff(c).Val() & 0xffffffffUL | ValAndOff(a).Val() << (int)(32L);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWstoreidx_0(ref Value v)
        { 
            // match: (MOVWstoreidx [c] {sym} (ADDconst [d] ptr) idx val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx [c] {sym} idx (ADDconst [d] ptr) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx [c] {sym} ptr (ADDconst [d] idx) val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx [c] {sym} (ADDconst [d] idx) ptr val mem)
            // cond: is20Bit(c+d)
            // result: (MOVWstoreidx  [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is20Bit(c + d)))
                {
                    break;
                }
                v.reset(OpS390XMOVWstoreidx);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} p idx w x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWstoreidx [i] {s} p idx w x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var w = v.Args[2L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} p idx w x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWstoreidx [i] {s} p idx w x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} idx p w x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWstoreidx [i] {s} idx p w x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} idx p w x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
 
            // match: (MOVWstoreidx [i] {s} idx p w x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w = v.Args[2L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWstoreidx [i] {s} p idx w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMOVWstoreidx_10(ref Value v)
        { 
            // match: (MOVWstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} p idx (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var idx = v.Args[0L];
                var p = v.Args[1L];
                var w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                var j = w0.AuxInt;
                var w = w0.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
 
            // match: (MOVWstoreidx [i] {s} idx p w0:(SRDconst [j] w) x:(MOVWstoreidx [i-4] {s} idx p (SRDconst [j+32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVDstoreidx [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                idx = v.Args[0L];
                p = v.Args[1L];
                w0 = v.Args[2L];
                if (w0.Op != OpS390XSRDconst)
                {
                    break;
                }
                j = w0.AuxInt;
                w = w0.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpS390XMOVWstoreidx)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (idx != x.Args[0L])
                {
                    break;
                }
                if (p != x.Args[1L])
                {
                    break;
                }
                x_2 = x.Args[2L];
                if (x_2.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (x_2.AuxInt != j + 32L)
                {
                    break;
                }
                if (w != x_2.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XMOVDstoreidx);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLD_0(ref Value v)
        { 
            // match: (MULLD x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (MULLDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XMULLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MULLD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (MULLDconst [c] x)
 
            // match: (MULLD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (MULLDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XMULLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MULLD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
 
            // match: (MULLD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
 
            // match: (MULLD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
 
            // match: (MULLD <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
 
            // match: (MULLD <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLDload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLDconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULLDconst [-1] x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpS390XNEG);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (MULLDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (MULLDconst [1] x)
            // cond:
            // result: x
 
            // match: (MULLDconst [1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c)
            // result: (SLDconst [log2(c)] x)
 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c)
            // result: (SLDconst [log2(c)] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpS390XSLDconst);
                v.AuxInt = log2(c);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUB (SLDconst <v.Type> [log2(c+1)] x) x)
 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUB (SLDconst <v.Type> [log2(c+1)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c + 1L) && c >= 15L))
                {
                    break;
                }
                v.reset(OpS390XSUB);
                var v0 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (ADD (SLDconst <v.Type> [log2(c-1)] x) x)
 
            // match: (MULLDconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (ADD (SLDconst <v.Type> [log2(c-1)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 1L) && c >= 17L))
                {
                    break;
                }
                v.reset(OpS390XADD);
                v0 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c*d])
 
            // match: (MULLDconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c*d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c * d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLDload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULLDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (MULLD x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XMULLD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULLDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (MULLDload [off1+off2] {sym} x ptr mem)
 
            // match: (MULLDload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (MULLDload [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (MULLDload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (MULLDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (MULLDload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XMULLDload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLW_0(ref Value v)
        { 
            // match: (MULLW x (MOVDconst [c]))
            // cond:
            // result: (MULLWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XMULLWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (MULLW (MOVDconst [c]) x)
            // cond:
            // result: (MULLWconst [int64(int32(c))] x)
 
            // match: (MULLW (MOVDconst [c]) x)
            // cond:
            // result: (MULLWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XMULLWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (MULLW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
 
            // match: (MULLW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (MULLWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLWconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULLWconst [-1] x)
            // cond:
            // result: (NEGW x)
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpS390XNEGW);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLWconst [0] _)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (MULLWconst [0] _)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (MULLWconst [1] x)
            // cond:
            // result: x
 
            // match: (MULLWconst [1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c)
            // result: (SLWconst [log2(c)] x)
 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c)
            // result: (SLWconst [log2(c)] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpS390XSLWconst);
                v.AuxInt = log2(c);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUBW (SLWconst <v.Type> [log2(c+1)] x) x)
 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUBW (SLWconst <v.Type> [log2(c+1)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c + 1L) && c >= 15L))
                {
                    break;
                }
                v.reset(OpS390XSUBW);
                var v0 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (ADDW (SLWconst <v.Type> [log2(c-1)] x) x)
 
            // match: (MULLWconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (ADDW (SLWconst <v.Type> [log2(c-1)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 1L) && c >= 17L))
                {
                    break;
                }
                v.reset(OpS390XADDW);
                v0 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULLWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [int64(int32(c*d))])
 
            // match: (MULLWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [int64(int32(c*d))])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int32(c * d));
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XMULLWload_0(ref Value v)
        { 
            // match: (MULLWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (MULLWload [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULLWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (MULLWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (MULLWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (MULLWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XMULLWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XNEG_0(ref Value v)
        { 
            // match: (NEG (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [-c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -c;
                return true;
            } 
            // match: (NEG (ADDconst [c] (NEG x)))
            // cond: c != -(1<<31)
            // result: (ADDconst [-c] x)
 
            // match: (NEG (ADDconst [c] (NEG x)))
            // cond: c != -(1<<31)
            // result: (ADDconst [-c] x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XADDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XNEG)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                if (!(c != -(1L << (int)(31L))))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = -c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XNEGW_0(ref Value v)
        { 
            // match: (NEGW (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int32(-c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int32(-c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XNOT_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (NOT x)
            // cond: true
            // result: (XOR (MOVDconst [-1]) x)
            while (true)
            {
                var x = v.Args[0L];
                if (!(true))
                {
                    break;
                }
                v.reset(OpS390XXOR);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDconst, typ.UInt64);
                v0.AuxInt = -1L;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XNOTW_0(ref Value v)
        { 
            // match: (NOTW x)
            // cond: true
            // result: (XORWconst [-1] x)
            while (true)
            {
                var x = v.Args[0L];
                if (!(true))
                {
                    break;
                }
                v.reset(OpS390XXORWconst);
                v.AuxInt = -1L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (OR x (MOVDconst [c]))
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
 
            // match: (OR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (OR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (OR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (MOVDconst [-1<<63]) (LGDR <t> x))
            // cond:
            // result: (LGDR <t> (LNDFR <x.Type> x))
 
            // match: (OR (MOVDconst [-1<<63]) (LGDR <t> x))
            // cond:
            // result: (LGDR <t> (LNDFR <x.Type> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_0.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XLGDR)
                {
                    break;
                }
                var t = v_1.Type;
                x = v_1.Args[0L];
                v.reset(OpS390XLGDR);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XLNDFR, x.Type);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (OR (LGDR <t> x) (MOVDconst [-1<<63]))
            // cond:
            // result: (LGDR <t> (LNDFR <x.Type> x))
 
            // match: (OR (LGDR <t> x) (MOVDconst [-1<<63]))
            // cond:
            // result: (LGDR <t> (LNDFR <x.Type> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLGDR)
                {
                    break;
                }
                t = v_0.Type;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v.reset(OpS390XLGDR);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpS390XLNDFR, x.Type);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (OR (SLDconst [63] (SRDconst [63] (LGDR x))) (LGDR (LPDFR <t> y)))
            // cond:
            // result: (LGDR (CPSDR <t> y x))
 
            // match: (OR (SLDconst [63] (SRDconst [63] (LGDR x))) (LGDR (LPDFR <t> y)))
            // cond:
            // result: (LGDR (CPSDR <t> y x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 63L)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != 63L)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpS390XLGDR)
                {
                    break;
                }
                x = v_0_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XLGDR)
                {
                    break;
                }
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpS390XLPDFR)
                {
                    break;
                }
                t = v_1_0.Type;
                var y = v_1_0.Args[0L];
                v.reset(OpS390XLGDR);
                v0 = b.NewValue0(v.Pos, OpS390XCPSDR, t);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (OR (LGDR (LPDFR <t> y)) (SLDconst [63] (SRDconst [63] (LGDR x))))
            // cond:
            // result: (LGDR (CPSDR <t> y x))
 
            // match: (OR (LGDR (LPDFR <t> y)) (SLDconst [63] (SRDconst [63] (LGDR x))))
            // cond:
            // result: (LGDR (CPSDR <t> y x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XLGDR)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XLPDFR)
                {
                    break;
                }
                t = v_0_0.Type;
                y = v_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 63L)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpS390XLGDR)
                {
                    break;
                }
                x = v_1_0_0.Args[0L];
                v.reset(OpS390XLGDR);
                v0 = b.NewValue0(v.Pos, OpS390XCPSDR, t);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (OR (SLDconst [63] (SRDconst [63] (LGDR x))) (MOVDconst [c]))
            // cond: c & -1<<63 == 0
            // result: (LGDR (CPSDR <x.Type> (FMOVDconst <x.Type> [c]) x))
 
            // match: (OR (SLDconst [63] (SRDconst [63] (LGDR x))) (MOVDconst [c]))
            // cond: c & -1<<63 == 0
            // result: (LGDR (CPSDR <x.Type> (FMOVDconst <x.Type> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 63L)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != 63L)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpS390XLGDR)
                {
                    break;
                }
                x = v_0_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & -1L << (int)(63L) == 0L))
                {
                    break;
                }
                v.reset(OpS390XLGDR);
                v0 = b.NewValue0(v.Pos, OpS390XCPSDR, x.Type);
                var v1 = b.NewValue0(v.Pos, OpS390XFMOVDconst, x.Type);
                v1.AuxInt = c;
                v0.AddArg(v1);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (OR (MOVDconst [c]) (SLDconst [63] (SRDconst [63] (LGDR x))))
            // cond: c & -1<<63 == 0
            // result: (LGDR (CPSDR <x.Type> (FMOVDconst <x.Type> [c]) x))
 
            // match: (OR (MOVDconst [c]) (SLDconst [63] (SRDconst [63] (LGDR x))))
            // cond: c & -1<<63 == 0
            // result: (LGDR (CPSDR <x.Type> (FMOVDconst <x.Type> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 63L)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpS390XLGDR)
                {
                    break;
                }
                x = v_1_0_0.Args[0L];
                if (!(c & -1L << (int)(63L) == 0L))
                {
                    break;
                }
                v.reset(OpS390XLGDR);
                v0 = b.NewValue0(v.Pos, OpS390XCPSDR, x.Type);
                v1 = b.NewValue0(v.Pos, OpS390XFMOVDconst, x.Type);
                v1.AuxInt = c;
                v0.AddArg(v1);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (OR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c|d])
 
            // match: (OR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (OR x x)
            // cond:
            // result: x
 
            // match: (OR x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (OR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
 
            // match: (OR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (OR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
 
            // match: (OR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (OR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
 
            // match: (OR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (OR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
 
            // match: (OR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVBZload [i1] {s} p mem) sh:(SLDconst [8] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
 
            // match: (OR x1:(MOVBZload [i1] {s} p mem) sh:(SLDconst [8] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                mem = x1.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZload [i0] {s} p mem)) x1:(MOVBZload [i1] {s} p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZload [i0] {s} p mem)) x1:(MOVBZload [i1] {s} p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVHZload [i1] {s} p mem) sh:(SLDconst [16] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
 
            // match: (OR x1:(MOVHZload [i1] {s} p mem) sh:(SLDconst [16] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZload [i0] {s} p mem)) x1:(MOVHZload [i1] {s} p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVWZload [i1] {s} p mem) sh:(SLDconst [32] x0:(MOVWZload [i0] {s} p mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDload [i0] {s} p mem)
 
            // match: (OR x1:(MOVWZload [i1] {s} p mem) sh:(SLDconst [32] x0:(MOVWZload [i0] {s} p mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVWZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZload [i0] {s} p mem)) x1:(MOVWZload [i1] {s} p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDload [i0] {s} p mem)
 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZload [i0] {s} p mem)) x1:(MOVWZload [i1] {s} p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVWZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) y) s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) y) s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem))) s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem))) s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem)) y) s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem)) y) s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_30(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem))) s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                var mem = x1.Args[1L];
                var s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                var idx = x1.Args[1L];
                mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_40(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVWZloadidx [i1] {s} p idx mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVWZloadidx [i1] {s} p idx mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVWZloadidx [i1] {s} idx p mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVWZloadidx [i1] {s} idx p mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR x1:(MOVWZloadidx [i1] {s} p idx mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR x1:(MOVWZloadidx [i1] {s} p idx mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_50(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR x1:(MOVWZloadidx [i1] {s} idx p mem) sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)) x1:(MOVWZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)) x1:(MOVWZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)) x1:(MOVWZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)) x1:(MOVWZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)) x1:(MOVWZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} p idx mem)) x1:(MOVWZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)) x1:(MOVWZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] x0:(MOVWZloadidx [i0] {s} idx p mem)) x1:(MOVWZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+4   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVWZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDloadidx, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_60(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_70(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)) or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_80(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var y = or.Args[1L];
                var s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem)) y) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} p idx mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
 
            // match: (OR or:(OR y s1:(SLDconst [j1] x1:(MOVHZloadidx [i1] {s} idx p mem))) s0:(SLDconst [j0] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR x0:(MOVBZload [i0] {s} p mem) sh:(SLDconst [8] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
 
            // match: (OR x0:(MOVBZload [i0] {s} p mem) sh:(SLDconst [8] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZload [i1] {s} p mem)) x0:(MOVBZload [i0] {s} p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZload [i1] {s} p mem)) x0:(MOVBZload [i0] {s} p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRload [i0] {s} p mem))
 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_90(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                var mem = x1.Args[1L];
                var r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRload [i0] {s} p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRload [i1] {s} p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRload [i0] {s} p mem)
 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRload [i0] {s} p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRload [i1] {s} p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRload [i1] {s} p mem))) r0:(MOVWZreg x0:(MOVWBRload [i0] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRload [i0] {s} p mem)
 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRload [i1] {s} p mem))) r0:(MOVWZreg x0:(MOVWBRload [i0] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) y) s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) y) s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem))) s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem))) s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_100(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                var idx = x0.Args[1L];
                mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_110(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
 
            // match: (OR sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_120(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} p idx mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
 
            // match: (OR sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRloadidx [i1] {s} idx p mem))) r0:(MOVWZreg x0:(MOVWBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVDBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVWZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVWBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVDBRloadidx, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_130(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_140(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR y s0:(SLDconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLDconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XOR_150(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var y = or.Args[1L];
                var s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem))) y) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (OR or:(OR y s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))) s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XOR)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLDconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLDconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XOR, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLDconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVWZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_0(ref Value v)
        { 
            // match: (ORW x (MOVDconst [c]))
            // cond:
            // result: (ORWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XORWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ORW (MOVDconst [c]) x)
            // cond:
            // result: (ORWconst [int64(int32(c))] x)
 
            // match: (ORW (MOVDconst [c]) x)
            // cond:
            // result: (ORWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XORWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (ORW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (ORW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (ORW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORW x x)
            // cond:
            // result: x
 
            // match: (ORW x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                var x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
 
            // match: (ORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (ORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVBZload [i1] {s} p mem) sh:(SLWconst [8] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
 
            // match: (ORW x1:(MOVBZload [i1] {s} p mem) sh:(SLWconst [8] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                mem = x1.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZload [i0] {s} p mem)) x1:(MOVBZload [i1] {s} p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZload [i0] {s} p mem)) x1:(MOVBZload [i1] {s} p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVHZload [i1] {s} p mem) sh:(SLWconst [16] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
 
            // match: (ORW x1:(MOVHZload [i1] {s} p mem) sh:(SLWconst [16] x0:(MOVHZload [i0] {s} p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZload [i0] {s} p mem)) x1:(MOVHZload [i1] {s} p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZload [i0] {s} p mem)) x1:(MOVHZload [i1] {s} p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) y) s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) y) s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem))) s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                var mem = x1.Args[1L];
                var s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                var idx = x1.Args[1L];
                mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} p idx mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVBZloadidx [i1] {s} idx p mem) sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} p idx mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [8] x0:(MOVBZloadidx [i0] {s} idx p mem)) x1:(MOVBZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+1   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_30(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} p idx mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW x1:(MOVHZloadidx [i1] {s} idx p mem) sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} p idx mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} p idx mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] x0:(MOVHZloadidx [i0] {s} idx p mem)) x1:(MOVHZloadidx [i1] {s} idx p mem))
            // cond: i1 == i0+2   && p.Op != OpSB   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWZloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpS390XMOVHZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && p.Op != OpSB && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWZloadidx, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_40(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_50(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW or:(ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) y) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var y = or.Args[1L];
                var s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
 
            // match: (ORW or:(ORW y s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem))) s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZloadidx [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZloadidx, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW x0:(MOVBZload [i0] {s} p mem) sh:(SLWconst [8] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
 
            // match: (ORW x0:(MOVBZload [i0] {s} p mem) sh:(SLWconst [8] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZload [i1] {s} p mem)) x0:(MOVBZload [i0] {s} p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZload [i1] {s} p mem)) x0:(MOVBZload [i0] {s} p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRload [i0] {s} p mem)
 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRload [i0] {s} p mem)
 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) y) s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) y) s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_60(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem))) s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                var idx = x0.Args[1L];
                mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} p idx mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW x0:(MOVBZloadidx [i0] {s} idx p mem) sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} p idx mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} p idx mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
 
            // match: (ORW sh:(SLWconst [8] x1:(MOVBZloadidx [i1] {s} idx p mem)) x0:(MOVBZloadidx [i0] {s} idx p mem))
            // cond: p.Op != OpSB   && i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_70(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                r0 = v.Args[0L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} p idx mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
 
            // match: (ORW sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRloadidx [i1] {s} idx p mem))) r0:(MOVHZreg x0:(MOVHBRloadidx [i0] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWBRloadidx [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpS390XSLWconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r1 = sh.Args[0L];
                if (r1.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                r0 = v.Args[1L];
                if (r0.Op != OpS390XMOVHZreg)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpS390XMOVHBRloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWBRloadidx, typ.Int32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_80(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)) or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} p idx mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORW_90(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORW or:(ORW s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem)) y) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var y = or.Args[1L];
                var s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                var v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} p idx mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
 
            // match: (ORW or:(ORW y s0:(SLWconst [j0] x0:(MOVBZloadidx [i0] {s} idx p mem))) s1:(SLWconst [j1] x1:(MOVBZloadidx [i1] {s} idx p mem)))
            // cond: p.Op != OpSB   && i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRloadidx [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpS390XORW)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpS390XSLWconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpS390XSLWconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpS390XMOVBZloadidx)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(p.Op != OpSB && i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpS390XORW, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpS390XSLWconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpS390XMOVHZreg, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpS390XMOVHBRloadidx, typ.Int16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORWconst_0(ref Value v)
        { 
            // match: (ORWconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORWconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVDconst [-1])
 
            // match: (ORWconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVDconst [-1])
            while (true)
            {
                c = v.AuxInt;
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
 
            // match: (ORWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c | d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORWload_0(ref Value v)
        { 
            // match: (ORWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ORWload   [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ORWload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ORWload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XORWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORconst_0(ref Value v)
        { 
            // match: (ORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORconst [-1] _)
            // cond:
            // result: (MOVDconst [-1])
 
            // match: (ORconst [-1] _)
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
 
            // match: (ORconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c | d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XORload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (OR    x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XOR);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ORload    [off1+off2] {sym} x ptr mem)
 
            // match: (ORload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (ORload    [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ORload    [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (ORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (ORload    [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XORload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSLD_0(ref Value v)
        { 
            // match: (SLD x (MOVDconst [c]))
            // cond:
            // result: (SLDconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSLDconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SLD x (ANDconst [63] y))
            // cond:
            // result: (SLD x y)
 
            // match: (SLD x (ANDconst [63] y))
            // cond:
            // result: (SLD x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSLD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSLW_0(ref Value v)
        { 
            // match: (SLW x (MOVDconst [c]))
            // cond:
            // result: (SLWconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSLWconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SLW x (ANDWconst [63] y))
            // cond:
            // result: (SLW x y)
 
            // match: (SLW x (ANDWconst [63] y))
            // cond:
            // result: (SLW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRAD_0(ref Value v)
        { 
            // match: (SRAD x (MOVDconst [c]))
            // cond:
            // result: (SRADconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSRADconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRAD x (ANDconst [63] y))
            // cond:
            // result: (SRAD x y)
 
            // match: (SRAD x (ANDconst [63] y))
            // cond:
            // result: (SRAD x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSRAD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRADconst_0(ref Value v)
        { 
            // match: (SRADconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [d>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = d >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRAW_0(ref Value v)
        { 
            // match: (SRAW x (MOVDconst [c]))
            // cond:
            // result: (SRAWconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSRAWconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRAW x (ANDWconst [63] y))
            // cond:
            // result: (SRAW x y)
 
            // match: (SRAW x (ANDWconst [63] y))
            // cond:
            // result: (SRAW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSRAW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRAWconst_0(ref Value v)
        { 
            // match: (SRAWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [int64(int32(d))>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = int64(int32(d)) >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRD_0(ref Value v)
        { 
            // match: (SRD x (MOVDconst [c]))
            // cond:
            // result: (SRDconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSRDconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRD x (ANDconst [63] y))
            // cond:
            // result: (SRD x y)
 
            // match: (SRD x (ANDconst [63] y))
            // cond:
            // result: (SRD x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSRD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRDconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SRDconst [1] (SLDconst [1] (LGDR <t> x)))
            // cond:
            // result: (LGDR <t> (LPDFR <x.Type> x))
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpS390XLGDR)
                {
                    break;
                }
                var t = v_0_0.Type;
                var x = v_0_0.Args[0L];
                v.reset(OpS390XLGDR);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpS390XLPDFR, x.Type);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSRW_0(ref Value v)
        { 
            // match: (SRW x (MOVDconst [c]))
            // cond:
            // result: (SRWconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSRWconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRW x (ANDWconst [63] y))
            // cond:
            // result: (SRW x y)
 
            // match: (SRW x (ANDWconst [63] y))
            // cond:
            // result: (SRW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XANDWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpS390XSRW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSTM2_0(ref Value v)
        { 
            // match: (STM2 [i] {s} p w2 w3 x:(STM2 [i-8] {s} p w0 w1 mem))
            // cond: x.Uses == 1   && is20Bit(i-8)   && clobber(x)
            // result: (STM4 [i-8] {s} p w0 w1 w2 w3 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                var w2 = v.Args[1L];
                var w3 = v.Args[2L];
                var x = v.Args[3L];
                if (x.Op != OpS390XSTM2)
                {
                    break;
                }
                if (x.AuxInt != i - 8L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                var w1 = x.Args[2L];
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && is20Bit(i - 8L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTM4);
                v.AuxInt = i - 8L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(w3);
                v.AddArg(mem);
                return true;
            } 
            // match: (STM2 [i] {s} p (SRDconst [32] x) x mem)
            // cond:
            // result: (MOVDstore [i] {s} p x mem)
 
            // match: (STM2 [i] {s} p (SRDconst [32] x) x mem)
            // cond:
            // result: (MOVDstore [i] {s} p x mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                x = v_1.Args[0L];
                if (x != v.Args[2L])
                {
                    break;
                }
                mem = v.Args[3L];
                v.reset(OpS390XMOVDstore);
                v.AuxInt = i;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSTMG2_0(ref Value v)
        { 
            // match: (STMG2 [i] {s} p w2 w3 x:(STMG2 [i-16] {s} p w0 w1 mem))
            // cond: x.Uses == 1   && is20Bit(i-16)   && clobber(x)
            // result: (STMG4 [i-16] {s} p w0 w1 w2 w3 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                var w2 = v.Args[1L];
                var w3 = v.Args[2L];
                var x = v.Args[3L];
                if (x.Op != OpS390XSTMG2)
                {
                    break;
                }
                if (x.AuxInt != i - 16L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                var w1 = x.Args[2L];
                var mem = x.Args[3L];
                if (!(x.Uses == 1L && is20Bit(i - 16L) && clobber(x)))
                {
                    break;
                }
                v.reset(OpS390XSTMG4);
                v.AuxInt = i - 16L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(w1);
                v.AddArg(w2);
                v.AddArg(w3);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUB_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUB x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (SUBconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XSUBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUB (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (NEG (SUBconst <v.Type> x [c]))
 
            // match: (SUB (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (NEG (SUBconst <v.Type> x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XNEG);
                var v0 = b.NewValue0(v.Pos, OpS390XSUBconst, v.Type);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUB x x)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (SUB x x)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SUB <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBload <t> [off] {sym} x ptr mem)
 
            // match: (SUB <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XSUBload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBEWcarrymask_0(ref Value v)
        { 
            // match: (SUBEWcarrymask (FlagEQ))
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SUBEWcarrymask (FlagLT))
            // cond:
            // result: (MOVDconst [-1])
 
            // match: (SUBEWcarrymask (FlagLT))
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SUBEWcarrymask (FlagGT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (SUBEWcarrymask (FlagGT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBEcarrymask_0(ref Value v)
        { 
            // match: (SUBEcarrymask (FlagEQ))
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagEQ)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SUBEcarrymask (FlagLT))
            // cond:
            // result: (MOVDconst [-1])
 
            // match: (SUBEcarrymask (FlagLT))
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagLT)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SUBEcarrymask (FlagGT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (SUBEcarrymask (FlagGT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XFlagGT)
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBW_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBW x (MOVDconst [c]))
            // cond:
            // result: (SUBWconst x [int64(int32(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XSUBWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBW (MOVDconst [c]) x)
            // cond:
            // result: (NEGW (SUBWconst <v.Type> x [int64(int32(c))]))
 
            // match: (SUBW (MOVDconst [c]) x)
            // cond:
            // result: (NEGW (SUBWconst <v.Type> x [int64(int32(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XNEGW);
                var v0 = b.NewValue0(v.Pos, OpS390XSUBWconst, v.Type);
                v0.AuxInt = int64(int32(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBW x x)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (SUBW x x)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SUBW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBWload <t> [off] {sym} x ptr mem)
 
            // match: (SUBW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XSUBWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (SUBW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBWload <t> [off] {sym} x ptr mem)
 
            // match: (SUBW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (SUBWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XSUBWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBWconst_0(ref Value v)
        { 
            // match: (SUBWconst [c] x)
            // cond: int32(c) == 0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBWconst [c] x)
            // cond:
            // result: (ADDWconst [int64(int32(-c))] x)
 
            // match: (SUBWconst [c] x)
            // cond:
            // result: (ADDWconst [int64(int32(-c))] x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                v.reset(OpS390XADDWconst);
                v.AuxInt = int64(int32(-c));
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpS390XSUBWload_0(ref Value v)
        { 
            // match: (SUBWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (SUBWload  [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XSUBWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (SUBWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (SUBWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (SUBWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (SUBWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XSUBWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBconst_0(ref Value v)
        { 
            // match: (SUBconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst [c] x)
            // cond: c != -(1<<31)
            // result: (ADDconst [-c] x)
 
            // match: (SUBconst [c] x)
            // cond: c != -(1<<31)
            // result: (ADDconst [-c] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(c != -(1L << (int)(31L))))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = -c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst (MOVDconst [d]) [c])
            // cond:
            // result: (MOVDconst [d-c])
 
            // match: (SUBconst (MOVDconst [d]) [c])
            // cond:
            // result: (MOVDconst [d-c])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = d - c;
                return true;
            } 
            // match: (SUBconst (SUBconst x [d]) [c])
            // cond: is32Bit(-c-d)
            // result: (ADDconst [-c-d] x)
 
            // match: (SUBconst (SUBconst x [d]) [c])
            // cond: is32Bit(-c-d)
            // result: (ADDconst [-c-d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(is32Bit(-c - d)))
                {
                    break;
                }
                v.reset(OpS390XADDconst);
                v.AuxInt = -c - d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XSUBload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (SUB   x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XSUB);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (SUBload   [off1+off2] {sym} x ptr mem)
 
            // match: (SUBload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (SUBload   [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XSUBload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (SUBload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (SUBload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (SUBload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (SUBload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XSUBload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXOR_0(ref Value v)
        { 
            // match: (XOR x (MOVDconst [c]))
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XXORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
 
            // match: (XOR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpS390XXORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (XOR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
 
            // match: (XOR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (RLLGconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLGconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XOR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (XOR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XOR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (XOR x x)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (XOR x x)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (XOR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
 
            // match: (XOR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XOR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
 
            // match: (XOR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XOR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
 
            // match: (XOR <t> g:(MOVDload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXOR_10(ref Value v)
        { 
            // match: (XOR <t> x g:(MOVDload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVDload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORW_0(ref Value v)
        { 
            // match: (XORW x (MOVDconst [c]))
            // cond:
            // result: (XORWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpS390XXORWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (XORW (MOVDconst [c]) x)
            // cond:
            // result: (XORWconst [int64(int32(c))] x)
 
            // match: (XORW (MOVDconst [c]) x)
            // cond:
            // result: (XORWconst [int64(int32(c))] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpS390XXORWconst);
                v.AuxInt = int64(int32(c));
                v.AddArg(x);
                return true;
            } 
            // match: (XORW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (XORW (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSRWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
 
            // match: (XORW (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (RLLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XSRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XSLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpS390XRLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORW x x)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (XORW x x)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpS390XMOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (XORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> g:(MOVWload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> x g:(MOVWload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORW_10(ref Value v)
        { 
            // match: (XORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                var off = g.AuxInt;
                var sym = g.Aux;
                _ = g.Args[1L];
                var ptr = g.Args[0L];
                var mem = g.Args[1L];
                var x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> g:(MOVWZload [off] {sym} ptr mem) x)
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                g = v.Args[0L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                x = v.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
 
            // match: (XORW <t> x g:(MOVWZload [off] {sym} ptr mem))
            // cond: ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)
            // result: (XORWload <t> [off] {sym} x ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                g = v.Args[1L];
                if (g.Op != OpS390XMOVWZload)
                {
                    break;
                }
                off = g.AuxInt;
                sym = g.Aux;
                _ = g.Args[1L];
                ptr = g.Args[0L];
                mem = g.Args[1L];
                if (!(ptr.Op != OpSB && is20Bit(off) && canMergeLoad(v, g, x) && clobber(g)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.Type = t;
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORWconst_0(ref Value v)
        { 
            // match: (XORWconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (XORWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XORWconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c ^ d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORWload_0(ref Value v)
        { 
            // match: (XORWload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (XORWload  [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (XORWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (XORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (XORWload  [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XXORWload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORconst_0(ref Value v)
        { 
            // match: (XORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (XORconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XORconst [c] (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XMOVDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpS390XMOVDconst);
                v.AuxInt = c ^ d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpS390XXORload_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _))
            // cond: isSamePtr(ptr1, ptr2)
            // result: (XOR   x (LGDR <t> y))
            while (true)
            {
                var t = v.Type;
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr1 = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpS390XFMOVDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                var ptr2 = v_2.Args[0L];
                var y = v_2.Args[1L];
                if (!(isSamePtr(ptr1, ptr2)))
                {
                    break;
                }
                v.reset(OpS390XXOR);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpS390XLGDR, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (XORload   [off1+off2] {sym} x ptr mem)
 
            // match: (XORload [off1] {sym} x (ADDconst [off2] ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(off1+off2)
            // result: (XORload   [off1+off2] {sym} x ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpS390XADDconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (XORload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
 
            // match: (XORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem)
            // cond: ptr.Op != OpSB && is20Bit(o1+o2) && canMergeSym(s1, s2)
            // result: (XORload   [o1+o2] {mergeSym(s1, s2)} x ptr mem)
            while (true)
            {
                var o1 = v.AuxInt;
                var s1 = v.Aux;
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpS390XMOVDaddr)
                {
                    break;
                }
                var o2 = v_1.AuxInt;
                var s2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB && is20Bit(o1 + o2) && canMergeSym(s1, s2)))
                {
                    break;
                }
                v.reset(OpS390XXORload);
                v.AuxInt = o1 + o2;
                v.Aux = mergeSym(s1, s2);
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpSelect0_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Select0 <t> (AddTupleFirst32 val tuple))
            // cond:
            // result: (ADDW val (Select0 <t> tuple))
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XAddTupleFirst32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var val = v_0.Args[0L];
                var tuple = v_0.Args[1L];
                v.reset(OpS390XADDW);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpSelect0, t);
                v0.AddArg(tuple);
                v.AddArg(v0);
                return true;
            } 
            // match: (Select0 <t> (AddTupleFirst64 val tuple))
            // cond:
            // result: (ADD val (Select0 <t> tuple))
 
            // match: (Select0 <t> (AddTupleFirst64 val tuple))
            // cond:
            // result: (ADD val (Select0 <t> tuple))
            while (true)
            {
                t = v.Type;
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XAddTupleFirst64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                val = v_0.Args[0L];
                tuple = v_0.Args[1L];
                v.reset(OpS390XADD);
                v.AddArg(val);
                v0 = b.NewValue0(v.Pos, OpSelect0, t);
                v0.AddArg(tuple);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpSelect1_0(ref Value v)
        { 
            // match: (Select1 (AddTupleFirst32 _ tuple))
            // cond:
            // result: (Select1 tuple)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpS390XAddTupleFirst32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var tuple = v_0.Args[1L];
                v.reset(OpSelect1);
                v.AddArg(tuple);
                return true;
            } 
            // match: (Select1 (AddTupleFirst64 _ tuple))
            // cond:
            // result: (Select1 tuple)
 
            // match: (Select1 (AddTupleFirst64 _ tuple))
            // cond:
            // result: (Select1 tuple)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpS390XAddTupleFirst64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                tuple = v_0.Args[1L];
                v.reset(OpSelect1);
                v.AddArg(tuple);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpSignExt16to32_0(ref Value v)
        { 
            // match: (SignExt16to32 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSignExt16to64_0(ref Value v)
        { 
            // match: (SignExt16to64 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSignExt32to64_0(ref Value v)
        { 
            // match: (SignExt32to64 x)
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVWreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSignExt8to16_0(ref Value v)
        { 
            // match: (SignExt8to16 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSignExt8to32_0(ref Value v)
        { 
            // match: (SignExt8to32 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSignExt8to64_0(ref Value v)
        { 
            // match: (SignExt8to64 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSlicemask_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Slicemask <t> x)
            // cond:
            // result: (SRADconst (NEG <t> x) [63])
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpS390XSRADconst);
                v.AuxInt = 63L;
                var v0 = b.NewValue0(v.Pos, OpS390XNEG, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSqrt_0(ref Value v)
        { 
            // match: (Sqrt x)
            // cond:
            // result: (FSQRT x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFSQRT);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpStaticCall_0(ref Value v)
        { 
            // match: (StaticCall [argwid] {target} mem)
            // cond:
            // result: (CALLstatic [argwid] {target} mem)
            while (true)
            {
                var argwid = v.AuxInt;
                var target = v.Aux;
                var mem = v.Args[0L];
                v.reset(OpS390XCALLstatic);
                v.AuxInt = argwid;
                v.Aux = target;
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpStore_0(ref Value v)
        { 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
            // result: (FMOVDstore ptr val mem)
            while (true)
            {
                var t = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && is64BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpS390XFMOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (FMOVSstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (FMOVSstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpS390XFMOVSstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8
            // result: (MOVDstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8
            // result: (MOVDstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L))
                {
                    break;
                }
                v.reset(OpS390XMOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4
            // result: (MOVWstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4
            // result: (MOVWstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L))
                {
                    break;
                }
                v.reset(OpS390XMOVWstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 2L))
                {
                    break;
                }
                v.reset(OpS390XMOVHstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 1L))
                {
                    break;
                }
                v.reset(OpS390XMOVBstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpSub16_0(ref Value v)
        { 
            // match: (Sub16 x y)
            // cond:
            // result: (SUBW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSUBW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSub32_0(ref Value v)
        { 
            // match: (Sub32 x y)
            // cond:
            // result: (SUBW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSUBW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSub32F_0(ref Value v)
        { 
            // match: (Sub32F x y)
            // cond:
            // result: (FSUBS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFSUBS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSub64_0(ref Value v)
        { 
            // match: (Sub64 x y)
            // cond:
            // result: (SUB  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSub64F_0(ref Value v)
        { 
            // match: (Sub64F x y)
            // cond:
            // result: (FSUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XFSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSub8_0(ref Value v)
        { 
            // match: (Sub8 x y)
            // cond:
            // result: (SUBW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSUBW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpSubPtr_0(ref Value v)
        { 
            // match: (SubPtr x y)
            // cond:
            // result: (SUB  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc_0(ref Value v)
        { 
            // match: (Trunc x)
            // cond:
            // result: (FIDBR [5] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XFIDBR);
                v.AuxInt = 5L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc16to8_0(ref Value v)
        { 
            // match: (Trunc16to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc32to16_0(ref Value v)
        { 
            // match: (Trunc32to16 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc32to8_0(ref Value v)
        { 
            // match: (Trunc32to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc64to16_0(ref Value v)
        { 
            // match: (Trunc64to16 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc64to32_0(ref Value v)
        { 
            // match: (Trunc64to32 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpTrunc64to8_0(ref Value v)
        { 
            // match: (Trunc64to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpXor16_0(ref Value v)
        { 
            // match: (Xor16 x y)
            // cond:
            // result: (XORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XXORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpXor32_0(ref Value v)
        { 
            // match: (Xor32 x y)
            // cond:
            // result: (XORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XXORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpXor64_0(ref Value v)
        { 
            // match: (Xor64 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XXOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpXor8_0(ref Value v)
        { 
            // match: (Xor8 x y)
            // cond:
            // result: (XORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpS390XXORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZero_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Zero [0] _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[1L];
                var mem = v.Args[1L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstoreconst [0] destptr mem)
 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVHstoreconst [0] destptr mem)
 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVHstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVWstoreconst [0] destptr mem)
 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVWstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVWstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVDstoreconst [0] destptr mem)
 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVDstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVDstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,2)] destptr         (MOVHstoreconst [0] destptr mem))
 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,2)] destptr         (MOVHstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = makeValAndOff(0L, 2L);
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpS390XMOVHstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,4)] destptr         (MOVWstoreconst [0] destptr mem))
 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,4)] destptr         (MOVWstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVBstoreconst);
                v.AuxInt = makeValAndOff(0L, 4L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVHstoreconst [makeValAndOff(0,4)] destptr         (MOVWstoreconst [0] destptr mem))
 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVHstoreconst [makeValAndOff(0,4)] destptr         (MOVWstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVHstoreconst);
                v.AuxInt = makeValAndOff(0L, 4L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVWstoreconst [makeValAndOff(0,3)] destptr         (MOVWstoreconst [0] destptr mem))
 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVWstoreconst [makeValAndOff(0,3)] destptr         (MOVWstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpS390XMOVWstoreconst);
                v.AuxInt = makeValAndOff(0L, 3L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpS390XMOVWstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: s > 0 && s <= 1024
            // result: (CLEAR [makeValAndOff(s, 0)] destptr mem)
 
            // match: (Zero [s] destptr mem)
            // cond: s > 0 && s <= 1024
            // result: (CLEAR [makeValAndOff(s, 0)] destptr mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s > 0L && s <= 1024L))
                {
                    break;
                }
                v.reset(OpS390XCLEAR);
                v.AuxInt = makeValAndOff(s, 0L);
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpZero_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Zero [s] destptr mem)
            // cond: s > 1024
            // result: (LoweredZero [s%256] destptr (ADDconst <destptr.Type> destptr [(s/256)*256]) mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(s > 1024L))
                {
                    break;
                }
                v.reset(OpS390XLoweredZero);
                v.AuxInt = s % 256L;
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpS390XADDconst, destptr.Type);
                v0.AuxInt = (s / 256L) * 256L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueS390X_OpZeroExt16to32_0(ref Value v)
        { 
            // match: (ZeroExt16to32 x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZeroExt16to64_0(ref Value v)
        { 
            // match: (ZeroExt16to64 x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVHZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZeroExt32to64_0(ref Value v)
        { 
            // match: (ZeroExt32to64 x)
            // cond:
            // result: (MOVWZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVWZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZeroExt8to16_0(ref Value v)
        { 
            // match: (ZeroExt8to16 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZeroExt8to32_0(ref Value v)
        { 
            // match: (ZeroExt8to32 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueS390X_OpZeroExt8to64_0(ref Value v)
        { 
            // match: (ZeroExt8to64 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpS390XMOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteBlockS390X(ref Block b)
        {
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref config.Types;
            _ = typ;

            if (b.Kind == BlockS390XEQ) 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    var v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    var cmp = v.Args[0L];
                    b.Kind = BlockS390XEQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockS390XGE) 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockS390XLE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockS390XGT) 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockS390XLT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockIf) 
                // match: (If (MOVDLT (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDLT)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    var v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    var v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XLT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDLE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
 
                // match: (If (MOVDLE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDLE)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XLE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDGT (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
 
                // match: (If (MOVDGT (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDGT)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDGE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
 
                // match: (If (MOVDGE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDGE)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
 
                // match: (If (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDEQ)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XEQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDNE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (If (MOVDNE (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDNE)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XNE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GTF cmp yes no)
 
                // match: (If (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GTF cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDGTnoinv)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XGTF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GEF cmp yes no)
 
                // match: (If (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) cmp) yes no)
                // cond:
                // result: (GEF cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XMOVDGEnoinv)
                    {
                        break;
                    }
                    _ = v.Args[2L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v.Args[2L];
                    b.Kind = BlockS390XGEF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPWconst [0] (MOVBZreg <typ.Bool> cond)) yes no)
 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPWconst [0] (MOVBZreg <typ.Bool> cond)) yes no)
                while (true)
                {
                    v = b.Control;
                    _ = v;
                    var cond = b.Control;
                    b.Kind = BlockS390XNE;
                    var v0 = b.NewValue0(v.Pos, OpS390XCMPWconst, types.TypeFlags);
                    v0.AuxInt = 0L;
                    var v1 = b.NewValue0(v.Pos, OpS390XMOVBZreg, typ.Bool);
                    v1.AddArg(cond);
                    v0.AddArg(v1);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockS390XLE) 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockS390XGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockS390XLT) 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockS390XGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockS390XNE) 
                // match: (NE (CMPWconst [0] (MOVDLT (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDLT)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    var v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    var v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XLT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDLE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (LE cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDLE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDLE)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XLE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDGT (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GT cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDGT (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDGT)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDGE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GE cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDGE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDGE)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (EQ cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDEQ (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDEQ)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XEQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDNE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDNE (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDNE)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XNE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GTF cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDGTnoinv (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GTF cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDGTnoinv)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XGTF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GEF cmp yes no)
 
                // match: (NE (CMPWconst [0] (MOVDGEnoinv (MOVDconst [0]) (MOVDconst [1]) cmp)) yes no)
                // cond:
                // result: (GEF cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XCMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpS390XMOVDGEnoinv)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0_1 = v_0.Args[1L];
                    if (v_0_1.Op != OpS390XMOVDconst)
                    {
                        break;
                    }
                    if (v_0_1.AuxInt != 1L)
                    {
                        break;
                    }
                    cmp = v_0.Args[2L];
                    b.Kind = BlockS390XGEF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockS390XNE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (NE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpS390XFlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
                        return false;
        }
    }
}}}}
