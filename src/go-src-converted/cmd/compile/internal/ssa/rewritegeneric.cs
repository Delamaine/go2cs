// Code generated from gen/generic.rules; DO NOT EDIT.
// generated with: cd gen; go run *.go

// package ssa -- go2cs converted at 2020 August 29 09:11:37 UTC
// import "cmd/compile/internal/ssa" ==> using ssa = go.cmd.compile.@internal.ssa_package
// Original source: C:\Go\src\cmd\compile\internal\ssa\rewritegeneric.go
using math = go.math_package;
using obj = go.cmd.@internal.obj_package;
using objabi = go.cmd.@internal.objabi_package;
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        private static var _ = math.MinInt8; // in case not otherwise used
        private static var _ = obj.ANOP; // in case not otherwise used
        private static var _ = objabi.GOROOT; // in case not otherwise used
        private static var _ = types.TypeMem; // in case not otherwise used

        private static bool rewriteValuegeneric(ref Value v)
        {

            if (v.Op == OpAdd16) 
                return rewriteValuegeneric_OpAdd16_0(v) || rewriteValuegeneric_OpAdd16_10(v) || rewriteValuegeneric_OpAdd16_20(v) || rewriteValuegeneric_OpAdd16_30(v);
            else if (v.Op == OpAdd32) 
                return rewriteValuegeneric_OpAdd32_0(v) || rewriteValuegeneric_OpAdd32_10(v) || rewriteValuegeneric_OpAdd32_20(v) || rewriteValuegeneric_OpAdd32_30(v);
            else if (v.Op == OpAdd32F) 
                return rewriteValuegeneric_OpAdd32F_0(v);
            else if (v.Op == OpAdd64) 
                return rewriteValuegeneric_OpAdd64_0(v) || rewriteValuegeneric_OpAdd64_10(v) || rewriteValuegeneric_OpAdd64_20(v) || rewriteValuegeneric_OpAdd64_30(v);
            else if (v.Op == OpAdd64F) 
                return rewriteValuegeneric_OpAdd64F_0(v);
            else if (v.Op == OpAdd8) 
                return rewriteValuegeneric_OpAdd8_0(v) || rewriteValuegeneric_OpAdd8_10(v) || rewriteValuegeneric_OpAdd8_20(v) || rewriteValuegeneric_OpAdd8_30(v);
            else if (v.Op == OpAddPtr) 
                return rewriteValuegeneric_OpAddPtr_0(v);
            else if (v.Op == OpAnd16) 
                return rewriteValuegeneric_OpAnd16_0(v) || rewriteValuegeneric_OpAnd16_10(v);
            else if (v.Op == OpAnd32) 
                return rewriteValuegeneric_OpAnd32_0(v) || rewriteValuegeneric_OpAnd32_10(v);
            else if (v.Op == OpAnd64) 
                return rewriteValuegeneric_OpAnd64_0(v) || rewriteValuegeneric_OpAnd64_10(v) || rewriteValuegeneric_OpAnd64_20(v);
            else if (v.Op == OpAnd8) 
                return rewriteValuegeneric_OpAnd8_0(v) || rewriteValuegeneric_OpAnd8_10(v);
            else if (v.Op == OpArg) 
                return rewriteValuegeneric_OpArg_0(v) || rewriteValuegeneric_OpArg_10(v);
            else if (v.Op == OpArraySelect) 
                return rewriteValuegeneric_OpArraySelect_0(v);
            else if (v.Op == OpCom16) 
                return rewriteValuegeneric_OpCom16_0(v);
            else if (v.Op == OpCom32) 
                return rewriteValuegeneric_OpCom32_0(v);
            else if (v.Op == OpCom64) 
                return rewriteValuegeneric_OpCom64_0(v);
            else if (v.Op == OpCom8) 
                return rewriteValuegeneric_OpCom8_0(v);
            else if (v.Op == OpConstInterface) 
                return rewriteValuegeneric_OpConstInterface_0(v);
            else if (v.Op == OpConstSlice) 
                return rewriteValuegeneric_OpConstSlice_0(v);
            else if (v.Op == OpConstString) 
                return rewriteValuegeneric_OpConstString_0(v);
            else if (v.Op == OpConvert) 
                return rewriteValuegeneric_OpConvert_0(v);
            else if (v.Op == OpCvt32Fto32) 
                return rewriteValuegeneric_OpCvt32Fto32_0(v);
            else if (v.Op == OpCvt32Fto64) 
                return rewriteValuegeneric_OpCvt32Fto64_0(v);
            else if (v.Op == OpCvt32Fto64F) 
                return rewriteValuegeneric_OpCvt32Fto64F_0(v);
            else if (v.Op == OpCvt32to32F) 
                return rewriteValuegeneric_OpCvt32to32F_0(v);
            else if (v.Op == OpCvt32to64F) 
                return rewriteValuegeneric_OpCvt32to64F_0(v);
            else if (v.Op == OpCvt64Fto32) 
                return rewriteValuegeneric_OpCvt64Fto32_0(v);
            else if (v.Op == OpCvt64Fto32F) 
                return rewriteValuegeneric_OpCvt64Fto32F_0(v);
            else if (v.Op == OpCvt64Fto64) 
                return rewriteValuegeneric_OpCvt64Fto64_0(v);
            else if (v.Op == OpCvt64to32F) 
                return rewriteValuegeneric_OpCvt64to32F_0(v);
            else if (v.Op == OpCvt64to64F) 
                return rewriteValuegeneric_OpCvt64to64F_0(v);
            else if (v.Op == OpDiv16) 
                return rewriteValuegeneric_OpDiv16_0(v);
            else if (v.Op == OpDiv16u) 
                return rewriteValuegeneric_OpDiv16u_0(v);
            else if (v.Op == OpDiv32) 
                return rewriteValuegeneric_OpDiv32_0(v);
            else if (v.Op == OpDiv32F) 
                return rewriteValuegeneric_OpDiv32F_0(v);
            else if (v.Op == OpDiv32u) 
                return rewriteValuegeneric_OpDiv32u_0(v);
            else if (v.Op == OpDiv64) 
                return rewriteValuegeneric_OpDiv64_0(v);
            else if (v.Op == OpDiv64F) 
                return rewriteValuegeneric_OpDiv64F_0(v);
            else if (v.Op == OpDiv64u) 
                return rewriteValuegeneric_OpDiv64u_0(v);
            else if (v.Op == OpDiv8) 
                return rewriteValuegeneric_OpDiv8_0(v);
            else if (v.Op == OpDiv8u) 
                return rewriteValuegeneric_OpDiv8u_0(v);
            else if (v.Op == OpEq16) 
                return rewriteValuegeneric_OpEq16_0(v);
            else if (v.Op == OpEq32) 
                return rewriteValuegeneric_OpEq32_0(v);
            else if (v.Op == OpEq32F) 
                return rewriteValuegeneric_OpEq32F_0(v);
            else if (v.Op == OpEq64) 
                return rewriteValuegeneric_OpEq64_0(v);
            else if (v.Op == OpEq64F) 
                return rewriteValuegeneric_OpEq64F_0(v);
            else if (v.Op == OpEq8) 
                return rewriteValuegeneric_OpEq8_0(v);
            else if (v.Op == OpEqB) 
                return rewriteValuegeneric_OpEqB_0(v);
            else if (v.Op == OpEqInter) 
                return rewriteValuegeneric_OpEqInter_0(v);
            else if (v.Op == OpEqPtr) 
                return rewriteValuegeneric_OpEqPtr_0(v);
            else if (v.Op == OpEqSlice) 
                return rewriteValuegeneric_OpEqSlice_0(v);
            else if (v.Op == OpGeq16) 
                return rewriteValuegeneric_OpGeq16_0(v);
            else if (v.Op == OpGeq16U) 
                return rewriteValuegeneric_OpGeq16U_0(v);
            else if (v.Op == OpGeq32) 
                return rewriteValuegeneric_OpGeq32_0(v);
            else if (v.Op == OpGeq32F) 
                return rewriteValuegeneric_OpGeq32F_0(v);
            else if (v.Op == OpGeq32U) 
                return rewriteValuegeneric_OpGeq32U_0(v);
            else if (v.Op == OpGeq64) 
                return rewriteValuegeneric_OpGeq64_0(v);
            else if (v.Op == OpGeq64F) 
                return rewriteValuegeneric_OpGeq64F_0(v);
            else if (v.Op == OpGeq64U) 
                return rewriteValuegeneric_OpGeq64U_0(v);
            else if (v.Op == OpGeq8) 
                return rewriteValuegeneric_OpGeq8_0(v);
            else if (v.Op == OpGeq8U) 
                return rewriteValuegeneric_OpGeq8U_0(v);
            else if (v.Op == OpGreater16) 
                return rewriteValuegeneric_OpGreater16_0(v);
            else if (v.Op == OpGreater16U) 
                return rewriteValuegeneric_OpGreater16U_0(v);
            else if (v.Op == OpGreater32) 
                return rewriteValuegeneric_OpGreater32_0(v);
            else if (v.Op == OpGreater32F) 
                return rewriteValuegeneric_OpGreater32F_0(v);
            else if (v.Op == OpGreater32U) 
                return rewriteValuegeneric_OpGreater32U_0(v);
            else if (v.Op == OpGreater64) 
                return rewriteValuegeneric_OpGreater64_0(v);
            else if (v.Op == OpGreater64F) 
                return rewriteValuegeneric_OpGreater64F_0(v);
            else if (v.Op == OpGreater64U) 
                return rewriteValuegeneric_OpGreater64U_0(v);
            else if (v.Op == OpGreater8) 
                return rewriteValuegeneric_OpGreater8_0(v);
            else if (v.Op == OpGreater8U) 
                return rewriteValuegeneric_OpGreater8U_0(v);
            else if (v.Op == OpIMake) 
                return rewriteValuegeneric_OpIMake_0(v);
            else if (v.Op == OpInterCall) 
                return rewriteValuegeneric_OpInterCall_0(v);
            else if (v.Op == OpIsInBounds) 
                return rewriteValuegeneric_OpIsInBounds_0(v) || rewriteValuegeneric_OpIsInBounds_10(v) || rewriteValuegeneric_OpIsInBounds_20(v) || rewriteValuegeneric_OpIsInBounds_30(v);
            else if (v.Op == OpIsNonNil) 
                return rewriteValuegeneric_OpIsNonNil_0(v);
            else if (v.Op == OpIsSliceInBounds) 
                return rewriteValuegeneric_OpIsSliceInBounds_0(v);
            else if (v.Op == OpLeq16) 
                return rewriteValuegeneric_OpLeq16_0(v);
            else if (v.Op == OpLeq16U) 
                return rewriteValuegeneric_OpLeq16U_0(v);
            else if (v.Op == OpLeq32) 
                return rewriteValuegeneric_OpLeq32_0(v);
            else if (v.Op == OpLeq32F) 
                return rewriteValuegeneric_OpLeq32F_0(v);
            else if (v.Op == OpLeq32U) 
                return rewriteValuegeneric_OpLeq32U_0(v);
            else if (v.Op == OpLeq64) 
                return rewriteValuegeneric_OpLeq64_0(v);
            else if (v.Op == OpLeq64F) 
                return rewriteValuegeneric_OpLeq64F_0(v);
            else if (v.Op == OpLeq64U) 
                return rewriteValuegeneric_OpLeq64U_0(v);
            else if (v.Op == OpLeq8) 
                return rewriteValuegeneric_OpLeq8_0(v);
            else if (v.Op == OpLeq8U) 
                return rewriteValuegeneric_OpLeq8U_0(v);
            else if (v.Op == OpLess16) 
                return rewriteValuegeneric_OpLess16_0(v);
            else if (v.Op == OpLess16U) 
                return rewriteValuegeneric_OpLess16U_0(v);
            else if (v.Op == OpLess32) 
                return rewriteValuegeneric_OpLess32_0(v);
            else if (v.Op == OpLess32F) 
                return rewriteValuegeneric_OpLess32F_0(v);
            else if (v.Op == OpLess32U) 
                return rewriteValuegeneric_OpLess32U_0(v);
            else if (v.Op == OpLess64) 
                return rewriteValuegeneric_OpLess64_0(v);
            else if (v.Op == OpLess64F) 
                return rewriteValuegeneric_OpLess64F_0(v);
            else if (v.Op == OpLess64U) 
                return rewriteValuegeneric_OpLess64U_0(v);
            else if (v.Op == OpLess8) 
                return rewriteValuegeneric_OpLess8_0(v);
            else if (v.Op == OpLess8U) 
                return rewriteValuegeneric_OpLess8U_0(v);
            else if (v.Op == OpLoad) 
                return rewriteValuegeneric_OpLoad_0(v) || rewriteValuegeneric_OpLoad_10(v);
            else if (v.Op == OpLsh16x16) 
                return rewriteValuegeneric_OpLsh16x16_0(v);
            else if (v.Op == OpLsh16x32) 
                return rewriteValuegeneric_OpLsh16x32_0(v);
            else if (v.Op == OpLsh16x64) 
                return rewriteValuegeneric_OpLsh16x64_0(v);
            else if (v.Op == OpLsh16x8) 
                return rewriteValuegeneric_OpLsh16x8_0(v);
            else if (v.Op == OpLsh32x16) 
                return rewriteValuegeneric_OpLsh32x16_0(v);
            else if (v.Op == OpLsh32x32) 
                return rewriteValuegeneric_OpLsh32x32_0(v);
            else if (v.Op == OpLsh32x64) 
                return rewriteValuegeneric_OpLsh32x64_0(v);
            else if (v.Op == OpLsh32x8) 
                return rewriteValuegeneric_OpLsh32x8_0(v);
            else if (v.Op == OpLsh64x16) 
                return rewriteValuegeneric_OpLsh64x16_0(v);
            else if (v.Op == OpLsh64x32) 
                return rewriteValuegeneric_OpLsh64x32_0(v);
            else if (v.Op == OpLsh64x64) 
                return rewriteValuegeneric_OpLsh64x64_0(v);
            else if (v.Op == OpLsh64x8) 
                return rewriteValuegeneric_OpLsh64x8_0(v);
            else if (v.Op == OpLsh8x16) 
                return rewriteValuegeneric_OpLsh8x16_0(v);
            else if (v.Op == OpLsh8x32) 
                return rewriteValuegeneric_OpLsh8x32_0(v);
            else if (v.Op == OpLsh8x64) 
                return rewriteValuegeneric_OpLsh8x64_0(v);
            else if (v.Op == OpLsh8x8) 
                return rewriteValuegeneric_OpLsh8x8_0(v);
            else if (v.Op == OpMod16) 
                return rewriteValuegeneric_OpMod16_0(v);
            else if (v.Op == OpMod16u) 
                return rewriteValuegeneric_OpMod16u_0(v);
            else if (v.Op == OpMod32) 
                return rewriteValuegeneric_OpMod32_0(v);
            else if (v.Op == OpMod32u) 
                return rewriteValuegeneric_OpMod32u_0(v);
            else if (v.Op == OpMod64) 
                return rewriteValuegeneric_OpMod64_0(v);
            else if (v.Op == OpMod64u) 
                return rewriteValuegeneric_OpMod64u_0(v);
            else if (v.Op == OpMod8) 
                return rewriteValuegeneric_OpMod8_0(v);
            else if (v.Op == OpMod8u) 
                return rewriteValuegeneric_OpMod8u_0(v);
            else if (v.Op == OpMul16) 
                return rewriteValuegeneric_OpMul16_0(v) || rewriteValuegeneric_OpMul16_10(v);
            else if (v.Op == OpMul32) 
                return rewriteValuegeneric_OpMul32_0(v) || rewriteValuegeneric_OpMul32_10(v);
            else if (v.Op == OpMul32F) 
                return rewriteValuegeneric_OpMul32F_0(v);
            else if (v.Op == OpMul64) 
                return rewriteValuegeneric_OpMul64_0(v) || rewriteValuegeneric_OpMul64_10(v);
            else if (v.Op == OpMul64F) 
                return rewriteValuegeneric_OpMul64F_0(v);
            else if (v.Op == OpMul8) 
                return rewriteValuegeneric_OpMul8_0(v) || rewriteValuegeneric_OpMul8_10(v);
            else if (v.Op == OpNeg16) 
                return rewriteValuegeneric_OpNeg16_0(v);
            else if (v.Op == OpNeg32) 
                return rewriteValuegeneric_OpNeg32_0(v);
            else if (v.Op == OpNeg32F) 
                return rewriteValuegeneric_OpNeg32F_0(v);
            else if (v.Op == OpNeg64) 
                return rewriteValuegeneric_OpNeg64_0(v);
            else if (v.Op == OpNeg64F) 
                return rewriteValuegeneric_OpNeg64F_0(v);
            else if (v.Op == OpNeg8) 
                return rewriteValuegeneric_OpNeg8_0(v);
            else if (v.Op == OpNeq16) 
                return rewriteValuegeneric_OpNeq16_0(v);
            else if (v.Op == OpNeq32) 
                return rewriteValuegeneric_OpNeq32_0(v);
            else if (v.Op == OpNeq32F) 
                return rewriteValuegeneric_OpNeq32F_0(v);
            else if (v.Op == OpNeq64) 
                return rewriteValuegeneric_OpNeq64_0(v);
            else if (v.Op == OpNeq64F) 
                return rewriteValuegeneric_OpNeq64F_0(v);
            else if (v.Op == OpNeq8) 
                return rewriteValuegeneric_OpNeq8_0(v);
            else if (v.Op == OpNeqB) 
                return rewriteValuegeneric_OpNeqB_0(v);
            else if (v.Op == OpNeqInter) 
                return rewriteValuegeneric_OpNeqInter_0(v);
            else if (v.Op == OpNeqPtr) 
                return rewriteValuegeneric_OpNeqPtr_0(v);
            else if (v.Op == OpNeqSlice) 
                return rewriteValuegeneric_OpNeqSlice_0(v);
            else if (v.Op == OpNilCheck) 
                return rewriteValuegeneric_OpNilCheck_0(v);
            else if (v.Op == OpNot) 
                return rewriteValuegeneric_OpNot_0(v) || rewriteValuegeneric_OpNot_10(v) || rewriteValuegeneric_OpNot_20(v) || rewriteValuegeneric_OpNot_30(v) || rewriteValuegeneric_OpNot_40(v);
            else if (v.Op == OpOffPtr) 
                return rewriteValuegeneric_OpOffPtr_0(v);
            else if (v.Op == OpOr16) 
                return rewriteValuegeneric_OpOr16_0(v) || rewriteValuegeneric_OpOr16_10(v) || rewriteValuegeneric_OpOr16_20(v);
            else if (v.Op == OpOr32) 
                return rewriteValuegeneric_OpOr32_0(v) || rewriteValuegeneric_OpOr32_10(v) || rewriteValuegeneric_OpOr32_20(v);
            else if (v.Op == OpOr64) 
                return rewriteValuegeneric_OpOr64_0(v) || rewriteValuegeneric_OpOr64_10(v) || rewriteValuegeneric_OpOr64_20(v);
            else if (v.Op == OpOr8) 
                return rewriteValuegeneric_OpOr8_0(v) || rewriteValuegeneric_OpOr8_10(v) || rewriteValuegeneric_OpOr8_20(v);
            else if (v.Op == OpPhi) 
                return rewriteValuegeneric_OpPhi_0(v);
            else if (v.Op == OpPtrIndex) 
                return rewriteValuegeneric_OpPtrIndex_0(v);
            else if (v.Op == OpRound32F) 
                return rewriteValuegeneric_OpRound32F_0(v);
            else if (v.Op == OpRound64F) 
                return rewriteValuegeneric_OpRound64F_0(v);
            else if (v.Op == OpRsh16Ux16) 
                return rewriteValuegeneric_OpRsh16Ux16_0(v);
            else if (v.Op == OpRsh16Ux32) 
                return rewriteValuegeneric_OpRsh16Ux32_0(v);
            else if (v.Op == OpRsh16Ux64) 
                return rewriteValuegeneric_OpRsh16Ux64_0(v);
            else if (v.Op == OpRsh16Ux8) 
                return rewriteValuegeneric_OpRsh16Ux8_0(v);
            else if (v.Op == OpRsh16x16) 
                return rewriteValuegeneric_OpRsh16x16_0(v);
            else if (v.Op == OpRsh16x32) 
                return rewriteValuegeneric_OpRsh16x32_0(v);
            else if (v.Op == OpRsh16x64) 
                return rewriteValuegeneric_OpRsh16x64_0(v);
            else if (v.Op == OpRsh16x8) 
                return rewriteValuegeneric_OpRsh16x8_0(v);
            else if (v.Op == OpRsh32Ux16) 
                return rewriteValuegeneric_OpRsh32Ux16_0(v);
            else if (v.Op == OpRsh32Ux32) 
                return rewriteValuegeneric_OpRsh32Ux32_0(v);
            else if (v.Op == OpRsh32Ux64) 
                return rewriteValuegeneric_OpRsh32Ux64_0(v);
            else if (v.Op == OpRsh32Ux8) 
                return rewriteValuegeneric_OpRsh32Ux8_0(v);
            else if (v.Op == OpRsh32x16) 
                return rewriteValuegeneric_OpRsh32x16_0(v);
            else if (v.Op == OpRsh32x32) 
                return rewriteValuegeneric_OpRsh32x32_0(v);
            else if (v.Op == OpRsh32x64) 
                return rewriteValuegeneric_OpRsh32x64_0(v);
            else if (v.Op == OpRsh32x8) 
                return rewriteValuegeneric_OpRsh32x8_0(v);
            else if (v.Op == OpRsh64Ux16) 
                return rewriteValuegeneric_OpRsh64Ux16_0(v);
            else if (v.Op == OpRsh64Ux32) 
                return rewriteValuegeneric_OpRsh64Ux32_0(v);
            else if (v.Op == OpRsh64Ux64) 
                return rewriteValuegeneric_OpRsh64Ux64_0(v);
            else if (v.Op == OpRsh64Ux8) 
                return rewriteValuegeneric_OpRsh64Ux8_0(v);
            else if (v.Op == OpRsh64x16) 
                return rewriteValuegeneric_OpRsh64x16_0(v);
            else if (v.Op == OpRsh64x32) 
                return rewriteValuegeneric_OpRsh64x32_0(v);
            else if (v.Op == OpRsh64x64) 
                return rewriteValuegeneric_OpRsh64x64_0(v);
            else if (v.Op == OpRsh64x8) 
                return rewriteValuegeneric_OpRsh64x8_0(v);
            else if (v.Op == OpRsh8Ux16) 
                return rewriteValuegeneric_OpRsh8Ux16_0(v);
            else if (v.Op == OpRsh8Ux32) 
                return rewriteValuegeneric_OpRsh8Ux32_0(v);
            else if (v.Op == OpRsh8Ux64) 
                return rewriteValuegeneric_OpRsh8Ux64_0(v);
            else if (v.Op == OpRsh8Ux8) 
                return rewriteValuegeneric_OpRsh8Ux8_0(v);
            else if (v.Op == OpRsh8x16) 
                return rewriteValuegeneric_OpRsh8x16_0(v);
            else if (v.Op == OpRsh8x32) 
                return rewriteValuegeneric_OpRsh8x32_0(v);
            else if (v.Op == OpRsh8x64) 
                return rewriteValuegeneric_OpRsh8x64_0(v);
            else if (v.Op == OpRsh8x8) 
                return rewriteValuegeneric_OpRsh8x8_0(v);
            else if (v.Op == OpSignExt16to32) 
                return rewriteValuegeneric_OpSignExt16to32_0(v);
            else if (v.Op == OpSignExt16to64) 
                return rewriteValuegeneric_OpSignExt16to64_0(v);
            else if (v.Op == OpSignExt32to64) 
                return rewriteValuegeneric_OpSignExt32to64_0(v);
            else if (v.Op == OpSignExt8to16) 
                return rewriteValuegeneric_OpSignExt8to16_0(v);
            else if (v.Op == OpSignExt8to32) 
                return rewriteValuegeneric_OpSignExt8to32_0(v);
            else if (v.Op == OpSignExt8to64) 
                return rewriteValuegeneric_OpSignExt8to64_0(v);
            else if (v.Op == OpSliceCap) 
                return rewriteValuegeneric_OpSliceCap_0(v);
            else if (v.Op == OpSliceLen) 
                return rewriteValuegeneric_OpSliceLen_0(v);
            else if (v.Op == OpSlicePtr) 
                return rewriteValuegeneric_OpSlicePtr_0(v);
            else if (v.Op == OpSlicemask) 
                return rewriteValuegeneric_OpSlicemask_0(v);
            else if (v.Op == OpSqrt) 
                return rewriteValuegeneric_OpSqrt_0(v);
            else if (v.Op == OpStaticCall) 
                return rewriteValuegeneric_OpStaticCall_0(v);
            else if (v.Op == OpStore) 
                return rewriteValuegeneric_OpStore_0(v) || rewriteValuegeneric_OpStore_10(v);
            else if (v.Op == OpStringLen) 
                return rewriteValuegeneric_OpStringLen_0(v);
            else if (v.Op == OpStringPtr) 
                return rewriteValuegeneric_OpStringPtr_0(v);
            else if (v.Op == OpStructSelect) 
                return rewriteValuegeneric_OpStructSelect_0(v) || rewriteValuegeneric_OpStructSelect_10(v);
            else if (v.Op == OpSub16) 
                return rewriteValuegeneric_OpSub16_0(v) || rewriteValuegeneric_OpSub16_10(v);
            else if (v.Op == OpSub32) 
                return rewriteValuegeneric_OpSub32_0(v) || rewriteValuegeneric_OpSub32_10(v);
            else if (v.Op == OpSub32F) 
                return rewriteValuegeneric_OpSub32F_0(v);
            else if (v.Op == OpSub64) 
                return rewriteValuegeneric_OpSub64_0(v) || rewriteValuegeneric_OpSub64_10(v);
            else if (v.Op == OpSub64F) 
                return rewriteValuegeneric_OpSub64F_0(v);
            else if (v.Op == OpSub8) 
                return rewriteValuegeneric_OpSub8_0(v) || rewriteValuegeneric_OpSub8_10(v);
            else if (v.Op == OpTrunc16to8) 
                return rewriteValuegeneric_OpTrunc16to8_0(v);
            else if (v.Op == OpTrunc32to16) 
                return rewriteValuegeneric_OpTrunc32to16_0(v);
            else if (v.Op == OpTrunc32to8) 
                return rewriteValuegeneric_OpTrunc32to8_0(v);
            else if (v.Op == OpTrunc64to16) 
                return rewriteValuegeneric_OpTrunc64to16_0(v);
            else if (v.Op == OpTrunc64to32) 
                return rewriteValuegeneric_OpTrunc64to32_0(v);
            else if (v.Op == OpTrunc64to8) 
                return rewriteValuegeneric_OpTrunc64to8_0(v);
            else if (v.Op == OpXor16) 
                return rewriteValuegeneric_OpXor16_0(v) || rewriteValuegeneric_OpXor16_10(v);
            else if (v.Op == OpXor32) 
                return rewriteValuegeneric_OpXor32_0(v) || rewriteValuegeneric_OpXor32_10(v);
            else if (v.Op == OpXor64) 
                return rewriteValuegeneric_OpXor64_0(v) || rewriteValuegeneric_OpXor64_10(v);
            else if (v.Op == OpXor8) 
                return rewriteValuegeneric_OpXor8_0(v) || rewriteValuegeneric_OpXor8_10(v);
            else if (v.Op == OpZero) 
                return rewriteValuegeneric_OpZero_0(v);
            else if (v.Op == OpZeroExt16to32) 
                return rewriteValuegeneric_OpZeroExt16to32_0(v);
            else if (v.Op == OpZeroExt16to64) 
                return rewriteValuegeneric_OpZeroExt16to64_0(v);
            else if (v.Op == OpZeroExt32to64) 
                return rewriteValuegeneric_OpZeroExt32to64_0(v);
            else if (v.Op == OpZeroExt8to16) 
                return rewriteValuegeneric_OpZeroExt8to16_0(v);
            else if (v.Op == OpZeroExt8to32) 
                return rewriteValuegeneric_OpZeroExt8to32_0(v);
            else if (v.Op == OpZeroExt8to64) 
                return rewriteValuegeneric_OpZeroExt8to64_0(v);
                        return false;
        }
        private static bool rewriteValuegeneric_OpAdd16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c + d));
                return true;
            } 
            // match: (Add16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c+d))])
 
            // match: (Add16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c + d));
                return true;
            } 
            // match: (Add16 <t> (Mul16 x y) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 x y) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 y x) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 y x) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 x y) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 x y) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 y x) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 y x) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 x z) (Mul16 x y))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 x z) (Mul16 x y))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 z x) (Mul16 x y))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 z x) (Mul16 x y))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 x z) (Mul16 y x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 x z) (Mul16 y x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 <t> (Mul16 z x) (Mul16 y x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
 
            // match: (Add16 <t> (Mul16 z x) (Mul16 y x))
            // cond:
            // result: (Mul16 x (Add16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add16 (Const16 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 x (Const16 [0]))
            // cond:
            // result: x
 
            // match: (Add16 x (Const16 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Const16 [1]) (Com16 x))
            // cond:
            // result: (Neg16 x)
 
            // match: (Add16 (Const16 [1]) (Com16 x))
            // cond:
            // result: (Neg16 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpCom16)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpNeg16);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Com16 x) (Const16 [1]))
            // cond:
            // result: (Neg16 x)
 
            // match: (Add16 (Com16 x) (Const16 [1]))
            // cond:
            // result: (Neg16 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpCom16)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpNeg16);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Add16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
 
            // match: (Add16 (Add16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 (Add16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
 
            // match: (Add16 (Add16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 x (Add16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
 
            // match: (Add16 x (Add16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 x (Add16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
 
            // match: (Add16 x (Add16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Add16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 (Sub16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
 
            // match: (Add16 (Sub16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 x (Sub16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
 
            // match: (Add16 x (Sub16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd16_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add16 x (Sub16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 (Sub16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
 
            // match: (Add16 (Sub16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add16 (Sub16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
 
            // match: (Add16 (Sub16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
 
            // match: (Add16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
 
            // match: (Add16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add16 (Sub16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
 
            // match: (Add16 (Sub16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Add16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Add16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Add16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Add16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd16_30(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add16 (Const16 <t> [c]) (Sub16 (Const16 <t> [d]) x))
            // cond:
            // result: (Sub16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpSub16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Sub16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Sub16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Add16 (Sub16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Sub16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Const16 <t> [c]) (Sub16 x (Const16 <t> [d])))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Add16 (Const16 <t> [c]) (Sub16 x (Const16 <t> [d])))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add16 (Sub16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Add16 (Sub16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c + d));
                return true;
            } 
            // match: (Add32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c+d))])
 
            // match: (Add32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c + d));
                return true;
            } 
            // match: (Add32 <t> (Mul32 x y) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 x y) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 y x) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 y x) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 x y) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 x y) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 y x) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 y x) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 x z) (Mul32 x y))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 x z) (Mul32 x y))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 z x) (Mul32 x y))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 z x) (Mul32 x y))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 x z) (Mul32 y x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 x z) (Mul32 y x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 <t> (Mul32 z x) (Mul32 y x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
 
            // match: (Add32 <t> (Mul32 z x) (Mul32 y x))
            // cond:
            // result: (Mul32 x (Add32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add32 (Const32 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 x (Const32 [0]))
            // cond:
            // result: x
 
            // match: (Add32 x (Const32 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Const32 [1]) (Com32 x))
            // cond:
            // result: (Neg32 x)
 
            // match: (Add32 (Const32 [1]) (Com32 x))
            // cond:
            // result: (Neg32 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpCom32)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpNeg32);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Com32 x) (Const32 [1]))
            // cond:
            // result: (Neg32 x)
 
            // match: (Add32 (Com32 x) (Const32 [1]))
            // cond:
            // result: (Neg32 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpCom32)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpNeg32);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Add32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
 
            // match: (Add32 (Add32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 (Add32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
 
            // match: (Add32 (Add32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 x (Add32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
 
            // match: (Add32 x (Add32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 x (Add32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
 
            // match: (Add32 x (Add32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Add32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 (Sub32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
 
            // match: (Add32 (Sub32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 x (Sub32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
 
            // match: (Add32 x (Sub32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd32_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add32 x (Sub32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 (Sub32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
 
            // match: (Add32 (Sub32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add32 (Sub32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
 
            // match: (Add32 (Sub32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
 
            // match: (Add32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
 
            // match: (Add32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add32 (Sub32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
 
            // match: (Add32 (Sub32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Add32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Add32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Add32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Add32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd32_30(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add32 (Const32 <t> [c]) (Sub32 (Const32 <t> [d]) x))
            // cond:
            // result: (Sub32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpSub32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Sub32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Sub32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Add32 (Sub32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Sub32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Const32 <t> [c]) (Sub32 x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Add32 (Const32 <t> [c]) (Sub32 x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add32 (Sub32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Add32 (Sub32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd32F_0(ref Value v)
        { 
            // match: (Add32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) + i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) + i2f32(d)));
                return true;
            } 
            // match: (Add32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) + i2f32(d)))])
 
            // match: (Add32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) + i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) + i2f32(d)));
                return true;
            } 
            // match: (Add32F x (Const32F [0]))
            // cond:
            // result: x
 
            // match: (Add32F x (Const32F [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add32F (Const32F [0]) x)
            // cond:
            // result: x
 
            // match: (Add32F (Const32F [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c+d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c + d;
                return true;
            } 
            // match: (Add64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c+d])
 
            // match: (Add64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c+d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c + d;
                return true;
            } 
            // match: (Add64 <t> (Mul64 x y) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 x y) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 y x) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 y x) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 x y) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 x y) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 y x) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 y x) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 x z) (Mul64 x y))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 x z) (Mul64 x y))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 z x) (Mul64 x y))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 z x) (Mul64 x y))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 x z) (Mul64 y x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 x z) (Mul64 y x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 <t> (Mul64 z x) (Mul64 y x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
 
            // match: (Add64 <t> (Mul64 z x) (Mul64 y x))
            // cond:
            // result: (Mul64 x (Add64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add64 (Const64 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Add64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Const64 [1]) (Com64 x))
            // cond:
            // result: (Neg64 x)
 
            // match: (Add64 (Const64 [1]) (Com64 x))
            // cond:
            // result: (Neg64 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpCom64)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpNeg64);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Com64 x) (Const64 [1]))
            // cond:
            // result: (Neg64 x)
 
            // match: (Add64 (Com64 x) (Const64 [1]))
            // cond:
            // result: (Neg64 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpCom64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpNeg64);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Add64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
 
            // match: (Add64 (Add64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 (Add64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
 
            // match: (Add64 (Add64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 x (Add64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
 
            // match: (Add64 x (Add64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 x (Add64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
 
            // match: (Add64 x (Add64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Add64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 (Sub64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
 
            // match: (Add64 (Sub64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 x (Sub64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
 
            // match: (Add64 x (Sub64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd64_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add64 x (Sub64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 (Sub64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
 
            // match: (Add64 (Sub64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add64 (Sub64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
 
            // match: (Add64 (Sub64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
 
            // match: (Add64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
 
            // match: (Add64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add64 (Sub64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
 
            // match: (Add64 (Sub64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
 
            // match: (Add64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
 
            // match: (Add64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
 
            // match: (Add64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
 
            // match: (Add64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd64_30(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add64 (Const64 <t> [c]) (Sub64 (Const64 <t> [d]) x))
            // cond:
            // result: (Sub64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpSub64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Sub64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Sub64 (Const64 <t> [c+d]) x)
 
            // match: (Add64 (Sub64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Sub64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Const64 <t> [c]) (Sub64 x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
 
            // match: (Add64 (Const64 <t> [c]) (Sub64 x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add64 (Sub64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
 
            // match: (Add64 (Sub64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd64F_0(ref Value v)
        { 
            // match: (Add64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (Const64F [f2i(i2f(c) + i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) + i2f(d));
                return true;
            } 
            // match: (Add64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (Const64F [f2i(i2f(c) + i2f(d))])
 
            // match: (Add64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (Const64F [f2i(i2f(c) + i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) + i2f(d));
                return true;
            } 
            // match: (Add64F x (Const64F [0]))
            // cond:
            // result: x
 
            // match: (Add64F x (Const64F [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add64F (Const64F [0]) x)
            // cond:
            // result: x
 
            // match: (Add64F (Const64F [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8  [int64(int8(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c + d));
                return true;
            } 
            // match: (Add8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c+d))])
 
            // match: (Add8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c+d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c + d));
                return true;
            } 
            // match: (Add8 <t> (Mul8 x y) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 x y) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 y x) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 y x) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 x y) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 x y) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 y x) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 y x) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 x z) (Mul8 x y))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 x z) (Mul8 x y))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 z x) (Mul8 x y))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 z x) (Mul8 x y))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 x z) (Mul8 y x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 x z) (Mul8 y x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                z = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 <t> (Mul8 z x) (Mul8 y x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
 
            // match: (Add8 <t> (Mul8 z x) (Mul8 y x))
            // cond:
            // result: (Mul8  x (Add8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add8 (Const8 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 x (Const8 [0]))
            // cond:
            // result: x
 
            // match: (Add8 x (Const8 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Const8 [1]) (Com8 x))
            // cond:
            // result: (Neg8  x)
 
            // match: (Add8 (Const8 [1]) (Com8 x))
            // cond:
            // result: (Neg8  x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpCom8)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpNeg8);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Com8 x) (Const8 [1]))
            // cond:
            // result: (Neg8  x)
 
            // match: (Add8 (Com8 x) (Const8 [1]))
            // cond:
            // result: (Neg8  x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpCom8)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpNeg8);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Add8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
 
            // match: (Add8 (Add8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 (Add8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
 
            // match: (Add8 (Add8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 x (Add8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
 
            // match: (Add8 x (Add8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 x (Add8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
 
            // match: (Add8 x (Add8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Add8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 (Sub8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
 
            // match: (Add8 (Sub8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 x (Sub8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
 
            // match: (Add8 x (Sub8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd8_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add8 x (Sub8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 (Sub8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
 
            // match: (Add8 (Sub8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Add8 (Sub8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
 
            // match: (Add8 (Sub8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
 
            // match: (Add8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
 
            // match: (Add8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add8 (Sub8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
 
            // match: (Add8 (Sub8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Add8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Add8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Add8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Add8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Add8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAdd8_30(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Add8 (Const8 <t> [c]) (Sub8 (Const8 <t> [d]) x))
            // cond:
            // result: (Sub8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpSub8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Sub8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Sub8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Add8 (Sub8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Sub8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Const8 <t> [c]) (Sub8 x (Const8 <t> [d])))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
 
            // match: (Add8 (Const8 <t> [c]) (Sub8 x (Const8 <t> [d])))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Add8 (Sub8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
 
            // match: (Add8 (Sub8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAddPtr_0(ref Value v)
        { 
            // match: (AddPtr <t> x (Const64 [c]))
            // cond:
            // result: (OffPtr <t> x [c])
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpOffPtr);
                v.Type = t;
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AddPtr <t> x (Const32 [c]))
            // cond:
            // result: (OffPtr <t> x [c])
 
            // match: (AddPtr <t> x (Const32 [c]))
            // cond:
            // result: (OffPtr <t> x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOffPtr);
                v.Type = t;
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd16_0(ref Value v)
        { 
            // match: (And16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c & d));
                return true;
            } 
            // match: (And16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c&d))])
 
            // match: (And16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c & d));
                return true;
            } 
            // match: (And16 x x)
            // cond:
            // result: x
 
            // match: (And16 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And16 (Const16 [-1]) x)
            // cond:
            // result: x
 
            // match: (And16 (Const16 [-1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And16 x (Const16 [-1]))
            // cond:
            // result: x
 
            // match: (And16 x (Const16 [-1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (And16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And16 _ (Const16 [0]))
            // cond:
            // result: (Const16 [0])
 
            // match: (And16 _ (Const16 [0]))
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And16 x (And16 x y))
            // cond:
            // result: (And16 x y)
 
            // match: (And16 x (And16 x y))
            // cond:
            // result: (And16 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpAnd16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And16 x (And16 y x))
            // cond:
            // result: (And16 x y)
 
            // match: (And16 x (And16 y x))
            // cond:
            // result: (And16 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And16 (And16 x y) x)
            // cond:
            // result: (And16 x y)
 
            // match: (And16 (And16 x y) x)
            // cond:
            // result: (And16 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (And16 (And16 y x) x)
            // cond:
            // result: (And16 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And16 (And16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
 
            // match: (And16 (And16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAnd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And16 (And16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
 
            // match: (And16 (And16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And16 x (And16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
 
            // match: (And16 x (And16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And16 x (And16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
 
            // match: (And16 x (And16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (And16 i (And16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And16 (Const16 <t> [c]) (And16 (Const16 <t> [d]) x))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
 
            // match: (And16 (Const16 <t> [c]) (And16 (Const16 <t> [d]) x))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAnd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And16 (Const16 <t> [c]) (And16 x (Const16 <t> [d])))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
 
            // match: (And16 (Const16 <t> [c]) (And16 x (Const16 <t> [d])))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAnd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And16 (And16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
 
            // match: (And16 (And16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And16 (And16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
 
            // match: (And16 (And16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (And16 (Const16 <t> [int64(int16(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd32_0(ref Value v)
        { 
            // match: (And32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c & d));
                return true;
            } 
            // match: (And32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c&d))])
 
            // match: (And32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c & d));
                return true;
            } 
            // match: (And32 x x)
            // cond:
            // result: x
 
            // match: (And32 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And32 (Const32 [-1]) x)
            // cond:
            // result: x
 
            // match: (And32 (Const32 [-1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And32 x (Const32 [-1]))
            // cond:
            // result: x
 
            // match: (And32 x (Const32 [-1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (And32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And32 _ (Const32 [0]))
            // cond:
            // result: (Const32 [0])
 
            // match: (And32 _ (Const32 [0]))
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And32 x (And32 x y))
            // cond:
            // result: (And32 x y)
 
            // match: (And32 x (And32 x y))
            // cond:
            // result: (And32 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpAnd32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And32 x (And32 y x))
            // cond:
            // result: (And32 x y)
 
            // match: (And32 x (And32 y x))
            // cond:
            // result: (And32 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And32 (And32 x y) x)
            // cond:
            // result: (And32 x y)
 
            // match: (And32 (And32 x y) x)
            // cond:
            // result: (And32 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (And32 (And32 y x) x)
            // cond:
            // result: (And32 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And32 (And32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
 
            // match: (And32 (And32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAnd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And32 (And32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
 
            // match: (And32 (And32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And32 x (And32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
 
            // match: (And32 x (And32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And32 x (And32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
 
            // match: (And32 x (And32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (And32 i (And32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And32 (Const32 <t> [c]) (And32 (Const32 <t> [d]) x))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
 
            // match: (And32 (Const32 <t> [c]) (And32 (Const32 <t> [d]) x))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAnd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And32 (Const32 <t> [c]) (And32 x (Const32 <t> [d])))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
 
            // match: (And32 (Const32 <t> [c]) (And32 x (Const32 <t> [d])))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAnd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And32 (And32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
 
            // match: (And32 (And32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And32 (And32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
 
            // match: (And32 (And32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (And32 (Const32 <t> [int64(int32(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd64_0(ref Value v)
        { 
            // match: (And64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c&d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (And64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c&d])
 
            // match: (And64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c&d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (And64 x x)
            // cond:
            // result: x
 
            // match: (And64 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And64 (Const64 [-1]) x)
            // cond:
            // result: x
 
            // match: (And64 (Const64 [-1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And64 x (Const64 [-1]))
            // cond:
            // result: x
 
            // match: (And64 x (Const64 [-1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (And64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And64 _ (Const64 [0]))
            // cond:
            // result: (Const64 [0])
 
            // match: (And64 _ (Const64 [0]))
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And64 x (And64 x y))
            // cond:
            // result: (And64 x y)
 
            // match: (And64 x (And64 x y))
            // cond:
            // result: (And64 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpAnd64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And64 x (And64 y x))
            // cond:
            // result: (And64 x y)
 
            // match: (And64 x (And64 y x))
            // cond:
            // result: (And64 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And64 (And64 x y) x)
            // cond:
            // result: (And64 x y)
 
            // match: (And64 (And64 x y) x)
            // cond:
            // result: (And64 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (And64 (And64 y x) x)
            // cond:
            // result: (And64 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And64 <t> (Const64 [y]) x)
            // cond: nlz(y) + nto(y) == 64 && nto(y) >= 32
            // result: (Rsh64Ux64 (Lsh64x64 <t> x (Const64 <t> [nlz(y)])) (Const64 <t> [nlz(y)]))
 
            // match: (And64 <t> (Const64 [y]) x)
            // cond: nlz(y) + nto(y) == 64 && nto(y) >= 32
            // result: (Rsh64Ux64 (Lsh64x64 <t> x (Const64 <t> [nlz(y)])) (Const64 <t> [nlz(y)]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                y = v_0.AuxInt;
                x = v.Args[1L];
                if (!(nlz(y) + nto(y) == 64L && nto(y) >= 32L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                var v0 = b.NewValue0(v.Pos, OpLsh64x64, t);
                v0.AddArg(x);
                var v1 = b.NewValue0(v.Pos, OpConst64, t);
                v1.AuxInt = nlz(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = nlz(y);
                v.AddArg(v2);
                return true;
            } 
            // match: (And64 <t> x (Const64 [y]))
            // cond: nlz(y) + nto(y) == 64 && nto(y) >= 32
            // result: (Rsh64Ux64 (Lsh64x64 <t> x (Const64 <t> [nlz(y)])) (Const64 <t> [nlz(y)]))
 
            // match: (And64 <t> x (Const64 [y]))
            // cond: nlz(y) + nto(y) == 64 && nto(y) >= 32
            // result: (Rsh64Ux64 (Lsh64x64 <t> x (Const64 <t> [nlz(y)])) (Const64 <t> [nlz(y)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                y = v_1.AuxInt;
                if (!(nlz(y) + nto(y) == 64L && nto(y) >= 32L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v0 = b.NewValue0(v.Pos, OpLsh64x64, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpConst64, t);
                v1.AuxInt = nlz(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = nlz(y);
                v.AddArg(v2);
                return true;
            } 
            // match: (And64 <t> (Const64 [y]) x)
            // cond: nlo(y) + ntz(y) == 64 && ntz(y) >= 32
            // result: (Lsh64x64 (Rsh64Ux64 <t> x (Const64 <t> [ntz(y)])) (Const64 <t> [ntz(y)]))
 
            // match: (And64 <t> (Const64 [y]) x)
            // cond: nlo(y) + ntz(y) == 64 && ntz(y) >= 32
            // result: (Lsh64x64 (Rsh64Ux64 <t> x (Const64 <t> [ntz(y)])) (Const64 <t> [ntz(y)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                y = v_0.AuxInt;
                x = v.Args[1L];
                if (!(nlo(y) + ntz(y) == 64L && ntz(y) >= 32L))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpConst64, t);
                v1.AuxInt = ntz(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = ntz(y);
                v.AddArg(v2);
                return true;
            } 
            // match: (And64 <t> x (Const64 [y]))
            // cond: nlo(y) + ntz(y) == 64 && ntz(y) >= 32
            // result: (Lsh64x64 (Rsh64Ux64 <t> x (Const64 <t> [ntz(y)])) (Const64 <t> [ntz(y)]))
 
            // match: (And64 <t> x (Const64 [y]))
            // cond: nlo(y) + ntz(y) == 64 && ntz(y) >= 32
            // result: (Lsh64x64 (Rsh64Ux64 <t> x (Const64 <t> [ntz(y)])) (Const64 <t> [ntz(y)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                y = v_1.AuxInt;
                if (!(nlo(y) + ntz(y) == 64L && ntz(y) >= 32L))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpConst64, t);
                v1.AuxInt = ntz(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = ntz(y);
                v.AddArg(v2);
                return true;
            } 
            // match: (And64 (And64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
 
            // match: (And64 (And64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And64 (And64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
 
            // match: (And64 (And64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And64 x (And64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
 
            // match: (And64 x (And64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And64 x (And64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
 
            // match: (And64 x (And64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (And64 i (And64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And64 (Const64 <t> [c]) (And64 (Const64 <t> [d]) x))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
 
            // match: (And64 (Const64 <t> [c]) (And64 (Const64 <t> [d]) x))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAnd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c & d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd64_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (And64 (Const64 <t> [c]) (And64 x (Const64 <t> [d])))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpAnd64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c & d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And64 (And64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
 
            // match: (And64 (And64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c & d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And64 (And64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
 
            // match: (And64 (And64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (And64 (Const64 <t> [c&d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c & d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd8_0(ref Value v)
        { 
            // match: (And8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8  [int64(int8(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c & d));
                return true;
            } 
            // match: (And8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c&d))])
 
            // match: (And8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c&d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c & d));
                return true;
            } 
            // match: (And8 x x)
            // cond:
            // result: x
 
            // match: (And8 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And8 (Const8 [-1]) x)
            // cond:
            // result: x
 
            // match: (And8 (Const8 [-1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And8 x (Const8 [-1]))
            // cond:
            // result: x
 
            // match: (And8 x (Const8 [-1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (And8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (And8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And8 _ (Const8 [0]))
            // cond:
            // result: (Const8  [0])
 
            // match: (And8 _ (Const8 [0]))
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (And8 x (And8 x y))
            // cond:
            // result: (And8  x y)
 
            // match: (And8 x (And8 x y))
            // cond:
            // result: (And8  x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpAnd8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And8 x (And8 y x))
            // cond:
            // result: (And8  x y)
 
            // match: (And8 x (And8 y x))
            // cond:
            // result: (And8  x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And8 (And8 x y) x)
            // cond:
            // result: (And8  x y)
 
            // match: (And8 (And8 x y) x)
            // cond:
            // result: (And8  x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpAnd8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (And8 (And8 y x) x)
            // cond:
            // result: (And8  x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (And8 (And8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
 
            // match: (And8 (And8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAnd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And8 (And8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
 
            // match: (And8 (And8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And8 x (And8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
 
            // match: (And8 x (And8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And8 x (And8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
 
            // match: (And8 x (And8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (And8  i (And8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpAnd8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (And8 (Const8 <t> [c]) (And8 (Const8 <t> [d]) x))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
 
            // match: (And8 (Const8 <t> [c]) (And8 (Const8 <t> [d]) x))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAnd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And8 (Const8 <t> [c]) (And8 x (Const8 <t> [d])))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
 
            // match: (And8 (Const8 <t> [c]) (And8 x (Const8 <t> [d])))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAnd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And8 (And8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
 
            // match: (And8 (And8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (And8 (And8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
 
            // match: (And8 (And8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (And8  (Const8  <t> [int64(int8(c&d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAnd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c & d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpArg_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Arg {n} [off])
            // cond: v.Type.IsString()
            // result: (StringMake     (Arg <typ.BytePtr> {n} [off])     (Arg <typ.Int> {n} [off+config.PtrSize]))
            while (true)
            {
                var off = v.AuxInt;
                var n = v.Aux;
                if (!(v.Type.IsString()))
                {
                    break;
                }
                v.reset(OpStringMake);
                var v0 = b.NewValue0(v.Pos, OpArg, typ.BytePtr);
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpArg, typ.Int);
                v1.AuxInt = off + config.PtrSize;
                v1.Aux = n;
                v.AddArg(v1);
                return true;
            } 
            // match: (Arg {n} [off])
            // cond: v.Type.IsSlice()
            // result: (SliceMake     (Arg <v.Type.ElemType().PtrTo()> {n} [off])     (Arg <typ.Int> {n} [off+config.PtrSize])     (Arg <typ.Int> {n} [off+2*config.PtrSize]))
 
            // match: (Arg {n} [off])
            // cond: v.Type.IsSlice()
            // result: (SliceMake     (Arg <v.Type.ElemType().PtrTo()> {n} [off])     (Arg <typ.Int> {n} [off+config.PtrSize])     (Arg <typ.Int> {n} [off+2*config.PtrSize]))
            while (true)
            {
                off = v.AuxInt;
                n = v.Aux;
                if (!(v.Type.IsSlice()))
                {
                    break;
                }
                v.reset(OpSliceMake);
                v0 = b.NewValue0(v.Pos, OpArg, v.Type.ElemType().PtrTo());
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, typ.Int);
                v1.AuxInt = off + config.PtrSize;
                v1.Aux = n;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpArg, typ.Int);
                v2.AuxInt = off + 2L * config.PtrSize;
                v2.Aux = n;
                v.AddArg(v2);
                return true;
            } 
            // match: (Arg {n} [off])
            // cond: v.Type.IsInterface()
            // result: (IMake     (Arg <typ.BytePtr> {n} [off])     (Arg <typ.BytePtr> {n} [off+config.PtrSize]))
 
            // match: (Arg {n} [off])
            // cond: v.Type.IsInterface()
            // result: (IMake     (Arg <typ.BytePtr> {n} [off])     (Arg <typ.BytePtr> {n} [off+config.PtrSize]))
            while (true)
            {
                off = v.AuxInt;
                n = v.Aux;
                if (!(v.Type.IsInterface()))
                {
                    break;
                }
                v.reset(OpIMake);
                v0 = b.NewValue0(v.Pos, OpArg, typ.BytePtr);
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, typ.BytePtr);
                v1.AuxInt = off + config.PtrSize;
                v1.Aux = n;
                v.AddArg(v1);
                return true;
            } 
            // match: (Arg {n} [off])
            // cond: v.Type.IsComplex() && v.Type.Size() == 16
            // result: (ComplexMake     (Arg <typ.Float64> {n} [off])     (Arg <typ.Float64> {n} [off+8]))
 
            // match: (Arg {n} [off])
            // cond: v.Type.IsComplex() && v.Type.Size() == 16
            // result: (ComplexMake     (Arg <typ.Float64> {n} [off])     (Arg <typ.Float64> {n} [off+8]))
            while (true)
            {
                off = v.AuxInt;
                n = v.Aux;
                if (!(v.Type.IsComplex() && v.Type.Size() == 16L))
                {
                    break;
                }
                v.reset(OpComplexMake);
                v0 = b.NewValue0(v.Pos, OpArg, typ.Float64);
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, typ.Float64);
                v1.AuxInt = off + 8L;
                v1.Aux = n;
                v.AddArg(v1);
                return true;
            } 
            // match: (Arg {n} [off])
            // cond: v.Type.IsComplex() && v.Type.Size() == 8
            // result: (ComplexMake     (Arg <typ.Float32> {n} [off])     (Arg <typ.Float32> {n} [off+4]))
 
            // match: (Arg {n} [off])
            // cond: v.Type.IsComplex() && v.Type.Size() == 8
            // result: (ComplexMake     (Arg <typ.Float32> {n} [off])     (Arg <typ.Float32> {n} [off+4]))
            while (true)
            {
                off = v.AuxInt;
                n = v.Aux;
                if (!(v.Type.IsComplex() && v.Type.Size() == 8L))
                {
                    break;
                }
                v.reset(OpComplexMake);
                v0 = b.NewValue0(v.Pos, OpArg, typ.Float32);
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, typ.Float32);
                v1.AuxInt = off + 4L;
                v1.Aux = n;
                v.AddArg(v1);
                return true;
            } 
            // match: (Arg <t>)
            // cond: t.IsStruct() && t.NumFields() == 0 && fe.CanSSA(t)
            // result: (StructMake0)
 
            // match: (Arg <t>)
            // cond: t.IsStruct() && t.NumFields() == 0 && fe.CanSSA(t)
            // result: (StructMake0)
            while (true)
            {
                var t = v.Type;
                if (!(t.IsStruct() && t.NumFields() == 0L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake0);
                return true;
            } 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 1 && fe.CanSSA(t)
            // result: (StructMake1     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)]))
 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 1 && fe.CanSSA(t)
            // result: (StructMake1     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)]))
            while (true)
            {
                t = v.Type;
                off = v.AuxInt;
                n = v.Aux;
                if (!(t.IsStruct() && t.NumFields() == 1L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake1);
                v0 = b.NewValue0(v.Pos, OpArg, t.FieldType(0L));
                v0.AuxInt = off + t.FieldOff(0L);
                v0.Aux = n;
                v.AddArg(v0);
                return true;
            } 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 2 && fe.CanSSA(t)
            // result: (StructMake2     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)]))
 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 2 && fe.CanSSA(t)
            // result: (StructMake2     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)]))
            while (true)
            {
                t = v.Type;
                off = v.AuxInt;
                n = v.Aux;
                if (!(t.IsStruct() && t.NumFields() == 2L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake2);
                v0 = b.NewValue0(v.Pos, OpArg, t.FieldType(0L));
                v0.AuxInt = off + t.FieldOff(0L);
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, t.FieldType(1L));
                v1.AuxInt = off + t.FieldOff(1L);
                v1.Aux = n;
                v.AddArg(v1);
                return true;
            } 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 3 && fe.CanSSA(t)
            // result: (StructMake3     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)])     (Arg <t.FieldType(2)> {n} [off+t.FieldOff(2)]))
 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 3 && fe.CanSSA(t)
            // result: (StructMake3     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)])     (Arg <t.FieldType(2)> {n} [off+t.FieldOff(2)]))
            while (true)
            {
                t = v.Type;
                off = v.AuxInt;
                n = v.Aux;
                if (!(t.IsStruct() && t.NumFields() == 3L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake3);
                v0 = b.NewValue0(v.Pos, OpArg, t.FieldType(0L));
                v0.AuxInt = off + t.FieldOff(0L);
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, t.FieldType(1L));
                v1.AuxInt = off + t.FieldOff(1L);
                v1.Aux = n;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpArg, t.FieldType(2L));
                v2.AuxInt = off + t.FieldOff(2L);
                v2.Aux = n;
                v.AddArg(v2);
                return true;
            } 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 4 && fe.CanSSA(t)
            // result: (StructMake4     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)])     (Arg <t.FieldType(2)> {n} [off+t.FieldOff(2)])     (Arg <t.FieldType(3)> {n} [off+t.FieldOff(3)]))
 
            // match: (Arg <t> {n} [off])
            // cond: t.IsStruct() && t.NumFields() == 4 && fe.CanSSA(t)
            // result: (StructMake4     (Arg <t.FieldType(0)> {n} [off+t.FieldOff(0)])     (Arg <t.FieldType(1)> {n} [off+t.FieldOff(1)])     (Arg <t.FieldType(2)> {n} [off+t.FieldOff(2)])     (Arg <t.FieldType(3)> {n} [off+t.FieldOff(3)]))
            while (true)
            {
                t = v.Type;
                off = v.AuxInt;
                n = v.Aux;
                if (!(t.IsStruct() && t.NumFields() == 4L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake4);
                v0 = b.NewValue0(v.Pos, OpArg, t.FieldType(0L));
                v0.AuxInt = off + t.FieldOff(0L);
                v0.Aux = n;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpArg, t.FieldType(1L));
                v1.AuxInt = off + t.FieldOff(1L);
                v1.Aux = n;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpArg, t.FieldType(2L));
                v2.AuxInt = off + t.FieldOff(2L);
                v2.Aux = n;
                v.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpArg, t.FieldType(3L));
                v3.AuxInt = off + t.FieldOff(3L);
                v3.Aux = n;
                v.AddArg(v3);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpArg_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (Arg <t>)
            // cond: t.IsArray() && t.NumElem() == 0
            // result: (ArrayMake0)
            while (true)
            {
                var t = v.Type;
                if (!(t.IsArray() && t.NumElem() == 0L))
                {
                    break;
                }
                v.reset(OpArrayMake0);
                return true;
            } 
            // match: (Arg <t> {n} [off])
            // cond: t.IsArray() && t.NumElem() == 1 && fe.CanSSA(t)
            // result: (ArrayMake1 (Arg <t.ElemType()> {n} [off]))
 
            // match: (Arg <t> {n} [off])
            // cond: t.IsArray() && t.NumElem() == 1 && fe.CanSSA(t)
            // result: (ArrayMake1 (Arg <t.ElemType()> {n} [off]))
            while (true)
            {
                t = v.Type;
                var off = v.AuxInt;
                var n = v.Aux;
                if (!(t.IsArray() && t.NumElem() == 1L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpArrayMake1);
                var v0 = b.NewValue0(v.Pos, OpArg, t.ElemType());
                v0.AuxInt = off;
                v0.Aux = n;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpArraySelect_0(ref Value v)
        { 
            // match: (ArraySelect (ArrayMake1 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpArrayMake1)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ArraySelect [0] x:(IData _))
            // cond:
            // result: x
 
            // match: (ArraySelect [0] x:(IData _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                if (x.Op != OpIData)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCom16_0(ref Value v)
        { 
            // match: (Com16 (Com16 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpCom16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Com16 (Const16 [c]))
            // cond:
            // result: (Const16 [^c])
 
            // match: (Com16 (Const16 [c]))
            // cond:
            // result: (Const16 [^c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCom32_0(ref Value v)
        { 
            // match: (Com32 (Com32 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpCom32)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Com32 (Const32 [c]))
            // cond:
            // result: (Const32 [^c])
 
            // match: (Com32 (Const32 [c]))
            // cond:
            // result: (Const32 [^c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCom64_0(ref Value v)
        { 
            // match: (Com64 (Com64 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpCom64)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Com64 (Const64 [c]))
            // cond:
            // result: (Const64 [^c])
 
            // match: (Com64 (Const64 [c]))
            // cond:
            // result: (Const64 [^c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCom8_0(ref Value v)
        { 
            // match: (Com8 (Com8 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpCom8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Com8 (Const8 [c]))
            // cond:
            // result: (Const8  [^c])
 
            // match: (Com8 (Const8 [c]))
            // cond:
            // result: (Const8  [^c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpConstInterface_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ConstInterface)
            // cond:
            // result: (IMake     (ConstNil <typ.BytePtr>)     (ConstNil <typ.BytePtr>))
            while (true)
            {
                v.reset(OpIMake);
                var v0 = b.NewValue0(v.Pos, OpConstNil, typ.BytePtr);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpConstNil, typ.BytePtr);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuegeneric_OpConstSlice_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ConstSlice)
            // cond: config.PtrSize == 4
            // result: (SliceMake     (ConstNil <v.Type.ElemType().PtrTo()>)     (Const32 <typ.Int> [0])     (Const32 <typ.Int> [0]))
            while (true)
            {
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpSliceMake);
                var v0 = b.NewValue0(v.Pos, OpConstNil, v.Type.ElemType().PtrTo());
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpConst32, typ.Int);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpConst32, typ.Int);
                v2.AuxInt = 0L;
                v.AddArg(v2);
                return true;
            } 
            // match: (ConstSlice)
            // cond: config.PtrSize == 8
            // result: (SliceMake     (ConstNil <v.Type.ElemType().PtrTo()>)     (Const64 <typ.Int> [0])     (Const64 <typ.Int> [0]))
 
            // match: (ConstSlice)
            // cond: config.PtrSize == 8
            // result: (SliceMake     (ConstNil <v.Type.ElemType().PtrTo()>)     (Const64 <typ.Int> [0])     (Const64 <typ.Int> [0]))
            while (true)
            {
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpSliceMake);
                v0 = b.NewValue0(v.Pos, OpConstNil, v.Type.ElemType().PtrTo());
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.Int);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.Int);
                v2.AuxInt = 0L;
                v.AddArg(v2);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpConstString_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ConstString {s})
            // cond: config.PtrSize == 4 && s.(string) == ""
            // result: (StringMake (ConstNil) (Const32 <typ.Int> [0]))
            while (true)
            {
                var s = v.Aux;
                if (!(config.PtrSize == 4L && s._<@string>() == ""))
                {
                    break;
                }
                v.reset(OpStringMake);
                var v0 = b.NewValue0(v.Pos, OpConstNil, typ.BytePtr);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpConst32, typ.Int);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                return true;
            } 
            // match: (ConstString {s})
            // cond: config.PtrSize == 8 && s.(string) == ""
            // result: (StringMake (ConstNil) (Const64 <typ.Int> [0]))
 
            // match: (ConstString {s})
            // cond: config.PtrSize == 8 && s.(string) == ""
            // result: (StringMake (ConstNil) (Const64 <typ.Int> [0]))
            while (true)
            {
                s = v.Aux;
                if (!(config.PtrSize == 8L && s._<@string>() == ""))
                {
                    break;
                }
                v.reset(OpStringMake);
                v0 = b.NewValue0(v.Pos, OpConstNil, typ.BytePtr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.Int);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                return true;
            } 
            // match: (ConstString {s})
            // cond: config.PtrSize == 4 && s.(string) != ""
            // result: (StringMake     (Addr <typ.BytePtr> {fe.StringData(s.(string))}       (SB))     (Const32 <typ.Int> [int64(len(s.(string)))]))
 
            // match: (ConstString {s})
            // cond: config.PtrSize == 4 && s.(string) != ""
            // result: (StringMake     (Addr <typ.BytePtr> {fe.StringData(s.(string))}       (SB))     (Const32 <typ.Int> [int64(len(s.(string)))]))
            while (true)
            {
                s = v.Aux;
                if (!(config.PtrSize == 4L && s._<@string>() != ""))
                {
                    break;
                }
                v.reset(OpStringMake);
                v0 = b.NewValue0(v.Pos, OpAddr, typ.BytePtr);
                v0.Aux = fe.StringData(s._<@string>());
                v1 = b.NewValue0(v.Pos, OpSB, typ.Uintptr);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst32, typ.Int);
                v2.AuxInt = int64(len(s._<@string>()));
                v.AddArg(v2);
                return true;
            } 
            // match: (ConstString {s})
            // cond: config.PtrSize == 8 && s.(string) != ""
            // result: (StringMake     (Addr <typ.BytePtr> {fe.StringData(s.(string))}       (SB))     (Const64 <typ.Int> [int64(len(s.(string)))]))
 
            // match: (ConstString {s})
            // cond: config.PtrSize == 8 && s.(string) != ""
            // result: (StringMake     (Addr <typ.BytePtr> {fe.StringData(s.(string))}       (SB))     (Const64 <typ.Int> [int64(len(s.(string)))]))
            while (true)
            {
                s = v.Aux;
                if (!(config.PtrSize == 8L && s._<@string>() != ""))
                {
                    break;
                }
                v.reset(OpStringMake);
                v0 = b.NewValue0(v.Pos, OpAddr, typ.BytePtr);
                v0.Aux = fe.StringData(s._<@string>());
                v1 = b.NewValue0(v.Pos, OpSB, typ.Uintptr);
                v0.AddArg(v1);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.Int);
                v2.AuxInt = int64(len(s._<@string>()));
                v.AddArg(v2);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpConvert_0(ref Value v)
        { 
            // match: (Convert (Add64 (Convert ptr mem) off) mem)
            // cond:
            // result: (Add64 ptr off)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConvert)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var ptr = v_0_0.Args[0L];
                var mem = v_0_0.Args[1L];
                var off = v_0.Args[1L];
                if (mem != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(ptr);
                v.AddArg(off);
                return true;
            } 
            // match: (Convert (Add64 off (Convert ptr mem)) mem)
            // cond:
            // result: (Add64 ptr off)
 
            // match: (Convert (Add64 off (Convert ptr mem)) mem)
            // cond:
            // result: (Add64 ptr off)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                off = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConvert)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                ptr = v_0_1.Args[0L];
                mem = v_0_1.Args[1L];
                if (mem != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(ptr);
                v.AddArg(off);
                return true;
            } 
            // match: (Convert (Convert ptr mem) mem)
            // cond:
            // result: ptr
 
            // match: (Convert (Convert ptr mem) mem)
            // cond:
            // result: ptr
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConvert)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                mem = v_0.Args[1L];
                if (mem != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = ptr.Type;
                v.AddArg(ptr);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt32Fto32_0(ref Value v)
        { 
            // match: (Cvt32Fto32 (Const32F [c]))
            // cond:
            // result: (Const32  [int64(int32(i2f(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(i2f(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt32Fto64_0(ref Value v)
        { 
            // match: (Cvt32Fto64 (Const32F [c]))
            // cond:
            // result: (Const64  [int64(i2f(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(i2f(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt32Fto64F_0(ref Value v)
        { 
            // match: (Cvt32Fto64F (Const32F [c]))
            // cond:
            // result: (Const64F [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt32to32F_0(ref Value v)
        { 
            // match: (Cvt32to32F (Const32 [c]))
            // cond:
            // result: (Const32F [f2i(float64(float32(int32(c))))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(float32(int32(c))));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt32to64F_0(ref Value v)
        { 
            // match: (Cvt32to64F (Const32 [c]))
            // cond:
            // result: (Const64F [f2i(float64(int32(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(float64(int32(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt64Fto32_0(ref Value v)
        { 
            // match: (Cvt64Fto32 (Const64F [c]))
            // cond:
            // result: (Const32  [int64(int32(i2f(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(i2f(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt64Fto32F_0(ref Value v)
        { 
            // match: (Cvt64Fto32F (Const64F [c]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt64Fto64_0(ref Value v)
        { 
            // match: (Cvt64Fto64 (Const64F [c]))
            // cond:
            // result: (Const64  [int64(i2f(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(i2f(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt64to32F_0(ref Value v)
        { 
            // match: (Cvt64to32F (Const64 [c]))
            // cond:
            // result: (Const32F [f2i(float64(float32(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(float32(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpCvt64to64F_0(ref Value v)
        { 
            // match: (Cvt64to64F (Const64 [c]))
            // cond:
            // result: (Const64F [f2i(float64(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(float64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16 (Const16 [c]) (Const16 [d]))
            // cond: d != 0
            // result: (Const16 [int64(int16(c)/int16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c) / int16(d));
                return true;
            } 
            // match: (Div16 n (Const16 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffff)
            // result: (Rsh16Ux64 n (Const64 <typ.UInt64> [log2(c&0xffff)]))
 
            // match: (Div16 n (Const16 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffff)
            // result: (Rsh16Ux64 n (Const64 <typ.UInt64> [log2(c&0xffff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffffUL)))
                {
                    break;
                }
                v.reset(OpRsh16Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16 <t> n (Const16 [c]))
            // cond: c < 0 && c != -1<<15
            // result: (Neg16 (Div16 <t> n (Const16 <t> [-c])))
 
            // match: (Div16 <t> n (Const16 [c]))
            // cond: c < 0 && c != -1<<15
            // result: (Neg16 (Div16 <t> n (Const16 <t> [-c])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(15L)))
                {
                    break;
                }
                v.reset(OpNeg16);
                v0 = b.NewValue0(v.Pos, OpDiv16, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst16, t);
                v1.AuxInt = -c;
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16 <t> x (Const16 [-1<<15]))
            // cond:
            // result: (Rsh16Ux64 (And16 <t> x (Neg16 <t> x)) (Const64 <typ.UInt64> [15]))
 
            // match: (Div16 <t> x (Const16 [-1<<15]))
            // cond:
            // result: (Rsh16Ux64 (And16 <t> x (Neg16 <t> x)) (Const64 <typ.UInt64> [15]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(15L))
                {
                    break;
                }
                v.reset(OpRsh16Ux64);
                v0 = b.NewValue0(v.Pos, OpAnd16, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpNeg16, t);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = 15L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div16 <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh16x64     (Add16 <t> n (Rsh16Ux64 <t> (Rsh16x64 <t> n (Const64 <typ.UInt64> [15])) (Const64 <typ.UInt64> [16-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div16 <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh16x64     (Add16 <t> n (Rsh16Ux64 <t> (Rsh16x64 <t> n (Const64 <typ.UInt64> [15])) (Const64 <typ.UInt64> [16-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh16x64);
                v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpRsh16Ux64, t);
                v2 = b.NewValue0(v.Pos, OpRsh16x64, t);
                v2.AddArg(n);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 15L;
                v2.AddArg(v3);
                v1.AddArg(v2);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 16L - log2(c);
                v1.AddArg(v4);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = log2(c);
                v.AddArg(v5);
                return true;
            } 
            // match: (Div16 <t> x (Const16 [c]))
            // cond: smagicOK(16,c)
            // result: (Sub16 <t>     (Rsh32x64 <t>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(smagic(16,c).m)])         (SignExt16to32 x))       (Const64 <typ.UInt64> [16+smagic(16,c).s]))     (Rsh32x64 <t>       (SignExt16to32 x)       (Const64 <typ.UInt64> [31])))
 
            // match: (Div16 <t> x (Const16 [c]))
            // cond: smagicOK(16,c)
            // result: (Sub16 <t>     (Rsh32x64 <t>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(smagic(16,c).m)])         (SignExt16to32 x))       (Const64 <typ.UInt64> [16+smagic(16,c).s]))     (Rsh32x64 <t>       (SignExt16to32 x)       (Const64 <typ.UInt64> [31])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(16L, c)))
                {
                    break;
                }
                v.reset(OpSub16);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v1 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(smagic(16L, c).m);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 16L + smagic(16L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                v5 = b.NewValue0(v.Pos, OpRsh32x64, t);
                var v6 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v6.AddArg(x);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v7.AuxInt = 31L;
                v5.AddArg(v7);
                v.AddArg(v5);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16u (Const16 [c]) (Const16 [d]))
            // cond: d != 0
            // result: (Const16 [int64(int16(uint16(c)/uint16(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = int64(int16(uint16(c) / uint16(d)));
                return true;
            } 
            // match: (Div16u n (Const16 [c]))
            // cond: isPowerOfTwo(c&0xffff)
            // result: (Rsh16Ux64 n (Const64 <typ.UInt64> [log2(c&0xffff)]))
 
            // match: (Div16u n (Const16 [c]))
            // cond: isPowerOfTwo(c&0xffff)
            // result: (Rsh16Ux64 n (Const64 <typ.UInt64> [log2(c&0xffff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffffUL)))
                {
                    break;
                }
                v.reset(OpRsh16Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 8
            // result: (Trunc64to16     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<16+umagic(16,c).m)])         (ZeroExt16to64 x))       (Const64 <typ.UInt64> [16+umagic(16,c).s])))
 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 8
            // result: (Trunc64to16     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<16+umagic(16,c).m)])         (ZeroExt16to64 x))       (Const64 <typ.UInt64> [16+umagic(16,c).s])))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(16L, c) && config.RegSize == 8L))
                {
                    break;
                }
                v.reset(OpTrunc64to16);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                var v1 = b.NewValue0(v.Pos, OpMul64, typ.UInt64);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(1L << (int)(16L) + umagic(16L, c).m);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 16L + umagic(16L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4 && umagic(16,c).m&1 == 0
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<15+umagic(16,c).m/2)])         (ZeroExt16to32 x))       (Const64 <typ.UInt64> [16+umagic(16,c).s-1])))
 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4 && umagic(16,c).m&1 == 0
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<15+umagic(16,c).m/2)])         (ZeroExt16to32 x))       (Const64 <typ.UInt64> [16+umagic(16,c).s-1])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(16L, c) && config.RegSize == 4L && umagic(16L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpTrunc32to16);
                v0 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                v1 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(1L << (int)(15L) + umagic(16L, c).m / 2L);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 16L + umagic(16L, c).s - 1L;
                v0.AddArg(v4);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4 && c&1 == 0
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<15+(umagic(16,c).m+1)/2)])         (Rsh32Ux64 <typ.UInt32> (ZeroExt16to32 x) (Const64 <typ.UInt64> [1])))       (Const64 <typ.UInt64> [16+umagic(16,c).s-2])))
 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4 && c&1 == 0
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<15+(umagic(16,c).m+1)/2)])         (Rsh32Ux64 <typ.UInt32> (ZeroExt16to32 x) (Const64 <typ.UInt64> [1])))       (Const64 <typ.UInt64> [16+umagic(16,c).s-2])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(16L, c) && config.RegSize == 4L && c & 1L == 0L))
                {
                    break;
                }
                v.reset(OpTrunc32to16);
                v0 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                v1 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(1L << (int)(15L) + (umagic(16L, c).m + 1L) / 2L);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                v4 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v4.AddArg(x);
                v3.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = 1L;
                v3.AddArg(v5);
                v1.AddArg(v3);
                v0.AddArg(v1);
                var v6 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v6.AuxInt = 16L + umagic(16L, c).s - 2L;
                v0.AddArg(v6);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Avg32u         (Lsh32x64 <typ.UInt32> (ZeroExt16to32 x) (Const64 <typ.UInt64> [16]))         (Mul32 <typ.UInt32>           (Const32 <typ.UInt32> [int64(umagic(16,c).m)])           (ZeroExt16to32 x)))       (Const64 <typ.UInt64> [16+umagic(16,c).s-1])))
 
            // match: (Div16u x (Const16 [c]))
            // cond: umagicOK(16, c) && config.RegSize == 4
            // result: (Trunc32to16     (Rsh32Ux64 <typ.UInt32>       (Avg32u         (Lsh32x64 <typ.UInt32> (ZeroExt16to32 x) (Const64 <typ.UInt64> [16]))         (Mul32 <typ.UInt32>           (Const32 <typ.UInt32> [int64(umagic(16,c).m)])           (ZeroExt16to32 x)))       (Const64 <typ.UInt64> [16+umagic(16,c).s-1])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(16L, c) && config.RegSize == 4L))
                {
                    break;
                }
                v.reset(OpTrunc32to16);
                v0 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                v1 = b.NewValue0(v.Pos, OpAvg32u, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpLsh32x64, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(x);
                v2.AddArg(v3);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 16L;
                v2.AddArg(v4);
                v1.AddArg(v2);
                v5 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                v6 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v6.AuxInt = int64(umagic(16L, c).m);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v7.AddArg(x);
                v5.AddArg(v7);
                v1.AddArg(v5);
                v0.AddArg(v1);
                var v8 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v8.AuxInt = 16L + umagic(16L, c).s - 1L;
                v0.AddArg(v8);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32 (Const32 [c]) (Const32 [d]))
            // cond: d != 0
            // result: (Const32 [int64(int32(c)/int32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c) / int32(d));
                return true;
            } 
            // match: (Div32 n (Const32 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffffffff)
            // result: (Rsh32Ux64 n (Const64 <typ.UInt64> [log2(c&0xffffffff)]))
 
            // match: (Div32 n (Const32 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffffffff)
            // result: (Rsh32Ux64 n (Const64 <typ.UInt64> [log2(c&0xffffffff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffffffffUL)))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffffffffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div32 <t> n (Const32 [c]))
            // cond: c < 0 && c != -1<<31
            // result: (Neg32 (Div32 <t> n (Const32 <t> [-c])))
 
            // match: (Div32 <t> n (Const32 [c]))
            // cond: c < 0 && c != -1<<31
            // result: (Neg32 (Div32 <t> n (Const32 <t> [-c])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(31L)))
                {
                    break;
                }
                v.reset(OpNeg32);
                v0 = b.NewValue0(v.Pos, OpDiv32, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst32, t);
                v1.AuxInt = -c;
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div32 <t> x (Const32 [-1<<31]))
            // cond:
            // result: (Rsh32Ux64 (And32 <t> x (Neg32 <t> x)) (Const64 <typ.UInt64> [31]))
 
            // match: (Div32 <t> x (Const32 [-1<<31]))
            // cond:
            // result: (Rsh32Ux64 (And32 <t> x (Neg32 <t> x)) (Const64 <typ.UInt64> [31]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(31L))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v0 = b.NewValue0(v.Pos, OpAnd32, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpNeg32, t);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = 31L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div32 <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh32x64     (Add32 <t> n (Rsh32Ux64 <t> (Rsh32x64 <t> n (Const64 <typ.UInt64> [31])) (Const64 <typ.UInt64> [32-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div32 <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh32x64     (Add32 <t> n (Rsh32Ux64 <t> (Rsh32x64 <t> n (Const64 <typ.UInt64> [31])) (Const64 <typ.UInt64> [32-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh32x64);
                v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpRsh32Ux64, t);
                v2 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v2.AddArg(n);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 31L;
                v2.AddArg(v3);
                v1.AddArg(v2);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 32L - log2(c);
                v1.AddArg(v4);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = log2(c);
                v.AddArg(v5);
                return true;
            } 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 8
            // result: (Sub32 <t>     (Rsh64x64 <t>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(smagic(32,c).m)])         (SignExt32to64 x))       (Const64 <typ.UInt64> [32+smagic(32,c).s]))     (Rsh64x64 <t>       (SignExt32to64 x)       (Const64 <typ.UInt64> [63])))
 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 8
            // result: (Sub32 <t>     (Rsh64x64 <t>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(smagic(32,c).m)])         (SignExt32to64 x))       (Const64 <typ.UInt64> [32+smagic(32,c).s]))     (Rsh64x64 <t>       (SignExt32to64 x)       (Const64 <typ.UInt64> [63])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(32L, c) && config.RegSize == 8L))
                {
                    break;
                }
                v.reset(OpSub32);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v1 = b.NewValue0(v.Pos, OpMul64, typ.UInt64);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(smagic(32L, c).m);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 32L + smagic(32L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                v5 = b.NewValue0(v.Pos, OpRsh64x64, t);
                var v6 = b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64);
                v6.AddArg(x);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v7.AuxInt = 63L;
                v5.AddArg(v7);
                v.AddArg(v5);
                return true;
            } 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 4 && smagic(32,c).m&1 == 0
            // result: (Sub32 <t>     (Rsh32x64 <t>       (Hmul32 <t>         (Const32 <typ.UInt32> [int64(int32(smagic(32,c).m/2))])         x)       (Const64 <typ.UInt64> [smagic(32,c).s-1]))     (Rsh32x64 <t>       x       (Const64 <typ.UInt64> [31])))
 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 4 && smagic(32,c).m&1 == 0
            // result: (Sub32 <t>     (Rsh32x64 <t>       (Hmul32 <t>         (Const32 <typ.UInt32> [int64(int32(smagic(32,c).m/2))])         x)       (Const64 <typ.UInt64> [smagic(32,c).s-1]))     (Rsh32x64 <t>       x       (Const64 <typ.UInt64> [31])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(32L, c) && config.RegSize == 4L && smagic(32L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpSub32);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v1 = b.NewValue0(v.Pos, OpHmul32, t);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(int32(smagic(32L, c).m / 2L));
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = smagic(32L, c).s - 1L;
                v0.AddArg(v3);
                v.AddArg(v0);
                v4 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v4.AddArg(x);
                v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = 31L;
                v4.AddArg(v5);
                v.AddArg(v4);
                return true;
            } 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 4 && smagic(32,c).m&1 != 0
            // result: (Sub32 <t>     (Rsh32x64 <t>       (Add32 <t>         (Hmul32 <t>           (Const32 <typ.UInt32> [int64(int32(smagic(32,c).m))])           x)         x)       (Const64 <typ.UInt64> [smagic(32,c).s]))     (Rsh32x64 <t>       x       (Const64 <typ.UInt64> [31])))
 
            // match: (Div32 <t> x (Const32 [c]))
            // cond: smagicOK(32,c) && config.RegSize == 4 && smagic(32,c).m&1 != 0
            // result: (Sub32 <t>     (Rsh32x64 <t>       (Add32 <t>         (Hmul32 <t>           (Const32 <typ.UInt32> [int64(int32(smagic(32,c).m))])           x)         x)       (Const64 <typ.UInt64> [smagic(32,c).s]))     (Rsh32x64 <t>       x       (Const64 <typ.UInt64> [31])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(32L, c) && config.RegSize == 4L && smagic(32L, c).m & 1L != 0L))
                {
                    break;
                }
                v.reset(OpSub32);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v1 = b.NewValue0(v.Pos, OpAdd32, t);
                v2 = b.NewValue0(v.Pos, OpHmul32, t);
                v3 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v3.AuxInt = int64(int32(smagic(32L, c).m));
                v2.AddArg(v3);
                v2.AddArg(x);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = smagic(32L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                v5 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v5.AddArg(x);
                v6 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v6.AuxInt = 31L;
                v5.AddArg(v6);
                v.AddArg(v5);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Div32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) / i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) / i2f32(d)));
                return true;
            } 
            // match: (Div32F x (Const32F <t> [c]))
            // cond: reciprocalExact32(float32(i2f(c)))
            // result: (Mul32F x (Const32F <t> [f2i(1/i2f(c))]))
 
            // match: (Div32F x (Const32F <t> [c]))
            // cond: reciprocalExact32(float32(i2f(c)))
            // result: (Mul32F x (Const32F <t> [f2i(1/i2f(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(reciprocalExact32(float32(i2f(c)))))
                {
                    break;
                }
                v.reset(OpMul32F);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst32F, t);
                v0.AuxInt = f2i(1L / i2f(c));
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32u (Const32 [c]) (Const32 [d]))
            // cond: d != 0
            // result: (Const32 [int64(int32(uint32(c)/uint32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = int64(int32(uint32(c) / uint32(d)));
                return true;
            } 
            // match: (Div32u n (Const32 [c]))
            // cond: isPowerOfTwo(c&0xffffffff)
            // result: (Rsh32Ux64 n (Const64 <typ.UInt64> [log2(c&0xffffffff)]))
 
            // match: (Div32u n (Const32 [c]))
            // cond: isPowerOfTwo(c&0xffffffff)
            // result: (Rsh32Ux64 n (Const64 <typ.UInt64> [log2(c&0xffffffff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffffffffUL)))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffffffffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4 && umagic(32,c).m&1 == 0
            // result: (Rsh32Ux64 <typ.UInt32>     (Hmul32u <typ.UInt32>       (Const32 <typ.UInt32> [int64(int32(1<<31+umagic(32,c).m/2))])       x)     (Const64 <typ.UInt64> [umagic(32,c).s-1]))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4 && umagic(32,c).m&1 == 0
            // result: (Rsh32Ux64 <typ.UInt32>     (Hmul32u <typ.UInt32>       (Const32 <typ.UInt32> [int64(int32(1<<31+umagic(32,c).m/2))])       x)     (Const64 <typ.UInt64> [umagic(32,c).s-1]))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 4L && umagic(32L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.Type = typ.UInt32;
                v0 = b.NewValue0(v.Pos, OpHmul32u, typ.UInt32);
                var v1 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v1.AuxInt = int64(int32(1L << (int)(31L) + umagic(32L, c).m / 2L));
                v0.AddArg(v1);
                v0.AddArg(x);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = umagic(32L, c).s - 1L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4 && c&1 == 0
            // result: (Rsh32Ux64 <typ.UInt32>     (Hmul32u <typ.UInt32>       (Const32 <typ.UInt32> [int64(int32(1<<31+(umagic(32,c).m+1)/2))])       (Rsh32Ux64 <typ.UInt32> x (Const64 <typ.UInt64> [1])))     (Const64 <typ.UInt64> [umagic(32,c).s-2]))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4 && c&1 == 0
            // result: (Rsh32Ux64 <typ.UInt32>     (Hmul32u <typ.UInt32>       (Const32 <typ.UInt32> [int64(int32(1<<31+(umagic(32,c).m+1)/2))])       (Rsh32Ux64 <typ.UInt32> x (Const64 <typ.UInt64> [1])))     (Const64 <typ.UInt64> [umagic(32,c).s-2]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 4L && c & 1L == 0L))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.Type = typ.UInt32;
                v0 = b.NewValue0(v.Pos, OpHmul32u, typ.UInt32);
                v1 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v1.AuxInt = int64(int32(1L << (int)(31L) + (umagic(32L, c).m + 1L) / 2L));
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                v2.AddArg(x);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 1L;
                v2.AddArg(v3);
                v0.AddArg(v2);
                v.AddArg(v0);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = umagic(32L, c).s - 2L;
                v.AddArg(v4);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4
            // result: (Rsh32Ux64 <typ.UInt32>     (Avg32u       x       (Hmul32u <typ.UInt32>         (Const32 <typ.UInt32> [int64(int32(umagic(32,c).m))])         x))     (Const64 <typ.UInt64> [umagic(32,c).s-1]))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 4
            // result: (Rsh32Ux64 <typ.UInt32>     (Avg32u       x       (Hmul32u <typ.UInt32>         (Const32 <typ.UInt32> [int64(int32(umagic(32,c).m))])         x))     (Const64 <typ.UInt64> [umagic(32,c).s-1]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 4L))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.Type = typ.UInt32;
                v0 = b.NewValue0(v.Pos, OpAvg32u, typ.UInt32);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpHmul32u, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(int32(umagic(32L, c).m));
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = umagic(32L, c).s - 1L;
                v.AddArg(v3);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8 && umagic(32,c).m&1 == 0
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<31+umagic(32,c).m/2)])         (ZeroExt32to64 x))       (Const64 <typ.UInt64> [32+umagic(32,c).s-1])))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8 && umagic(32,c).m&1 == 0
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<31+umagic(32,c).m/2)])         (ZeroExt32to64 x))       (Const64 <typ.UInt64> [32+umagic(32,c).s-1])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 8L && umagic(32L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpTrunc64to32);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                v1 = b.NewValue0(v.Pos, OpMul64, typ.UInt64);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(1L << (int)(31L) + umagic(32L, c).m / 2L);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 32L + umagic(32L, c).s - 1L;
                v0.AddArg(v4);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8 && c&1 == 0
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<31+(umagic(32,c).m+1)/2)])         (Rsh64Ux64 <typ.UInt64> (ZeroExt32to64 x) (Const64 <typ.UInt64> [1])))       (Const64 <typ.UInt64> [32+umagic(32,c).s-2])))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8 && c&1 == 0
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Mul64 <typ.UInt64>         (Const64 <typ.UInt64> [int64(1<<31+(umagic(32,c).m+1)/2)])         (Rsh64Ux64 <typ.UInt64> (ZeroExt32to64 x) (Const64 <typ.UInt64> [1])))       (Const64 <typ.UInt64> [32+umagic(32,c).s-2])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 8L && c & 1L == 0L))
                {
                    break;
                }
                v.reset(OpTrunc64to32);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                v1 = b.NewValue0(v.Pos, OpMul64, typ.UInt64);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(1L << (int)(31L) + (umagic(32L, c).m + 1L) / 2L);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                v4 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v4.AddArg(x);
                v3.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = 1L;
                v3.AddArg(v5);
                v1.AddArg(v3);
                v0.AddArg(v1);
                var v6 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v6.AuxInt = 32L + umagic(32L, c).s - 2L;
                v0.AddArg(v6);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Avg64u         (Lsh64x64 <typ.UInt64> (ZeroExt32to64 x) (Const64 <typ.UInt64> [32]))         (Mul64 <typ.UInt64>           (Const64 <typ.UInt32> [int64(umagic(32,c).m)])           (ZeroExt32to64 x)))       (Const64 <typ.UInt64> [32+umagic(32,c).s-1])))
 
            // match: (Div32u x (Const32 [c]))
            // cond: umagicOK(32, c) && config.RegSize == 8
            // result: (Trunc64to32     (Rsh64Ux64 <typ.UInt64>       (Avg64u         (Lsh64x64 <typ.UInt64> (ZeroExt32to64 x) (Const64 <typ.UInt64> [32]))         (Mul64 <typ.UInt64>           (Const64 <typ.UInt32> [int64(umagic(32,c).m)])           (ZeroExt32to64 x)))       (Const64 <typ.UInt64> [32+umagic(32,c).s-1])))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(32L, c) && config.RegSize == 8L))
                {
                    break;
                }
                v.reset(OpTrunc64to32);
                v0 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                v1 = b.NewValue0(v.Pos, OpAvg64u, typ.UInt64);
                v2 = b.NewValue0(v.Pos, OpLsh64x64, typ.UInt64);
                v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(x);
                v2.AddArg(v3);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 32L;
                v2.AddArg(v4);
                v1.AddArg(v2);
                v5 = b.NewValue0(v.Pos, OpMul64, typ.UInt64);
                v6 = b.NewValue0(v.Pos, OpConst64, typ.UInt32);
                v6.AuxInt = int64(umagic(32L, c).m);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v7.AddArg(x);
                v5.AddArg(v7);
                v1.AddArg(v5);
                v0.AddArg(v1);
                var v8 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v8.AuxInt = 32L + umagic(32L, c).s - 1L;
                v0.AddArg(v8);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div64 (Const64 [c]) (Const64 [d]))
            // cond: d != 0
            // result: (Const64 [c/d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = c / d;
                return true;
            } 
            // match: (Div64 n (Const64 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c)
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div64 n (Const64 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c)
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div64 n (Const64 [-1<<63]))
            // cond: isNonNegative(n)
            // result: (Const64 [0])
 
            // match: (Div64 n (Const64 [-1<<63]))
            // cond: isNonNegative(n)
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                if (!(isNonNegative(n)))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Div64 <t> n (Const64 [c]))
            // cond: c < 0 && c != -1<<63
            // result: (Neg64 (Div64 <t> n (Const64 <t> [-c])))
 
            // match: (Div64 <t> n (Const64 [c]))
            // cond: c < 0 && c != -1<<63
            // result: (Neg64 (Div64 <t> n (Const64 <t> [-c])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(63L)))
                {
                    break;
                }
                v.reset(OpNeg64);
                v0 = b.NewValue0(v.Pos, OpDiv64, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst64, t);
                v1.AuxInt = -c;
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div64 <t> x (Const64 [-1<<63]))
            // cond:
            // result: (Rsh64Ux64 (And64 <t> x (Neg64 <t> x)) (Const64 <typ.UInt64> [63]))
 
            // match: (Div64 <t> x (Const64 [-1<<63]))
            // cond:
            // result: (Rsh64Ux64 (And64 <t> x (Neg64 <t> x)) (Const64 <typ.UInt64> [63]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v0 = b.NewValue0(v.Pos, OpAnd64, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpNeg64, t);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = 63L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div64 <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh64x64     (Add64 <t> n (Rsh64Ux64 <t> (Rsh64x64 <t> n (Const64 <typ.UInt64> [63])) (Const64 <typ.UInt64> [64-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div64 <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh64x64     (Add64 <t> n (Rsh64Ux64 <t> (Rsh64x64 <t> n (Const64 <typ.UInt64> [63])) (Const64 <typ.UInt64> [64-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh64x64);
                v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpRsh64Ux64, t);
                v2 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v2.AddArg(n);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 63L;
                v2.AddArg(v3);
                v1.AddArg(v2);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 64L - log2(c);
                v1.AddArg(v4);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = log2(c);
                v.AddArg(v5);
                return true;
            } 
            // match: (Div64 <t> x (Const64 [c]))
            // cond: smagicOK(64,c) && smagic(64,c).m&1 == 0
            // result: (Sub64 <t>     (Rsh64x64 <t>       (Hmul64 <t>         (Const64 <typ.UInt64> [int64(smagic(64,c).m/2)])         x)       (Const64 <typ.UInt64> [smagic(64,c).s-1]))     (Rsh64x64 <t>       x       (Const64 <typ.UInt64> [63])))
 
            // match: (Div64 <t> x (Const64 [c]))
            // cond: smagicOK(64,c) && smagic(64,c).m&1 == 0
            // result: (Sub64 <t>     (Rsh64x64 <t>       (Hmul64 <t>         (Const64 <typ.UInt64> [int64(smagic(64,c).m/2)])         x)       (Const64 <typ.UInt64> [smagic(64,c).s-1]))     (Rsh64x64 <t>       x       (Const64 <typ.UInt64> [63])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(64L, c) && smagic(64L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpSub64);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v1 = b.NewValue0(v.Pos, OpHmul64, t);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(smagic(64L, c).m / 2L);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = smagic(64L, c).s - 1L;
                v0.AddArg(v3);
                v.AddArg(v0);
                v4 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v4.AddArg(x);
                v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = 63L;
                v4.AddArg(v5);
                v.AddArg(v4);
                return true;
            } 
            // match: (Div64 <t> x (Const64 [c]))
            // cond: smagicOK(64,c) && smagic(64,c).m&1 != 0
            // result: (Sub64 <t>     (Rsh64x64 <t>       (Add64 <t>         (Hmul64 <t>           (Const64 <typ.UInt64> [int64(smagic(64,c).m)])           x)         x)       (Const64 <typ.UInt64> [smagic(64,c).s]))     (Rsh64x64 <t>       x       (Const64 <typ.UInt64> [63])))
 
            // match: (Div64 <t> x (Const64 [c]))
            // cond: smagicOK(64,c) && smagic(64,c).m&1 != 0
            // result: (Sub64 <t>     (Rsh64x64 <t>       (Add64 <t>         (Hmul64 <t>           (Const64 <typ.UInt64> [int64(smagic(64,c).m)])           x)         x)       (Const64 <typ.UInt64> [smagic(64,c).s]))     (Rsh64x64 <t>       x       (Const64 <typ.UInt64> [63])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(64L, c) && smagic(64L, c).m & 1L != 0L))
                {
                    break;
                }
                v.reset(OpSub64);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v1 = b.NewValue0(v.Pos, OpAdd64, t);
                v2 = b.NewValue0(v.Pos, OpHmul64, t);
                v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = int64(smagic(64L, c).m);
                v2.AddArg(v3);
                v2.AddArg(x);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = smagic(64L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                v5 = b.NewValue0(v.Pos, OpRsh64x64, t);
                v5.AddArg(x);
                var v6 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v6.AuxInt = 63L;
                v5.AddArg(v6);
                v.AddArg(v5);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Div64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (Const64F [f2i(i2f(c) / i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) / i2f(d));
                return true;
            } 
            // match: (Div64F x (Const64F <t> [c]))
            // cond: reciprocalExact64(i2f(c))
            // result: (Mul64F x (Const64F <t> [f2i(1/i2f(c))]))
 
            // match: (Div64F x (Const64F <t> [c]))
            // cond: reciprocalExact64(i2f(c))
            // result: (Mul64F x (Const64F <t> [f2i(1/i2f(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(reciprocalExact64(i2f(c))))
                {
                    break;
                }
                v.reset(OpMul64F);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64F, t);
                v0.AuxInt = f2i(1L / i2f(c));
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div64u (Const64 [c]) (Const64 [d]))
            // cond: d != 0
            // result: (Const64 [int64(uint64(c)/uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = int64(uint64(c) / uint64(d));
                return true;
            } 
            // match: (Div64u n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div64u n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div64u n (Const64 [-1<<63]))
            // cond:
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [63]))
 
            // match: (Div64u n (Const64 [-1<<63]))
            // cond:
            // result: (Rsh64Ux64 n (Const64 <typ.UInt64> [63]))
            while (true)
            {
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = 63L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8 && umagic(64,c).m&1 == 0
            // result: (Rsh64Ux64 <typ.UInt64>     (Hmul64u <typ.UInt64>       (Const64 <typ.UInt64> [int64(1<<63+umagic(64,c).m/2)])       x)     (Const64 <typ.UInt64> [umagic(64,c).s-1]))
 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8 && umagic(64,c).m&1 == 0
            // result: (Rsh64Ux64 <typ.UInt64>     (Hmul64u <typ.UInt64>       (Const64 <typ.UInt64> [int64(1<<63+umagic(64,c).m/2)])       x)     (Const64 <typ.UInt64> [umagic(64,c).s-1]))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(64L, c) && config.RegSize == 8L && umagic(64L, c).m & 1L == 0L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.Type = typ.UInt64;
                v0 = b.NewValue0(v.Pos, OpHmul64u, typ.UInt64);
                var v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = int64(1L << (int)(63L) + umagic(64L, c).m / 2L);
                v0.AddArg(v1);
                v0.AddArg(x);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = umagic(64L, c).s - 1L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8 && c&1 == 0
            // result: (Rsh64Ux64 <typ.UInt64>     (Hmul64u <typ.UInt64>       (Const64 <typ.UInt64> [int64(1<<63+(umagic(64,c).m+1)/2)])       (Rsh64Ux64 <typ.UInt64> x (Const64 <typ.UInt64> [1])))     (Const64 <typ.UInt64> [umagic(64,c).s-2]))
 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8 && c&1 == 0
            // result: (Rsh64Ux64 <typ.UInt64>     (Hmul64u <typ.UInt64>       (Const64 <typ.UInt64> [int64(1<<63+(umagic(64,c).m+1)/2)])       (Rsh64Ux64 <typ.UInt64> x (Const64 <typ.UInt64> [1])))     (Const64 <typ.UInt64> [umagic(64,c).s-2]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(64L, c) && config.RegSize == 8L && c & 1L == 0L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.Type = typ.UInt64;
                v0 = b.NewValue0(v.Pos, OpHmul64u, typ.UInt64);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = int64(1L << (int)(63L) + (umagic(64L, c).m + 1L) / 2L);
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpRsh64Ux64, typ.UInt64);
                v2.AddArg(x);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 1L;
                v2.AddArg(v3);
                v0.AddArg(v2);
                v.AddArg(v0);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = umagic(64L, c).s - 2L;
                v.AddArg(v4);
                return true;
            } 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8
            // result: (Rsh64Ux64 <typ.UInt64>     (Avg64u       x       (Hmul64u <typ.UInt64>         (Const64 <typ.UInt64> [int64(umagic(64,c).m)])         x))     (Const64 <typ.UInt64> [umagic(64,c).s-1]))
 
            // match: (Div64u x (Const64 [c]))
            // cond: umagicOK(64, c) && config.RegSize == 8
            // result: (Rsh64Ux64 <typ.UInt64>     (Avg64u       x       (Hmul64u <typ.UInt64>         (Const64 <typ.UInt64> [int64(umagic(64,c).m)])         x))     (Const64 <typ.UInt64> [umagic(64,c).s-1]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(64L, c) && config.RegSize == 8L))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.Type = typ.UInt64;
                v0 = b.NewValue0(v.Pos, OpAvg64u, typ.UInt64);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpHmul64u, typ.UInt64);
                v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = int64(umagic(64L, c).m);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = umagic(64L, c).s - 1L;
                v.AddArg(v3);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8 (Const8 [c]) (Const8 [d]))
            // cond: d != 0
            // result: (Const8  [int64(int8(c)/int8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c) / int8(d));
                return true;
            } 
            // match: (Div8 n (Const8 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xff)
            // result: (Rsh8Ux64 n  (Const64 <typ.UInt64> [log2(c&0xff)]))
 
            // match: (Div8 n (Const8 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xff)
            // result: (Rsh8Ux64 n  (Const64 <typ.UInt64> [log2(c&0xff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffUL)))
                {
                    break;
                }
                v.reset(OpRsh8Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div8 <t> n (Const8 [c]))
            // cond: c < 0 && c != -1<<7
            // result: (Neg8  (Div8  <t> n (Const8  <t> [-c])))
 
            // match: (Div8 <t> n (Const8 [c]))
            // cond: c < 0 && c != -1<<7
            // result: (Neg8  (Div8  <t> n (Const8  <t> [-c])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(7L)))
                {
                    break;
                }
                v.reset(OpNeg8);
                v0 = b.NewValue0(v.Pos, OpDiv8, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst8, t);
                v1.AuxInt = -c;
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div8 <t> x (Const8 [-1<<7 ]))
            // cond:
            // result: (Rsh8Ux64  (And8  <t> x (Neg8  <t> x)) (Const64 <typ.UInt64> [7 ]))
 
            // match: (Div8 <t> x (Const8 [-1<<7 ]))
            // cond:
            // result: (Rsh8Ux64  (And8  <t> x (Neg8  <t> x)) (Const64 <typ.UInt64> [7 ]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(7L))
                {
                    break;
                }
                v.reset(OpRsh8Ux64);
                v0 = b.NewValue0(v.Pos, OpAnd8, t);
                v0.AddArg(x);
                v1 = b.NewValue0(v.Pos, OpNeg8, t);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v2.AuxInt = 7L;
                v.AddArg(v2);
                return true;
            } 
            // match: (Div8 <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh8x64     (Add8  <t> n (Rsh8Ux64  <t> (Rsh8x64  <t> n (Const64 <typ.UInt64> [ 7])) (Const64 <typ.UInt64> [ 8-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Div8 <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Rsh8x64     (Add8  <t> n (Rsh8Ux64  <t> (Rsh8x64  <t> n (Const64 <typ.UInt64> [ 7])) (Const64 <typ.UInt64> [ 8-log2(c)])))     (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpRsh8x64);
                v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpRsh8Ux64, t);
                v2 = b.NewValue0(v.Pos, OpRsh8x64, t);
                v2.AddArg(n);
                var v3 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v3.AuxInt = 7L;
                v2.AddArg(v3);
                v1.AddArg(v2);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 8L - log2(c);
                v1.AddArg(v4);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v5 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v5.AuxInt = log2(c);
                v.AddArg(v5);
                return true;
            } 
            // match: (Div8 <t> x (Const8 [c]))
            // cond: smagicOK(8,c)
            // result: (Sub8 <t>     (Rsh32x64 <t>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(smagic(8,c).m)])         (SignExt8to32 x))       (Const64 <typ.UInt64> [8+smagic(8,c).s]))     (Rsh32x64 <t>       (SignExt8to32 x)       (Const64 <typ.UInt64> [31])))
 
            // match: (Div8 <t> x (Const8 [c]))
            // cond: smagicOK(8,c)
            // result: (Sub8 <t>     (Rsh32x64 <t>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(smagic(8,c).m)])         (SignExt8to32 x))       (Const64 <typ.UInt64> [8+smagic(8,c).s]))     (Rsh32x64 <t>       (SignExt8to32 x)       (Const64 <typ.UInt64> [31])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(smagicOK(8L, c)))
                {
                    break;
                }
                v.reset(OpSub8);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpRsh32x64, t);
                v1 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(smagic(8L, c).m);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 8L + smagic(8L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                v5 = b.NewValue0(v.Pos, OpRsh32x64, t);
                var v6 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v6.AddArg(x);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v7.AuxInt = 31L;
                v5.AddArg(v7);
                v.AddArg(v5);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpDiv8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8u (Const8 [c]) (Const8 [d]))
            // cond: d != 0
            // result: (Const8  [int64(int8(uint8(c)/uint8(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = int64(int8(uint8(c) / uint8(d)));
                return true;
            } 
            // match: (Div8u n (Const8 [c]))
            // cond: isPowerOfTwo(c&0xff)
            // result: (Rsh8Ux64 n  (Const64 <typ.UInt64> [log2(c&0xff)]))
 
            // match: (Div8u n (Const8 [c]))
            // cond: isPowerOfTwo(c&0xff)
            // result: (Rsh8Ux64 n  (Const64 <typ.UInt64> [log2(c&0xff)]))
            while (true)
            {
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffUL)))
                {
                    break;
                }
                v.reset(OpRsh8Ux64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c & 0xffUL);
                v.AddArg(v0);
                return true;
            } 
            // match: (Div8u x (Const8 [c]))
            // cond: umagicOK(8, c)
            // result: (Trunc32to8     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<8+umagic(8,c).m)])         (ZeroExt8to32 x))       (Const64 <typ.UInt64> [8+umagic(8,c).s])))
 
            // match: (Div8u x (Const8 [c]))
            // cond: umagicOK(8, c)
            // result: (Trunc32to8     (Rsh32Ux64 <typ.UInt32>       (Mul32 <typ.UInt32>         (Const32 <typ.UInt32> [int64(1<<8+umagic(8,c).m)])         (ZeroExt8to32 x))       (Const64 <typ.UInt64> [8+umagic(8,c).s])))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(umagicOK(8L, c)))
                {
                    break;
                }
                v.reset(OpTrunc32to8);
                v0 = b.NewValue0(v.Pos, OpRsh32Ux64, typ.UInt32);
                var v1 = b.NewValue0(v.Pos, OpMul32, typ.UInt32);
                var v2 = b.NewValue0(v.Pos, OpConst32, typ.UInt32);
                v2.AuxInt = int64(1L << (int)(8L) + umagic(8L, c).m);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v3.AddArg(x);
                v1.AddArg(v3);
                v0.AddArg(v1);
                var v4 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v4.AuxInt = 8L + umagic(8L, c).s;
                v0.AddArg(v4);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq16 x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Eq16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Eq16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpEq16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Eq16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpEq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Eq16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Eq16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Eq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (Eq16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32 x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Eq32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Eq32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpEq32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Eq32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpEq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Eq32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Eq32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Eq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (Eq32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq32F_0(ref Value v)
        { 
            // match: (Eq32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) == i2f(d));
                return true;
            } 
            // match: (Eq32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
 
            // match: (Eq32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) == i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64 x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Eq64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
 
            // match: (Eq64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpEq64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
 
            // match: (Eq64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpEq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
 
            // match: (Eq64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
 
            // match: (Eq64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Eq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (Eq64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq64F_0(ref Value v)
        { 
            // match: (Eq64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) == i2f(d));
                return true;
            } 
            // match: (Eq64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
 
            // match: (Eq64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) == i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) == i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq8 x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Eq8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Eq8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpEq8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Eq8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpEq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Eq8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Eq8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Eq8  (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpEq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Eq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (Eq8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (Eq8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEqB_0(ref Value v)
        { 
            // match: (EqB (ConstBool [c]) (ConstBool [d]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (EqB (ConstBool [d]) (ConstBool [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
 
            // match: (EqB (ConstBool [d]) (ConstBool [c]))
            // cond:
            // result: (ConstBool [b2i(c == d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c == d);
                return true;
            } 
            // match: (EqB (ConstBool [0]) x)
            // cond:
            // result: (Not x)
 
            // match: (EqB (ConstBool [0]) x)
            // cond:
            // result: (Not x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpNot);
                v.AddArg(x);
                return true;
            } 
            // match: (EqB x (ConstBool [0]))
            // cond:
            // result: (Not x)
 
            // match: (EqB x (ConstBool [0]))
            // cond:
            // result: (Not x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpNot);
                v.AddArg(x);
                return true;
            } 
            // match: (EqB (ConstBool [1]) x)
            // cond:
            // result: x
 
            // match: (EqB (ConstBool [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (EqB x (ConstBool [1]))
            // cond:
            // result: x
 
            // match: (EqB x (ConstBool [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEqInter_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqInter x y)
            // cond:
            // result: (EqPtr  (ITab x) (ITab y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpEqPtr);
                var v0 = b.NewValue0(v.Pos, OpITab, typ.BytePtr);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpITab, typ.BytePtr);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuegeneric_OpEqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqPtr p (ConstNil))
            // cond:
            // result: (Not (IsNonNil p))
            while (true)
            {
                _ = v.Args[1L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConstNil)
                {
                    break;
                }
                v.reset(OpNot);
                var v0 = b.NewValue0(v.Pos, OpIsNonNil, typ.Bool);
                v0.AddArg(p);
                v.AddArg(v0);
                return true;
            } 
            // match: (EqPtr (ConstNil) p)
            // cond:
            // result: (Not (IsNonNil p))
 
            // match: (EqPtr (ConstNil) p)
            // cond:
            // result: (Not (IsNonNil p))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConstNil)
                {
                    break;
                }
                p = v.Args[1L];
                v.reset(OpNot);
                v0 = b.NewValue0(v.Pos, OpIsNonNil, typ.Bool);
                v0.AddArg(p);
                v.AddArg(v0);
                return true;
            } 
            // match: (EqPtr x x)
            // cond:
            // result: (ConstBool [1])
 
            // match: (EqPtr x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (EqPtr (Addr {a} x) (Addr {b} x))
            // cond:
            // result: (ConstBool [b2i(a == b)])
 
            // match: (EqPtr (Addr {a} x) (Addr {b} x))
            // cond:
            // result: (ConstBool [b2i(a == b)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAddr)
                {
                    break;
                }
                var a = v_0.Aux;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAddr)
                {
                    break;
                }
                b = v_1.Aux;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = b2i(a == b);
                return true;
            } 
            // match: (EqPtr (Addr {b} x) (Addr {a} x))
            // cond:
            // result: (ConstBool [b2i(a == b)])
 
            // match: (EqPtr (Addr {b} x) (Addr {a} x))
            // cond:
            // result: (ConstBool [b2i(a == b)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAddr)
                {
                    break;
                }
                b = v_0.Aux;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAddr)
                {
                    break;
                }
                a = v_1.Aux;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = b2i(a == b);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpEqSlice_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqSlice x y)
            // cond:
            // result: (EqPtr  (SlicePtr x) (SlicePtr y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpEqPtr);
                var v0 = b.NewValue0(v.Pos, OpSlicePtr, typ.BytePtr);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSlicePtr, typ.BytePtr);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuegeneric_OpGeq16_0(ref Value v)
        { 
            // match: (Geq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c >= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c >= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq16U_0(ref Value v)
        { 
            // match: (Geq16U (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(uint16(c) >= uint16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint16(c) >= uint16(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq32_0(ref Value v)
        { 
            // match: (Geq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c >= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c >= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq32F_0(ref Value v)
        { 
            // match: (Geq32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) >= i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) >= i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq32U_0(ref Value v)
        { 
            // match: (Geq32U (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(uint32(c) >= uint32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint32(c) >= uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq64_0(ref Value v)
        { 
            // match: (Geq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c >= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c >= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq64F_0(ref Value v)
        { 
            // match: (Geq64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) >= i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) >= i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq64U_0(ref Value v)
        { 
            // match: (Geq64U (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(uint64(c) >= uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint64(c) >= uint64(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq8_0(ref Value v)
        { 
            // match: (Geq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c >= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c >= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGeq8U_0(ref Value v)
        { 
            // match: (Geq8U (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(uint8(c)  >= uint8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint8(c) >= uint8(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater16_0(ref Value v)
        { 
            // match: (Greater16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c > d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c > d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater16U_0(ref Value v)
        { 
            // match: (Greater16U (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(uint16(c) > uint16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint16(c) > uint16(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater32_0(ref Value v)
        { 
            // match: (Greater32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c > d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c > d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater32F_0(ref Value v)
        { 
            // match: (Greater32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) > i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) > i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater32U_0(ref Value v)
        { 
            // match: (Greater32U (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(uint32(c) > uint32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint32(c) > uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater64_0(ref Value v)
        { 
            // match: (Greater64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c > d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c > d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater64F_0(ref Value v)
        { 
            // match: (Greater64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) > i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) > i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater64U_0(ref Value v)
        { 
            // match: (Greater64U (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(uint64(c) > uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint64(c) > uint64(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater8_0(ref Value v)
        { 
            // match: (Greater8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c > d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c > d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpGreater8U_0(ref Value v)
        { 
            // match: (Greater8U (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(uint8(c)  > uint8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint8(c) > uint8(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIMake_0(ref Value v)
        { 
            // match: (IMake typ (StructMake1 val))
            // cond:
            // result: (IMake typ val)
            while (true)
            {
                _ = v.Args[1L];
                var typ = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake1)
                {
                    break;
                }
                var val = v_1.Args[0L];
                v.reset(OpIMake);
                v.AddArg(typ);
                v.AddArg(val);
                return true;
            } 
            // match: (IMake typ (ArrayMake1 val))
            // cond:
            // result: (IMake typ val)
 
            // match: (IMake typ (ArrayMake1 val))
            // cond:
            // result: (IMake typ val)
            while (true)
            {
                _ = v.Args[1L];
                typ = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpArrayMake1)
                {
                    break;
                }
                val = v_1.Args[0L];
                v.reset(OpIMake);
                v.AddArg(typ);
                v.AddArg(val);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpInterCall_0(ref Value v)
        { 
            // match: (InterCall [argsize] (Load (OffPtr [off] (ITab (IMake (Addr {itab} (SB)) _))) _) mem)
            // cond: devirt(v, itab, off) != nil
            // result: (StaticCall [argsize] {devirt(v, itab, off)} mem)
            while (true)
            {
                var argsize = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpOffPtr)
                {
                    break;
                }
                var off = v_0_0.AuxInt;
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpITab)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpIMake)
                {
                    break;
                }
                _ = v_0_0_0_0.Args[1L];
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAddr)
                {
                    break;
                }
                var itab = v_0_0_0_0_0.Aux;
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpSB)
                {
                    break;
                }
                var mem = v.Args[1L];
                if (!(devirt(v, itab, off) != null))
                {
                    break;
                }
                v.reset(OpStaticCall);
                v.AuxInt = argsize;
                v.Aux = devirt(v, itab, off);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsInBounds_0(ref Value v)
        { 
            // match: (IsInBounds (ZeroExt8to32 _) (Const32 [c]))
            // cond: (1 << 8)  <= c
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!((1L << (int)(8L)) <= c))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to64 _) (Const64 [c]))
            // cond: (1 << 8)  <= c
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to64 _) (Const64 [c]))
            // cond: (1 << 8)  <= c
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!((1L << (int)(8L)) <= c))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to32 _) (Const32 [c]))
            // cond: (1 << 16) <= c
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to32 _) (Const32 [c]))
            // cond: (1 << 16) <= c
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to32)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!((1L << (int)(16L)) <= c))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to64 _) (Const64 [c]))
            // cond: (1 << 16) <= c
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to64 _) (Const64 [c]))
            // cond: (1 << 16) <= c
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!((1L << (int)(16L)) <= c))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds x x)
            // cond:
            // result: (ConstBool [0])
 
            // match: (IsInBounds x x)
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (IsInBounds (And8 (Const8 [c]) _) (Const8 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And8 (Const8 [c]) _) (Const8 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And8 _ (Const8 [c])) (Const8 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And8 _ (Const8 [c])) (Const8 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to16 (And8 (Const8 [c]) _)) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to16 (And8 (Const8 [c]) _)) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to16)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to16 (And8 _ (Const8 [c]))) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to16 (And8 _ (Const8 [c]))) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to16)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to32 (And8 (Const8 [c]) _)) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to32 (And8 (Const8 [c]) _)) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsInBounds_10(ref Value v)
        { 
            // match: (IsInBounds (ZeroExt8to32 (And8 _ (Const8 [c]))) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_0_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to64 (And8 (Const8 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to64 (And8 (Const8 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to64 (And8 _ (Const8 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to64 (And8 _ (Const8 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst8)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And16 (Const16 [c]) _) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And16 (Const16 [c]) _) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And16 _ (Const16 [c])) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And16 _ (Const16 [c])) (Const16 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to32 (And16 (Const16 [c]) _)) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to32 (And16 (Const16 [c]) _)) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to32)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to32 (And16 _ (Const16 [c]))) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to32 (And16 _ (Const16 [c]))) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to32)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst16)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to64 (And16 (Const16 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to64 (And16 (Const16 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to64 (And16 _ (Const16 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to64 (And16 _ (Const16 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst16)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And32 (Const32 [c]) _) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And32 (Const32 [c]) _) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsInBounds_20(ref Value v)
        { 
            // match: (IsInBounds (And32 _ (Const32 [c])) (Const32 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt32to64 (And32 (Const32 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt32to64 (And32 (Const32 [c]) _)) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt32to64)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt32to64 (And32 _ (Const32 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt32to64 (And32 _ (Const32 [c]))) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt32to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst32)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And64 (Const64 [c]) _) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And64 (Const64 [c]) _) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (And64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (And64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 <= c && c < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c < d)])
 
            // match: (IsInBounds (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c < d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(0L <= c && c < d);
                return true;
            } 
            // match: (IsInBounds (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c < d)])
 
            // match: (IsInBounds (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c < d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(0L <= c && c < d);
                return true;
            } 
            // match: (IsInBounds (Mod32u _ y) y)
            // cond:
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Mod32u _ y) y)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMod32u)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Mod64u _ y) y)
            // cond:
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Mod64u _ y) y)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMod64u)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to64 (Rsh8Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to64 (Rsh8Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 8L && 1L << (int)(uint(8L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsInBounds_30(ref Value v)
        { 
            // match: (IsInBounds (ZeroExt8to32 (Rsh8Ux64 _ (Const64 [c]))) (Const32 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_0_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(0L < c && c < 8L && 1L << (int)(uint(8L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt8to16 (Rsh8Ux64 _ (Const64 [c]))) (Const16 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt8to16 (Rsh8Ux64 _ (Const64 [c]))) (Const16 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to16)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 8L && 1L << (int)(uint(8L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Rsh8Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Rsh8Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c <  8 && 1<<uint( 8-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 8L && 1L << (int)(uint(8L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to64 (Rsh16Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to64 (Rsh16Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 16L && 1L << (int)(uint(16L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt16to32 (Rsh16Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt16to32 (Rsh16Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to32)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 16L && 1L << (int)(uint(16L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Rsh16Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Rsh16Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 16 && 1<<uint(16-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 16L && 1L << (int)(uint(16L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (ZeroExt32to64 (Rsh32Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 32 && 1<<uint(32-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (ZeroExt32to64 (Rsh32Ux64 _ (Const64 [c]))) (Const64 [d]))
            // cond: 0 < c && c < 32 && 1<<uint(32-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt32to64)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 32L && 1L << (int)(uint(32L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Rsh32Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 32 && 1<<uint(32-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Rsh32Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 32 && 1<<uint(32-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 32L && 1L << (int)(uint(32L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsInBounds (Rsh64Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 64 && 1<<uint(64-c)-1 < d
            // result: (ConstBool [1])
 
            // match: (IsInBounds (Rsh64Ux64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 < c && c < 64 && 1<<uint(64-c)-1 < d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L < c && c < 64L && 1L << (int)(uint(64L - c)) - 1L < d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsNonNil_0(ref Value v)
        { 
            // match: (IsNonNil (ConstNil))
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConstNil)
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpIsSliceInBounds_0(ref Value v)
        { 
            // match: (IsSliceInBounds x x)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (And32 (Const32 [c]) _) (Const32 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (And32 (Const32 [c]) _) (Const32 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(0L <= c && c <= d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (And32 _ (Const32 [c])) (Const32 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (And32 _ (Const32 [c])) (Const32 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c <= d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (And64 (Const64 [c]) _) (Const64 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (And64 (Const64 [c]) _) (Const64 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c <= d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (And64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (And64 _ (Const64 [c])) (Const64 [d]))
            // cond: 0 <= c && c <= d
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(0L <= c && c <= d))
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (Const32 [0]) _)
            // cond:
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (Const32 [0]) _)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (Const64 [0]) _)
            // cond:
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (Const64 [0]) _)
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (IsSliceInBounds (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c <= d)])
 
            // match: (IsSliceInBounds (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(0L <= c && c <= d);
                return true;
            } 
            // match: (IsSliceInBounds (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c <= d)])
 
            // match: (IsSliceInBounds (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(0 <= c && c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(0L <= c && c <= d);
                return true;
            } 
            // match: (IsSliceInBounds (SliceLen x) (SliceCap x))
            // cond:
            // result: (ConstBool [1])
 
            // match: (IsSliceInBounds (SliceLen x) (SliceCap x))
            // cond:
            // result: (ConstBool [1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceLen)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSliceCap)
                {
                    break;
                }
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq16_0(ref Value v)
        { 
            // match: (Leq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c <= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq16U_0(ref Value v)
        { 
            // match: (Leq16U (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(uint16(c) <= uint16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint16(c) <= uint16(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq32_0(ref Value v)
        { 
            // match: (Leq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c <= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq32F_0(ref Value v)
        { 
            // match: (Leq32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) <= i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) <= i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq32U_0(ref Value v)
        { 
            // match: (Leq32U (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(uint32(c) <= uint32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint32(c) <= uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq64_0(ref Value v)
        { 
            // match: (Leq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c <= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq64F_0(ref Value v)
        { 
            // match: (Leq64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) <= i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) <= i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq64U_0(ref Value v)
        { 
            // match: (Leq64U (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(uint64(c) <= uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint64(c) <= uint64(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq8_0(ref Value v)
        { 
            // match: (Leq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c <= d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c <= d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLeq8U_0(ref Value v)
        { 
            // match: (Leq8U (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(uint8(c)  <= uint8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint8(c) <= uint8(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess16_0(ref Value v)
        { 
            // match: (Less16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c < d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c < d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess16U_0(ref Value v)
        { 
            // match: (Less16U (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(uint16(c) < uint16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint16(c) < uint16(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess32_0(ref Value v)
        { 
            // match: (Less32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c < d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c < d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess32F_0(ref Value v)
        { 
            // match: (Less32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) < i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) < i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess32U_0(ref Value v)
        { 
            // match: (Less32U (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(uint32(c) < uint32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint32(c) < uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess64_0(ref Value v)
        { 
            // match: (Less64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c < d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c < d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess64F_0(ref Value v)
        { 
            // match: (Less64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) < i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) < i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess64U_0(ref Value v)
        { 
            // match: (Less64U (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(uint64(c) < uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint64(c) < uint64(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess8_0(ref Value v)
        { 
            // match: (Less8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c < d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c < d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLess8U_0(ref Value v)
        { 
            // match: (Less8U (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(uint8(c)  < uint8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(uint8(c) < uint8(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLoad_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (Load <t1> p1 (Store {t2} p2 x _))
            // cond: isSamePtr(p1,p2) && t1.Compare(x.Type) == types.CMPeq && t1.Size() == t2.(*types.Type).Size()
            // result: x
            while (true)
            {
                var t1 = v.Type;
                _ = v.Args[1L];
                var p1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpStore)
                {
                    break;
                }
                var t2 = v_1.Aux;
                _ = v_1.Args[2L];
                var p2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(isSamePtr(p1, p2) && t1.Compare(x.Type) == types.CMPeq && t1.Size() == t2._<ref types.Type>().Size()))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Load <t1> p1 (Store {t2} p2 (Const64 [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 8 && is64BitFloat(t1)
            // result: (Const64F [x])
 
            // match: (Load <t1> p1 (Store {t2} p2 (Const64 [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 8 && is64BitFloat(t1)
            // result: (Const64F [x])
            while (true)
            {
                t1 = v.Type;
                _ = v.Args[1L];
                p1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStore)
                {
                    break;
                }
                t2 = v_1.Aux;
                _ = v_1.Args[2L];
                p2 = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                x = v_1_1.AuxInt;
                if (!(isSamePtr(p1, p2) && t2._<ref types.Type>().Size() == 8L && is64BitFloat(t1)))
                {
                    break;
                }
                v.reset(OpConst64F);
                v.AuxInt = x;
                return true;
            } 
            // match: (Load <t1> p1 (Store {t2} p2 (Const32 [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 4 && is32BitFloat(t1)
            // result: (Const32F [f2i(float64(math.Float32frombits(uint32(x))))])
 
            // match: (Load <t1> p1 (Store {t2} p2 (Const32 [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 4 && is32BitFloat(t1)
            // result: (Const32F [f2i(float64(math.Float32frombits(uint32(x))))])
            while (true)
            {
                t1 = v.Type;
                _ = v.Args[1L];
                p1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStore)
                {
                    break;
                }
                t2 = v_1.Aux;
                _ = v_1.Args[2L];
                p2 = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                x = v_1_1.AuxInt;
                if (!(isSamePtr(p1, p2) && t2._<ref types.Type>().Size() == 4L && is32BitFloat(t1)))
                {
                    break;
                }
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(math.Float32frombits(uint32(x))));
                return true;
            } 
            // match: (Load <t1> p1 (Store {t2} p2 (Const64F [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 8 && is64BitInt(t1)
            // result: (Const64  [x])
 
            // match: (Load <t1> p1 (Store {t2} p2 (Const64F [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 8 && is64BitInt(t1)
            // result: (Const64  [x])
            while (true)
            {
                t1 = v.Type;
                _ = v.Args[1L];
                p1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStore)
                {
                    break;
                }
                t2 = v_1.Aux;
                _ = v_1.Args[2L];
                p2 = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64F)
                {
                    break;
                }
                x = v_1_1.AuxInt;
                if (!(isSamePtr(p1, p2) && t2._<ref types.Type>().Size() == 8L && is64BitInt(t1)))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = x;
                return true;
            } 
            // match: (Load <t1> p1 (Store {t2} p2 (Const32F [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 4 && is32BitInt(t1)
            // result: (Const32  [int64(int32(math.Float32bits(float32(i2f(x)))))])
 
            // match: (Load <t1> p1 (Store {t2} p2 (Const32F [x]) _))
            // cond: isSamePtr(p1,p2) && t2.(*types.Type).Size() == 4 && is32BitInt(t1)
            // result: (Const32  [int64(int32(math.Float32bits(float32(i2f(x)))))])
            while (true)
            {
                t1 = v.Type;
                _ = v.Args[1L];
                p1 = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStore)
                {
                    break;
                }
                t2 = v_1.Aux;
                _ = v_1.Args[2L];
                p2 = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32F)
                {
                    break;
                }
                x = v_1_1.AuxInt;
                if (!(isSamePtr(p1, p2) && t2._<ref types.Type>().Size() == 4L && is32BitInt(t1)))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = int64(int32(math.Float32bits(float32(i2f(x)))));
                return true;
            } 
            // match: (Load <t> _ _)
            // cond: t.IsStruct() && t.NumFields() == 0 && fe.CanSSA(t)
            // result: (StructMake0)
 
            // match: (Load <t> _ _)
            // cond: t.IsStruct() && t.NumFields() == 0 && fe.CanSSA(t)
            // result: (StructMake0)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                if (!(t.IsStruct() && t.NumFields() == 0L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake0);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 1 && fe.CanSSA(t)
            // result: (StructMake1     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0] ptr) mem))
 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 1 && fe.CanSSA(t)
            // result: (StructMake1     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0] ptr) mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(t.IsStruct() && t.NumFields() == 1L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake1);
                var v0 = b.NewValue0(v.Pos, OpLoad, t.FieldType(0L));
                var v1 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                v0.AddArg(v1);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 2 && fe.CanSSA(t)
            // result: (StructMake2     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem))
 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 2 && fe.CanSSA(t)
            // result: (StructMake2     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsStruct() && t.NumFields() == 2L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake2);
                v0 = b.NewValue0(v.Pos, OpLoad, t.FieldType(0L));
                v1 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                v0.AddArg(v1);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpLoad, t.FieldType(1L));
                var v3 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v3.AuxInt = t.FieldOff(1L);
                v3.AddArg(ptr);
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 3 && fe.CanSSA(t)
            // result: (StructMake3     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem)     (Load <t.FieldType(2)> (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] ptr) mem))
 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 3 && fe.CanSSA(t)
            // result: (StructMake3     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem)     (Load <t.FieldType(2)> (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] ptr) mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsStruct() && t.NumFields() == 3L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake3);
                v0 = b.NewValue0(v.Pos, OpLoad, t.FieldType(0L));
                v1 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                v0.AddArg(v1);
                v0.AddArg(mem);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpLoad, t.FieldType(1L));
                v3 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v3.AuxInt = t.FieldOff(1L);
                v3.AddArg(ptr);
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                var v4 = b.NewValue0(v.Pos, OpLoad, t.FieldType(2L));
                var v5 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(2L).PtrTo());
                v5.AuxInt = t.FieldOff(2L);
                v5.AddArg(ptr);
                v4.AddArg(v5);
                v4.AddArg(mem);
                v.AddArg(v4);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 4 && fe.CanSSA(t)
            // result: (StructMake4     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem)     (Load <t.FieldType(2)> (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] ptr) mem)     (Load <t.FieldType(3)> (OffPtr <t.FieldType(3).PtrTo()> [t.FieldOff(3)] ptr) mem))
 
            // match: (Load <t> ptr mem)
            // cond: t.IsStruct() && t.NumFields() == 4 && fe.CanSSA(t)
            // result: (StructMake4     (Load <t.FieldType(0)> (OffPtr <t.FieldType(0).PtrTo()> [0]             ptr) mem)     (Load <t.FieldType(1)> (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] ptr) mem)     (Load <t.FieldType(2)> (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] ptr) mem)     (Load <t.FieldType(3)> (OffPtr <t.FieldType(3).PtrTo()> [t.FieldOff(3)] ptr) mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsStruct() && t.NumFields() == 4L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpStructMake4);
                v0 = b.NewValue0(v.Pos, OpLoad, t.FieldType(0L));
                v1 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                v0.AddArg(v1);
                v0.AddArg(mem);
                v.AddArg(v0);
                v2 = b.NewValue0(v.Pos, OpLoad, t.FieldType(1L));
                v3 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v3.AuxInt = t.FieldOff(1L);
                v3.AddArg(ptr);
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                v4 = b.NewValue0(v.Pos, OpLoad, t.FieldType(2L));
                v5 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(2L).PtrTo());
                v5.AuxInt = t.FieldOff(2L);
                v5.AddArg(ptr);
                v4.AddArg(v5);
                v4.AddArg(mem);
                v.AddArg(v4);
                var v6 = b.NewValue0(v.Pos, OpLoad, t.FieldType(3L));
                var v7 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(3L).PtrTo());
                v7.AuxInt = t.FieldOff(3L);
                v7.AddArg(ptr);
                v6.AddArg(v7);
                v6.AddArg(mem);
                v.AddArg(v6);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLoad_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (Load <t> _ _)
            // cond: t.IsArray() && t.NumElem() == 0
            // result: (ArrayMake0)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                if (!(t.IsArray() && t.NumElem() == 0L))
                {
                    break;
                }
                v.reset(OpArrayMake0);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsArray() && t.NumElem() == 1 && fe.CanSSA(t)
            // result: (ArrayMake1 (Load <t.ElemType()> ptr mem))
 
            // match: (Load <t> ptr mem)
            // cond: t.IsArray() && t.NumElem() == 1 && fe.CanSSA(t)
            // result: (ArrayMake1 (Load <t.ElemType()> ptr mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(t.IsArray() && t.NumElem() == 1L && fe.CanSSA(t)))
                {
                    break;
                }
                v.reset(OpArrayMake1);
                var v0 = b.NewValue0(v.Pos, OpLoad, t.ElemType());
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x16 <t> x (Const16 [c]))
            // cond:
            // result: (Lsh16x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh16x16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Lsh16x16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x32 <t> x (Const32 [c]))
            // cond:
            // result: (Lsh16x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh16x32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Lsh16x32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x64 (Const16 [c]) (Const64 [d]))
            // cond:
            // result: (Const16 [int64(int16(c) << uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c) << (int)(uint64(d)));
                return true;
            } 
            // match: (Lsh16x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Lsh16x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Lsh16x64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh16x64 <t> (Lsh16x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh16x64 x (Const64 <t> [c+d]))
 
            // match: (Lsh16x64 <t> (Lsh16x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh16x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh16x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpLsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh16x64 (Rsh16Ux64 (Lsh16x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh16x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Lsh16x64 (Rsh16Ux64 (Lsh16x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh16x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLsh16x64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpLsh16x64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x8 <t> x (Const8 [c]))
            // cond:
            // result: (Lsh16x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh16x8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Lsh16x8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x16 <t> x (Const16 [c]))
            // cond:
            // result: (Lsh32x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Lsh32x16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x32 <t> x (Const32 [c]))
            // cond:
            // result: (Lsh32x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Lsh32x32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x64 (Const32 [c]) (Const64 [d]))
            // cond:
            // result: (Const32 [int64(int32(c) << uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c) << (int)(uint64(d)));
                return true;
            } 
            // match: (Lsh32x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Lsh32x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Lsh32x64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh32x64 <t> (Lsh32x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh32x64 x (Const64 <t> [c+d]))
 
            // match: (Lsh32x64 <t> (Lsh32x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh32x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpLsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x64 (Rsh32Ux64 (Lsh32x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh32x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Lsh32x64 (Rsh32Ux64 (Lsh32x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh32x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpLsh32x64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x8 <t> x (Const8 [c]))
            // cond:
            // result: (Lsh32x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Lsh32x8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x16 <t> x (Const16 [c]))
            // cond:
            // result: (Lsh64x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Lsh64x16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x32 <t> x (Const32 [c]))
            // cond:
            // result: (Lsh64x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Lsh64x32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c << uint64(d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c << (int)(uint64(d));
                return true;
            } 
            // match: (Lsh64x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Lsh64x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh64x64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Lsh64x64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh64x64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (Const64 [0])
 
            // match: (Lsh64x64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 64L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh64x64 <t> (Lsh64x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh64x64 x (Const64 <t> [c+d]))
 
            // match: (Lsh64x64 <t> (Lsh64x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh64x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x64 (Rsh64Ux64 (Lsh64x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh64x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Lsh64x64 (Rsh64Ux64 (Lsh64x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh64x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x8 <t> x (Const8 [c]))
            // cond:
            // result: (Lsh64x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Lsh64x8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x16 <t> x (Const16 [c]))
            // cond:
            // result: (Lsh8x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh8x16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Lsh8x16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x32 <t> x (Const32 [c]))
            // cond:
            // result: (Lsh8x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh8x32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Lsh8x32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x64 (Const8 [c]) (Const64 [d]))
            // cond:
            // result: (Const8  [int64(int8(c) << uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c) << (int)(uint64(d)));
                return true;
            } 
            // match: (Lsh8x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Lsh8x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Lsh8x64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8  [0])
 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh8x64 <t> (Lsh8x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh8x64  x (Const64 <t> [c+d]))
 
            // match: (Lsh8x64 <t> (Lsh8x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Lsh8x64  x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh8x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpLsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh8x64 (Rsh8Ux64 (Lsh8x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh8x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Lsh8x64 (Rsh8Ux64 (Lsh8x64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Lsh8x64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLsh8x64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpLsh8x64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpLsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x8 <t> x (Const8 [c]))
            // cond:
            // result: (Lsh8x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpLsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh8x8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Lsh8x8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod16 (Const16 [c]) (Const16 [d]))
            // cond: d != 0
            // result: (Const16 [int64(int16(c % d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c % d));
                return true;
            } 
            // match: (Mod16 <t> n (Const16 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffff)
            // result: (And16 n (Const16 <t> [(c&0xffff)-1]))
 
            // match: (Mod16 <t> n (Const16 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffff)
            // result: (And16 n (Const16 <t> [(c&0xffff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffffUL)))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = (c & 0xffffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod16 <t> n (Const16 [c]))
            // cond: c < 0 && c != -1<<15
            // result: (Mod16 <t> n (Const16 <t> [-c]))
 
            // match: (Mod16 <t> n (Const16 [c]))
            // cond: c < 0 && c != -1<<15
            // result: (Mod16 <t> n (Const16 <t> [-c]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(15L)))
                {
                    break;
                }
                v.reset(OpMod16);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = -c;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod16 <t> x (Const16 [c]))
            // cond: x.Op != OpConst16 && (c > 0 || c == -1<<15)
            // result: (Sub16 x (Mul16 <t> (Div16  <t> x (Const16 <t> [c])) (Const16 <t> [c])))
 
            // match: (Mod16 <t> x (Const16 [c]))
            // cond: x.Op != OpConst16 && (c > 0 || c == -1<<15)
            // result: (Sub16 x (Mul16 <t> (Div16  <t> x (Const16 <t> [c])) (Const16 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst16 && (c > 0L || c == -1L << (int)(15L))))
                {
                    break;
                }
                v.reset(OpSub16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul16, t);
                var v1 = b.NewValue0(v.Pos, OpDiv16, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst16, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst16, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod16u (Const16 [c]) (Const16 [d]))
            // cond: d != 0
            // result: (Const16 [int64(uint16(c) % uint16(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = int64(uint16(c) % uint16(d));
                return true;
            } 
            // match: (Mod16u <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c&0xffff)
            // result: (And16 n (Const16 <t> [(c&0xffff)-1]))
 
            // match: (Mod16u <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c&0xffff)
            // result: (And16 n (Const16 <t> [(c&0xffff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffffUL)))
                {
                    break;
                }
                v.reset(OpAnd16);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = (c & 0xffffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod16u <t> x (Const16 [c]))
            // cond: x.Op != OpConst16 && c > 0 && umagicOK(16,c)
            // result: (Sub16 x (Mul16 <t> (Div16u <t> x (Const16 <t> [c])) (Const16 <t> [c])))
 
            // match: (Mod16u <t> x (Const16 [c]))
            // cond: x.Op != OpConst16 && c > 0 && umagicOK(16,c)
            // result: (Sub16 x (Mul16 <t> (Div16u <t> x (Const16 <t> [c])) (Const16 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst16 && c > 0L && umagicOK(16L, c)))
                {
                    break;
                }
                v.reset(OpSub16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul16, t);
                var v1 = b.NewValue0(v.Pos, OpDiv16u, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst16, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst16, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod32 (Const32 [c]) (Const32 [d]))
            // cond: d != 0
            // result: (Const32 [int64(int32(c % d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c % d));
                return true;
            } 
            // match: (Mod32 <t> n (Const32 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffffffff)
            // result: (And32 n (Const32 <t> [(c&0xffffffff)-1]))
 
            // match: (Mod32 <t> n (Const32 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xffffffff)
            // result: (And32 n (Const32 <t> [(c&0xffffffff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffffffffUL)))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = (c & 0xffffffffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod32 <t> n (Const32 [c]))
            // cond: c < 0 && c != -1<<31
            // result: (Mod32 <t> n (Const32 <t> [-c]))
 
            // match: (Mod32 <t> n (Const32 [c]))
            // cond: c < 0 && c != -1<<31
            // result: (Mod32 <t> n (Const32 <t> [-c]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(31L)))
                {
                    break;
                }
                v.reset(OpMod32);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = -c;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod32 <t> x (Const32 [c]))
            // cond: x.Op != OpConst32 && (c > 0 || c == -1<<31)
            // result: (Sub32 x (Mul32 <t> (Div32  <t> x (Const32 <t> [c])) (Const32 <t> [c])))
 
            // match: (Mod32 <t> x (Const32 [c]))
            // cond: x.Op != OpConst32 && (c > 0 || c == -1<<31)
            // result: (Sub32 x (Mul32 <t> (Div32  <t> x (Const32 <t> [c])) (Const32 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst32 && (c > 0L || c == -1L << (int)(31L))))
                {
                    break;
                }
                v.reset(OpSub32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul32, t);
                var v1 = b.NewValue0(v.Pos, OpDiv32, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst32, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod32u (Const32 [c]) (Const32 [d]))
            // cond: d != 0
            // result: (Const32 [int64(uint32(c) % uint32(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = int64(uint32(c) % uint32(d));
                return true;
            } 
            // match: (Mod32u <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c&0xffffffff)
            // result: (And32 n (Const32 <t> [(c&0xffffffff)-1]))
 
            // match: (Mod32u <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c&0xffffffff)
            // result: (And32 n (Const32 <t> [(c&0xffffffff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffffffffUL)))
                {
                    break;
                }
                v.reset(OpAnd32);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = (c & 0xffffffffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod32u <t> x (Const32 [c]))
            // cond: x.Op != OpConst32 && c > 0 && umagicOK(32,c)
            // result: (Sub32 x (Mul32 <t> (Div32u <t> x (Const32 <t> [c])) (Const32 <t> [c])))
 
            // match: (Mod32u <t> x (Const32 [c]))
            // cond: x.Op != OpConst32 && c > 0 && umagicOK(32,c)
            // result: (Sub32 x (Mul32 <t> (Div32u <t> x (Const32 <t> [c])) (Const32 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst32 && c > 0L && umagicOK(32L, c)))
                {
                    break;
                }
                v.reset(OpSub32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul32, t);
                var v1 = b.NewValue0(v.Pos, OpDiv32u, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst32, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod64 (Const64 [c]) (Const64 [d]))
            // cond: d != 0
            // result: (Const64 [c % d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = c % d;
                return true;
            } 
            // match: (Mod64 <t> n (Const64 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c)
            // result: (And64 n (Const64 <t> [c-1]))
 
            // match: (Mod64 <t> n (Const64 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c)
            // result: (And64 n (Const64 <t> [c-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod64 n (Const64 [-1<<63]))
            // cond: isNonNegative(n)
            // result: n
 
            // match: (Mod64 n (Const64 [-1<<63]))
            // cond: isNonNegative(n)
            // result: n
            while (true)
            {
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                if (!(isNonNegative(n)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = n.Type;
                v.AddArg(n);
                return true;
            } 
            // match: (Mod64 <t> n (Const64 [c]))
            // cond: c < 0 && c != -1<<63
            // result: (Mod64 <t> n (Const64 <t> [-c]))
 
            // match: (Mod64 <t> n (Const64 [c]))
            // cond: c < 0 && c != -1<<63
            // result: (Mod64 <t> n (Const64 <t> [-c]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(63L)))
                {
                    break;
                }
                v.reset(OpMod64);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = -c;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod64 <t> x (Const64 [c]))
            // cond: x.Op != OpConst64 && (c > 0 || c == -1<<63)
            // result: (Sub64 x (Mul64 <t> (Div64  <t> x (Const64 <t> [c])) (Const64 <t> [c])))
 
            // match: (Mod64 <t> x (Const64 [c]))
            // cond: x.Op != OpConst64 && (c > 0 || c == -1<<63)
            // result: (Sub64 x (Mul64 <t> (Div64  <t> x (Const64 <t> [c])) (Const64 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst64 && (c > 0L || c == -1L << (int)(63L))))
                {
                    break;
                }
                v.reset(OpSub64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul64, t);
                var v1 = b.NewValue0(v.Pos, OpDiv64, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst64, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod64u (Const64 [c]) (Const64 [d]))
            // cond: d != 0
            // result: (Const64 [int64(uint64(c) % uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = int64(uint64(c) % uint64(d));
                return true;
            } 
            // match: (Mod64u <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (And64 n (Const64 <t> [c-1]))
 
            // match: (Mod64u <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (And64 n (Const64 <t> [c-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod64u <t> n (Const64 [-1<<63]))
            // cond:
            // result: (And64 n (Const64 <t> [1<<63-1]))
 
            // match: (Mod64u <t> n (Const64 [-1<<63]))
            // cond:
            // result: (And64 n (Const64 <t> [1<<63-1]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L << (int)(63L))
                {
                    break;
                }
                v.reset(OpAnd64);
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = 1L << (int)(63L) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod64u <t> x (Const64 [c]))
            // cond: x.Op != OpConst64 && c > 0 && umagicOK(64,c)
            // result: (Sub64 x (Mul64 <t> (Div64u <t> x (Const64 <t> [c])) (Const64 <t> [c])))
 
            // match: (Mod64u <t> x (Const64 [c]))
            // cond: x.Op != OpConst64 && c > 0 && umagicOK(64,c)
            // result: (Sub64 x (Mul64 <t> (Div64u <t> x (Const64 <t> [c])) (Const64 <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst64 && c > 0L && umagicOK(64L, c)))
                {
                    break;
                }
                v.reset(OpSub64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul64, t);
                var v1 = b.NewValue0(v.Pos, OpDiv64u, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst64, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod8 (Const8 [c]) (Const8 [d]))
            // cond: d != 0
            // result: (Const8  [int64(int8(c % d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c % d));
                return true;
            } 
            // match: (Mod8 <t> n (Const8 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xff)
            // result: (And8 n (Const8 <t> [(c&0xff)-1]))
 
            // match: (Mod8 <t> n (Const8 [c]))
            // cond: isNonNegative(n) && isPowerOfTwo(c&0xff)
            // result: (And8 n (Const8 <t> [(c&0xff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isNonNegative(n) && isPowerOfTwo(c & 0xffUL)))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = (c & 0xffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod8 <t> n (Const8 [c]))
            // cond: c < 0 && c != -1<<7
            // result: (Mod8  <t> n (Const8  <t> [-c]))
 
            // match: (Mod8 <t> n (Const8 [c]))
            // cond: c < 0 && c != -1<<7
            // result: (Mod8  <t> n (Const8  <t> [-c]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c < 0L && c != -1L << (int)(7L)))
                {
                    break;
                }
                v.reset(OpMod8);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = -c;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod8 <t> x (Const8 [c]))
            // cond: x.Op != OpConst8  && (c > 0 || c == -1<<7)
            // result: (Sub8  x (Mul8  <t> (Div8   <t> x (Const8  <t> [c])) (Const8  <t> [c])))
 
            // match: (Mod8 <t> x (Const8 [c]))
            // cond: x.Op != OpConst8  && (c > 0 || c == -1<<7)
            // result: (Sub8  x (Mul8  <t> (Div8   <t> x (Const8  <t> [c])) (Const8  <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst8 && (c > 0L || c == -1L << (int)(7L))))
                {
                    break;
                }
                v.reset(OpSub8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul8, t);
                var v1 = b.NewValue0(v.Pos, OpDiv8, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst8, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst8, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMod8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mod8u (Const8 [c]) (Const8 [d]))
            // cond: d != 0
            // result: (Const8  [int64(uint8(c) % uint8(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (!(d != 0L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = int64(uint8(c) % uint8(d));
                return true;
            } 
            // match: (Mod8u <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c&0xff)
            // result: (And8 n (Const8 <t> [(c&0xff)-1]))
 
            // match: (Mod8u <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c&0xff)
            // result: (And8 n (Const8 <t> [(c&0xff)-1]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c & 0xffUL)))
                {
                    break;
                }
                v.reset(OpAnd8);
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = (c & 0xffUL) - 1L;
                v.AddArg(v0);
                return true;
            } 
            // match: (Mod8u <t> x (Const8 [c]))
            // cond: x.Op != OpConst8  && c > 0 && umagicOK(8 ,c)
            // result: (Sub8  x (Mul8  <t> (Div8u  <t> x (Const8  <t> [c])) (Const8  <t> [c])))
 
            // match: (Mod8u <t> x (Const8 [c]))
            // cond: x.Op != OpConst8  && c > 0 && umagicOK(8 ,c)
            // result: (Sub8  x (Mul8  <t> (Div8u  <t> x (Const8  <t> [c])) (Const8  <t> [c])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(x.Op != OpConst8 && c > 0L && umagicOK(8L, c)))
                {
                    break;
                }
                v.reset(OpSub8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpMul8, t);
                var v1 = b.NewValue0(v.Pos, OpDiv8u, t);
                v1.AddArg(x);
                var v2 = b.NewValue0(v.Pos, OpConst8, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpConst8, t);
                v3.AuxInt = c;
                v0.AddArg(v3);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mul16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c * d));
                return true;
            } 
            // match: (Mul16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c*d))])
 
            // match: (Mul16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c * d));
                return true;
            } 
            // match: (Mul16 (Const16 [1]) x)
            // cond:
            // result: x
 
            // match: (Mul16 (Const16 [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 x (Const16 [1]))
            // cond:
            // result: x
 
            // match: (Mul16 x (Const16 [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 (Const16 [-1]) x)
            // cond:
            // result: (Neg16 x)
 
            // match: (Mul16 (Const16 [-1]) x)
            // cond:
            // result: (Neg16 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg16);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 x (Const16 [-1]))
            // cond:
            // result: (Neg16 x)
 
            // match: (Mul16 x (Const16 [-1]))
            // cond:
            // result: (Neg16 x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpNeg16);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul16 <t> n (Const16 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh16x64);
                v.Type = t;
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul16 <t> (Const16 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul16 <t> (Const16 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh16x64);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul16 <t> n (Const16 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg16 (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul16 <t> n (Const16 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg16 (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg16);
                v0 = b.NewValue0(v.Pos, OpLsh16x64, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul16 <t> (Const16 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg16 (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul16 <t> (Const16 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg16 (Lsh16x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg16);
                v0 = b.NewValue0(v.Pos, OpLsh16x64, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mul16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul16 _ (Const16 [0]))
            // cond:
            // result: (Const16 [0])
 
            // match: (Mul16 _ (Const16 [0]))
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul16 (Const16 <t> [c]) (Mul16 (Const16 <t> [d]) x))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
 
            // match: (Mul16 (Const16 <t> [c]) (Mul16 (Const16 <t> [d]) x))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpMul16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 (Const16 <t> [c]) (Mul16 x (Const16 <t> [d])))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
 
            // match: (Mul16 (Const16 <t> [c]) (Mul16 x (Const16 <t> [d])))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpMul16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 (Mul16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
 
            // match: (Mul16 (Mul16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul16 (Mul16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
 
            // match: (Mul16 (Mul16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Mul16 (Const16 <t> [int64(int16(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mul32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c * d));
                return true;
            } 
            // match: (Mul32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c*d))])
 
            // match: (Mul32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c * d));
                return true;
            } 
            // match: (Mul32 (Const32 [1]) x)
            // cond:
            // result: x
 
            // match: (Mul32 (Const32 [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 x (Const32 [1]))
            // cond:
            // result: x
 
            // match: (Mul32 x (Const32 [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 (Const32 [-1]) x)
            // cond:
            // result: (Neg32 x)
 
            // match: (Mul32 (Const32 [-1]) x)
            // cond:
            // result: (Neg32 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg32);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 x (Const32 [-1]))
            // cond:
            // result: (Neg32 x)
 
            // match: (Mul32 x (Const32 [-1]))
            // cond:
            // result: (Neg32 x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpNeg32);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul32 <t> n (Const32 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh32x64);
                v.Type = t;
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul32 <t> (Const32 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul32 <t> (Const32 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh32x64);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul32 <t> n (Const32 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg32 (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul32 <t> n (Const32 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg32 (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg32);
                v0 = b.NewValue0(v.Pos, OpLsh32x64, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul32 <t> (Const32 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg32 (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul32 <t> (Const32 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg32 (Lsh32x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg32);
                v0 = b.NewValue0(v.Pos, OpLsh32x64, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mul32 (Const32 <t> [c]) (Add32 <t> (Const32 <t> [d]) x))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpAdd32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpMul32, t);
                var v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul32 (Const32 <t> [c]) (Add32 <t> x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
 
            // match: (Mul32 (Const32 <t> [c]) (Add32 <t> x (Const32 <t> [d])))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul32, t);
                v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul32 (Add32 <t> (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
 
            // match: (Mul32 (Add32 <t> (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                t = v_0.Type;
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0_0.Type != t)
                {
                    break;
                }
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul32, t);
                v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul32 (Add32 <t> x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
 
            // match: (Mul32 (Add32 <t> x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c*d))]) (Mul32 <t> (Const32 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                t = v_0.Type;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                if (v_0_1.Type != t)
                {
                    break;
                }
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul32, t);
                v2 = b.NewValue0(v.Pos, OpConst32, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Mul32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul32 _ (Const32 [0]))
            // cond:
            // result: (Const32 [0])
 
            // match: (Mul32 _ (Const32 [0]))
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul32 (Const32 <t> [c]) (Mul32 (Const32 <t> [d]) x))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
 
            // match: (Mul32 (Const32 <t> [c]) (Mul32 (Const32 <t> [d]) x))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpMul32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 (Const32 <t> [c]) (Mul32 x (Const32 <t> [d])))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
 
            // match: (Mul32 (Const32 <t> [c]) (Mul32 x (Const32 <t> [d])))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpMul32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 (Mul32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
 
            // match: (Mul32 (Mul32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32 (Mul32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
 
            // match: (Mul32 (Mul32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Mul32 (Const32 <t> [int64(int32(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul32F_0(ref Value v)
        { 
            // match: (Mul32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) * i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) * i2f32(d)));
                return true;
            } 
            // match: (Mul32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) * i2f32(d)))])
 
            // match: (Mul32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) * i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) * i2f32(d)));
                return true;
            } 
            // match: (Mul32F x (Const32F [f2i(1)]))
            // cond:
            // result: x
 
            // match: (Mul32F x (Const32F [f2i(1)]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(1L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32F (Const32F [f2i(1)]) x)
            // cond:
            // result: x
 
            // match: (Mul32F (Const32F [f2i(1)]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(1L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32F x (Const32F [f2i(-1)]))
            // cond:
            // result: (Neg32F x)
 
            // match: (Mul32F x (Const32F [f2i(-1)]))
            // cond:
            // result: (Neg32F x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(-1L))
                {
                    break;
                }
                v.reset(OpNeg32F);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32F (Const32F [f2i(-1)]) x)
            // cond:
            // result: (Neg32F x)
 
            // match: (Mul32F (Const32F [f2i(-1)]) x)
            // cond:
            // result: (Neg32F x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(-1L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg32F);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32F x (Const32F [f2i(2)]))
            // cond:
            // result: (Add32F x x)
 
            // match: (Mul32F x (Const32F [f2i(2)]))
            // cond:
            // result: (Add32F x x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(2L))
                {
                    break;
                }
                v.reset(OpAdd32F);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul32F (Const32F [f2i(2)]) x)
            // cond:
            // result: (Add32F x x)
 
            // match: (Mul32F (Const32F [f2i(2)]) x)
            // cond:
            // result: (Add32F x x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(2L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpAdd32F);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mul64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c*d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c * d;
                return true;
            } 
            // match: (Mul64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c*d])
 
            // match: (Mul64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c*d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c * d;
                return true;
            } 
            // match: (Mul64 (Const64 [1]) x)
            // cond:
            // result: x
 
            // match: (Mul64 (Const64 [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 x (Const64 [1]))
            // cond:
            // result: x
 
            // match: (Mul64 x (Const64 [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 (Const64 [-1]) x)
            // cond:
            // result: (Neg64 x)
 
            // match: (Mul64 (Const64 [-1]) x)
            // cond:
            // result: (Neg64 x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg64);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 x (Const64 [-1]))
            // cond:
            // result: (Neg64 x)
 
            // match: (Mul64 x (Const64 [-1]))
            // cond:
            // result: (Neg64 x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpNeg64);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul64 <t> n (Const64 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v.Type = t;
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul64 <t> (Const64 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul64 <t> (Const64 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh64x64);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul64 <t> n (Const64 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg64 (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul64 <t> n (Const64 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg64 (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg64);
                v0 = b.NewValue0(v.Pos, OpLsh64x64, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul64 <t> (Const64 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg64 (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul64 <t> (Const64 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg64 (Lsh64x64 <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg64);
                v0 = b.NewValue0(v.Pos, OpLsh64x64, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mul64 (Const64 <t> [c]) (Add64 <t> (Const64 <t> [d]) x))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpAdd64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpMul64, t);
                var v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul64 (Const64 <t> [c]) (Add64 <t> x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
 
            // match: (Mul64 (Const64 <t> [c]) (Add64 <t> x (Const64 <t> [d])))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul64, t);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul64 (Add64 <t> (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
 
            // match: (Mul64 (Add64 <t> (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                t = v_0.Type;
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0_0.Type != t)
                {
                    break;
                }
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul64, t);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul64 (Add64 <t> x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
 
            // match: (Mul64 (Add64 <t> x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Add64 (Const64 <t> [c*d]) (Mul64 <t> (Const64 <t> [c]) x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                t = v_0.Type;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.Type != t)
                {
                    break;
                }
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpMul64, t);
                v2 = b.NewValue0(v.Pos, OpConst64, t);
                v2.AuxInt = c;
                v1.AddArg(v2);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            } 
            // match: (Mul64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Mul64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul64 _ (Const64 [0]))
            // cond:
            // result: (Const64 [0])
 
            // match: (Mul64 _ (Const64 [0]))
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul64 (Const64 <t> [c]) (Mul64 (Const64 <t> [d]) x))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
 
            // match: (Mul64 (Const64 <t> [c]) (Mul64 (Const64 <t> [d]) x))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpMul64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 (Const64 <t> [c]) (Mul64 x (Const64 <t> [d])))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
 
            // match: (Mul64 (Const64 <t> [c]) (Mul64 x (Const64 <t> [d])))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpMul64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 (Mul64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
 
            // match: (Mul64 (Mul64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64 (Mul64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
 
            // match: (Mul64 (Mul64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Mul64 (Const64 <t> [c*d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c * d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul64F_0(ref Value v)
        { 
            // match: (Mul64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (Const64F [f2i(i2f(c) * i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) * i2f(d));
                return true;
            } 
            // match: (Mul64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (Const64F [f2i(i2f(c) * i2f(d))])
 
            // match: (Mul64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (Const64F [f2i(i2f(c) * i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) * i2f(d));
                return true;
            } 
            // match: (Mul64F x (Const64F [f2i(1)]))
            // cond:
            // result: x
 
            // match: (Mul64F x (Const64F [f2i(1)]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(1L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64F (Const64F [f2i(1)]) x)
            // cond:
            // result: x
 
            // match: (Mul64F (Const64F [f2i(1)]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(1L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64F x (Const64F [f2i(-1)]))
            // cond:
            // result: (Neg64F x)
 
            // match: (Mul64F x (Const64F [f2i(-1)]))
            // cond:
            // result: (Neg64F x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(-1L))
                {
                    break;
                }
                v.reset(OpNeg64F);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64F (Const64F [f2i(-1)]) x)
            // cond:
            // result: (Neg64F x)
 
            // match: (Mul64F (Const64F [f2i(-1)]) x)
            // cond:
            // result: (Neg64F x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(-1L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg64F);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64F x (Const64F [f2i(2)]))
            // cond:
            // result: (Add64F x x)
 
            // match: (Mul64F x (Const64F [f2i(2)]))
            // cond:
            // result: (Add64F x x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                if (v_1.AuxInt != f2i(2L))
                {
                    break;
                }
                v.reset(OpAdd64F);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul64F (Const64F [f2i(2)]) x)
            // cond:
            // result: (Add64F x x)
 
            // match: (Mul64F (Const64F [f2i(2)]) x)
            // cond:
            // result: (Add64F x x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                if (v_0.AuxInt != f2i(2L))
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpAdd64F);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mul8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8  [int64(int8(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c * d));
                return true;
            } 
            // match: (Mul8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c*d))])
 
            // match: (Mul8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c * d));
                return true;
            } 
            // match: (Mul8 (Const8 [1]) x)
            // cond:
            // result: x
 
            // match: (Mul8 (Const8 [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 x (Const8 [1]))
            // cond:
            // result: x
 
            // match: (Mul8 x (Const8 [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 (Const8 [-1]) x)
            // cond:
            // result: (Neg8  x)
 
            // match: (Mul8 (Const8 [-1]) x)
            // cond:
            // result: (Neg8  x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNeg8);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 x (Const8 [-1]))
            // cond:
            // result: (Neg8  x)
 
            // match: (Mul8 x (Const8 [-1]))
            // cond:
            // result: (Neg8  x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpNeg8);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul8 <t> n (Const8 [c]))
            // cond: isPowerOfTwo(c)
            // result: (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh8x64);
                v.Type = t;
                v.AddArg(n);
                var v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul8 <t> (Const8 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(c)]))
 
            // match: (Mul8 <t> (Const8 [c]) n)
            // cond: isPowerOfTwo(c)
            // result: (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(c)]))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpLsh8x64);
                v.Type = t;
                v.AddArg(n);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = log2(c);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul8 <t> n (Const8 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg8  (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul8 <t> n (Const8 [c]))
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg8  (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                n = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg8);
                v0 = b.NewValue0(v.Pos, OpLsh8x64, t);
                v0.AddArg(n);
                var v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Mul8 <t> (Const8 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg8  (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(-c)])))
 
            // match: (Mul8 <t> (Const8 [c]) n)
            // cond: t.IsSigned() && isPowerOfTwo(-c)
            // result: (Neg8  (Lsh8x64  <t> n (Const64 <typ.UInt64> [log2(-c)])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0.AuxInt;
                n = v.Args[1L];
                if (!(t.IsSigned() && isPowerOfTwo(-c)))
                {
                    break;
                }
                v.reset(OpNeg8);
                v0 = b.NewValue0(v.Pos, OpLsh8x64, t);
                v0.AddArg(n);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v1.AuxInt = log2(-c);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpMul8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Mul8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul8 _ (Const8 [0]))
            // cond:
            // result: (Const8  [0])
 
            // match: (Mul8 _ (Const8 [0]))
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Mul8 (Const8 <t> [c]) (Mul8 (Const8 <t> [d]) x))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
 
            // match: (Mul8 (Const8 <t> [c]) (Mul8 (Const8 <t> [d]) x))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                var x = v_1.Args[1L];
                v.reset(OpMul8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 (Const8 <t> [c]) (Mul8 x (Const8 <t> [d])))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
 
            // match: (Mul8 (Const8 <t> [c]) (Mul8 x (Const8 <t> [d])))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpMul8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 (Mul8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
 
            // match: (Mul8 (Mul8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Mul8 (Mul8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
 
            // match: (Mul8 (Mul8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Mul8  (Const8  <t> [int64(int8(c*d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpMul8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c * d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg16_0(ref Value v)
        { 
            // match: (Neg16 (Const16 [c]))
            // cond:
            // result: (Const16  [int64(-int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(-int16(c));
                return true;
            } 
            // match: (Neg16 (Sub16 x y))
            // cond:
            // result: (Sub16 y x)
 
            // match: (Neg16 (Sub16 x y))
            // cond:
            // result: (Sub16 y x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpSub16);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg32_0(ref Value v)
        { 
            // match: (Neg32 (Const32 [c]))
            // cond:
            // result: (Const32  [int64(-int32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(-int32(c));
                return true;
            } 
            // match: (Neg32 (Sub32 x y))
            // cond:
            // result: (Sub32 y x)
 
            // match: (Neg32 (Sub32 x y))
            // cond:
            // result: (Sub32 y x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpSub32);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg32F_0(ref Value v)
        { 
            // match: (Neg32F (Const32F [c]))
            // cond: i2f(c) != 0
            // result: (Const32F [f2i(-i2f(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                if (!(i2f(c) != 0L))
                {
                    break;
                }
                v.reset(OpConst32F);
                v.AuxInt = f2i(-i2f(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg64_0(ref Value v)
        { 
            // match: (Neg64 (Const64 [c]))
            // cond:
            // result: (Const64  [-c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = -c;
                return true;
            } 
            // match: (Neg64 (Sub64 x y))
            // cond:
            // result: (Sub64 y x)
 
            // match: (Neg64 (Sub64 x y))
            // cond:
            // result: (Sub64 y x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpSub64);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg64F_0(ref Value v)
        { 
            // match: (Neg64F (Const64F [c]))
            // cond: i2f(c) != 0
            // result: (Const64F [f2i(-i2f(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                if (!(i2f(c) != 0L))
                {
                    break;
                }
                v.reset(OpConst64F);
                v.AuxInt = f2i(-i2f(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeg8_0(ref Value v)
        { 
            // match: (Neg8 (Const8 [c]))
            // cond:
            // result: (Const8   [int64( -int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(-int8(c));
                return true;
            } 
            // match: (Neg8 (Sub8 x y))
            // cond:
            // result: (Sub8  y x)
 
            // match: (Neg8 (Sub8 x y))
            // cond:
            // result: (Sub8  y x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSub8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpSub8);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq16 x x)
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Neq16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Neq16 (Const16 <t> [c]) (Add16 (Const16 <t> [d]) x))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpNeq16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Neq16 (Const16 <t> [c]) (Add16 x (Const16 <t> [d])))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpNeq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Neq16 (Add16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Neq16 (Add16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Neq16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (Neq16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32 x x)
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Neq32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Neq32 (Const32 <t> [c]) (Add32 (Const32 <t> [d]) x))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpNeq32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Neq32 (Const32 <t> [c]) (Add32 x (Const32 <t> [d])))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpNeq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Neq32 (Add32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Neq32 (Add32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Neq32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (Neq32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq32F_0(ref Value v)
        { 
            // match: (Neq32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) != i2f(d));
                return true;
            } 
            // match: (Neq32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
 
            // match: (Neq32F (Const32F [d]) (Const32F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) != i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64 x x)
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Neq64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
 
            // match: (Neq64 (Const64 <t> [c]) (Add64 (Const64 <t> [d]) x))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpNeq64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
 
            // match: (Neq64 (Const64 <t> [c]) (Add64 x (Const64 <t> [d])))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpNeq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
 
            // match: (Neq64 (Add64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
 
            // match: (Neq64 (Add64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Neq64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (Neq64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq64F_0(ref Value v)
        { 
            // match: (Neq64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) != i2f(d));
                return true;
            } 
            // match: (Neq64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
 
            // match: (Neq64F (Const64F [d]) (Const64F [c]))
            // cond:
            // result: (ConstBool [b2i(i2f(c) != i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(i2f(c) != i2f(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq8 x x)
            // cond:
            // result: (ConstBool [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConstBool);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Neq8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Neq8 (Const8 <t> [c]) (Add8 (Const8 <t> [d]) x))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpNeq8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Neq8 (Const8 <t> [c]) (Add8 x (Const8 <t> [d])))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAdd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpNeq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Neq8 (Add8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
 
            // match: (Neq8 (Add8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Neq8 (Const8 <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpNeq8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Neq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (Neq8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (Neq8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeqB_0(ref Value v)
        { 
            // match: (NeqB (ConstBool [c]) (ConstBool [d]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (NeqB (ConstBool [d]) (ConstBool [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
 
            // match: (NeqB (ConstBool [d]) (ConstBool [c]))
            // cond:
            // result: (ConstBool [b2i(c != d)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConstBool);
                v.AuxInt = b2i(c != d);
                return true;
            } 
            // match: (NeqB (ConstBool [0]) x)
            // cond:
            // result: x
 
            // match: (NeqB (ConstBool [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (NeqB x (ConstBool [0]))
            // cond:
            // result: x
 
            // match: (NeqB x (ConstBool [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (NeqB (ConstBool [1]) x)
            // cond:
            // result: (Not x)
 
            // match: (NeqB (ConstBool [1]) x)
            // cond:
            // result: (Not x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConstBool)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpNot);
                v.AddArg(x);
                return true;
            } 
            // match: (NeqB x (ConstBool [1]))
            // cond:
            // result: (Not x)
 
            // match: (NeqB x (ConstBool [1]))
            // cond:
            // result: (Not x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConstBool)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpNot);
                v.AddArg(x);
                return true;
            } 
            // match: (NeqB (Not x) (Not y))
            // cond:
            // result: (NeqB x y)
 
            // match: (NeqB (Not x) (Not y))
            // cond:
            // result: (NeqB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpNot)
                {
                    break;
                }
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpNot)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpNeqB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (NeqB (Not y) (Not x))
            // cond:
            // result: (NeqB x y)
 
            // match: (NeqB (Not y) (Not x))
            // cond:
            // result: (NeqB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpNot)
                {
                    break;
                }
                y = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpNot)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpNeqB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeqInter_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (NeqInter x y)
            // cond:
            // result: (NeqPtr (ITab x) (ITab y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpNeqPtr);
                var v0 = b.NewValue0(v.Pos, OpITab, typ.BytePtr);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpITab, typ.BytePtr);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuegeneric_OpNeqPtr_0(ref Value v)
        { 
            // match: (NeqPtr p (ConstNil))
            // cond:
            // result: (IsNonNil p)
            while (true)
            {
                _ = v.Args[1L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConstNil)
                {
                    break;
                }
                v.reset(OpIsNonNil);
                v.AddArg(p);
                return true;
            } 
            // match: (NeqPtr (ConstNil) p)
            // cond:
            // result: (IsNonNil p)
 
            // match: (NeqPtr (ConstNil) p)
            // cond:
            // result: (IsNonNil p)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConstNil)
                {
                    break;
                }
                p = v.Args[1L];
                v.reset(OpIsNonNil);
                v.AddArg(p);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNeqSlice_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (NeqSlice x y)
            // cond:
            // result: (NeqPtr (SlicePtr x) (SlicePtr y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpNeqPtr);
                var v0 = b.NewValue0(v.Pos, OpSlicePtr, typ.BytePtr);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSlicePtr, typ.BytePtr);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuegeneric_OpNilCheck_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (NilCheck (GetG mem) mem)
            // cond:
            // result: mem
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpGetG)
                {
                    break;
                }
                var mem = v_0.Args[0L];
                if (mem != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (NilCheck (Load (OffPtr [c] (SP)) (StaticCall {sym} _)) _)
            // cond: isSameSym(sym, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize     && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1, v, "removed nil check")
            // result: (Invalid)
 
            // match: (NilCheck (Load (OffPtr [c] (SP)) (StaticCall {sym} _)) _)
            // cond: isSameSym(sym, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize     && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1, v, "removed nil check")
            // result: (Invalid)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpOffPtr)
                {
                    break;
                }
                var c = v_0_0.AuxInt;
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpSP)
                {
                    break;
                }
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpStaticCall)
                {
                    break;
                }
                var sym = v_0_1.Aux;
                if (!(isSameSym(sym, "runtime.newobject") && c == config.ctxt.FixedFrameSize() + config.RegSize && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1L, v, "removed nil check")))
                {
                    break;
                }
                v.reset(OpInvalid);
                return true;
            } 
            // match: (NilCheck (OffPtr (Load (OffPtr [c] (SP)) (StaticCall {sym} _))) _)
            // cond: isSameSym(sym, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize     && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1, v, "removed nil check")
            // result: (Invalid)
 
            // match: (NilCheck (OffPtr (Load (OffPtr [c] (SP)) (StaticCall {sym} _))) _)
            // cond: isSameSym(sym, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize     && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1, v, "removed nil check")
            // result: (Invalid)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpOffPtr)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpSP)
                {
                    break;
                }
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpStaticCall)
                {
                    break;
                }
                sym = v_0_0_1.Aux;
                if (!(isSameSym(sym, "runtime.newobject") && c == config.ctxt.FixedFrameSize() + config.RegSize && warnRule(fe.Debug_checknil() && v.Pos.Line() > 1L, v, "removed nil check")))
                {
                    break;
                }
                v.reset(OpInvalid);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNot_0(ref Value v)
        { 
            // match: (Not (Eq64 x y))
            // cond:
            // result: (Neq64 x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpEq64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpNeq64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Eq32 x y))
            // cond:
            // result: (Neq32 x y)
 
            // match: (Not (Eq32 x y))
            // cond:
            // result: (Neq32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpEq32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpNeq32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Eq16 x y))
            // cond:
            // result: (Neq16 x y)
 
            // match: (Not (Eq16 x y))
            // cond:
            // result: (Neq16 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpEq16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpNeq16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Eq8 x y))
            // cond:
            // result: (Neq8  x y)
 
            // match: (Not (Eq8 x y))
            // cond:
            // result: (Neq8  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpEq8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpNeq8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (EqB x y))
            // cond:
            // result: (NeqB  x y)
 
            // match: (Not (EqB x y))
            // cond:
            // result: (NeqB  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpEqB)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpNeqB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Neq64 x y))
            // cond:
            // result: (Eq64 x y)
 
            // match: (Not (Neq64 x y))
            // cond:
            // result: (Eq64 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpNeq64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpEq64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Neq32 x y))
            // cond:
            // result: (Eq32 x y)
 
            // match: (Not (Neq32 x y))
            // cond:
            // result: (Eq32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpNeq32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpEq32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Neq16 x y))
            // cond:
            // result: (Eq16 x y)
 
            // match: (Not (Neq16 x y))
            // cond:
            // result: (Eq16 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpNeq16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpEq16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Neq8 x y))
            // cond:
            // result: (Eq8  x y)
 
            // match: (Not (Neq8 x y))
            // cond:
            // result: (Eq8  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpNeq8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpEq8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (NeqB x y))
            // cond:
            // result: (EqB  x y)
 
            // match: (Not (NeqB x y))
            // cond:
            // result: (EqB  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpNeqB)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpEqB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNot_10(ref Value v)
        { 
            // match: (Not (Greater64 x y))
            // cond:
            // result: (Leq64 x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpGreater64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpLeq64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater32 x y))
            // cond:
            // result: (Leq32 x y)
 
            // match: (Not (Greater32 x y))
            // cond:
            // result: (Leq32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater16 x y))
            // cond:
            // result: (Leq16 x y)
 
            // match: (Not (Greater16 x y))
            // cond:
            // result: (Leq16 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater8 x y))
            // cond:
            // result: (Leq8  x y)
 
            // match: (Not (Greater8 x y))
            // cond:
            // result: (Leq8  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater64U x y))
            // cond:
            // result: (Leq64U x y)
 
            // match: (Not (Greater64U x y))
            // cond:
            // result: (Leq64U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater64U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq64U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater32U x y))
            // cond:
            // result: (Leq32U x y)
 
            // match: (Not (Greater32U x y))
            // cond:
            // result: (Leq32U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater32U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq32U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater16U x y))
            // cond:
            // result: (Leq16U x y)
 
            // match: (Not (Greater16U x y))
            // cond:
            // result: (Leq16U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater16U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq16U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Greater8U x y))
            // cond:
            // result: (Leq8U  x y)
 
            // match: (Not (Greater8U x y))
            // cond:
            // result: (Leq8U  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGreater8U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLeq8U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq64 x y))
            // cond:
            // result: (Less64 x y)
 
            // match: (Not (Geq64 x y))
            // cond:
            // result: (Less64 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq32 x y))
            // cond:
            // result: (Less32 x y)
 
            // match: (Not (Geq32 x y))
            // cond:
            // result: (Less32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNot_20(ref Value v)
        { 
            // match: (Not (Geq16 x y))
            // cond:
            // result: (Less16 x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpGeq16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpLess16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq8 x y))
            // cond:
            // result: (Less8  x y)
 
            // match: (Not (Geq8 x y))
            // cond:
            // result: (Less8  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq64U x y))
            // cond:
            // result: (Less64U x y)
 
            // match: (Not (Geq64U x y))
            // cond:
            // result: (Less64U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq64U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess64U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq32U x y))
            // cond:
            // result: (Less32U x y)
 
            // match: (Not (Geq32U x y))
            // cond:
            // result: (Less32U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq32U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess32U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq16U x y))
            // cond:
            // result: (Less16U x y)
 
            // match: (Not (Geq16U x y))
            // cond:
            // result: (Less16U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq16U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess16U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Geq8U x y))
            // cond:
            // result: (Less8U  x y)
 
            // match: (Not (Geq8U x y))
            // cond:
            // result: (Less8U  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpGeq8U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpLess8U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less64 x y))
            // cond:
            // result: (Geq64 x y)
 
            // match: (Not (Less64 x y))
            // cond:
            // result: (Geq64 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less32 x y))
            // cond:
            // result: (Geq32 x y)
 
            // match: (Not (Less32 x y))
            // cond:
            // result: (Geq32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less16 x y))
            // cond:
            // result: (Geq16 x y)
 
            // match: (Not (Less16 x y))
            // cond:
            // result: (Geq16 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less8 x y))
            // cond:
            // result: (Geq8  x y)
 
            // match: (Not (Less8 x y))
            // cond:
            // result: (Geq8  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNot_30(ref Value v)
        { 
            // match: (Not (Less64U x y))
            // cond:
            // result: (Geq64U x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLess64U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpGeq64U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less32U x y))
            // cond:
            // result: (Geq32U x y)
 
            // match: (Not (Less32U x y))
            // cond:
            // result: (Geq32U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess32U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq32U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less16U x y))
            // cond:
            // result: (Geq16U x y)
 
            // match: (Not (Less16U x y))
            // cond:
            // result: (Geq16U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess16U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq16U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Less8U x y))
            // cond:
            // result: (Geq8U  x y)
 
            // match: (Not (Less8U x y))
            // cond:
            // result: (Geq8U  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLess8U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGeq8U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq64 x y))
            // cond:
            // result: (Greater64 x y)
 
            // match: (Not (Leq64 x y))
            // cond:
            // result: (Greater64 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq32 x y))
            // cond:
            // result: (Greater32 x y)
 
            // match: (Not (Leq32 x y))
            // cond:
            // result: (Greater32 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq16 x y))
            // cond:
            // result: (Greater16 x y)
 
            // match: (Not (Leq16 x y))
            // cond:
            // result: (Greater16 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq8 x y))
            // cond:
            // result: (Greater8 x y)
 
            // match: (Not (Leq8 x y))
            // cond:
            // result: (Greater8 x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq64U x y))
            // cond:
            // result: (Greater64U x y)
 
            // match: (Not (Leq64U x y))
            // cond:
            // result: (Greater64U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq64U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater64U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq32U x y))
            // cond:
            // result: (Greater32U x y)
 
            // match: (Not (Leq32U x y))
            // cond:
            // result: (Greater32U x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq32U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater32U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpNot_40(ref Value v)
        { 
            // match: (Not (Leq16U x y))
            // cond:
            // result: (Greater16U x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLeq16U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpGreater16U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Not (Leq8U x y))
            // cond:
            // result: (Greater8U  x y)
 
            // match: (Not (Leq8U x y))
            // cond:
            // result: (Greater8U  x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpLeq8U)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpGreater8U);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOffPtr_0(ref Value v)
        { 
            // match: (OffPtr (OffPtr p [b]) [a])
            // cond:
            // result: (OffPtr p [a+b])
            while (true)
            {
                var a = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                var b = v_0.AuxInt;
                var p = v_0.Args[0L];
                v.reset(OpOffPtr);
                v.AuxInt = a + b;
                v.AddArg(p);
                return true;
            } 
            // match: (OffPtr p [0])
            // cond: v.Type.Compare(p.Type) == types.CMPeq
            // result: p
 
            // match: (OffPtr p [0])
            // cond: v.Type.Compare(p.Type) == types.CMPeq
            // result: p
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                p = v.Args[0L];
                if (!(v.Type.Compare(p.Type) == types.CMPeq))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = p.Type;
                v.AddArg(p);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr16_0(ref Value v)
        { 
            // match: (Or16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c | d));
                return true;
            } 
            // match: (Or16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c|d))])
 
            // match: (Or16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c | d));
                return true;
            } 
            // match: (Or16 x x)
            // cond:
            // result: x
 
            // match: (Or16 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Const16 [0]) x)
            // cond:
            // result: x
 
            // match: (Or16 (Const16 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 x (Const16 [0]))
            // cond:
            // result: x
 
            // match: (Or16 x (Const16 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Const16 [-1]) _)
            // cond:
            // result: (Const16 [-1])
 
            // match: (Or16 (Const16 [-1]) _)
            // cond:
            // result: (Const16 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or16 _ (Const16 [-1]))
            // cond:
            // result: (Const16 [-1])
 
            // match: (Or16 _ (Const16 [-1]))
            // cond:
            // result: (Const16 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or16 x (Or16 x y))
            // cond:
            // result: (Or16 x y)
 
            // match: (Or16 x (Or16 x y))
            // cond:
            // result: (Or16 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpOr16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or16 x (Or16 y x))
            // cond:
            // result: (Or16 x y)
 
            // match: (Or16 x (Or16 y x))
            // cond:
            // result: (Or16 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or16 (Or16 x y) x)
            // cond:
            // result: (Or16 x y)
 
            // match: (Or16 (Or16 x y) x)
            // cond:
            // result: (Or16 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or16 (Or16 y x) x)
            // cond:
            // result: (Or16 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or16 (And16 x (Const16 [c2])) (Const16 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
 
            // match: (Or16 (And16 x (Const16 [c2])) (Const16 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var t = v_1.Type;
                var c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (And16 (Const16 [c2]) x) (Const16 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
 
            // match: (Or16 (And16 (Const16 [c2]) x) (Const16 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                c2 = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                t = v_1.Type;
                c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Const16 <t> [c1]) (And16 x (Const16 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
 
            // match: (Or16 (Const16 <t> [c1]) (And16 x (Const16 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                c2 = v_1_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Const16 <t> [c1]) (And16 (Const16 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
 
            // match: (Or16 (Const16 <t> [c1]) (And16 (Const16 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or16 (Const16 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                c2 = v_1_0.AuxInt;
                x = v_1.Args[1L];
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Or16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
 
            // match: (Or16 (Or16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or16 (Or16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
 
            // match: (Or16 (Or16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or16 x (Or16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
 
            // match: (Or16 x (Or16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or16 x (Or16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
 
            // match: (Or16 x (Or16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Or16 i (Or16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpOr16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or16 (Const16 <t> [c]) (Or16 (Const16 <t> [d]) x))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
 
            // match: (Or16 (Const16 <t> [c]) (Or16 (Const16 <t> [d]) x))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr16_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or16 (Const16 <t> [c]) (Or16 x (Const16 <t> [d])))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpOr16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpOr16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Or16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
 
            // match: (Or16 (Or16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or16 (Or16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
 
            // match: (Or16 (Or16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Or16 (Const16 <t> [int64(int16(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr32_0(ref Value v)
        { 
            // match: (Or32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c | d));
                return true;
            } 
            // match: (Or32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c|d))])
 
            // match: (Or32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c | d));
                return true;
            } 
            // match: (Or32 x x)
            // cond:
            // result: x
 
            // match: (Or32 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Const32 [0]) x)
            // cond:
            // result: x
 
            // match: (Or32 (Const32 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 x (Const32 [0]))
            // cond:
            // result: x
 
            // match: (Or32 x (Const32 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Const32 [-1]) _)
            // cond:
            // result: (Const32 [-1])
 
            // match: (Or32 (Const32 [-1]) _)
            // cond:
            // result: (Const32 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or32 _ (Const32 [-1]))
            // cond:
            // result: (Const32 [-1])
 
            // match: (Or32 _ (Const32 [-1]))
            // cond:
            // result: (Const32 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or32 x (Or32 x y))
            // cond:
            // result: (Or32 x y)
 
            // match: (Or32 x (Or32 x y))
            // cond:
            // result: (Or32 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpOr32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or32 x (Or32 y x))
            // cond:
            // result: (Or32 x y)
 
            // match: (Or32 x (Or32 y x))
            // cond:
            // result: (Or32 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or32 (Or32 x y) x)
            // cond:
            // result: (Or32 x y)
 
            // match: (Or32 (Or32 x y) x)
            // cond:
            // result: (Or32 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or32 (Or32 y x) x)
            // cond:
            // result: (Or32 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or32 (And32 x (Const32 [c2])) (Const32 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
 
            // match: (Or32 (And32 x (Const32 [c2])) (Const32 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var t = v_1.Type;
                var c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (And32 (Const32 [c2]) x) (Const32 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
 
            // match: (Or32 (And32 (Const32 [c2]) x) (Const32 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                c2 = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                t = v_1.Type;
                c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Const32 <t> [c1]) (And32 x (Const32 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
 
            // match: (Or32 (Const32 <t> [c1]) (And32 x (Const32 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                c2 = v_1_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Const32 <t> [c1]) (And32 (Const32 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
 
            // match: (Or32 (Const32 <t> [c1]) (And32 (Const32 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or32 (Const32 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                c2 = v_1_0.AuxInt;
                x = v_1.Args[1L];
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Or32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
 
            // match: (Or32 (Or32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or32 (Or32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
 
            // match: (Or32 (Or32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or32 x (Or32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
 
            // match: (Or32 x (Or32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or32 x (Or32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
 
            // match: (Or32 x (Or32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Or32 i (Or32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpOr32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or32 (Const32 <t> [c]) (Or32 (Const32 <t> [d]) x))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
 
            // match: (Or32 (Const32 <t> [c]) (Or32 (Const32 <t> [d]) x))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr32_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or32 (Const32 <t> [c]) (Or32 x (Const32 <t> [d])))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpOr32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpOr32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Or32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
 
            // match: (Or32 (Or32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or32 (Or32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
 
            // match: (Or32 (Or32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Or32 (Const32 <t> [int64(int32(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr64_0(ref Value v)
        { 
            // match: (Or64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c|d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (Or64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c|d])
 
            // match: (Or64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c|d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (Or64 x x)
            // cond:
            // result: x
 
            // match: (Or64 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Const64 [0]) x)
            // cond:
            // result: x
 
            // match: (Or64 (Const64 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Or64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Const64 [-1]) _)
            // cond:
            // result: (Const64 [-1])
 
            // match: (Or64 (Const64 [-1]) _)
            // cond:
            // result: (Const64 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or64 _ (Const64 [-1]))
            // cond:
            // result: (Const64 [-1])
 
            // match: (Or64 _ (Const64 [-1]))
            // cond:
            // result: (Const64 [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or64 x (Or64 x y))
            // cond:
            // result: (Or64 x y)
 
            // match: (Or64 x (Or64 x y))
            // cond:
            // result: (Or64 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpOr64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or64 x (Or64 y x))
            // cond:
            // result: (Or64 x y)
 
            // match: (Or64 x (Or64 y x))
            // cond:
            // result: (Or64 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or64 (Or64 x y) x)
            // cond:
            // result: (Or64 x y)
 
            // match: (Or64 (Or64 x y) x)
            // cond:
            // result: (Or64 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or64 (Or64 y x) x)
            // cond:
            // result: (Or64 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or64 (And64 x (Const64 [c2])) (Const64 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
 
            // match: (Or64 (And64 x (Const64 [c2])) (Const64 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var t = v_1.Type;
                var c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (And64 (Const64 [c2]) x) (Const64 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
 
            // match: (Or64 (And64 (Const64 [c2]) x) (Const64 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                c2 = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                t = v_1.Type;
                c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Const64 <t> [c1]) (And64 x (Const64 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
 
            // match: (Or64 (Const64 <t> [c1]) (And64 x (Const64 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                c2 = v_1_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Const64 <t> [c1]) (And64 (Const64 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
 
            // match: (Or64 (Const64 <t> [c1]) (And64 (Const64 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or64 (Const64 <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                c2 = v_1_0.AuxInt;
                x = v_1.Args[1L];
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Or64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
 
            // match: (Or64 (Or64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or64 (Or64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
 
            // match: (Or64 (Or64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or64 x (Or64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
 
            // match: (Or64 x (Or64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or64 x (Or64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
 
            // match: (Or64 x (Or64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Or64 i (Or64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpOr64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or64 (Const64 <t> [c]) (Or64 (Const64 <t> [d]) x))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
 
            // match: (Or64 (Const64 <t> [c]) (Or64 (Const64 <t> [d]) x))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c | d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr64_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or64 (Const64 <t> [c]) (Or64 x (Const64 <t> [d])))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpOr64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpOr64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c | d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Or64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
 
            // match: (Or64 (Or64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c | d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or64 (Or64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
 
            // match: (Or64 (Or64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Or64 (Const64 <t> [c|d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c | d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr8_0(ref Value v)
        { 
            // match: (Or8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8  [int64(int8(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c | d));
                return true;
            } 
            // match: (Or8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c|d))])
 
            // match: (Or8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c|d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c | d));
                return true;
            } 
            // match: (Or8 x x)
            // cond:
            // result: x
 
            // match: (Or8 x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Const8 [0]) x)
            // cond:
            // result: x
 
            // match: (Or8 (Const8 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 x (Const8 [0]))
            // cond:
            // result: x
 
            // match: (Or8 x (Const8 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Const8 [-1]) _)
            // cond:
            // result: (Const8  [-1])
 
            // match: (Or8 (Const8 [-1]) _)
            // cond:
            // result: (Const8  [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or8 _ (Const8 [-1]))
            // cond:
            // result: (Const8  [-1])
 
            // match: (Or8 _ (Const8 [-1]))
            // cond:
            // result: (Const8  [-1])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Or8 x (Or8 x y))
            // cond:
            // result: (Or8  x y)
 
            // match: (Or8 x (Or8 x y))
            // cond:
            // result: (Or8  x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpOr8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or8 x (Or8 y x))
            // cond:
            // result: (Or8  x y)
 
            // match: (Or8 x (Or8 y x))
            // cond:
            // result: (Or8  x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or8 (Or8 x y) x)
            // cond:
            // result: (Or8  x y)
 
            // match: (Or8 (Or8 x y) x)
            // cond:
            // result: (Or8  x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or8 (Or8 y x) x)
            // cond:
            // result: (Or8  x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (Or8 (And8 x (Const8 [c2])) (Const8 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
 
            // match: (Or8 (And8 x (Const8 [c2])) (Const8 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var t = v_1.Type;
                var c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (And8 (Const8 [c2]) x) (Const8 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
 
            // match: (Or8 (And8 (Const8 [c2]) x) (Const8 <t> [c1]))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                c2 = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                t = v_1.Type;
                c1 = v_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Const8 <t> [c1]) (And8 x (Const8 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
 
            // match: (Or8 (Const8 <t> [c1]) (And8 x (Const8 [c2])))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                c2 = v_1_1.AuxInt;
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Const8 <t> [c1]) (And8 (Const8 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
 
            // match: (Or8 (Const8 <t> [c1]) (And8 (Const8 [c2]) x))
            // cond: ^(c1 | c2) == 0
            // result: (Or8  (Const8  <t> [c1]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c1 = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpAnd8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                c2 = v_1_0.AuxInt;
                x = v_1.Args[1L];
                if (!(~(c1 | c2) == 0L))
                {
                    break;
                }
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = c1;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Or8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
 
            // match: (Or8 (Or8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or8 (Or8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
 
            // match: (Or8 (Or8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                z = v_0.Args[0L];
                i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or8 x (Or8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
 
            // match: (Or8 x (Or8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or8 x (Or8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
 
            // match: (Or8 x (Or8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Or8  i (Or8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpOr8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpOr8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Or8 (Const8 <t> [c]) (Or8 (Const8 <t> [d]) x))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
 
            // match: (Or8 (Const8 <t> [c]) (Or8 (Const8 <t> [d]) x))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpOr8_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Or8 (Const8 <t> [c]) (Or8 x (Const8 <t> [d])))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var t = v_0.Type;
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpOr8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpOr8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Or8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
 
            // match: (Or8 (Or8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Or8 (Or8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
 
            // match: (Or8 (Or8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Or8  (Const8  <t> [int64(int8(c|d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOr8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpOr8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c | d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpPhi_0(ref Value v)
        { 
            // match: (Phi (Const8 [c]) (Const8 [c]))
            // cond:
            // result: (Const8  [c])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != c)
                {
                    break;
                }
                if (len(v.Args) != 2L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = c;
                return true;
            } 
            // match: (Phi (Const16 [c]) (Const16 [c]))
            // cond:
            // result: (Const16 [c])
 
            // match: (Phi (Const16 [c]) (Const16 [c]))
            // cond:
            // result: (Const16 [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != c)
                {
                    break;
                }
                if (len(v.Args) != 2L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = c;
                return true;
            } 
            // match: (Phi (Const32 [c]) (Const32 [c]))
            // cond:
            // result: (Const32 [c])
 
            // match: (Phi (Const32 [c]) (Const32 [c]))
            // cond:
            // result: (Const32 [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != c)
                {
                    break;
                }
                if (len(v.Args) != 2L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = c;
                return true;
            } 
            // match: (Phi (Const64 [c]) (Const64 [c]))
            // cond:
            // result: (Const64 [c])
 
            // match: (Phi (Const64 [c]) (Const64 [c]))
            // cond:
            // result: (Const64 [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != c)
                {
                    break;
                }
                if (len(v.Args) != 2L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpPtrIndex_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PtrIndex <t> ptr idx)
            // cond: config.PtrSize == 4
            // result: (AddPtr ptr (Mul32 <typ.Int> idx (Const32 <typ.Int> [t.ElemType().Size()])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAddPtr);
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpMul32, typ.Int);
                v0.AddArg(idx);
                var v1 = b.NewValue0(v.Pos, OpConst32, typ.Int);
                v1.AuxInt = t.ElemType().Size();
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (PtrIndex <t> ptr idx)
            // cond: config.PtrSize == 8
            // result: (AddPtr ptr (Mul64 <typ.Int> idx (Const64 <typ.Int> [t.ElemType().Size()])))
 
            // match: (PtrIndex <t> ptr idx)
            // cond: config.PtrSize == 8
            // result: (AddPtr ptr (Mul64 <typ.Int> idx (Const64 <typ.Int> [t.ElemType().Size()])))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                idx = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAddPtr);
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpMul64, typ.Int);
                v0.AddArg(idx);
                v1 = b.NewValue0(v.Pos, OpConst64, typ.Int);
                v1.AuxInt = t.ElemType().Size();
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRound32F_0(ref Value v)
        { 
            // match: (Round32F x:(Const32F))
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpConst32F)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRound64F_0(ref Value v)
        { 
            // match: (Round64F x:(Const64F))
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpConst64F)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh16Ux64 x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16Ux16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh16Ux64 x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16Ux32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux64 (Const16 [c]) (Const64 [d]))
            // cond:
            // result: (Const16 [int64(int16(uint16(c) >> uint64(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(uint16(c) >> (int)(uint64(d))));
                return true;
            } 
            // match: (Rsh16Ux64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh16Ux64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh16Ux64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16Ux64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh16Ux64 <t> (Rsh16Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh16Ux64 x (Const64 <t> [c+d]))
 
            // match: (Rsh16Ux64 <t> (Rsh16Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh16Ux64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh16Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux64 (Lsh16x64 (Rsh16Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh16Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Rsh16Ux64 (Lsh16x64 (Rsh16Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh16Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh16x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpRsh16Ux64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux64 (Lsh16x64 x (Const64 [8])) (Const64 [8]))
            // cond:
            // result: (ZeroExt8to16  (Trunc16to8  <typ.UInt8>  x))
 
            // match: (Rsh16Ux64 (Lsh16x64 x (Const64 [8])) (Const64 [8]))
            // cond:
            // result: (ZeroExt8to16  (Trunc16to8  <typ.UInt8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh16x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 8L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                v.reset(OpZeroExt8to16);
                v0 = b.NewValue0(v.Pos, OpTrunc16to8, typ.UInt8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh16Ux64 x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16Ux8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh16x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16x16 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh16x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16x32 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x64 (Const16 [c]) (Const64 [d]))
            // cond:
            // result: (Const16 [int64(int16(c) >> uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c) >> (int)(uint64(d)));
                return true;
            } 
            // match: (Rsh16x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh16x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh16x64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16x64 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh16x64 <t> (Rsh16x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh16x64 x (Const64 <t> [c+d]))
 
            // match: (Rsh16x64 <t> (Rsh16x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh16x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh16x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x64 (Lsh16x64 x (Const64 [8])) (Const64 [8]))
            // cond:
            // result: (SignExt8to16  (Trunc16to8  <typ.Int8>  x))
 
            // match: (Rsh16x64 (Lsh16x64 x (Const64 [8])) (Const64 [8]))
            // cond:
            // result: (SignExt8to16  (Trunc16to8  <typ.Int8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh16x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 8L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                v.reset(OpSignExt8to16);
                v0 = b.NewValue0(v.Pos, OpTrunc16to8, typ.Int8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh16x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh16x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
 
            // match: (Rsh16x8 (Const16 [0]) _)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh32Ux64 x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32Ux16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh32Ux64 x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32Ux32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux64 (Const32 [c]) (Const64 [d]))
            // cond:
            // result: (Const32 [int64(int32(uint32(c) >> uint64(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                return true;
            } 
            // match: (Rsh32Ux64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh32Ux64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32Ux64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh32Ux64 <t> (Rsh32Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh32Ux64 x (Const64 <t> [c+d]))
 
            // match: (Rsh32Ux64 <t> (Rsh32Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh32Ux64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 (Lsh32x64 (Rsh32Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh32Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Rsh32Ux64 (Lsh32x64 (Rsh32Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh32Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpRsh32Ux64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 (Lsh32x64 x (Const64 [24])) (Const64 [24]))
            // cond:
            // result: (ZeroExt8to32  (Trunc32to8  <typ.UInt8>  x))
 
            // match: (Rsh32Ux64 (Lsh32x64 x (Const64 [24])) (Const64 [24]))
            // cond:
            // result: (ZeroExt8to32  (Trunc32to8  <typ.UInt8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 24L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 24L)
                {
                    break;
                }
                v.reset(OpZeroExt8to32);
                v0 = b.NewValue0(v.Pos, OpTrunc32to8, typ.UInt8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 (Lsh32x64 x (Const64 [16])) (Const64 [16]))
            // cond:
            // result: (ZeroExt16to32 (Trunc32to16 <typ.UInt16> x))
 
            // match: (Rsh32Ux64 (Lsh32x64 x (Const64 [16])) (Const64 [16]))
            // cond:
            // result: (ZeroExt16to32 (Trunc32to16 <typ.UInt16> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 16L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 16L)
                {
                    break;
                }
                v.reset(OpZeroExt16to32);
                v0 = b.NewValue0(v.Pos, OpTrunc32to16, typ.UInt16);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh32Ux64 x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32Ux8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh32x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32x16 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh32x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32x32 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x64 (Const32 [c]) (Const64 [d]))
            // cond:
            // result: (Const32 [int64(int32(c) >> uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                return true;
            } 
            // match: (Rsh32x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh32x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32x64 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh32x64 <t> (Rsh32x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh32x64 x (Const64 <t> [c+d]))
 
            // match: (Rsh32x64 <t> (Rsh32x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh32x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 (Lsh32x64 x (Const64 [24])) (Const64 [24]))
            // cond:
            // result: (SignExt8to32  (Trunc32to8  <typ.Int8>  x))
 
            // match: (Rsh32x64 (Lsh32x64 x (Const64 [24])) (Const64 [24]))
            // cond:
            // result: (SignExt8to32  (Trunc32to8  <typ.Int8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 24L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 24L)
                {
                    break;
                }
                v.reset(OpSignExt8to32);
                v0 = b.NewValue0(v.Pos, OpTrunc32to8, typ.Int8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 (Lsh32x64 x (Const64 [16])) (Const64 [16]))
            // cond:
            // result: (SignExt16to32 (Trunc32to16 <typ.Int16> x))
 
            // match: (Rsh32x64 (Lsh32x64 x (Const64 [16])) (Const64 [16]))
            // cond:
            // result: (SignExt16to32 (Trunc32to16 <typ.Int16> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh32x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 16L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 16L)
                {
                    break;
                }
                v.reset(OpSignExt16to32);
                v0 = b.NewValue0(v.Pos, OpTrunc32to16, typ.Int16);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh32x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh32x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
 
            // match: (Rsh32x8 (Const32 [0]) _)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh64Ux64 x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64Ux16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh64Ux64 x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64Ux32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [int64(uint64(c) >> uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(uint64(c) >> (int)(uint64(d)));
                return true;
            } 
            // match: (Rsh64Ux64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh64Ux64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64Ux64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64Ux64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh64Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (Const64 [0])
 
            // match: (Rsh64Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 64L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh64Ux64 <t> (Rsh64Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh64Ux64 x (Const64 <t> [c+d]))
 
            // match: (Rsh64Ux64 <t> (Rsh64Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh64Ux64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 (Lsh64x64 (Rsh64Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh64Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Rsh64Ux64 (Lsh64x64 (Rsh64Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh64Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpRsh64Ux64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [56])) (Const64 [56]))
            // cond:
            // result: (ZeroExt8to64  (Trunc64to8  <typ.UInt8>  x))
 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [56])) (Const64 [56]))
            // cond:
            // result: (ZeroExt8to64  (Trunc64to8  <typ.UInt8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 56L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 56L)
                {
                    break;
                }
                v.reset(OpZeroExt8to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to8, typ.UInt8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [48])) (Const64 [48]))
            // cond:
            // result: (ZeroExt16to64 (Trunc64to16 <typ.UInt16> x))
 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [48])) (Const64 [48]))
            // cond:
            // result: (ZeroExt16to64 (Trunc64to16 <typ.UInt16> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 48L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 48L)
                {
                    break;
                }
                v.reset(OpZeroExt16to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to16, typ.UInt16);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [32])) (Const64 [32]))
            // cond:
            // result: (ZeroExt32to64 (Trunc64to32 <typ.UInt32> x))
 
            // match: (Rsh64Ux64 (Lsh64x64 x (Const64 [32])) (Const64 [32]))
            // cond:
            // result: (ZeroExt32to64 (Trunc64to32 <typ.UInt32> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 32L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                v.reset(OpZeroExt32to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh64Ux64 x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64Ux8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh64x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64x16 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh64x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64x32 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c >> uint64(d)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c >> (int)(uint64(d));
                return true;
            } 
            // match: (Rsh64x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh64x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64x64 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh64x64 <t> (Rsh64x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh64x64 x (Const64 <t> [c+d]))
 
            // match: (Rsh64x64 <t> (Rsh64x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh64x64 x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [56])) (Const64 [56]))
            // cond:
            // result: (SignExt8to64  (Trunc64to8  <typ.Int8>  x))
 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [56])) (Const64 [56]))
            // cond:
            // result: (SignExt8to64  (Trunc64to8  <typ.Int8>  x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 56L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 56L)
                {
                    break;
                }
                v.reset(OpSignExt8to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to8, typ.Int8);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [48])) (Const64 [48]))
            // cond:
            // result: (SignExt16to64 (Trunc64to16 <typ.Int16> x))
 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [48])) (Const64 [48]))
            // cond:
            // result: (SignExt16to64 (Trunc64to16 <typ.Int16> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 48L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 48L)
                {
                    break;
                }
                v.reset(OpSignExt16to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to16, typ.Int16);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [32])) (Const64 [32]))
            // cond:
            // result: (SignExt32to64 (Trunc64to32 <typ.Int32> x))
 
            // match: (Rsh64x64 (Lsh64x64 x (Const64 [32])) (Const64 [32]))
            // cond:
            // result: (SignExt32to64 (Trunc64to32 <typ.Int32> x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh64x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 32L)
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                v.reset(OpSignExt32to64);
                v0 = b.NewValue0(v.Pos, OpTrunc64to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh64x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh64x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
 
            // match: (Rsh64x8 (Const64 [0]) _)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh8Ux64 x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8Ux16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh8Ux64 x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8Ux32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux64 (Const8 [c]) (Const64 [d]))
            // cond:
            // result: (Const8  [int64(int8(uint8(c) >> uint64(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(uint8(c) >> (int)(uint64(d))));
                return true;
            } 
            // match: (Rsh8Ux64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh8Ux64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh8Ux64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8Ux64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8  [0])
 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh8Ux64 <t> (Rsh8Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh8Ux64  x (Const64 <t> [c+d]))
 
            // match: (Rsh8Ux64 <t> (Rsh8Ux64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh8Ux64  x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh8Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux64 (Lsh8x64 (Rsh8Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh8Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
 
            // match: (Rsh8Ux64 (Lsh8x64 (Rsh8Ux64 x (Const64 [c1])) (Const64 [c2])) (Const64 [c3]))
            // cond: uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1-c2, c3)
            // result: (Rsh8Ux64 x (Const64 <typ.UInt64> [c1-c2+c3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpLsh8x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpRsh8Ux64)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpConst64)
                {
                    break;
                }
                var c1 = v_0_0_1.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var c2 = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c3 = v_1.AuxInt;
                if (!(uint64(c1) >= uint64(c2) && uint64(c3) >= uint64(c2) && !uaddOvf(c1 - c2, c3)))
                {
                    break;
                }
                v.reset(OpRsh8Ux64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpConst64, typ.UInt64);
                v0.AuxInt = c1 - c2 + c3;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh8Ux64 x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8Ux64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8Ux8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x16 <t> x (Const16 [c]))
            // cond:
            // result: (Rsh8x64  x (Const64 <t> [int64(uint16(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint16(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8x16 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x32 <t> x (Const32 [c]))
            // cond:
            // result: (Rsh8x64  x (Const64 <t> [int64(uint32(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint32(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8x32 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x64 (Const8 [c]) (Const64 [d]))
            // cond:
            // result: (Const8  [int64(int8(c) >> uint64(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c) >> (int)(uint64(d)));
                return true;
            } 
            // match: (Rsh8x64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Rsh8x64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh8x64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8x64 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh8x64 <t> (Rsh8x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh8x64  x (Const64 <t> [c+d]))
 
            // match: (Rsh8x64 <t> (Rsh8x64 x (Const64 [c])) (Const64 [d]))
            // cond: !uaddOvf(c,d)
            // result: (Rsh8x64  x (Const64 <t> [c+d]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpRsh8x64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (!(!uaddOvf(c, d)))
                {
                    break;
                }
                v.reset(OpRsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpRsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x8 <t> x (Const8 [c]))
            // cond:
            // result: (Rsh8x64  x (Const64 <t> [int64(uint8(c))]))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpRsh8x64);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = int64(uint8(c));
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
 
            // match: (Rsh8x8 (Const8 [0]) _)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt16to32_0(ref Value v)
        { 
            // match: (SignExt16to32 (Const16 [c]))
            // cond:
            // result: (Const32 [int64( int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int16(c));
                return true;
            } 
            // match: (SignExt16to32 (Trunc32to16 x:(Rsh32x64 _ (Const64 [s]))))
            // cond: s >= 16
            // result: x
 
            // match: (SignExt16to32 (Trunc32to16 x:(Rsh32x64 _ (Const64 [s]))))
            // cond: s >= 16
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc32to16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh32x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 16L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt16to64_0(ref Value v)
        { 
            // match: (SignExt16to64 (Const16 [c]))
            // cond:
            // result: (Const64 [int64( int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(int16(c));
                return true;
            } 
            // match: (SignExt16to64 (Trunc64to16 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 48
            // result: x
 
            // match: (SignExt16to64 (Trunc64to16 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 48
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 48L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt32to64_0(ref Value v)
        { 
            // match: (SignExt32to64 (Const32 [c]))
            // cond:
            // result: (Const64 [int64( int32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(int32(c));
                return true;
            } 
            // match: (SignExt32to64 (Trunc64to32 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 32
            // result: x
 
            // match: (SignExt32to64 (Trunc64to32 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 32
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to32)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 32L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt8to16_0(ref Value v)
        { 
            // match: (SignExt8to16 (Const8 [c]))
            // cond:
            // result: (Const16 [int64(  int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (SignExt8to16 (Trunc16to8 x:(Rsh16x64 _ (Const64 [s]))))
            // cond: s >= 8
            // result: x
 
            // match: (SignExt8to16 (Trunc16to8 x:(Rsh16x64 _ (Const64 [s]))))
            // cond: s >= 8
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc16to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh16x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 8L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt8to32_0(ref Value v)
        { 
            // match: (SignExt8to32 (Const8 [c]))
            // cond:
            // result: (Const32 [int64(  int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (SignExt8to32 (Trunc32to8 x:(Rsh32x64 _ (Const64 [s]))))
            // cond: s >= 24
            // result: x
 
            // match: (SignExt8to32 (Trunc32to8 x:(Rsh32x64 _ (Const64 [s]))))
            // cond: s >= 24
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc32to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh32x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 24L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSignExt8to64_0(ref Value v)
        { 
            // match: (SignExt8to64 (Const8 [c]))
            // cond:
            // result: (Const64 [int64(  int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (SignExt8to64 (Trunc64to8 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 56
            // result: x
 
            // match: (SignExt8to64 (Trunc64to8 x:(Rsh64x64 _ (Const64 [s]))))
            // cond: s >= 56
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64x64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 56L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSliceCap_0(ref Value v)
        { 
            // match: (SliceCap (SliceMake _ _ (Const64 <t> [c])))
            // cond:
            // result: (Const64 <t> [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                var v_0_2 = v_0.Args[2L];
                if (v_0_2.Op != OpConst64)
                {
                    break;
                }
                var t = v_0_2.Type;
                var c = v_0_2.AuxInt;
                v.reset(OpConst64);
                v.Type = t;
                v.AuxInt = c;
                return true;
            } 
            // match: (SliceCap (SliceMake _ _ (Const32 <t> [c])))
            // cond:
            // result: (Const32 <t> [c])
 
            // match: (SliceCap (SliceMake _ _ (Const32 <t> [c])))
            // cond:
            // result: (Const32 <t> [c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                v_0_2 = v_0.Args[2L];
                if (v_0_2.Op != OpConst32)
                {
                    break;
                }
                t = v_0_2.Type;
                c = v_0_2.AuxInt;
                v.reset(OpConst32);
                v.Type = t;
                v.AuxInt = c;
                return true;
            } 
            // match: (SliceCap (SliceMake _ _ (SliceCap x)))
            // cond:
            // result: (SliceCap x)
 
            // match: (SliceCap (SliceMake _ _ (SliceCap x)))
            // cond:
            // result: (SliceCap x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                v_0_2 = v_0.Args[2L];
                if (v_0_2.Op != OpSliceCap)
                {
                    break;
                }
                var x = v_0_2.Args[0L];
                v.reset(OpSliceCap);
                v.AddArg(x);
                return true;
            } 
            // match: (SliceCap (SliceMake _ _ (SliceLen x)))
            // cond:
            // result: (SliceLen x)
 
            // match: (SliceCap (SliceMake _ _ (SliceLen x)))
            // cond:
            // result: (SliceLen x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                v_0_2 = v_0.Args[2L];
                if (v_0_2.Op != OpSliceLen)
                {
                    break;
                }
                x = v_0_2.Args[0L];
                v.reset(OpSliceLen);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSliceLen_0(ref Value v)
        { 
            // match: (SliceLen (SliceMake _ (Const64 <t> [c]) _))
            // cond:
            // result: (Const64 <t> [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var t = v_0_1.Type;
                var c = v_0_1.AuxInt;
                v.reset(OpConst64);
                v.Type = t;
                v.AuxInt = c;
                return true;
            } 
            // match: (SliceLen (SliceMake _ (Const32 <t> [c]) _))
            // cond:
            // result: (Const32 <t> [c])
 
            // match: (SliceLen (SliceMake _ (Const32 <t> [c]) _))
            // cond:
            // result: (Const32 <t> [c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                c = v_0_1.AuxInt;
                v.reset(OpConst32);
                v.Type = t;
                v.AuxInt = c;
                return true;
            } 
            // match: (SliceLen (SliceMake _ (SliceLen x) _))
            // cond:
            // result: (SliceLen x)
 
            // match: (SliceLen (SliceMake _ (SliceLen x) _))
            // cond:
            // result: (SliceLen x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpSliceLen)
                {
                    break;
                }
                var x = v_0_1.Args[0L];
                v.reset(OpSliceLen);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSlicePtr_0(ref Value v)
        { 
            // match: (SlicePtr (SliceMake (SlicePtr x) _ _))
            // cond:
            // result: (SlicePtr x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpSliceMake)
                {
                    break;
                }
                _ = v_0.Args[2L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpSlicePtr)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                v.reset(OpSlicePtr);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSlicemask_0(ref Value v)
        { 
            // match: (Slicemask (Const32 [x]))
            // cond: x > 0
            // result: (Const32 [-1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(x > 0L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Slicemask (Const32 [0]))
            // cond:
            // result: (Const32 [0])
 
            // match: (Slicemask (Const32 [0]))
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Slicemask (Const64 [x]))
            // cond: x > 0
            // result: (Const64 [-1])
 
            // match: (Slicemask (Const64 [x]))
            // cond: x > 0
            // result: (Const64 [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x > 0L))
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (Slicemask (Const64 [0]))
            // cond:
            // result: (Const64 [0])
 
            // match: (Slicemask (Const64 [0]))
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSqrt_0(ref Value v)
        { 
            // match: (Sqrt (Const64F [c]))
            // cond:
            // result: (Const64F [f2i(math.Sqrt(i2f(c)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(math.Sqrt(i2f(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStaticCall_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (StaticCall {sym} s1:(Store _ (Const64 [sz]) s2:(Store _ src s3:(Store {t} _ dst mem))))
            // cond: isSameSym(sym,"runtime.memmove") && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && isInlinableMemmoveSize(sz,config)
            // result: (Move {t.(*types.Type).Elem()} [sz] dst src mem)
            while (true)
            {
                var sym = v.Aux;
                var s1 = v.Args[0L];
                if (s1.Op != OpStore)
                {
                    break;
                }
                _ = s1.Args[2L];
                var s1_1 = s1.Args[1L];
                if (s1_1.Op != OpConst64)
                {
                    break;
                }
                var sz = s1_1.AuxInt;
                var s2 = s1.Args[2L];
                if (s2.Op != OpStore)
                {
                    break;
                }
                _ = s2.Args[2L];
                var src = s2.Args[1L];
                var s3 = s2.Args[2L];
                if (s3.Op != OpStore)
                {
                    break;
                }
                var t = s3.Aux;
                _ = s3.Args[2L];
                var dst = s3.Args[1L];
                var mem = s3.Args[2L];
                if (!(isSameSym(sym, "runtime.memmove") && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && isInlinableMemmoveSize(sz, config)))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = sz;
                v.Aux = t._<ref types.Type>().Elem();
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            } 
            // match: (StaticCall {sym} s1:(Store _ (Const32 [sz]) s2:(Store _ src s3:(Store {t} _ dst mem))))
            // cond: isSameSym(sym,"runtime.memmove") && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && isInlinableMemmoveSize(sz,config)
            // result: (Move {t.(*types.Type).Elem()} [sz] dst src mem)
 
            // match: (StaticCall {sym} s1:(Store _ (Const32 [sz]) s2:(Store _ src s3:(Store {t} _ dst mem))))
            // cond: isSameSym(sym,"runtime.memmove") && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && isInlinableMemmoveSize(sz,config)
            // result: (Move {t.(*types.Type).Elem()} [sz] dst src mem)
            while (true)
            {
                sym = v.Aux;
                s1 = v.Args[0L];
                if (s1.Op != OpStore)
                {
                    break;
                }
                _ = s1.Args[2L];
                s1_1 = s1.Args[1L];
                if (s1_1.Op != OpConst32)
                {
                    break;
                }
                sz = s1_1.AuxInt;
                s2 = s1.Args[2L];
                if (s2.Op != OpStore)
                {
                    break;
                }
                _ = s2.Args[2L];
                src = s2.Args[1L];
                s3 = s2.Args[2L];
                if (s3.Op != OpStore)
                {
                    break;
                }
                t = s3.Aux;
                _ = s3.Args[2L];
                dst = s3.Args[1L];
                mem = s3.Args[2L];
                if (!(isSameSym(sym, "runtime.memmove") && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && isInlinableMemmoveSize(sz, config)))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = sz;
                v.Aux = t._<ref types.Type>().Elem();
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStore_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (Store {t1} p1 (Load <t2> p2 mem) mem)
            // cond: isSamePtr(p1, p2) &&     t2.Size() == t1.(*types.Type).Size()
            // result: mem
            while (true)
            {
                var t1 = v.Aux;
                _ = v.Args[2L];
                var p1 = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                var t2 = v_1.Type;
                _ = v_1.Args[1L];
                var p2 = v_1.Args[0L];
                var mem = v_1.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(p1, p2) && t2.Size() == t1._<ref types.Type>().Size()))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ oldmem))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size())
            // result: mem
 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ oldmem))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size())
            // result: mem
            while (true)
            {
                t1 = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                var o1 = v_0.AuxInt;
                p1 = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                t2 = v_1.Type;
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpOffPtr)
                {
                    break;
                }
                if (v_1_0.AuxInt != o1)
                {
                    break;
                }
                p2 = v_1_0.Args[0L];
                var oldmem = v_1.Args[1L];
                mem = v.Args[2L];
                if (mem.Op != OpStore)
                {
                    break;
                }
                var t3 = mem.Aux;
                _ = mem.Args[2L];
                var mem_0 = mem.Args[0L];
                if (mem_0.Op != OpOffPtr)
                {
                    break;
                }
                var o3 = mem_0.AuxInt;
                var p3 = mem_0.Args[0L];
                if (oldmem != mem.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(p1, p2) && isSamePtr(p1, p3) && t2.Size() == t1._<ref types.Type>().Size() && !overlap(o1, t2.Size(), o3, t3._<ref types.Type>().Size())))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ (Store {t4} (OffPtr [o4] p4) _ oldmem)))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     isSamePtr(p1, p4) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o4, t4.(*types.Type).Size())
            // result: mem
 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ (Store {t4} (OffPtr [o4] p4) _ oldmem)))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     isSamePtr(p1, p4) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o4, t4.(*types.Type).Size())
            // result: mem
            while (true)
            {
                t1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                o1 = v_0.AuxInt;
                p1 = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                t2 = v_1.Type;
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpOffPtr)
                {
                    break;
                }
                if (v_1_0.AuxInt != o1)
                {
                    break;
                }
                p2 = v_1_0.Args[0L];
                oldmem = v_1.Args[1L];
                mem = v.Args[2L];
                if (mem.Op != OpStore)
                {
                    break;
                }
                t3 = mem.Aux;
                _ = mem.Args[2L];
                mem_0 = mem.Args[0L];
                if (mem_0.Op != OpOffPtr)
                {
                    break;
                }
                o3 = mem_0.AuxInt;
                p3 = mem_0.Args[0L];
                var mem_2 = mem.Args[2L];
                if (mem_2.Op != OpStore)
                {
                    break;
                }
                var t4 = mem_2.Aux;
                _ = mem_2.Args[2L];
                var mem_2_0 = mem_2.Args[0L];
                if (mem_2_0.Op != OpOffPtr)
                {
                    break;
                }
                var o4 = mem_2_0.AuxInt;
                var p4 = mem_2_0.Args[0L];
                if (oldmem != mem_2.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(p1, p2) && isSamePtr(p1, p3) && isSamePtr(p1, p4) && t2.Size() == t1._<ref types.Type>().Size() && !overlap(o1, t2.Size(), o3, t3._<ref types.Type>().Size()) && !overlap(o1, t2.Size(), o4, t4._<ref types.Type>().Size())))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ (Store {t4} (OffPtr [o4] p4) _ (Store {t5} (OffPtr [o5] p5) _ oldmem))))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     isSamePtr(p1, p4) &&     isSamePtr(p1, p5) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o4, t4.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o5, t5.(*types.Type).Size())
            // result: mem
 
            // match: (Store {t1} (OffPtr [o1] p1) (Load <t2> (OffPtr [o1] p2) oldmem) mem:(Store {t3} (OffPtr [o3] p3) _ (Store {t4} (OffPtr [o4] p4) _ (Store {t5} (OffPtr [o5] p5) _ oldmem))))
            // cond: isSamePtr(p1, p2) &&     isSamePtr(p1, p3) &&     isSamePtr(p1, p4) &&     isSamePtr(p1, p5) &&     t2.Size() == t1.(*types.Type).Size() &&     !overlap(o1, t2.Size(), o3, t3.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o4, t4.(*types.Type).Size()) &&     !overlap(o1, t2.Size(), o5, t5.(*types.Type).Size())
            // result: mem
            while (true)
            {
                t1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                o1 = v_0.AuxInt;
                p1 = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                t2 = v_1.Type;
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpOffPtr)
                {
                    break;
                }
                if (v_1_0.AuxInt != o1)
                {
                    break;
                }
                p2 = v_1_0.Args[0L];
                oldmem = v_1.Args[1L];
                mem = v.Args[2L];
                if (mem.Op != OpStore)
                {
                    break;
                }
                t3 = mem.Aux;
                _ = mem.Args[2L];
                mem_0 = mem.Args[0L];
                if (mem_0.Op != OpOffPtr)
                {
                    break;
                }
                o3 = mem_0.AuxInt;
                p3 = mem_0.Args[0L];
                mem_2 = mem.Args[2L];
                if (mem_2.Op != OpStore)
                {
                    break;
                }
                t4 = mem_2.Aux;
                _ = mem_2.Args[2L];
                mem_2_0 = mem_2.Args[0L];
                if (mem_2_0.Op != OpOffPtr)
                {
                    break;
                }
                o4 = mem_2_0.AuxInt;
                p4 = mem_2_0.Args[0L];
                var mem_2_2 = mem_2.Args[2L];
                if (mem_2_2.Op != OpStore)
                {
                    break;
                }
                var t5 = mem_2_2.Aux;
                _ = mem_2_2.Args[2L];
                var mem_2_2_0 = mem_2_2.Args[0L];
                if (mem_2_2_0.Op != OpOffPtr)
                {
                    break;
                }
                var o5 = mem_2_2_0.AuxInt;
                var p5 = mem_2_2_0.Args[0L];
                if (oldmem != mem_2_2.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(p1, p2) && isSamePtr(p1, p3) && isSamePtr(p1, p4) && isSamePtr(p1, p5) && t2.Size() == t1._<ref types.Type>().Size() && !overlap(o1, t2.Size(), o3, t3._<ref types.Type>().Size()) && !overlap(o1, t2.Size(), o4, t4._<ref types.Type>().Size()) && !overlap(o1, t2.Size(), o5, t5._<ref types.Type>().Size())))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store _ (StructMake0) mem)
            // cond:
            // result: mem
 
            // match: (Store _ (StructMake0) mem)
            // cond:
            // result: mem
            while (true)
            {
                _ = v.Args[2L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake0)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store dst (StructMake1 <t> f0) mem)
            // cond:
            // result: (Store {t.FieldType(0)} (OffPtr <t.FieldType(0).PtrTo()> [0] dst) f0 mem)
 
            // match: (Store dst (StructMake1 <t> f0) mem)
            // cond:
            // result: (Store {t.FieldType(0)} (OffPtr <t.FieldType(0).PtrTo()> [0] dst) f0 mem)
            while (true)
            {
                _ = v.Args[2L];
                var dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake1)
                {
                    break;
                }
                var t = v_1.Type;
                var f0 = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpStore);
                v.Aux = t.FieldType(0L);
                var v0 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v0.AuxInt = 0L;
                v0.AddArg(dst);
                v.AddArg(v0);
                v.AddArg(f0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store dst (StructMake2 <t> f0 f1) mem)
            // cond:
            // result: (Store {t.FieldType(1)}     (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)     f1     (Store {t.FieldType(0)}       (OffPtr <t.FieldType(0).PtrTo()> [0] dst)         f0 mem))
 
            // match: (Store dst (StructMake2 <t> f0 f1) mem)
            // cond:
            // result: (Store {t.FieldType(1)}     (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)     f1     (Store {t.FieldType(0)}       (OffPtr <t.FieldType(0).PtrTo()> [0] dst)         f0 mem))
            while (true)
            {
                _ = v.Args[2L];
                dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake2)
                {
                    break;
                }
                t = v_1.Type;
                _ = v_1.Args[1L];
                f0 = v_1.Args[0L];
                var f1 = v_1.Args[1L];
                mem = v.Args[2L];
                v.reset(OpStore);
                v.Aux = t.FieldType(1L);
                v0 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v0.AuxInt = t.FieldOff(1L);
                v0.AddArg(dst);
                v.AddArg(v0);
                v.AddArg(f1);
                var v1 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v1.Aux = t.FieldType(0L);
                var v2 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v2.AuxInt = 0L;
                v2.AddArg(dst);
                v1.AddArg(v2);
                v1.AddArg(f0);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Store dst (StructMake3 <t> f0 f1 f2) mem)
            // cond:
            // result: (Store {t.FieldType(2)}     (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] dst)     f2     (Store {t.FieldType(1)}       (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)       f1       (Store {t.FieldType(0)}         (OffPtr <t.FieldType(0).PtrTo()> [0] dst)           f0 mem)))
 
            // match: (Store dst (StructMake3 <t> f0 f1 f2) mem)
            // cond:
            // result: (Store {t.FieldType(2)}     (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] dst)     f2     (Store {t.FieldType(1)}       (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)       f1       (Store {t.FieldType(0)}         (OffPtr <t.FieldType(0).PtrTo()> [0] dst)           f0 mem)))
            while (true)
            {
                _ = v.Args[2L];
                dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake3)
                {
                    break;
                }
                t = v_1.Type;
                _ = v_1.Args[2L];
                f0 = v_1.Args[0L];
                f1 = v_1.Args[1L];
                var f2 = v_1.Args[2L];
                mem = v.Args[2L];
                v.reset(OpStore);
                v.Aux = t.FieldType(2L);
                v0 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(2L).PtrTo());
                v0.AuxInt = t.FieldOff(2L);
                v0.AddArg(dst);
                v.AddArg(v0);
                v.AddArg(f2);
                v1 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v1.Aux = t.FieldType(1L);
                v2 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v2.AuxInt = t.FieldOff(1L);
                v2.AddArg(dst);
                v1.AddArg(v2);
                v1.AddArg(f1);
                var v3 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v3.Aux = t.FieldType(0L);
                var v4 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v4.AuxInt = 0L;
                v4.AddArg(dst);
                v3.AddArg(v4);
                v3.AddArg(f0);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Store dst (StructMake4 <t> f0 f1 f2 f3) mem)
            // cond:
            // result: (Store {t.FieldType(3)}     (OffPtr <t.FieldType(3).PtrTo()> [t.FieldOff(3)] dst)     f3     (Store {t.FieldType(2)}       (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] dst)       f2       (Store {t.FieldType(1)}         (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)         f1         (Store {t.FieldType(0)}           (OffPtr <t.FieldType(0).PtrTo()> [0] dst)             f0 mem))))
 
            // match: (Store dst (StructMake4 <t> f0 f1 f2 f3) mem)
            // cond:
            // result: (Store {t.FieldType(3)}     (OffPtr <t.FieldType(3).PtrTo()> [t.FieldOff(3)] dst)     f3     (Store {t.FieldType(2)}       (OffPtr <t.FieldType(2).PtrTo()> [t.FieldOff(2)] dst)       f2       (Store {t.FieldType(1)}         (OffPtr <t.FieldType(1).PtrTo()> [t.FieldOff(1)] dst)         f1         (Store {t.FieldType(0)}           (OffPtr <t.FieldType(0).PtrTo()> [0] dst)             f0 mem))))
            while (true)
            {
                _ = v.Args[2L];
                dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpStructMake4)
                {
                    break;
                }
                t = v_1.Type;
                _ = v_1.Args[3L];
                f0 = v_1.Args[0L];
                f1 = v_1.Args[1L];
                f2 = v_1.Args[2L];
                var f3 = v_1.Args[3L];
                mem = v.Args[2L];
                v.reset(OpStore);
                v.Aux = t.FieldType(3L);
                v0 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(3L).PtrTo());
                v0.AuxInt = t.FieldOff(3L);
                v0.AddArg(dst);
                v.AddArg(v0);
                v.AddArg(f3);
                v1 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v1.Aux = t.FieldType(2L);
                v2 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(2L).PtrTo());
                v2.AuxInt = t.FieldOff(2L);
                v2.AddArg(dst);
                v1.AddArg(v2);
                v1.AddArg(f2);
                v3 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v3.Aux = t.FieldType(1L);
                v4 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(1L).PtrTo());
                v4.AuxInt = t.FieldOff(1L);
                v4.AddArg(dst);
                v3.AddArg(v4);
                v3.AddArg(f1);
                var v5 = b.NewValue0(v.Pos, OpStore, types.TypeMem);
                v5.Aux = t.FieldType(0L);
                var v6 = b.NewValue0(v.Pos, OpOffPtr, t.FieldType(0L).PtrTo());
                v6.AuxInt = 0L;
                v6.AddArg(dst);
                v5.AddArg(v6);
                v5.AddArg(f0);
                v5.AddArg(mem);
                v3.AddArg(v5);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Store {t} dst (Load src mem) mem)
            // cond: !fe.CanSSA(t.(*types.Type))
            // result: (Move {t} [t.(*types.Type).Size()] dst src mem)
 
            // match: (Store {t} dst (Load src mem) mem)
            // cond: !fe.CanSSA(t.(*types.Type))
            // result: (Move {t} [t.(*types.Type).Size()] dst src mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var src = v_1.Args[0L];
                mem = v_1.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(!fe.CanSSA(t._<ref types.Type>())))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = t._<ref types.Type>().Size();
                v.Aux = t;
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStore_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (Store {t} dst (Load src mem) (VarDef {x} mem))
            // cond: !fe.CanSSA(t.(*types.Type))
            // result: (Move {t} [t.(*types.Type).Size()] dst src (VarDef {x} mem))
            while (true)
            {
                var t = v.Aux;
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpLoad)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var src = v_1.Args[0L];
                var mem = v_1.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpVarDef)
                {
                    break;
                }
                var x = v_2.Aux;
                if (mem != v_2.Args[0L])
                {
                    break;
                }
                if (!(!fe.CanSSA(t._<ref types.Type>())))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = t._<ref types.Type>().Size();
                v.Aux = t;
                v.AddArg(dst);
                v.AddArg(src);
                var v0 = b.NewValue0(v.Pos, OpVarDef, types.TypeMem);
                v0.Aux = x;
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Store _ (ArrayMake0) mem)
            // cond:
            // result: mem
 
            // match: (Store _ (ArrayMake0) mem)
            // cond:
            // result: mem
            while (true)
            {
                _ = v.Args[2L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpArrayMake0)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store dst (ArrayMake1 e) mem)
            // cond:
            // result: (Store {e.Type} dst e mem)
 
            // match: (Store dst (ArrayMake1 e) mem)
            // cond:
            // result: (Store {e.Type} dst e mem)
            while (true)
            {
                _ = v.Args[2L];
                dst = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpArrayMake1)
                {
                    break;
                }
                var e = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpStore);
                v.Aux = e.Type;
                v.AddArg(dst);
                v.AddArg(e);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store (Load (OffPtr [c] (SP)) mem) x mem)
            // cond: isConstZero(x)     && mem.Op == OpStaticCall     && isSameSym(mem.Aux, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize
            // result: mem
 
            // match: (Store (Load (OffPtr [c] (SP)) mem) x mem)
            // cond: isConstZero(x)     && mem.Op == OpStaticCall     && isSameSym(mem.Aux, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize
            // result: mem
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpOffPtr)
                {
                    break;
                }
                var c = v_0_0.AuxInt;
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpSP)
                {
                    break;
                }
                mem = v_0.Args[1L];
                x = v.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(isConstZero(x) && mem.Op == OpStaticCall && isSameSym(mem.Aux, "runtime.newobject") && c == config.ctxt.FixedFrameSize() + config.RegSize))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Store (OffPtr (Load (OffPtr [c] (SP)) mem)) x mem)
            // cond: isConstZero(x)     && mem.Op == OpStaticCall     && isSameSym(mem.Aux, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize
            // result: mem
 
            // match: (Store (OffPtr (Load (OffPtr [c] (SP)) mem)) x mem)
            // cond: isConstZero(x)     && mem.Op == OpStaticCall     && isSameSym(mem.Aux, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize
            // result: mem
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpOffPtr)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpOffPtr)
                {
                    break;
                }
                c = v_0_0_0.AuxInt;
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpSP)
                {
                    break;
                }
                mem = v_0_0.Args[1L];
                x = v.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(isConstZero(x) && mem.Op == OpStaticCall && isSameSym(mem.Aux, "runtime.newobject") && c == config.ctxt.FixedFrameSize() + config.RegSize))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStringLen_0(ref Value v)
        { 
            // match: (StringLen (StringMake _ (Const64 <t> [c])))
            // cond:
            // result: (Const64 <t> [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpStringMake)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                var t = v_0_1.Type;
                var c = v_0_1.AuxInt;
                v.reset(OpConst64);
                v.Type = t;
                v.AuxInt = c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStringPtr_0(ref Value v)
        { 
            // match: (StringPtr (StringMake (Const64 <t> [c]) _))
            // cond:
            // result: (Const64 <t> [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpStringMake)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                var t = v_0_0.Type;
                var c = v_0_0.AuxInt;
                v.reset(OpConst64);
                v.Type = t;
                v.AuxInt = c;
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStructSelect_0(ref Value v)
        { 
            // match: (StructSelect (StructMake1 x))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake1)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [0] (StructMake2 x _))
            // cond:
            // result: x
 
            // match: (StructSelect [0] (StructMake2 x _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake2)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [1] (StructMake2 _ x))
            // cond:
            // result: x
 
            // match: (StructSelect [1] (StructMake2 _ x))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake2)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [0] (StructMake3 x _ _))
            // cond:
            // result: x
 
            // match: (StructSelect [0] (StructMake3 x _ _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake3)
                {
                    break;
                }
                _ = v_0.Args[2L];
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [1] (StructMake3 _ x _))
            // cond:
            // result: x
 
            // match: (StructSelect [1] (StructMake3 _ x _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake3)
                {
                    break;
                }
                _ = v_0.Args[2L];
                x = v_0.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [2] (StructMake3 _ _ x))
            // cond:
            // result: x
 
            // match: (StructSelect [2] (StructMake3 _ _ x))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake3)
                {
                    break;
                }
                _ = v_0.Args[2L];
                x = v_0.Args[2L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [0] (StructMake4 x _ _ _))
            // cond:
            // result: x
 
            // match: (StructSelect [0] (StructMake4 x _ _ _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake4)
                {
                    break;
                }
                _ = v_0.Args[3L];
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [1] (StructMake4 _ x _ _))
            // cond:
            // result: x
 
            // match: (StructSelect [1] (StructMake4 _ x _ _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake4)
                {
                    break;
                }
                _ = v_0.Args[3L];
                x = v_0.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [2] (StructMake4 _ _ x _))
            // cond:
            // result: x
 
            // match: (StructSelect [2] (StructMake4 _ _ x _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake4)
                {
                    break;
                }
                _ = v_0.Args[3L];
                x = v_0.Args[2L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (StructSelect [3] (StructMake4 _ _ _ x))
            // cond:
            // result: x
 
            // match: (StructSelect [3] (StructMake4 _ _ _ x))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpStructMake4)
                {
                    break;
                }
                _ = v_0.Args[3L];
                x = v_0.Args[3L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpStructSelect_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var fe = b.Func.fe;
            _ = fe; 
            // match: (StructSelect [i] x:(Load <t> ptr mem))
            // cond: !fe.CanSSA(t)
            // result: @x.Block (Load <v.Type> (OffPtr <v.Type.PtrTo()> [t.FieldOff(int(i))] ptr) mem)
            while (true)
            {
                var i = v.AuxInt;
                var x = v.Args[0L];
                if (x.Op != OpLoad)
                {
                    break;
                }
                var t = x.Type;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(!fe.CanSSA(t)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpLoad, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpOffPtr, v.Type.PtrTo());
                v1.AuxInt = t.FieldOff(int(i));
                v1.AddArg(ptr);
                v0.AddArg(v1);
                v0.AddArg(mem);
                return true;
            } 
            // match: (StructSelect [0] x:(IData _))
            // cond:
            // result: x
 
            // match: (StructSelect [0] x:(IData _))
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                if (x.Op != OpIData)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c-d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c - d));
                return true;
            } 
            // match: (Sub16 x (Const16 <t> [c]))
            // cond: x.Op != OpConst16
            // result: (Add16 (Const16 <t> [int64(int16(-c))]) x)
 
            // match: (Sub16 x (Const16 <t> [c]))
            // cond: x.Op != OpConst16
            // result: (Add16 (Const16 <t> [int64(int16(-c))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                var v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(-c));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub16 <t> (Mul16 x y) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
 
            // match: (Sub16 <t> (Mul16 x y) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub16 <t> (Mul16 y x) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
 
            // match: (Sub16 <t> (Mul16 y x) (Mul16 x z))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub16 <t> (Mul16 x y) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
 
            // match: (Sub16 <t> (Mul16 x y) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub16 <t> (Mul16 y x) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
 
            // match: (Sub16 <t> (Mul16 y x) (Mul16 z x))
            // cond:
            // result: (Mul16 x (Sub16 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul16);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub16 x x)
            // cond:
            // result: (Const16 [0])
 
            // match: (Sub16 x x)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Sub16 (Add16 x y) x)
            // cond:
            // result: y
 
            // match: (Sub16 (Add16 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub16 (Add16 y x) x)
            // cond:
            // result: y
 
            // match: (Sub16 (Add16 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub16 (Add16 x y) y)
            // cond:
            // result: x
 
            // match: (Sub16 (Add16 x y) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub16 (Add16 y x) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAdd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Sub16 x (Sub16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
 
            // match: (Sub16 x (Sub16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Sub16 (Add16 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpSub16);
                var v0 = b.NewValue0(v.Pos, OpAdd16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Sub16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
 
            // match: (Sub16 x (Sub16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Add16 i (Sub16 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpAdd16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub16, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub16 (Const16 <t> [c]) (Sub16 x (Const16 <t> [d])))
            // cond:
            // result: (Sub16 (Const16 <t> [int64(int16(c+d))]) x)
 
            // match: (Sub16 (Const16 <t> [c]) (Sub16 x (Const16 <t> [d])))
            // cond:
            // result: (Sub16 (Const16 <t> [int64(int16(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpSub16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub16 (Const16 <t> [c]) (Sub16 (Const16 <t> [d]) x))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
 
            // match: (Sub16 (Const16 <t> [c]) (Sub16 (Const16 <t> [d]) x))
            // cond:
            // result: (Add16 (Const16 <t> [int64(int16(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c-d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c - d));
                return true;
            } 
            // match: (Sub32 x (Const32 <t> [c]))
            // cond: x.Op != OpConst32
            // result: (Add32 (Const32 <t> [int64(int32(-c))]) x)
 
            // match: (Sub32 x (Const32 <t> [c]))
            // cond: x.Op != OpConst32
            // result: (Add32 (Const32 <t> [int64(int32(-c))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                var v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(-c));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub32 <t> (Mul32 x y) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
 
            // match: (Sub32 <t> (Mul32 x y) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub32 <t> (Mul32 y x) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
 
            // match: (Sub32 <t> (Mul32 y x) (Mul32 x z))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub32 <t> (Mul32 x y) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
 
            // match: (Sub32 <t> (Mul32 x y) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub32 <t> (Mul32 y x) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
 
            // match: (Sub32 <t> (Mul32 y x) (Mul32 z x))
            // cond:
            // result: (Mul32 x (Sub32 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul32);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub32 x x)
            // cond:
            // result: (Const32 [0])
 
            // match: (Sub32 x x)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Sub32 (Add32 x y) x)
            // cond:
            // result: y
 
            // match: (Sub32 (Add32 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub32 (Add32 y x) x)
            // cond:
            // result: y
 
            // match: (Sub32 (Add32 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub32 (Add32 x y) y)
            // cond:
            // result: x
 
            // match: (Sub32 (Add32 x y) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub32 (Add32 y x) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAdd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Sub32 x (Sub32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
 
            // match: (Sub32 x (Sub32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Sub32 (Add32 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpSub32);
                var v0 = b.NewValue0(v.Pos, OpAdd32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Sub32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
 
            // match: (Sub32 x (Sub32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Add32 i (Sub32 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpAdd32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub32, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub32 (Const32 <t> [c]) (Sub32 x (Const32 <t> [d])))
            // cond:
            // result: (Sub32 (Const32 <t> [int64(int32(c+d))]) x)
 
            // match: (Sub32 (Const32 <t> [c]) (Sub32 x (Const32 <t> [d])))
            // cond:
            // result: (Sub32 (Const32 <t> [int64(int32(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpSub32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub32 (Const32 <t> [c]) (Sub32 (Const32 <t> [d]) x))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
 
            // match: (Sub32 (Const32 <t> [c]) (Sub32 (Const32 <t> [d]) x))
            // cond:
            // result: (Add32 (Const32 <t> [int64(int32(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub32F_0(ref Value v)
        { 
            // match: (Sub32F (Const32F [c]) (Const32F [d]))
            // cond:
            // result: (Const32F [f2i(float64(i2f32(c) - i2f32(d)))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32F);
                v.AuxInt = f2i(float64(i2f32(c) - i2f32(d)));
                return true;
            } 
            // match: (Sub32F x (Const32F [0]))
            // cond:
            // result: x
 
            // match: (Sub32F x (Const32F [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32F)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c-d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c - d;
                return true;
            } 
            // match: (Sub64 x (Const64 <t> [c]))
            // cond: x.Op != OpConst64
            // result: (Add64 (Const64 <t> [-c]) x)
 
            // match: (Sub64 x (Const64 <t> [c]))
            // cond: x.Op != OpConst64
            // result: (Add64 (Const64 <t> [-c]) x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                var v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = -c;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub64 <t> (Mul64 x y) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
 
            // match: (Sub64 <t> (Mul64 x y) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub64 <t> (Mul64 y x) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
 
            // match: (Sub64 <t> (Mul64 y x) (Mul64 x z))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub64 <t> (Mul64 x y) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
 
            // match: (Sub64 <t> (Mul64 x y) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub64 <t> (Mul64 y x) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
 
            // match: (Sub64 <t> (Mul64 y x) (Mul64 z x))
            // cond:
            // result: (Mul64 x (Sub64 <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul64);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub64 x x)
            // cond:
            // result: (Const64 [0])
 
            // match: (Sub64 x x)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Sub64 (Add64 x y) x)
            // cond:
            // result: y
 
            // match: (Sub64 (Add64 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub64 (Add64 y x) x)
            // cond:
            // result: y
 
            // match: (Sub64 (Add64 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub64 (Add64 x y) y)
            // cond:
            // result: x
 
            // match: (Sub64 (Add64 x y) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub64 (Add64 y x) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAdd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Sub64 x (Sub64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
 
            // match: (Sub64 x (Sub64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Sub64 (Add64 <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpSub64);
                var v0 = b.NewValue0(v.Pos, OpAdd64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Sub64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
 
            // match: (Sub64 x (Sub64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Add64 i (Sub64 <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpAdd64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub64, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub64 (Const64 <t> [c]) (Sub64 x (Const64 <t> [d])))
            // cond:
            // result: (Sub64 (Const64 <t> [c+d]) x)
 
            // match: (Sub64 (Const64 <t> [c]) (Sub64 x (Const64 <t> [d])))
            // cond:
            // result: (Sub64 (Const64 <t> [c+d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpSub64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c + d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub64 (Const64 <t> [c]) (Sub64 (Const64 <t> [d]) x))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
 
            // match: (Sub64 (Const64 <t> [c]) (Sub64 (Const64 <t> [d]) x))
            // cond:
            // result: (Add64 (Const64 <t> [c-d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c - d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub64F_0(ref Value v)
        { 
            // match: (Sub64F (Const64F [c]) (Const64F [d]))
            // cond:
            // result: (Const64F [f2i(i2f(c) - i2f(d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64F)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64F);
                v.AuxInt = f2i(i2f(c) - i2f(d));
                return true;
            } 
            // match: (Sub64F x (Const64F [0]))
            // cond:
            // result: x
 
            // match: (Sub64F x (Const64F [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64F)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8 [int64(int8(c-d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c - d));
                return true;
            } 
            // match: (Sub8 x (Const8 <t> [c]))
            // cond: x.Op != OpConst8
            // result: (Add8  (Const8  <t> [int64(int8(-c))]) x)
 
            // match: (Sub8 x (Const8 <t> [c]))
            // cond: x.Op != OpConst8
            // result: (Add8  (Const8  <t> [int64(int8(-c))]) x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var t = v_1.Type;
                c = v_1.AuxInt;
                if (!(x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                var v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(-c));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub8 <t> (Mul8 x y) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
 
            // match: (Sub8 <t> (Mul8 x y) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var z = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub8 <t> (Mul8 y x) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
 
            // match: (Sub8 <t> (Mul8 y x) (Mul8 x z))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                z = v_1.Args[1L];
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub8 <t> (Mul8 x y) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
 
            // match: (Sub8 <t> (Mul8 x y) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub8 <t> (Mul8 y x) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
 
            // match: (Sub8 <t> (Mul8 y x) (Mul8 z x))
            // cond:
            // result: (Mul8  x (Sub8  <t> y z))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpMul8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpMul8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpMul8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub8 x x)
            // cond:
            // result: (Const8  [0])
 
            // match: (Sub8 x x)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Sub8 (Add8 x y) x)
            // cond:
            // result: y
 
            // match: (Sub8 (Add8 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub8 (Add8 y x) x)
            // cond:
            // result: y
 
            // match: (Sub8 (Add8 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Sub8 (Add8 x y) y)
            // cond:
            // result: x
 
            // match: (Sub8 (Add8 x y) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpSub8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Sub8 (Add8 y x) y)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAdd8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var x = v_0.Args[1L];
                if (y != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Sub8 x (Sub8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
 
            // match: (Sub8 x (Sub8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Sub8  (Add8  <t> x z) i)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpSub8);
                var v0 = b.NewValue0(v.Pos, OpAdd8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                v.AddArg(i);
                return true;
            } 
            // match: (Sub8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
 
            // match: (Sub8 x (Sub8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Add8  i (Sub8  <t> x z))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpAdd8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpSub8, t);
                v0.AddArg(x);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (Sub8 (Const8 <t> [c]) (Sub8 x (Const8 <t> [d])))
            // cond:
            // result: (Sub8  (Const8  <t> [int64(int8(c+d))]) x)
 
            // match: (Sub8 (Const8 <t> [c]) (Sub8 x (Const8 <t> [d])))
            // cond:
            // result: (Sub8  (Const8  <t> [int64(int8(c+d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                var d = v_1_1.AuxInt;
                v.reset(OpSub8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c + d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Sub8 (Const8 <t> [c]) (Sub8 (Const8 <t> [d]) x))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
 
            // match: (Sub8 (Const8 <t> [c]) (Sub8 (Const8 <t> [d]) x))
            // cond:
            // result: (Add8  (Const8  <t> [int64(int8(c-d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpSub8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpAdd8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c - d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc16to8_0(ref Value v)
        { 
            // match: (Trunc16to8 (Const16 [c]))
            // cond:
            // result: (Const8   [int64(int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (Trunc16to8 (ZeroExt8to16 x))
            // cond:
            // result: x
 
            // match: (Trunc16to8 (ZeroExt8to16 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc16to8 (SignExt8to16 x))
            // cond:
            // result: x
 
            // match: (Trunc16to8 (SignExt8to16 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to16)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc16to8 (And16 (Const16 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc16to8 x)
 
            // match: (Trunc16to8 (And16 (Const16 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc16to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc16to8);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc16to8 (And16 x (Const16 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc16to8 x)
 
            // match: (Trunc16to8 (And16 x (Const16 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc16to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc16to8);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc32to16_0(ref Value v)
        { 
            // match: (Trunc32to16 (Const32 [c]))
            // cond:
            // result: (Const16  [int64(int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c));
                return true;
            } 
            // match: (Trunc32to16 (ZeroExt8to32 x))
            // cond:
            // result: (ZeroExt8to16  x)
 
            // match: (Trunc32to16 (ZeroExt8to32 x))
            // cond:
            // result: (ZeroExt8to16  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpZeroExt8to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to16 (ZeroExt16to32 x))
            // cond:
            // result: x
 
            // match: (Trunc32to16 (ZeroExt16to32 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to32)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to16 (SignExt8to32 x))
            // cond:
            // result: (SignExt8to16  x)
 
            // match: (Trunc32to16 (SignExt8to32 x))
            // cond:
            // result: (SignExt8to16  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to32)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpSignExt8to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to16 (SignExt16to32 x))
            // cond:
            // result: x
 
            // match: (Trunc32to16 (SignExt16to32 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt16to32)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to16 (And32 (Const32 [y]) x))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc32to16 x)
 
            // match: (Trunc32to16 (And32 (Const32 [y]) x))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc32to16 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFFFUL == 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc32to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to16 (And32 x (Const32 [y])))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc32to16 x)
 
            // match: (Trunc32to16 (And32 x (Const32 [y])))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc32to16 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFFFUL == 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc32to16);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc32to8_0(ref Value v)
        { 
            // match: (Trunc32to8 (Const32 [c]))
            // cond:
            // result: (Const8   [int64(int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (Trunc32to8 (ZeroExt8to32 x))
            // cond:
            // result: x
 
            // match: (Trunc32to8 (ZeroExt8to32 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to32)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to8 (SignExt8to32 x))
            // cond:
            // result: x
 
            // match: (Trunc32to8 (SignExt8to32 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to32)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to8 (And32 (Const32 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc32to8 x)
 
            // match: (Trunc32to8 (And32 (Const32 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc32to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc32to8);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc32to8 (And32 x (Const32 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc32to8 x)
 
            // match: (Trunc32to8 (And32 x (Const32 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc32to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc32to8);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc64to16_0(ref Value v)
        { 
            // match: (Trunc64to16 (Const64 [c]))
            // cond:
            // result: (Const16  [int64(int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c));
                return true;
            } 
            // match: (Trunc64to16 (ZeroExt8to64 x))
            // cond:
            // result: (ZeroExt8to16  x)
 
            // match: (Trunc64to16 (ZeroExt8to64 x))
            // cond:
            // result: (ZeroExt8to16  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpZeroExt8to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to16 (ZeroExt16to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to16 (ZeroExt16to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to16 (SignExt8to64 x))
            // cond:
            // result: (SignExt8to16  x)
 
            // match: (Trunc64to16 (SignExt8to64 x))
            // cond:
            // result: (SignExt8to16  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpSignExt8to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to16 (SignExt16to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to16 (SignExt16to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt16to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to16 (And64 (Const64 [y]) x))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc64to16 x)
 
            // match: (Trunc64to16 (And64 (Const64 [y]) x))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc64to16 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFFFUL == 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to16);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to16 (And64 x (Const64 [y])))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc64to16 x)
 
            // match: (Trunc64to16 (And64 x (Const64 [y])))
            // cond: y&0xFFFF == 0xFFFF
            // result: (Trunc64to16 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFFFUL == 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to16);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc64to32_0(ref Value v)
        { 
            // match: (Trunc64to32 (Const64 [c]))
            // cond:
            // result: (Const32  [int64(int32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c));
                return true;
            } 
            // match: (Trunc64to32 (ZeroExt8to64 x))
            // cond:
            // result: (ZeroExt8to32  x)
 
            // match: (Trunc64to32 (ZeroExt8to64 x))
            // cond:
            // result: (ZeroExt8to32  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpZeroExt8to32);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (ZeroExt16to64 x))
            // cond:
            // result: (ZeroExt16to32 x)
 
            // match: (Trunc64to32 (ZeroExt16to64 x))
            // cond:
            // result: (ZeroExt16to32 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt16to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpZeroExt16to32);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (ZeroExt32to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to32 (ZeroExt32to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt32to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (SignExt8to64 x))
            // cond:
            // result: (SignExt8to32  x)
 
            // match: (Trunc64to32 (SignExt8to64 x))
            // cond:
            // result: (SignExt8to32  x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpSignExt8to32);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (SignExt16to64 x))
            // cond:
            // result: (SignExt16to32 x)
 
            // match: (Trunc64to32 (SignExt16to64 x))
            // cond:
            // result: (SignExt16to32 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt16to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpSignExt16to32);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (SignExt32to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to32 (SignExt32to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt32to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (And64 (Const64 [y]) x))
            // cond: y&0xFFFFFFFF == 0xFFFFFFFF
            // result: (Trunc64to32 x)
 
            // match: (Trunc64to32 (And64 (Const64 [y]) x))
            // cond: y&0xFFFFFFFF == 0xFFFFFFFF
            // result: (Trunc64to32 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFFFFFFFUL == 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to32);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to32 (And64 x (Const64 [y])))
            // cond: y&0xFFFFFFFF == 0xFFFFFFFF
            // result: (Trunc64to32 x)
 
            // match: (Trunc64to32 (And64 x (Const64 [y])))
            // cond: y&0xFFFFFFFF == 0xFFFFFFFF
            // result: (Trunc64to32 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFFFFFFFUL == 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to32);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpTrunc64to8_0(ref Value v)
        { 
            // match: (Trunc64to8 (Const64 [c]))
            // cond:
            // result: (Const8   [int64(int8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c));
                return true;
            } 
            // match: (Trunc64to8 (ZeroExt8to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to8 (ZeroExt8to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpZeroExt8to64)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to8 (SignExt8to64 x))
            // cond:
            // result: x
 
            // match: (Trunc64to8 (SignExt8to64 x))
            // cond:
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpSignExt8to64)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to8 (And64 (Const64 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc64to8 x)
 
            // match: (Trunc64to8 (And64 (Const64 [y]) x))
            // cond: y&0xFF == 0xFF
            // result: (Trunc64to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                var y = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to8);
                v.AddArg(x);
                return true;
            } 
            // match: (Trunc64to8 (And64 x (Const64 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc64to8 x)
 
            // match: (Trunc64to8 (And64 x (Const64 [y])))
            // cond: y&0xFF == 0xFF
            // result: (Trunc64to8 x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAnd64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                y = v_0_1.AuxInt;
                if (!(y & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpTrunc64to8);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor16 (Const16 [c]) (Const16 [d]))
            // cond:
            // result: (Const16 [int64(int16(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c ^ d));
                return true;
            } 
            // match: (Xor16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c^d))])
 
            // match: (Xor16 (Const16 [d]) (Const16 [c]))
            // cond:
            // result: (Const16 [int64(int16(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(int16(c ^ d));
                return true;
            } 
            // match: (Xor16 x x)
            // cond:
            // result: (Const16 [0])
 
            // match: (Xor16 x x)
            // cond:
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Xor16 (Const16 [0]) x)
            // cond:
            // result: x
 
            // match: (Xor16 (Const16 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor16 x (Const16 [0]))
            // cond:
            // result: x
 
            // match: (Xor16 x (Const16 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor16 x (Xor16 x y))
            // cond:
            // result: y
 
            // match: (Xor16 x (Xor16 x y))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor16 x (Xor16 y x))
            // cond:
            // result: y
 
            // match: (Xor16 x (Xor16 y x))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor16 (Xor16 x y) x)
            // cond:
            // result: y
 
            // match: (Xor16 (Xor16 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor16 (Xor16 y x) x)
            // cond:
            // result: y
 
            // match: (Xor16 (Xor16 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor16 (Xor16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
 
            // match: (Xor16 (Xor16 i:(Const16 <t>) z) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpXor16);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor16_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor16 (Xor16 z i:(Const16 <t>)) x)
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var z = v_0.Args[0L];
                var i = v_0.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                var t = i.Type;
                var x = v.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpXor16);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor16 x (Xor16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
 
            // match: (Xor16 x (Xor16 i:(Const16 <t>) z))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpXor16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor16 x (Xor16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
 
            // match: (Xor16 x (Xor16 z i:(Const16 <t>)))
            // cond: (z.Op != OpConst16 && x.Op != OpConst16)
            // result: (Xor16 i (Xor16 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst16)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst16 && x.Op != OpConst16))
                {
                    break;
                }
                v.reset(OpXor16);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor16, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor16 (Const16 <t> [c]) (Xor16 (Const16 <t> [d]) x))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
 
            // match: (Xor16 (Const16 <t> [c]) (Xor16 (Const16 <t> [d]) x))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst16)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpXor16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor16 (Const16 <t> [c]) (Xor16 x (Const16 <t> [d])))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
 
            // match: (Xor16 (Const16 <t> [c]) (Xor16 x (Const16 <t> [d])))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor16)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpXor16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor16 (Xor16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
 
            // match: (Xor16 (Xor16 (Const16 <t> [d]) x) (Const16 <t> [c]))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst16)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor16 (Xor16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
 
            // match: (Xor16 (Xor16 x (Const16 <t> [d])) (Const16 <t> [c]))
            // cond:
            // result: (Xor16 (Const16 <t> [int64(int16(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor16)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst16)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst16)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor16);
                v0 = b.NewValue0(v.Pos, OpConst16, t);
                v0.AuxInt = int64(int16(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor32 (Const32 [c]) (Const32 [d]))
            // cond:
            // result: (Const32 [int64(int32(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c ^ d));
                return true;
            } 
            // match: (Xor32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c^d))])
 
            // match: (Xor32 (Const32 [d]) (Const32 [c]))
            // cond:
            // result: (Const32 [int64(int32(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(int32(c ^ d));
                return true;
            } 
            // match: (Xor32 x x)
            // cond:
            // result: (Const32 [0])
 
            // match: (Xor32 x x)
            // cond:
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Xor32 (Const32 [0]) x)
            // cond:
            // result: x
 
            // match: (Xor32 (Const32 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor32 x (Const32 [0]))
            // cond:
            // result: x
 
            // match: (Xor32 x (Const32 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor32 x (Xor32 x y))
            // cond:
            // result: y
 
            // match: (Xor32 x (Xor32 x y))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor32 x (Xor32 y x))
            // cond:
            // result: y
 
            // match: (Xor32 x (Xor32 y x))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor32 (Xor32 x y) x)
            // cond:
            // result: y
 
            // match: (Xor32 (Xor32 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor32 (Xor32 y x) x)
            // cond:
            // result: y
 
            // match: (Xor32 (Xor32 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor32 (Xor32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
 
            // match: (Xor32 (Xor32 i:(Const32 <t>) z) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpXor32);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor32_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor32 (Xor32 z i:(Const32 <t>)) x)
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var z = v_0.Args[0L];
                var i = v_0.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                var t = i.Type;
                var x = v.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpXor32);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor32 x (Xor32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
 
            // match: (Xor32 x (Xor32 i:(Const32 <t>) z))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpXor32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor32 x (Xor32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
 
            // match: (Xor32 x (Xor32 z i:(Const32 <t>)))
            // cond: (z.Op != OpConst32 && x.Op != OpConst32)
            // result: (Xor32 i (Xor32 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst32)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst32 && x.Op != OpConst32))
                {
                    break;
                }
                v.reset(OpXor32);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor32, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor32 (Const32 <t> [c]) (Xor32 (Const32 <t> [d]) x))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
 
            // match: (Xor32 (Const32 <t> [c]) (Xor32 (Const32 <t> [d]) x))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst32)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpXor32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor32 (Const32 <t> [c]) (Xor32 x (Const32 <t> [d])))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
 
            // match: (Xor32 (Const32 <t> [c]) (Xor32 x (Const32 <t> [d])))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor32)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpXor32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor32 (Xor32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
 
            // match: (Xor32 (Xor32 (Const32 <t> [d]) x) (Const32 <t> [c]))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst32)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor32 (Xor32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
 
            // match: (Xor32 (Xor32 x (Const32 <t> [d])) (Const32 <t> [c]))
            // cond:
            // result: (Xor32 (Const32 <t> [int64(int32(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst32)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst32)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor32);
                v0 = b.NewValue0(v.Pos, OpConst32, t);
                v0.AuxInt = int64(int32(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor64 (Const64 [c]) (Const64 [d]))
            // cond:
            // result: (Const64 [c^d])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (Xor64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c^d])
 
            // match: (Xor64 (Const64 [d]) (Const64 [c]))
            // cond:
            // result: (Const64 [c^d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (Xor64 x x)
            // cond:
            // result: (Const64 [0])
 
            // match: (Xor64 x x)
            // cond:
            // result: (Const64 [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst64);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Xor64 (Const64 [0]) x)
            // cond:
            // result: x
 
            // match: (Xor64 (Const64 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor64 x (Const64 [0]))
            // cond:
            // result: x
 
            // match: (Xor64 x (Const64 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor64 x (Xor64 x y))
            // cond:
            // result: y
 
            // match: (Xor64 x (Xor64 x y))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor64 x (Xor64 y x))
            // cond:
            // result: y
 
            // match: (Xor64 x (Xor64 y x))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor64 (Xor64 x y) x)
            // cond:
            // result: y
 
            // match: (Xor64 (Xor64 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor64 (Xor64 y x) x)
            // cond:
            // result: y
 
            // match: (Xor64 (Xor64 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor64 (Xor64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
 
            // match: (Xor64 (Xor64 i:(Const64 <t>) z) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpXor64);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor64_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor64 (Xor64 z i:(Const64 <t>)) x)
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var z = v_0.Args[0L];
                var i = v_0.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                var t = i.Type;
                var x = v.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpXor64);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor64 x (Xor64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
 
            // match: (Xor64 x (Xor64 i:(Const64 <t>) z))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpXor64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor64 x (Xor64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
 
            // match: (Xor64 x (Xor64 z i:(Const64 <t>)))
            // cond: (z.Op != OpConst64 && x.Op != OpConst64)
            // result: (Xor64 i (Xor64 <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst64)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst64 && x.Op != OpConst64))
                {
                    break;
                }
                v.reset(OpXor64);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor64, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor64 (Const64 <t> [c]) (Xor64 (Const64 <t> [d]) x))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
 
            // match: (Xor64 (Const64 <t> [c]) (Xor64 (Const64 <t> [d]) x))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst64)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpXor64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c ^ d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor64 (Const64 <t> [c]) (Xor64 x (Const64 <t> [d])))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
 
            // match: (Xor64 (Const64 <t> [c]) (Xor64 x (Const64 <t> [d])))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor64)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpXor64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c ^ d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor64 (Xor64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
 
            // match: (Xor64 (Xor64 (Const64 <t> [d]) x) (Const64 <t> [c]))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst64)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c ^ d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor64 (Xor64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
 
            // match: (Xor64 (Xor64 x (Const64 <t> [d])) (Const64 <t> [c]))
            // cond:
            // result: (Xor64 (Const64 <t> [c^d]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst64)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor64);
                v0 = b.NewValue0(v.Pos, OpConst64, t);
                v0.AuxInt = c ^ d;
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor8 (Const8 [c]) (Const8 [d]))
            // cond:
            // result: (Const8  [int64(int8(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c ^ d));
                return true;
            } 
            // match: (Xor8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c^d))])
 
            // match: (Xor8 (Const8 [d]) (Const8 [c]))
            // cond:
            // result: (Const8  [int64(int8(c^d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpConst8);
                v.AuxInt = int64(int8(c ^ d));
                return true;
            } 
            // match: (Xor8 x x)
            // cond:
            // result: (Const8  [0])
 
            // match: (Xor8 x x)
            // cond:
            // result: (Const8  [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Xor8 (Const8 [0]) x)
            // cond:
            // result: x
 
            // match: (Xor8 (Const8 [0]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor8 x (Const8 [0]))
            // cond:
            // result: x
 
            // match: (Xor8 x (Const8 [0]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Xor8 x (Xor8 x y))
            // cond:
            // result: y
 
            // match: (Xor8 x (Xor8 x y))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var y = v_1.Args[1L];
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor8 x (Xor8 y x))
            // cond:
            // result: y
 
            // match: (Xor8 x (Xor8 y x))
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor8 (Xor8 x y) x)
            // cond:
            // result: y
 
            // match: (Xor8 (Xor8 x y) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor8 (Xor8 y x) x)
            // cond:
            // result: y
 
            // match: (Xor8 (Xor8 y x) x)
            // cond:
            // result: y
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (Xor8 (Xor8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
 
            // match: (Xor8 (Xor8 i:(Const8 <t>) z) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var i = v_0.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var z = v_0.Args[1L];
                x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpXor8);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpXor8_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Xor8 (Xor8 z i:(Const8 <t>)) x)
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var z = v_0.Args[0L];
                var i = v_0.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                var t = i.Type;
                var x = v.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpXor8);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpXor8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor8 x (Xor8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
 
            // match: (Xor8 x (Xor8 i:(Const8 <t>) z))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                i = v_1.Args[0L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                z = v_1.Args[1L];
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpXor8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor8 x (Xor8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
 
            // match: (Xor8 x (Xor8 z i:(Const8 <t>)))
            // cond: (z.Op != OpConst8  && x.Op != OpConst8)
            // result: (Xor8  i (Xor8  <t> z x))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                z = v_1.Args[0L];
                i = v_1.Args[1L];
                if (i.Op != OpConst8)
                {
                    break;
                }
                t = i.Type;
                if (!(z.Op != OpConst8 && x.Op != OpConst8))
                {
                    break;
                }
                v.reset(OpXor8);
                v.AddArg(i);
                v0 = b.NewValue0(v.Pos, OpXor8, t);
                v0.AddArg(z);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Xor8 (Const8 <t> [c]) (Xor8 (Const8 <t> [d]) x))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
 
            // match: (Xor8 (Const8 <t> [c]) (Xor8 (Const8 <t> [d]) x))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpConst8)
                {
                    break;
                }
                if (v_1_0.Type != t)
                {
                    break;
                }
                var d = v_1_0.AuxInt;
                x = v_1.Args[1L];
                v.reset(OpXor8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor8 (Const8 <t> [c]) (Xor8 x (Const8 <t> [d])))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
 
            // match: (Xor8 (Const8 <t> [c]) (Xor8 x (Const8 <t> [d])))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0.Type;
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpXor8)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1_1.Type != t)
                {
                    break;
                }
                d = v_1_1.AuxInt;
                v.reset(OpXor8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor8 (Xor8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
 
            // match: (Xor8 (Xor8 (Const8 <t> [d]) x) (Const8 <t> [c]))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpConst8)
                {
                    break;
                }
                t = v_0_0.Type;
                d = v_0_0.AuxInt;
                x = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (Xor8 (Xor8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
 
            // match: (Xor8 (Xor8 x (Const8 <t> [d])) (Const8 <t> [c]))
            // cond:
            // result: (Xor8  (Const8  <t> [int64(int8(c^d))]) x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpXor8)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpConst8)
                {
                    break;
                }
                t = v_0_1.Type;
                d = v_0_1.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst8)
                {
                    break;
                }
                if (v_1.Type != t)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpXor8);
                v0 = b.NewValue0(v.Pos, OpConst8, t);
                v0.AuxInt = int64(int8(c ^ d));
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZero_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Zero (Load (OffPtr [c] (SP)) mem) mem)
            // cond: mem.Op == OpStaticCall     && isSameSym(mem.Aux, "runtime.newobject")     && c == config.ctxt.FixedFrameSize() + config.RegSize
            // result: mem
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpLoad)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpOffPtr)
                {
                    break;
                }
                var c = v_0_0.AuxInt;
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpSP)
                {
                    break;
                }
                var mem = v_0.Args[1L];
                if (mem != v.Args[1L])
                {
                    break;
                }
                if (!(mem.Op == OpStaticCall && isSameSym(mem.Aux, "runtime.newobject") && c == config.ctxt.FixedFrameSize() + config.RegSize))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt16to32_0(ref Value v)
        { 
            // match: (ZeroExt16to32 (Const16 [c]))
            // cond:
            // result: (Const32 [int64(uint16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(uint16(c));
                return true;
            } 
            // match: (ZeroExt16to32 (Trunc32to16 x:(Rsh32Ux64 _ (Const64 [s]))))
            // cond: s >= 16
            // result: x
 
            // match: (ZeroExt16to32 (Trunc32to16 x:(Rsh32Ux64 _ (Const64 [s]))))
            // cond: s >= 16
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc32to16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 16L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt16to64_0(ref Value v)
        { 
            // match: (ZeroExt16to64 (Const16 [c]))
            // cond:
            // result: (Const64 [int64(uint16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst16)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(uint16(c));
                return true;
            } 
            // match: (ZeroExt16to64 (Trunc64to16 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 48
            // result: x
 
            // match: (ZeroExt16to64 (Trunc64to16 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 48
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to16)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 48L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt32to64_0(ref Value v)
        { 
            // match: (ZeroExt32to64 (Const32 [c]))
            // cond:
            // result: (Const64 [int64(uint32(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst32)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(uint32(c));
                return true;
            } 
            // match: (ZeroExt32to64 (Trunc64to32 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 32
            // result: x
 
            // match: (ZeroExt32to64 (Trunc64to32 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 32
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to32)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 32L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt8to16_0(ref Value v)
        { 
            // match: (ZeroExt8to16 (Const8 [c]))
            // cond:
            // result: (Const16 [int64( uint8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst16);
                v.AuxInt = int64(uint8(c));
                return true;
            } 
            // match: (ZeroExt8to16 (Trunc16to8 x:(Rsh16Ux64 _ (Const64 [s]))))
            // cond: s >= 8
            // result: x
 
            // match: (ZeroExt8to16 (Trunc16to8 x:(Rsh16Ux64 _ (Const64 [s]))))
            // cond: s >= 8
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc16to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh16Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 8L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt8to32_0(ref Value v)
        { 
            // match: (ZeroExt8to32 (Const8 [c]))
            // cond:
            // result: (Const32 [int64( uint8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst32);
                v.AuxInt = int64(uint8(c));
                return true;
            } 
            // match: (ZeroExt8to32 (Trunc32to8 x:(Rsh32Ux64 _ (Const64 [s]))))
            // cond: s >= 24
            // result: x
 
            // match: (ZeroExt8to32 (Trunc32to8 x:(Rsh32Ux64 _ (Const64 [s]))))
            // cond: s >= 24
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc32to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh32Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 24L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuegeneric_OpZeroExt8to64_0(ref Value v)
        { 
            // match: (ZeroExt8to64 (Const8 [c]))
            // cond:
            // result: (Const64 [int64( uint8(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpConst8)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpConst64);
                v.AuxInt = int64(uint8(c));
                return true;
            } 
            // match: (ZeroExt8to64 (Trunc64to8 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 56
            // result: x
 
            // match: (ZeroExt8to64 (Trunc64to8 x:(Rsh64Ux64 _ (Const64 [s]))))
            // cond: s >= 56
            // result: x
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpTrunc64to8)
                {
                    break;
                }
                var x = v_0.Args[0L];
                if (x.Op != OpRsh64Ux64)
                {
                    break;
                }
                _ = x.Args[1L];
                var x_1 = x.Args[1L];
                if (x_1.Op != OpConst64)
                {
                    break;
                }
                var s = x_1.AuxInt;
                if (!(s >= 56L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteBlockgeneric(ref Block b)
        {
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref config.Types;
            _ = typ;

            if (b.Kind == BlockIf) 
                // match: (If (Not cond) yes no)
                // cond:
                // result: (If cond no yes)
                while (true)
                {
                    var v = b.Control;
                    if (v.Op != OpNot)
                    {
                        break;
                    }
                    var cond = v.Args[0L];
                    b.Kind = BlockIf;
                    b.SetControl(cond);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (If (ConstBool [c]) yes no)
                // cond: c == 1
                // result: (First nil yes no)
 
                // match: (If (ConstBool [c]) yes no)
                // cond: c == 1
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpConstBool)
                    {
                        break;
                    }
                    var c = v.AuxInt;
                    if (!(c == 1L))
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (ConstBool [c]) yes no)
                // cond: c == 0
                // result: (First nil no yes)
 
                // match: (If (ConstBool [c]) yes no)
                // cond: c == 0
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpConstBool)
                    {
                        break;
                    }
                    c = v.AuxInt;
                    if (!(c == 0L))
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
                        return false;
        }
    }
}}}}
