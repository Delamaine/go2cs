// Code generated from gen/AMD64.rules; DO NOT EDIT.
// generated with: cd gen; go run *.go

// package ssa -- go2cs converted at 2020 August 29 09:02:41 UTC
// import "cmd/compile/internal/ssa" ==> using ssa = go.cmd.compile.@internal.ssa_package
// Original source: C:\Go\src\cmd\compile\internal\ssa\rewriteAMD64.go
using math = go.math_package;
using obj = go.cmd.@internal.obj_package;
using objabi = go.cmd.@internal.objabi_package;
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        private static var _ = math.MinInt8; // in case not otherwise used
        private static var _ = obj.ANOP; // in case not otherwise used
        private static var _ = objabi.GOROOT; // in case not otherwise used
        private static var _ = types.TypeMem; // in case not otherwise used

        private static bool rewriteValueAMD64(ref Value v)
        {

            if (v.Op == OpAMD64ADDL) 
                return rewriteValueAMD64_OpAMD64ADDL_0(v) || rewriteValueAMD64_OpAMD64ADDL_10(v);
            else if (v.Op == OpAMD64ADDLconst) 
                return rewriteValueAMD64_OpAMD64ADDLconst_0(v);
            else if (v.Op == OpAMD64ADDLconstmem) 
                return rewriteValueAMD64_OpAMD64ADDLconstmem_0(v);
            else if (v.Op == OpAMD64ADDLmem) 
                return rewriteValueAMD64_OpAMD64ADDLmem_0(v);
            else if (v.Op == OpAMD64ADDQ) 
                return rewriteValueAMD64_OpAMD64ADDQ_0(v) || rewriteValueAMD64_OpAMD64ADDQ_10(v) || rewriteValueAMD64_OpAMD64ADDQ_20(v);
            else if (v.Op == OpAMD64ADDQconst) 
                return rewriteValueAMD64_OpAMD64ADDQconst_0(v);
            else if (v.Op == OpAMD64ADDQconstmem) 
                return rewriteValueAMD64_OpAMD64ADDQconstmem_0(v);
            else if (v.Op == OpAMD64ADDQmem) 
                return rewriteValueAMD64_OpAMD64ADDQmem_0(v);
            else if (v.Op == OpAMD64ADDSD) 
                return rewriteValueAMD64_OpAMD64ADDSD_0(v);
            else if (v.Op == OpAMD64ADDSDmem) 
                return rewriteValueAMD64_OpAMD64ADDSDmem_0(v);
            else if (v.Op == OpAMD64ADDSS) 
                return rewriteValueAMD64_OpAMD64ADDSS_0(v);
            else if (v.Op == OpAMD64ADDSSmem) 
                return rewriteValueAMD64_OpAMD64ADDSSmem_0(v);
            else if (v.Op == OpAMD64ANDL) 
                return rewriteValueAMD64_OpAMD64ANDL_0(v);
            else if (v.Op == OpAMD64ANDLconst) 
                return rewriteValueAMD64_OpAMD64ANDLconst_0(v);
            else if (v.Op == OpAMD64ANDLmem) 
                return rewriteValueAMD64_OpAMD64ANDLmem_0(v);
            else if (v.Op == OpAMD64ANDQ) 
                return rewriteValueAMD64_OpAMD64ANDQ_0(v);
            else if (v.Op == OpAMD64ANDQconst) 
                return rewriteValueAMD64_OpAMD64ANDQconst_0(v);
            else if (v.Op == OpAMD64ANDQmem) 
                return rewriteValueAMD64_OpAMD64ANDQmem_0(v);
            else if (v.Op == OpAMD64BSFQ) 
                return rewriteValueAMD64_OpAMD64BSFQ_0(v);
            else if (v.Op == OpAMD64BTQconst) 
                return rewriteValueAMD64_OpAMD64BTQconst_0(v);
            else if (v.Op == OpAMD64CMOVQEQ) 
                return rewriteValueAMD64_OpAMD64CMOVQEQ_0(v);
            else if (v.Op == OpAMD64CMPB) 
                return rewriteValueAMD64_OpAMD64CMPB_0(v);
            else if (v.Op == OpAMD64CMPBconst) 
                return rewriteValueAMD64_OpAMD64CMPBconst_0(v);
            else if (v.Op == OpAMD64CMPL) 
                return rewriteValueAMD64_OpAMD64CMPL_0(v);
            else if (v.Op == OpAMD64CMPLconst) 
                return rewriteValueAMD64_OpAMD64CMPLconst_0(v);
            else if (v.Op == OpAMD64CMPQ) 
                return rewriteValueAMD64_OpAMD64CMPQ_0(v);
            else if (v.Op == OpAMD64CMPQconst) 
                return rewriteValueAMD64_OpAMD64CMPQconst_0(v) || rewriteValueAMD64_OpAMD64CMPQconst_10(v);
            else if (v.Op == OpAMD64CMPW) 
                return rewriteValueAMD64_OpAMD64CMPW_0(v);
            else if (v.Op == OpAMD64CMPWconst) 
                return rewriteValueAMD64_OpAMD64CMPWconst_0(v);
            else if (v.Op == OpAMD64CMPXCHGLlock) 
                return rewriteValueAMD64_OpAMD64CMPXCHGLlock_0(v);
            else if (v.Op == OpAMD64CMPXCHGQlock) 
                return rewriteValueAMD64_OpAMD64CMPXCHGQlock_0(v);
            else if (v.Op == OpAMD64LEAL) 
                return rewriteValueAMD64_OpAMD64LEAL_0(v);
            else if (v.Op == OpAMD64LEAQ) 
                return rewriteValueAMD64_OpAMD64LEAQ_0(v);
            else if (v.Op == OpAMD64LEAQ1) 
                return rewriteValueAMD64_OpAMD64LEAQ1_0(v);
            else if (v.Op == OpAMD64LEAQ2) 
                return rewriteValueAMD64_OpAMD64LEAQ2_0(v);
            else if (v.Op == OpAMD64LEAQ4) 
                return rewriteValueAMD64_OpAMD64LEAQ4_0(v);
            else if (v.Op == OpAMD64LEAQ8) 
                return rewriteValueAMD64_OpAMD64LEAQ8_0(v);
            else if (v.Op == OpAMD64MOVBQSX) 
                return rewriteValueAMD64_OpAMD64MOVBQSX_0(v);
            else if (v.Op == OpAMD64MOVBQSXload) 
                return rewriteValueAMD64_OpAMD64MOVBQSXload_0(v);
            else if (v.Op == OpAMD64MOVBQZX) 
                return rewriteValueAMD64_OpAMD64MOVBQZX_0(v);
            else if (v.Op == OpAMD64MOVBload) 
                return rewriteValueAMD64_OpAMD64MOVBload_0(v);
            else if (v.Op == OpAMD64MOVBloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVBloadidx1_0(v);
            else if (v.Op == OpAMD64MOVBstore) 
                return rewriteValueAMD64_OpAMD64MOVBstore_0(v) || rewriteValueAMD64_OpAMD64MOVBstore_10(v) || rewriteValueAMD64_OpAMD64MOVBstore_20(v);
            else if (v.Op == OpAMD64MOVBstoreconst) 
                return rewriteValueAMD64_OpAMD64MOVBstoreconst_0(v);
            else if (v.Op == OpAMD64MOVBstoreconstidx1) 
                return rewriteValueAMD64_OpAMD64MOVBstoreconstidx1_0(v);
            else if (v.Op == OpAMD64MOVBstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVBstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVLQSX) 
                return rewriteValueAMD64_OpAMD64MOVLQSX_0(v);
            else if (v.Op == OpAMD64MOVLQSXload) 
                return rewriteValueAMD64_OpAMD64MOVLQSXload_0(v);
            else if (v.Op == OpAMD64MOVLQZX) 
                return rewriteValueAMD64_OpAMD64MOVLQZX_0(v);
            else if (v.Op == OpAMD64MOVLatomicload) 
                return rewriteValueAMD64_OpAMD64MOVLatomicload_0(v);
            else if (v.Op == OpAMD64MOVLf2i) 
                return rewriteValueAMD64_OpAMD64MOVLf2i_0(v);
            else if (v.Op == OpAMD64MOVLi2f) 
                return rewriteValueAMD64_OpAMD64MOVLi2f_0(v);
            else if (v.Op == OpAMD64MOVLload) 
                return rewriteValueAMD64_OpAMD64MOVLload_0(v);
            else if (v.Op == OpAMD64MOVLloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVLloadidx1_0(v);
            else if (v.Op == OpAMD64MOVLloadidx4) 
                return rewriteValueAMD64_OpAMD64MOVLloadidx4_0(v);
            else if (v.Op == OpAMD64MOVLloadidx8) 
                return rewriteValueAMD64_OpAMD64MOVLloadidx8_0(v);
            else if (v.Op == OpAMD64MOVLstore) 
                return rewriteValueAMD64_OpAMD64MOVLstore_0(v) || rewriteValueAMD64_OpAMD64MOVLstore_10(v);
            else if (v.Op == OpAMD64MOVLstoreconst) 
                return rewriteValueAMD64_OpAMD64MOVLstoreconst_0(v);
            else if (v.Op == OpAMD64MOVLstoreconstidx1) 
                return rewriteValueAMD64_OpAMD64MOVLstoreconstidx1_0(v);
            else if (v.Op == OpAMD64MOVLstoreconstidx4) 
                return rewriteValueAMD64_OpAMD64MOVLstoreconstidx4_0(v);
            else if (v.Op == OpAMD64MOVLstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVLstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVLstoreidx4) 
                return rewriteValueAMD64_OpAMD64MOVLstoreidx4_0(v);
            else if (v.Op == OpAMD64MOVLstoreidx8) 
                return rewriteValueAMD64_OpAMD64MOVLstoreidx8_0(v);
            else if (v.Op == OpAMD64MOVOload) 
                return rewriteValueAMD64_OpAMD64MOVOload_0(v);
            else if (v.Op == OpAMD64MOVOstore) 
                return rewriteValueAMD64_OpAMD64MOVOstore_0(v);
            else if (v.Op == OpAMD64MOVQatomicload) 
                return rewriteValueAMD64_OpAMD64MOVQatomicload_0(v);
            else if (v.Op == OpAMD64MOVQf2i) 
                return rewriteValueAMD64_OpAMD64MOVQf2i_0(v);
            else if (v.Op == OpAMD64MOVQi2f) 
                return rewriteValueAMD64_OpAMD64MOVQi2f_0(v);
            else if (v.Op == OpAMD64MOVQload) 
                return rewriteValueAMD64_OpAMD64MOVQload_0(v);
            else if (v.Op == OpAMD64MOVQloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVQloadidx1_0(v);
            else if (v.Op == OpAMD64MOVQloadidx8) 
                return rewriteValueAMD64_OpAMD64MOVQloadidx8_0(v);
            else if (v.Op == OpAMD64MOVQstore) 
                return rewriteValueAMD64_OpAMD64MOVQstore_0(v);
            else if (v.Op == OpAMD64MOVQstoreconst) 
                return rewriteValueAMD64_OpAMD64MOVQstoreconst_0(v);
            else if (v.Op == OpAMD64MOVQstoreconstidx1) 
                return rewriteValueAMD64_OpAMD64MOVQstoreconstidx1_0(v);
            else if (v.Op == OpAMD64MOVQstoreconstidx8) 
                return rewriteValueAMD64_OpAMD64MOVQstoreconstidx8_0(v);
            else if (v.Op == OpAMD64MOVQstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVQstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVQstoreidx8) 
                return rewriteValueAMD64_OpAMD64MOVQstoreidx8_0(v);
            else if (v.Op == OpAMD64MOVSDload) 
                return rewriteValueAMD64_OpAMD64MOVSDload_0(v);
            else if (v.Op == OpAMD64MOVSDloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVSDloadidx1_0(v);
            else if (v.Op == OpAMD64MOVSDloadidx8) 
                return rewriteValueAMD64_OpAMD64MOVSDloadidx8_0(v);
            else if (v.Op == OpAMD64MOVSDstore) 
                return rewriteValueAMD64_OpAMD64MOVSDstore_0(v);
            else if (v.Op == OpAMD64MOVSDstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVSDstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVSDstoreidx8) 
                return rewriteValueAMD64_OpAMD64MOVSDstoreidx8_0(v);
            else if (v.Op == OpAMD64MOVSSload) 
                return rewriteValueAMD64_OpAMD64MOVSSload_0(v);
            else if (v.Op == OpAMD64MOVSSloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVSSloadidx1_0(v);
            else if (v.Op == OpAMD64MOVSSloadidx4) 
                return rewriteValueAMD64_OpAMD64MOVSSloadidx4_0(v);
            else if (v.Op == OpAMD64MOVSSstore) 
                return rewriteValueAMD64_OpAMD64MOVSSstore_0(v);
            else if (v.Op == OpAMD64MOVSSstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVSSstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVSSstoreidx4) 
                return rewriteValueAMD64_OpAMD64MOVSSstoreidx4_0(v);
            else if (v.Op == OpAMD64MOVWQSX) 
                return rewriteValueAMD64_OpAMD64MOVWQSX_0(v);
            else if (v.Op == OpAMD64MOVWQSXload) 
                return rewriteValueAMD64_OpAMD64MOVWQSXload_0(v);
            else if (v.Op == OpAMD64MOVWQZX) 
                return rewriteValueAMD64_OpAMD64MOVWQZX_0(v);
            else if (v.Op == OpAMD64MOVWload) 
                return rewriteValueAMD64_OpAMD64MOVWload_0(v);
            else if (v.Op == OpAMD64MOVWloadidx1) 
                return rewriteValueAMD64_OpAMD64MOVWloadidx1_0(v);
            else if (v.Op == OpAMD64MOVWloadidx2) 
                return rewriteValueAMD64_OpAMD64MOVWloadidx2_0(v);
            else if (v.Op == OpAMD64MOVWstore) 
                return rewriteValueAMD64_OpAMD64MOVWstore_0(v) || rewriteValueAMD64_OpAMD64MOVWstore_10(v);
            else if (v.Op == OpAMD64MOVWstoreconst) 
                return rewriteValueAMD64_OpAMD64MOVWstoreconst_0(v);
            else if (v.Op == OpAMD64MOVWstoreconstidx1) 
                return rewriteValueAMD64_OpAMD64MOVWstoreconstidx1_0(v);
            else if (v.Op == OpAMD64MOVWstoreconstidx2) 
                return rewriteValueAMD64_OpAMD64MOVWstoreconstidx2_0(v);
            else if (v.Op == OpAMD64MOVWstoreidx1) 
                return rewriteValueAMD64_OpAMD64MOVWstoreidx1_0(v);
            else if (v.Op == OpAMD64MOVWstoreidx2) 
                return rewriteValueAMD64_OpAMD64MOVWstoreidx2_0(v);
            else if (v.Op == OpAMD64MULL) 
                return rewriteValueAMD64_OpAMD64MULL_0(v);
            else if (v.Op == OpAMD64MULLconst) 
                return rewriteValueAMD64_OpAMD64MULLconst_0(v);
            else if (v.Op == OpAMD64MULQ) 
                return rewriteValueAMD64_OpAMD64MULQ_0(v);
            else if (v.Op == OpAMD64MULQconst) 
                return rewriteValueAMD64_OpAMD64MULQconst_0(v) || rewriteValueAMD64_OpAMD64MULQconst_10(v) || rewriteValueAMD64_OpAMD64MULQconst_20(v);
            else if (v.Op == OpAMD64MULSD) 
                return rewriteValueAMD64_OpAMD64MULSD_0(v);
            else if (v.Op == OpAMD64MULSDmem) 
                return rewriteValueAMD64_OpAMD64MULSDmem_0(v);
            else if (v.Op == OpAMD64MULSS) 
                return rewriteValueAMD64_OpAMD64MULSS_0(v);
            else if (v.Op == OpAMD64MULSSmem) 
                return rewriteValueAMD64_OpAMD64MULSSmem_0(v);
            else if (v.Op == OpAMD64NEGL) 
                return rewriteValueAMD64_OpAMD64NEGL_0(v);
            else if (v.Op == OpAMD64NEGQ) 
                return rewriteValueAMD64_OpAMD64NEGQ_0(v);
            else if (v.Op == OpAMD64NOTL) 
                return rewriteValueAMD64_OpAMD64NOTL_0(v);
            else if (v.Op == OpAMD64NOTQ) 
                return rewriteValueAMD64_OpAMD64NOTQ_0(v);
            else if (v.Op == OpAMD64ORL) 
                return rewriteValueAMD64_OpAMD64ORL_0(v) || rewriteValueAMD64_OpAMD64ORL_10(v) || rewriteValueAMD64_OpAMD64ORL_20(v) || rewriteValueAMD64_OpAMD64ORL_30(v) || rewriteValueAMD64_OpAMD64ORL_40(v) || rewriteValueAMD64_OpAMD64ORL_50(v) || rewriteValueAMD64_OpAMD64ORL_60(v) || rewriteValueAMD64_OpAMD64ORL_70(v) || rewriteValueAMD64_OpAMD64ORL_80(v) || rewriteValueAMD64_OpAMD64ORL_90(v) || rewriteValueAMD64_OpAMD64ORL_100(v) || rewriteValueAMD64_OpAMD64ORL_110(v) || rewriteValueAMD64_OpAMD64ORL_120(v) || rewriteValueAMD64_OpAMD64ORL_130(v);
            else if (v.Op == OpAMD64ORLconst) 
                return rewriteValueAMD64_OpAMD64ORLconst_0(v);
            else if (v.Op == OpAMD64ORLmem) 
                return rewriteValueAMD64_OpAMD64ORLmem_0(v);
            else if (v.Op == OpAMD64ORQ) 
                return rewriteValueAMD64_OpAMD64ORQ_0(v) || rewriteValueAMD64_OpAMD64ORQ_10(v) || rewriteValueAMD64_OpAMD64ORQ_20(v) || rewriteValueAMD64_OpAMD64ORQ_30(v) || rewriteValueAMD64_OpAMD64ORQ_40(v) || rewriteValueAMD64_OpAMD64ORQ_50(v) || rewriteValueAMD64_OpAMD64ORQ_60(v) || rewriteValueAMD64_OpAMD64ORQ_70(v) || rewriteValueAMD64_OpAMD64ORQ_80(v) || rewriteValueAMD64_OpAMD64ORQ_90(v) || rewriteValueAMD64_OpAMD64ORQ_100(v) || rewriteValueAMD64_OpAMD64ORQ_110(v) || rewriteValueAMD64_OpAMD64ORQ_120(v) || rewriteValueAMD64_OpAMD64ORQ_130(v) || rewriteValueAMD64_OpAMD64ORQ_140(v) || rewriteValueAMD64_OpAMD64ORQ_150(v) || rewriteValueAMD64_OpAMD64ORQ_160(v);
            else if (v.Op == OpAMD64ORQconst) 
                return rewriteValueAMD64_OpAMD64ORQconst_0(v);
            else if (v.Op == OpAMD64ORQmem) 
                return rewriteValueAMD64_OpAMD64ORQmem_0(v);
            else if (v.Op == OpAMD64ROLB) 
                return rewriteValueAMD64_OpAMD64ROLB_0(v);
            else if (v.Op == OpAMD64ROLBconst) 
                return rewriteValueAMD64_OpAMD64ROLBconst_0(v);
            else if (v.Op == OpAMD64ROLL) 
                return rewriteValueAMD64_OpAMD64ROLL_0(v);
            else if (v.Op == OpAMD64ROLLconst) 
                return rewriteValueAMD64_OpAMD64ROLLconst_0(v);
            else if (v.Op == OpAMD64ROLQ) 
                return rewriteValueAMD64_OpAMD64ROLQ_0(v);
            else if (v.Op == OpAMD64ROLQconst) 
                return rewriteValueAMD64_OpAMD64ROLQconst_0(v);
            else if (v.Op == OpAMD64ROLW) 
                return rewriteValueAMD64_OpAMD64ROLW_0(v);
            else if (v.Op == OpAMD64ROLWconst) 
                return rewriteValueAMD64_OpAMD64ROLWconst_0(v);
            else if (v.Op == OpAMD64RORB) 
                return rewriteValueAMD64_OpAMD64RORB_0(v);
            else if (v.Op == OpAMD64RORL) 
                return rewriteValueAMD64_OpAMD64RORL_0(v);
            else if (v.Op == OpAMD64RORQ) 
                return rewriteValueAMD64_OpAMD64RORQ_0(v);
            else if (v.Op == OpAMD64RORW) 
                return rewriteValueAMD64_OpAMD64RORW_0(v);
            else if (v.Op == OpAMD64SARB) 
                return rewriteValueAMD64_OpAMD64SARB_0(v);
            else if (v.Op == OpAMD64SARBconst) 
                return rewriteValueAMD64_OpAMD64SARBconst_0(v);
            else if (v.Op == OpAMD64SARL) 
                return rewriteValueAMD64_OpAMD64SARL_0(v);
            else if (v.Op == OpAMD64SARLconst) 
                return rewriteValueAMD64_OpAMD64SARLconst_0(v);
            else if (v.Op == OpAMD64SARQ) 
                return rewriteValueAMD64_OpAMD64SARQ_0(v);
            else if (v.Op == OpAMD64SARQconst) 
                return rewriteValueAMD64_OpAMD64SARQconst_0(v);
            else if (v.Op == OpAMD64SARW) 
                return rewriteValueAMD64_OpAMD64SARW_0(v);
            else if (v.Op == OpAMD64SARWconst) 
                return rewriteValueAMD64_OpAMD64SARWconst_0(v);
            else if (v.Op == OpAMD64SBBLcarrymask) 
                return rewriteValueAMD64_OpAMD64SBBLcarrymask_0(v);
            else if (v.Op == OpAMD64SBBQcarrymask) 
                return rewriteValueAMD64_OpAMD64SBBQcarrymask_0(v);
            else if (v.Op == OpAMD64SETA) 
                return rewriteValueAMD64_OpAMD64SETA_0(v);
            else if (v.Op == OpAMD64SETAE) 
                return rewriteValueAMD64_OpAMD64SETAE_0(v);
            else if (v.Op == OpAMD64SETAEmem) 
                return rewriteValueAMD64_OpAMD64SETAEmem_0(v);
            else if (v.Op == OpAMD64SETAmem) 
                return rewriteValueAMD64_OpAMD64SETAmem_0(v);
            else if (v.Op == OpAMD64SETB) 
                return rewriteValueAMD64_OpAMD64SETB_0(v);
            else if (v.Op == OpAMD64SETBE) 
                return rewriteValueAMD64_OpAMD64SETBE_0(v);
            else if (v.Op == OpAMD64SETBEmem) 
                return rewriteValueAMD64_OpAMD64SETBEmem_0(v);
            else if (v.Op == OpAMD64SETBmem) 
                return rewriteValueAMD64_OpAMD64SETBmem_0(v);
            else if (v.Op == OpAMD64SETEQ) 
                return rewriteValueAMD64_OpAMD64SETEQ_0(v) || rewriteValueAMD64_OpAMD64SETEQ_10(v);
            else if (v.Op == OpAMD64SETEQmem) 
                return rewriteValueAMD64_OpAMD64SETEQmem_0(v) || rewriteValueAMD64_OpAMD64SETEQmem_10(v);
            else if (v.Op == OpAMD64SETG) 
                return rewriteValueAMD64_OpAMD64SETG_0(v);
            else if (v.Op == OpAMD64SETGE) 
                return rewriteValueAMD64_OpAMD64SETGE_0(v);
            else if (v.Op == OpAMD64SETGEmem) 
                return rewriteValueAMD64_OpAMD64SETGEmem_0(v);
            else if (v.Op == OpAMD64SETGmem) 
                return rewriteValueAMD64_OpAMD64SETGmem_0(v);
            else if (v.Op == OpAMD64SETL) 
                return rewriteValueAMD64_OpAMD64SETL_0(v);
            else if (v.Op == OpAMD64SETLE) 
                return rewriteValueAMD64_OpAMD64SETLE_0(v);
            else if (v.Op == OpAMD64SETLEmem) 
                return rewriteValueAMD64_OpAMD64SETLEmem_0(v);
            else if (v.Op == OpAMD64SETLmem) 
                return rewriteValueAMD64_OpAMD64SETLmem_0(v);
            else if (v.Op == OpAMD64SETNE) 
                return rewriteValueAMD64_OpAMD64SETNE_0(v) || rewriteValueAMD64_OpAMD64SETNE_10(v);
            else if (v.Op == OpAMD64SETNEmem) 
                return rewriteValueAMD64_OpAMD64SETNEmem_0(v) || rewriteValueAMD64_OpAMD64SETNEmem_10(v);
            else if (v.Op == OpAMD64SHLL) 
                return rewriteValueAMD64_OpAMD64SHLL_0(v);
            else if (v.Op == OpAMD64SHLLconst) 
                return rewriteValueAMD64_OpAMD64SHLLconst_0(v);
            else if (v.Op == OpAMD64SHLQ) 
                return rewriteValueAMD64_OpAMD64SHLQ_0(v);
            else if (v.Op == OpAMD64SHLQconst) 
                return rewriteValueAMD64_OpAMD64SHLQconst_0(v);
            else if (v.Op == OpAMD64SHRB) 
                return rewriteValueAMD64_OpAMD64SHRB_0(v);
            else if (v.Op == OpAMD64SHRBconst) 
                return rewriteValueAMD64_OpAMD64SHRBconst_0(v);
            else if (v.Op == OpAMD64SHRL) 
                return rewriteValueAMD64_OpAMD64SHRL_0(v);
            else if (v.Op == OpAMD64SHRLconst) 
                return rewriteValueAMD64_OpAMD64SHRLconst_0(v);
            else if (v.Op == OpAMD64SHRQ) 
                return rewriteValueAMD64_OpAMD64SHRQ_0(v);
            else if (v.Op == OpAMD64SHRQconst) 
                return rewriteValueAMD64_OpAMD64SHRQconst_0(v);
            else if (v.Op == OpAMD64SHRW) 
                return rewriteValueAMD64_OpAMD64SHRW_0(v);
            else if (v.Op == OpAMD64SHRWconst) 
                return rewriteValueAMD64_OpAMD64SHRWconst_0(v);
            else if (v.Op == OpAMD64SUBL) 
                return rewriteValueAMD64_OpAMD64SUBL_0(v);
            else if (v.Op == OpAMD64SUBLconst) 
                return rewriteValueAMD64_OpAMD64SUBLconst_0(v);
            else if (v.Op == OpAMD64SUBLmem) 
                return rewriteValueAMD64_OpAMD64SUBLmem_0(v);
            else if (v.Op == OpAMD64SUBQ) 
                return rewriteValueAMD64_OpAMD64SUBQ_0(v);
            else if (v.Op == OpAMD64SUBQconst) 
                return rewriteValueAMD64_OpAMD64SUBQconst_0(v);
            else if (v.Op == OpAMD64SUBQmem) 
                return rewriteValueAMD64_OpAMD64SUBQmem_0(v);
            else if (v.Op == OpAMD64SUBSD) 
                return rewriteValueAMD64_OpAMD64SUBSD_0(v);
            else if (v.Op == OpAMD64SUBSDmem) 
                return rewriteValueAMD64_OpAMD64SUBSDmem_0(v);
            else if (v.Op == OpAMD64SUBSS) 
                return rewriteValueAMD64_OpAMD64SUBSS_0(v);
            else if (v.Op == OpAMD64SUBSSmem) 
                return rewriteValueAMD64_OpAMD64SUBSSmem_0(v);
            else if (v.Op == OpAMD64TESTB) 
                return rewriteValueAMD64_OpAMD64TESTB_0(v);
            else if (v.Op == OpAMD64TESTL) 
                return rewriteValueAMD64_OpAMD64TESTL_0(v);
            else if (v.Op == OpAMD64TESTQ) 
                return rewriteValueAMD64_OpAMD64TESTQ_0(v);
            else if (v.Op == OpAMD64TESTW) 
                return rewriteValueAMD64_OpAMD64TESTW_0(v);
            else if (v.Op == OpAMD64XADDLlock) 
                return rewriteValueAMD64_OpAMD64XADDLlock_0(v);
            else if (v.Op == OpAMD64XADDQlock) 
                return rewriteValueAMD64_OpAMD64XADDQlock_0(v);
            else if (v.Op == OpAMD64XCHGL) 
                return rewriteValueAMD64_OpAMD64XCHGL_0(v);
            else if (v.Op == OpAMD64XCHGQ) 
                return rewriteValueAMD64_OpAMD64XCHGQ_0(v);
            else if (v.Op == OpAMD64XORL) 
                return rewriteValueAMD64_OpAMD64XORL_0(v) || rewriteValueAMD64_OpAMD64XORL_10(v);
            else if (v.Op == OpAMD64XORLconst) 
                return rewriteValueAMD64_OpAMD64XORLconst_0(v) || rewriteValueAMD64_OpAMD64XORLconst_10(v);
            else if (v.Op == OpAMD64XORLmem) 
                return rewriteValueAMD64_OpAMD64XORLmem_0(v);
            else if (v.Op == OpAMD64XORQ) 
                return rewriteValueAMD64_OpAMD64XORQ_0(v);
            else if (v.Op == OpAMD64XORQconst) 
                return rewriteValueAMD64_OpAMD64XORQconst_0(v);
            else if (v.Op == OpAMD64XORQmem) 
                return rewriteValueAMD64_OpAMD64XORQmem_0(v);
            else if (v.Op == OpAdd16) 
                return rewriteValueAMD64_OpAdd16_0(v);
            else if (v.Op == OpAdd32) 
                return rewriteValueAMD64_OpAdd32_0(v);
            else if (v.Op == OpAdd32F) 
                return rewriteValueAMD64_OpAdd32F_0(v);
            else if (v.Op == OpAdd64) 
                return rewriteValueAMD64_OpAdd64_0(v);
            else if (v.Op == OpAdd64F) 
                return rewriteValueAMD64_OpAdd64F_0(v);
            else if (v.Op == OpAdd8) 
                return rewriteValueAMD64_OpAdd8_0(v);
            else if (v.Op == OpAddPtr) 
                return rewriteValueAMD64_OpAddPtr_0(v);
            else if (v.Op == OpAddr) 
                return rewriteValueAMD64_OpAddr_0(v);
            else if (v.Op == OpAnd16) 
                return rewriteValueAMD64_OpAnd16_0(v);
            else if (v.Op == OpAnd32) 
                return rewriteValueAMD64_OpAnd32_0(v);
            else if (v.Op == OpAnd64) 
                return rewriteValueAMD64_OpAnd64_0(v);
            else if (v.Op == OpAnd8) 
                return rewriteValueAMD64_OpAnd8_0(v);
            else if (v.Op == OpAndB) 
                return rewriteValueAMD64_OpAndB_0(v);
            else if (v.Op == OpAtomicAdd32) 
                return rewriteValueAMD64_OpAtomicAdd32_0(v);
            else if (v.Op == OpAtomicAdd64) 
                return rewriteValueAMD64_OpAtomicAdd64_0(v);
            else if (v.Op == OpAtomicAnd8) 
                return rewriteValueAMD64_OpAtomicAnd8_0(v);
            else if (v.Op == OpAtomicCompareAndSwap32) 
                return rewriteValueAMD64_OpAtomicCompareAndSwap32_0(v);
            else if (v.Op == OpAtomicCompareAndSwap64) 
                return rewriteValueAMD64_OpAtomicCompareAndSwap64_0(v);
            else if (v.Op == OpAtomicExchange32) 
                return rewriteValueAMD64_OpAtomicExchange32_0(v);
            else if (v.Op == OpAtomicExchange64) 
                return rewriteValueAMD64_OpAtomicExchange64_0(v);
            else if (v.Op == OpAtomicLoad32) 
                return rewriteValueAMD64_OpAtomicLoad32_0(v);
            else if (v.Op == OpAtomicLoad64) 
                return rewriteValueAMD64_OpAtomicLoad64_0(v);
            else if (v.Op == OpAtomicLoadPtr) 
                return rewriteValueAMD64_OpAtomicLoadPtr_0(v);
            else if (v.Op == OpAtomicOr8) 
                return rewriteValueAMD64_OpAtomicOr8_0(v);
            else if (v.Op == OpAtomicStore32) 
                return rewriteValueAMD64_OpAtomicStore32_0(v);
            else if (v.Op == OpAtomicStore64) 
                return rewriteValueAMD64_OpAtomicStore64_0(v);
            else if (v.Op == OpAtomicStorePtrNoWB) 
                return rewriteValueAMD64_OpAtomicStorePtrNoWB_0(v);
            else if (v.Op == OpAvg64u) 
                return rewriteValueAMD64_OpAvg64u_0(v);
            else if (v.Op == OpBitLen32) 
                return rewriteValueAMD64_OpBitLen32_0(v);
            else if (v.Op == OpBitLen64) 
                return rewriteValueAMD64_OpBitLen64_0(v);
            else if (v.Op == OpBswap32) 
                return rewriteValueAMD64_OpBswap32_0(v);
            else if (v.Op == OpBswap64) 
                return rewriteValueAMD64_OpBswap64_0(v);
            else if (v.Op == OpCeil) 
                return rewriteValueAMD64_OpCeil_0(v);
            else if (v.Op == OpClosureCall) 
                return rewriteValueAMD64_OpClosureCall_0(v);
            else if (v.Op == OpCom16) 
                return rewriteValueAMD64_OpCom16_0(v);
            else if (v.Op == OpCom32) 
                return rewriteValueAMD64_OpCom32_0(v);
            else if (v.Op == OpCom64) 
                return rewriteValueAMD64_OpCom64_0(v);
            else if (v.Op == OpCom8) 
                return rewriteValueAMD64_OpCom8_0(v);
            else if (v.Op == OpConst16) 
                return rewriteValueAMD64_OpConst16_0(v);
            else if (v.Op == OpConst32) 
                return rewriteValueAMD64_OpConst32_0(v);
            else if (v.Op == OpConst32F) 
                return rewriteValueAMD64_OpConst32F_0(v);
            else if (v.Op == OpConst64) 
                return rewriteValueAMD64_OpConst64_0(v);
            else if (v.Op == OpConst64F) 
                return rewriteValueAMD64_OpConst64F_0(v);
            else if (v.Op == OpConst8) 
                return rewriteValueAMD64_OpConst8_0(v);
            else if (v.Op == OpConstBool) 
                return rewriteValueAMD64_OpConstBool_0(v);
            else if (v.Op == OpConstNil) 
                return rewriteValueAMD64_OpConstNil_0(v);
            else if (v.Op == OpConvert) 
                return rewriteValueAMD64_OpConvert_0(v);
            else if (v.Op == OpCtz32) 
                return rewriteValueAMD64_OpCtz32_0(v);
            else if (v.Op == OpCtz64) 
                return rewriteValueAMD64_OpCtz64_0(v);
            else if (v.Op == OpCvt32Fto32) 
                return rewriteValueAMD64_OpCvt32Fto32_0(v);
            else if (v.Op == OpCvt32Fto64) 
                return rewriteValueAMD64_OpCvt32Fto64_0(v);
            else if (v.Op == OpCvt32Fto64F) 
                return rewriteValueAMD64_OpCvt32Fto64F_0(v);
            else if (v.Op == OpCvt32to32F) 
                return rewriteValueAMD64_OpCvt32to32F_0(v);
            else if (v.Op == OpCvt32to64F) 
                return rewriteValueAMD64_OpCvt32to64F_0(v);
            else if (v.Op == OpCvt64Fto32) 
                return rewriteValueAMD64_OpCvt64Fto32_0(v);
            else if (v.Op == OpCvt64Fto32F) 
                return rewriteValueAMD64_OpCvt64Fto32F_0(v);
            else if (v.Op == OpCvt64Fto64) 
                return rewriteValueAMD64_OpCvt64Fto64_0(v);
            else if (v.Op == OpCvt64to32F) 
                return rewriteValueAMD64_OpCvt64to32F_0(v);
            else if (v.Op == OpCvt64to64F) 
                return rewriteValueAMD64_OpCvt64to64F_0(v);
            else if (v.Op == OpDiv128u) 
                return rewriteValueAMD64_OpDiv128u_0(v);
            else if (v.Op == OpDiv16) 
                return rewriteValueAMD64_OpDiv16_0(v);
            else if (v.Op == OpDiv16u) 
                return rewriteValueAMD64_OpDiv16u_0(v);
            else if (v.Op == OpDiv32) 
                return rewriteValueAMD64_OpDiv32_0(v);
            else if (v.Op == OpDiv32F) 
                return rewriteValueAMD64_OpDiv32F_0(v);
            else if (v.Op == OpDiv32u) 
                return rewriteValueAMD64_OpDiv32u_0(v);
            else if (v.Op == OpDiv64) 
                return rewriteValueAMD64_OpDiv64_0(v);
            else if (v.Op == OpDiv64F) 
                return rewriteValueAMD64_OpDiv64F_0(v);
            else if (v.Op == OpDiv64u) 
                return rewriteValueAMD64_OpDiv64u_0(v);
            else if (v.Op == OpDiv8) 
                return rewriteValueAMD64_OpDiv8_0(v);
            else if (v.Op == OpDiv8u) 
                return rewriteValueAMD64_OpDiv8u_0(v);
            else if (v.Op == OpEq16) 
                return rewriteValueAMD64_OpEq16_0(v);
            else if (v.Op == OpEq32) 
                return rewriteValueAMD64_OpEq32_0(v);
            else if (v.Op == OpEq32F) 
                return rewriteValueAMD64_OpEq32F_0(v);
            else if (v.Op == OpEq64) 
                return rewriteValueAMD64_OpEq64_0(v);
            else if (v.Op == OpEq64F) 
                return rewriteValueAMD64_OpEq64F_0(v);
            else if (v.Op == OpEq8) 
                return rewriteValueAMD64_OpEq8_0(v);
            else if (v.Op == OpEqB) 
                return rewriteValueAMD64_OpEqB_0(v);
            else if (v.Op == OpEqPtr) 
                return rewriteValueAMD64_OpEqPtr_0(v);
            else if (v.Op == OpFloor) 
                return rewriteValueAMD64_OpFloor_0(v);
            else if (v.Op == OpGeq16) 
                return rewriteValueAMD64_OpGeq16_0(v);
            else if (v.Op == OpGeq16U) 
                return rewriteValueAMD64_OpGeq16U_0(v);
            else if (v.Op == OpGeq32) 
                return rewriteValueAMD64_OpGeq32_0(v);
            else if (v.Op == OpGeq32F) 
                return rewriteValueAMD64_OpGeq32F_0(v);
            else if (v.Op == OpGeq32U) 
                return rewriteValueAMD64_OpGeq32U_0(v);
            else if (v.Op == OpGeq64) 
                return rewriteValueAMD64_OpGeq64_0(v);
            else if (v.Op == OpGeq64F) 
                return rewriteValueAMD64_OpGeq64F_0(v);
            else if (v.Op == OpGeq64U) 
                return rewriteValueAMD64_OpGeq64U_0(v);
            else if (v.Op == OpGeq8) 
                return rewriteValueAMD64_OpGeq8_0(v);
            else if (v.Op == OpGeq8U) 
                return rewriteValueAMD64_OpGeq8U_0(v);
            else if (v.Op == OpGetCallerPC) 
                return rewriteValueAMD64_OpGetCallerPC_0(v);
            else if (v.Op == OpGetCallerSP) 
                return rewriteValueAMD64_OpGetCallerSP_0(v);
            else if (v.Op == OpGetClosurePtr) 
                return rewriteValueAMD64_OpGetClosurePtr_0(v);
            else if (v.Op == OpGetG) 
                return rewriteValueAMD64_OpGetG_0(v);
            else if (v.Op == OpGreater16) 
                return rewriteValueAMD64_OpGreater16_0(v);
            else if (v.Op == OpGreater16U) 
                return rewriteValueAMD64_OpGreater16U_0(v);
            else if (v.Op == OpGreater32) 
                return rewriteValueAMD64_OpGreater32_0(v);
            else if (v.Op == OpGreater32F) 
                return rewriteValueAMD64_OpGreater32F_0(v);
            else if (v.Op == OpGreater32U) 
                return rewriteValueAMD64_OpGreater32U_0(v);
            else if (v.Op == OpGreater64) 
                return rewriteValueAMD64_OpGreater64_0(v);
            else if (v.Op == OpGreater64F) 
                return rewriteValueAMD64_OpGreater64F_0(v);
            else if (v.Op == OpGreater64U) 
                return rewriteValueAMD64_OpGreater64U_0(v);
            else if (v.Op == OpGreater8) 
                return rewriteValueAMD64_OpGreater8_0(v);
            else if (v.Op == OpGreater8U) 
                return rewriteValueAMD64_OpGreater8U_0(v);
            else if (v.Op == OpHmul32) 
                return rewriteValueAMD64_OpHmul32_0(v);
            else if (v.Op == OpHmul32u) 
                return rewriteValueAMD64_OpHmul32u_0(v);
            else if (v.Op == OpHmul64) 
                return rewriteValueAMD64_OpHmul64_0(v);
            else if (v.Op == OpHmul64u) 
                return rewriteValueAMD64_OpHmul64u_0(v);
            else if (v.Op == OpInt64Hi) 
                return rewriteValueAMD64_OpInt64Hi_0(v);
            else if (v.Op == OpInterCall) 
                return rewriteValueAMD64_OpInterCall_0(v);
            else if (v.Op == OpIsInBounds) 
                return rewriteValueAMD64_OpIsInBounds_0(v);
            else if (v.Op == OpIsNonNil) 
                return rewriteValueAMD64_OpIsNonNil_0(v);
            else if (v.Op == OpIsSliceInBounds) 
                return rewriteValueAMD64_OpIsSliceInBounds_0(v);
            else if (v.Op == OpLeq16) 
                return rewriteValueAMD64_OpLeq16_0(v);
            else if (v.Op == OpLeq16U) 
                return rewriteValueAMD64_OpLeq16U_0(v);
            else if (v.Op == OpLeq32) 
                return rewriteValueAMD64_OpLeq32_0(v);
            else if (v.Op == OpLeq32F) 
                return rewriteValueAMD64_OpLeq32F_0(v);
            else if (v.Op == OpLeq32U) 
                return rewriteValueAMD64_OpLeq32U_0(v);
            else if (v.Op == OpLeq64) 
                return rewriteValueAMD64_OpLeq64_0(v);
            else if (v.Op == OpLeq64F) 
                return rewriteValueAMD64_OpLeq64F_0(v);
            else if (v.Op == OpLeq64U) 
                return rewriteValueAMD64_OpLeq64U_0(v);
            else if (v.Op == OpLeq8) 
                return rewriteValueAMD64_OpLeq8_0(v);
            else if (v.Op == OpLeq8U) 
                return rewriteValueAMD64_OpLeq8U_0(v);
            else if (v.Op == OpLess16) 
                return rewriteValueAMD64_OpLess16_0(v);
            else if (v.Op == OpLess16U) 
                return rewriteValueAMD64_OpLess16U_0(v);
            else if (v.Op == OpLess32) 
                return rewriteValueAMD64_OpLess32_0(v);
            else if (v.Op == OpLess32F) 
                return rewriteValueAMD64_OpLess32F_0(v);
            else if (v.Op == OpLess32U) 
                return rewriteValueAMD64_OpLess32U_0(v);
            else if (v.Op == OpLess64) 
                return rewriteValueAMD64_OpLess64_0(v);
            else if (v.Op == OpLess64F) 
                return rewriteValueAMD64_OpLess64F_0(v);
            else if (v.Op == OpLess64U) 
                return rewriteValueAMD64_OpLess64U_0(v);
            else if (v.Op == OpLess8) 
                return rewriteValueAMD64_OpLess8_0(v);
            else if (v.Op == OpLess8U) 
                return rewriteValueAMD64_OpLess8U_0(v);
            else if (v.Op == OpLoad) 
                return rewriteValueAMD64_OpLoad_0(v);
            else if (v.Op == OpLsh16x16) 
                return rewriteValueAMD64_OpLsh16x16_0(v);
            else if (v.Op == OpLsh16x32) 
                return rewriteValueAMD64_OpLsh16x32_0(v);
            else if (v.Op == OpLsh16x64) 
                return rewriteValueAMD64_OpLsh16x64_0(v);
            else if (v.Op == OpLsh16x8) 
                return rewriteValueAMD64_OpLsh16x8_0(v);
            else if (v.Op == OpLsh32x16) 
                return rewriteValueAMD64_OpLsh32x16_0(v);
            else if (v.Op == OpLsh32x32) 
                return rewriteValueAMD64_OpLsh32x32_0(v);
            else if (v.Op == OpLsh32x64) 
                return rewriteValueAMD64_OpLsh32x64_0(v);
            else if (v.Op == OpLsh32x8) 
                return rewriteValueAMD64_OpLsh32x8_0(v);
            else if (v.Op == OpLsh64x16) 
                return rewriteValueAMD64_OpLsh64x16_0(v);
            else if (v.Op == OpLsh64x32) 
                return rewriteValueAMD64_OpLsh64x32_0(v);
            else if (v.Op == OpLsh64x64) 
                return rewriteValueAMD64_OpLsh64x64_0(v);
            else if (v.Op == OpLsh64x8) 
                return rewriteValueAMD64_OpLsh64x8_0(v);
            else if (v.Op == OpLsh8x16) 
                return rewriteValueAMD64_OpLsh8x16_0(v);
            else if (v.Op == OpLsh8x32) 
                return rewriteValueAMD64_OpLsh8x32_0(v);
            else if (v.Op == OpLsh8x64) 
                return rewriteValueAMD64_OpLsh8x64_0(v);
            else if (v.Op == OpLsh8x8) 
                return rewriteValueAMD64_OpLsh8x8_0(v);
            else if (v.Op == OpMod16) 
                return rewriteValueAMD64_OpMod16_0(v);
            else if (v.Op == OpMod16u) 
                return rewriteValueAMD64_OpMod16u_0(v);
            else if (v.Op == OpMod32) 
                return rewriteValueAMD64_OpMod32_0(v);
            else if (v.Op == OpMod32u) 
                return rewriteValueAMD64_OpMod32u_0(v);
            else if (v.Op == OpMod64) 
                return rewriteValueAMD64_OpMod64_0(v);
            else if (v.Op == OpMod64u) 
                return rewriteValueAMD64_OpMod64u_0(v);
            else if (v.Op == OpMod8) 
                return rewriteValueAMD64_OpMod8_0(v);
            else if (v.Op == OpMod8u) 
                return rewriteValueAMD64_OpMod8u_0(v);
            else if (v.Op == OpMove) 
                return rewriteValueAMD64_OpMove_0(v) || rewriteValueAMD64_OpMove_10(v);
            else if (v.Op == OpMul16) 
                return rewriteValueAMD64_OpMul16_0(v);
            else if (v.Op == OpMul32) 
                return rewriteValueAMD64_OpMul32_0(v);
            else if (v.Op == OpMul32F) 
                return rewriteValueAMD64_OpMul32F_0(v);
            else if (v.Op == OpMul64) 
                return rewriteValueAMD64_OpMul64_0(v);
            else if (v.Op == OpMul64F) 
                return rewriteValueAMD64_OpMul64F_0(v);
            else if (v.Op == OpMul64uhilo) 
                return rewriteValueAMD64_OpMul64uhilo_0(v);
            else if (v.Op == OpMul8) 
                return rewriteValueAMD64_OpMul8_0(v);
            else if (v.Op == OpNeg16) 
                return rewriteValueAMD64_OpNeg16_0(v);
            else if (v.Op == OpNeg32) 
                return rewriteValueAMD64_OpNeg32_0(v);
            else if (v.Op == OpNeg32F) 
                return rewriteValueAMD64_OpNeg32F_0(v);
            else if (v.Op == OpNeg64) 
                return rewriteValueAMD64_OpNeg64_0(v);
            else if (v.Op == OpNeg64F) 
                return rewriteValueAMD64_OpNeg64F_0(v);
            else if (v.Op == OpNeg8) 
                return rewriteValueAMD64_OpNeg8_0(v);
            else if (v.Op == OpNeq16) 
                return rewriteValueAMD64_OpNeq16_0(v);
            else if (v.Op == OpNeq32) 
                return rewriteValueAMD64_OpNeq32_0(v);
            else if (v.Op == OpNeq32F) 
                return rewriteValueAMD64_OpNeq32F_0(v);
            else if (v.Op == OpNeq64) 
                return rewriteValueAMD64_OpNeq64_0(v);
            else if (v.Op == OpNeq64F) 
                return rewriteValueAMD64_OpNeq64F_0(v);
            else if (v.Op == OpNeq8) 
                return rewriteValueAMD64_OpNeq8_0(v);
            else if (v.Op == OpNeqB) 
                return rewriteValueAMD64_OpNeqB_0(v);
            else if (v.Op == OpNeqPtr) 
                return rewriteValueAMD64_OpNeqPtr_0(v);
            else if (v.Op == OpNilCheck) 
                return rewriteValueAMD64_OpNilCheck_0(v);
            else if (v.Op == OpNot) 
                return rewriteValueAMD64_OpNot_0(v);
            else if (v.Op == OpOffPtr) 
                return rewriteValueAMD64_OpOffPtr_0(v);
            else if (v.Op == OpOr16) 
                return rewriteValueAMD64_OpOr16_0(v);
            else if (v.Op == OpOr32) 
                return rewriteValueAMD64_OpOr32_0(v);
            else if (v.Op == OpOr64) 
                return rewriteValueAMD64_OpOr64_0(v);
            else if (v.Op == OpOr8) 
                return rewriteValueAMD64_OpOr8_0(v);
            else if (v.Op == OpOrB) 
                return rewriteValueAMD64_OpOrB_0(v);
            else if (v.Op == OpPopCount16) 
                return rewriteValueAMD64_OpPopCount16_0(v);
            else if (v.Op == OpPopCount32) 
                return rewriteValueAMD64_OpPopCount32_0(v);
            else if (v.Op == OpPopCount64) 
                return rewriteValueAMD64_OpPopCount64_0(v);
            else if (v.Op == OpPopCount8) 
                return rewriteValueAMD64_OpPopCount8_0(v);
            else if (v.Op == OpRound32F) 
                return rewriteValueAMD64_OpRound32F_0(v);
            else if (v.Op == OpRound64F) 
                return rewriteValueAMD64_OpRound64F_0(v);
            else if (v.Op == OpRoundToEven) 
                return rewriteValueAMD64_OpRoundToEven_0(v);
            else if (v.Op == OpRsh16Ux16) 
                return rewriteValueAMD64_OpRsh16Ux16_0(v);
            else if (v.Op == OpRsh16Ux32) 
                return rewriteValueAMD64_OpRsh16Ux32_0(v);
            else if (v.Op == OpRsh16Ux64) 
                return rewriteValueAMD64_OpRsh16Ux64_0(v);
            else if (v.Op == OpRsh16Ux8) 
                return rewriteValueAMD64_OpRsh16Ux8_0(v);
            else if (v.Op == OpRsh16x16) 
                return rewriteValueAMD64_OpRsh16x16_0(v);
            else if (v.Op == OpRsh16x32) 
                return rewriteValueAMD64_OpRsh16x32_0(v);
            else if (v.Op == OpRsh16x64) 
                return rewriteValueAMD64_OpRsh16x64_0(v);
            else if (v.Op == OpRsh16x8) 
                return rewriteValueAMD64_OpRsh16x8_0(v);
            else if (v.Op == OpRsh32Ux16) 
                return rewriteValueAMD64_OpRsh32Ux16_0(v);
            else if (v.Op == OpRsh32Ux32) 
                return rewriteValueAMD64_OpRsh32Ux32_0(v);
            else if (v.Op == OpRsh32Ux64) 
                return rewriteValueAMD64_OpRsh32Ux64_0(v);
            else if (v.Op == OpRsh32Ux8) 
                return rewriteValueAMD64_OpRsh32Ux8_0(v);
            else if (v.Op == OpRsh32x16) 
                return rewriteValueAMD64_OpRsh32x16_0(v);
            else if (v.Op == OpRsh32x32) 
                return rewriteValueAMD64_OpRsh32x32_0(v);
            else if (v.Op == OpRsh32x64) 
                return rewriteValueAMD64_OpRsh32x64_0(v);
            else if (v.Op == OpRsh32x8) 
                return rewriteValueAMD64_OpRsh32x8_0(v);
            else if (v.Op == OpRsh64Ux16) 
                return rewriteValueAMD64_OpRsh64Ux16_0(v);
            else if (v.Op == OpRsh64Ux32) 
                return rewriteValueAMD64_OpRsh64Ux32_0(v);
            else if (v.Op == OpRsh64Ux64) 
                return rewriteValueAMD64_OpRsh64Ux64_0(v);
            else if (v.Op == OpRsh64Ux8) 
                return rewriteValueAMD64_OpRsh64Ux8_0(v);
            else if (v.Op == OpRsh64x16) 
                return rewriteValueAMD64_OpRsh64x16_0(v);
            else if (v.Op == OpRsh64x32) 
                return rewriteValueAMD64_OpRsh64x32_0(v);
            else if (v.Op == OpRsh64x64) 
                return rewriteValueAMD64_OpRsh64x64_0(v);
            else if (v.Op == OpRsh64x8) 
                return rewriteValueAMD64_OpRsh64x8_0(v);
            else if (v.Op == OpRsh8Ux16) 
                return rewriteValueAMD64_OpRsh8Ux16_0(v);
            else if (v.Op == OpRsh8Ux32) 
                return rewriteValueAMD64_OpRsh8Ux32_0(v);
            else if (v.Op == OpRsh8Ux64) 
                return rewriteValueAMD64_OpRsh8Ux64_0(v);
            else if (v.Op == OpRsh8Ux8) 
                return rewriteValueAMD64_OpRsh8Ux8_0(v);
            else if (v.Op == OpRsh8x16) 
                return rewriteValueAMD64_OpRsh8x16_0(v);
            else if (v.Op == OpRsh8x32) 
                return rewriteValueAMD64_OpRsh8x32_0(v);
            else if (v.Op == OpRsh8x64) 
                return rewriteValueAMD64_OpRsh8x64_0(v);
            else if (v.Op == OpRsh8x8) 
                return rewriteValueAMD64_OpRsh8x8_0(v);
            else if (v.Op == OpSelect0) 
                return rewriteValueAMD64_OpSelect0_0(v);
            else if (v.Op == OpSelect1) 
                return rewriteValueAMD64_OpSelect1_0(v);
            else if (v.Op == OpSignExt16to32) 
                return rewriteValueAMD64_OpSignExt16to32_0(v);
            else if (v.Op == OpSignExt16to64) 
                return rewriteValueAMD64_OpSignExt16to64_0(v);
            else if (v.Op == OpSignExt32to64) 
                return rewriteValueAMD64_OpSignExt32to64_0(v);
            else if (v.Op == OpSignExt8to16) 
                return rewriteValueAMD64_OpSignExt8to16_0(v);
            else if (v.Op == OpSignExt8to32) 
                return rewriteValueAMD64_OpSignExt8to32_0(v);
            else if (v.Op == OpSignExt8to64) 
                return rewriteValueAMD64_OpSignExt8to64_0(v);
            else if (v.Op == OpSlicemask) 
                return rewriteValueAMD64_OpSlicemask_0(v);
            else if (v.Op == OpSqrt) 
                return rewriteValueAMD64_OpSqrt_0(v);
            else if (v.Op == OpStaticCall) 
                return rewriteValueAMD64_OpStaticCall_0(v);
            else if (v.Op == OpStore) 
                return rewriteValueAMD64_OpStore_0(v);
            else if (v.Op == OpSub16) 
                return rewriteValueAMD64_OpSub16_0(v);
            else if (v.Op == OpSub32) 
                return rewriteValueAMD64_OpSub32_0(v);
            else if (v.Op == OpSub32F) 
                return rewriteValueAMD64_OpSub32F_0(v);
            else if (v.Op == OpSub64) 
                return rewriteValueAMD64_OpSub64_0(v);
            else if (v.Op == OpSub64F) 
                return rewriteValueAMD64_OpSub64F_0(v);
            else if (v.Op == OpSub8) 
                return rewriteValueAMD64_OpSub8_0(v);
            else if (v.Op == OpSubPtr) 
                return rewriteValueAMD64_OpSubPtr_0(v);
            else if (v.Op == OpTrunc) 
                return rewriteValueAMD64_OpTrunc_0(v);
            else if (v.Op == OpTrunc16to8) 
                return rewriteValueAMD64_OpTrunc16to8_0(v);
            else if (v.Op == OpTrunc32to16) 
                return rewriteValueAMD64_OpTrunc32to16_0(v);
            else if (v.Op == OpTrunc32to8) 
                return rewriteValueAMD64_OpTrunc32to8_0(v);
            else if (v.Op == OpTrunc64to16) 
                return rewriteValueAMD64_OpTrunc64to16_0(v);
            else if (v.Op == OpTrunc64to32) 
                return rewriteValueAMD64_OpTrunc64to32_0(v);
            else if (v.Op == OpTrunc64to8) 
                return rewriteValueAMD64_OpTrunc64to8_0(v);
            else if (v.Op == OpWB) 
                return rewriteValueAMD64_OpWB_0(v);
            else if (v.Op == OpXor16) 
                return rewriteValueAMD64_OpXor16_0(v);
            else if (v.Op == OpXor32) 
                return rewriteValueAMD64_OpXor32_0(v);
            else if (v.Op == OpXor64) 
                return rewriteValueAMD64_OpXor64_0(v);
            else if (v.Op == OpXor8) 
                return rewriteValueAMD64_OpXor8_0(v);
            else if (v.Op == OpZero) 
                return rewriteValueAMD64_OpZero_0(v) || rewriteValueAMD64_OpZero_10(v) || rewriteValueAMD64_OpZero_20(v);
            else if (v.Op == OpZeroExt16to32) 
                return rewriteValueAMD64_OpZeroExt16to32_0(v);
            else if (v.Op == OpZeroExt16to64) 
                return rewriteValueAMD64_OpZeroExt16to64_0(v);
            else if (v.Op == OpZeroExt32to64) 
                return rewriteValueAMD64_OpZeroExt32to64_0(v);
            else if (v.Op == OpZeroExt8to16) 
                return rewriteValueAMD64_OpZeroExt8to16_0(v);
            else if (v.Op == OpZeroExt8to32) 
                return rewriteValueAMD64_OpZeroExt8to32_0(v);
            else if (v.Op == OpZeroExt8to64) 
                return rewriteValueAMD64_OpZeroExt8to64_0(v);
                        return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDL_0(ref Value v)
        { 
            // match: (ADDL x (MOVLconst [c]))
            // cond:
            // result: (ADDLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL (MOVLconst [c]) x)
            // cond:
            // result: (ADDLconst [c] x)
 
            // match: (ADDL (MOVLconst [c]) x)
            // cond:
            // result: (ADDLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (ADDL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (ADDL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (ADDL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (ADDL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (ADDL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (ADDL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDL x (NEGL y))
            // cond:
            // result: (SUBL x y)
 
            // match: (ADDL x (NEGL y))
            // cond:
            // result: (SUBL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDL (NEGL y) x)
            // cond:
            // result: (SUBL x y)
 
            // match: (ADDL (NEGL y) x)
            // cond:
            // result: (SUBL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDL_10(ref Value v)
        { 
            // match: (ADDL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDLmem x [off] {sym} ptr mem)
 
            // match: (ADDL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDLconst_0(ref Value v)
        { 
            // match: (ADDLconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [int64(int32(c+d))])
 
            // match: (ADDLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [int64(int32(c+d))])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = int64(int32(c + d));
                return true;
            } 
            // match: (ADDLconst [c] (ADDLconst [d] x))
            // cond:
            // result: (ADDLconst [int64(int32(c+d))] x)
 
            // match: (ADDLconst [c] (ADDLconst [d] x))
            // cond:
            // result: (ADDLconst [int64(int32(c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDLconst [c] (LEAL [d] {s} x))
            // cond: is32Bit(c+d)
            // result: (LEAL [c+d] {s} x)
 
            // match: (ADDLconst [c] (LEAL [d] {s} x))
            // cond: is32Bit(c+d)
            // result: (LEAL [c+d] {s} x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                d = v_0.AuxInt;
                var s = v_0.Aux;
                x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAL);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDLconstmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDLconstmem [valOff] {sym} ptr (MOVSSstore [ValAndOff(valOff).Off()] {sym} ptr x _))
            // cond:
            // result: (ADDLconst [ValAndOff(valOff).Val()] (MOVLf2i x))
            while (true)
            {
                var valOff = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_1.AuxInt != ValAndOff(valOff).Off())
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var x = v_1.Args[1L];
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = ValAndOff(valOff).Val();
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDLmem x [off] {sym} ptr (MOVSSstore [off] {sym} ptr y _))
            // cond:
            // result: (ADDL x (MOVLf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ADDL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQ_0(ref Value v)
        { 
            // match: (ADDQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (ADDQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDQconst [c] x)
 
            // match: (ADDQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (ADDQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (ADDQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ x (SHLQconst [3] y))
            // cond:
            // result: (LEAQ8 x y)
 
            // match: (ADDQ x (SHLQconst [3] y))
            // cond:
            // result: (LEAQ8 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (SHLQconst [3] y) x)
            // cond:
            // result: (LEAQ8 x y)
 
            // match: (ADDQ (SHLQconst [3] y) x)
            // cond:
            // result: (LEAQ8 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 3L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ4 x y)
 
            // match: (ADDQ x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ4 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (SHLQconst [2] y) x)
            // cond:
            // result: (LEAQ4 x y)
 
            // match: (ADDQ (SHLQconst [2] y) x)
            // cond:
            // result: (LEAQ4 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 2L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ2 x y)
 
            // match: (ADDQ x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ2 x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (SHLQconst [1] y) x)
            // cond:
            // result: (LEAQ2 x y)
 
            // match: (ADDQ (SHLQconst [1] y) x)
            // cond:
            // result: (LEAQ2 x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQ_10(ref Value v)
        { 
            // match: (ADDQ x (ADDQ y y))
            // cond:
            // result: (LEAQ2 x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (ADDQ y y) x)
            // cond:
            // result: (LEAQ2 x y)
 
            // match: (ADDQ (ADDQ y y) x)
            // cond:
            // result: (LEAQ2 x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                if (y != v_0.Args[1L])
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ x (ADDQ x y))
            // cond:
            // result: (LEAQ2 y x)
 
            // match: (ADDQ x (ADDQ x y))
            // cond:
            // result: (LEAQ2 y x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ x (ADDQ y x))
            // cond:
            // result: (LEAQ2 y x)
 
            // match: (ADDQ x (ADDQ y x))
            // cond:
            // result: (LEAQ2 y x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                if (x != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (ADDQ x y) x)
            // cond:
            // result: (LEAQ2 y x)
 
            // match: (ADDQ (ADDQ x y) x)
            // cond:
            // result: (LEAQ2 y x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (ADDQ y x) x)
            // cond:
            // result: (LEAQ2 y x)
 
            // match: (ADDQ (ADDQ y x) x)
            // cond:
            // result: (LEAQ2 y x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                x = v_0.Args[1L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQ (ADDQconst [c] x) y)
            // cond:
            // result: (LEAQ1 [c] x y)
 
            // match: (ADDQ (ADDQconst [c] x) y)
            // cond:
            // result: (LEAQ1 [c] x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                y = v.Args[1L];
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ y (ADDQconst [c] x))
            // cond:
            // result: (LEAQ1 [c] x y)
 
            // match: (ADDQ y (ADDQconst [c] x))
            // cond:
            // result: (LEAQ1 [c] x y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                x = v_1.Args[0L];
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ x (LEAQ [c] {s} y))
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
 
            // match: (ADDQ x (LEAQ [c] {s} y))
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64LEAQ)
                {
                    break;
                }
                c = v_1.AuxInt;
                var s = v_1.Aux;
                y = v_1.Args[0L];
                if (!(x.Op != OpSB && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (LEAQ [c] {s} y) x)
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
 
            // match: (ADDQ (LEAQ [c] {s} y) x)
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                c = v_0.AuxInt;
                s = v_0.Aux;
                y = v_0.Args[0L];
                x = v.Args[1L];
                if (!(x.Op != OpSB && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQ_20(ref Value v)
        { 
            // match: (ADDQ x (NEGQ y))
            // cond:
            // result: (SUBQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64SUBQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ (NEGQ y) x)
            // cond:
            // result: (SUBQ x y)
 
            // match: (ADDQ (NEGQ y) x)
            // cond:
            // result: (SUBQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64SUBQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDQmem x [off] {sym} ptr mem)
 
            // match: (ADDQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDQmem x [off] {sym} ptr mem)
 
            // match: (ADDQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQconst_0(ref Value v)
        { 
            // match: (ADDQconst [c] (ADDQ x y))
            // cond:
            // result: (LEAQ1 [c] x y)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQconst [c] (LEAQ [d] {s} x))
            // cond: is32Bit(c+d)
            // result: (LEAQ [c+d] {s} x)
 
            // match: (ADDQconst [c] (LEAQ [d] {s} x))
            // cond: is32Bit(c+d)
            // result: (LEAQ [c+d] {s} x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var s = v_0.Aux;
                x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQconst [c] (LEAQ1 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ1 [c+d] {s} x y)
 
            // match: (ADDQconst [c] (LEAQ1 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ1 [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQconst [c] (LEAQ2 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ2 [c+d] {s} x y)
 
            // match: (ADDQconst [c] (LEAQ2 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ2 [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ2)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQconst [c] (LEAQ4 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ4 [c+d] {s} x y)
 
            // match: (ADDQconst [c] (LEAQ4 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ4 [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQconst [c] (LEAQ8 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ8 [c+d] {s} x y)
 
            // match: (ADDQconst [c] (LEAQ8 [d] {s} x y))
            // cond: is32Bit(c+d)
            // result: (LEAQ8 [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                d = v_0.AuxInt;
                s = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDQconst [0] x)
            // cond:
            // result: x
 
            // match: (ADDQconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c+d])
 
            // match: (ADDQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c+d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = c + d;
                return true;
            } 
            // match: (ADDQconst [c] (ADDQconst [d] x))
            // cond: is32Bit(c+d)
            // result: (ADDQconst [c+d] x)
 
            // match: (ADDQconst [c] (ADDQconst [d] x))
            // cond: is32Bit(c+d)
            // result: (ADDQconst [c+d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = c + d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQconstmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDQconstmem [valOff] {sym} ptr (MOVSDstore [ValAndOff(valOff).Off()] {sym} ptr x _))
            // cond:
            // result: (ADDQconst [ValAndOff(valOff).Val()] (MOVQf2i x))
            while (true)
            {
                var valOff = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_1.AuxInt != ValAndOff(valOff).Off())
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var x = v_1.Args[1L];
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = ValAndOff(valOff).Val();
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDQmem x [off] {sym} ptr (MOVSDstore [off] {sym} ptr y _))
            // cond:
            // result: (ADDQ x (MOVQf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ADDQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDSD_0(ref Value v)
        { 
            // match: (ADDSD x l:(MOVSDload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSDmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSDload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDSDmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDSD l:(MOVSDload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSDmem x [off] {sym} ptr mem)
 
            // match: (ADDSD l:(MOVSDload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSDmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVSDload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDSDmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDSDmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDSDmem x [off] {sym} ptr (MOVQstore [off] {sym} ptr y _))
            // cond:
            // result: (ADDSD x (MOVQi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVQstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ADDSD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDSS_0(ref Value v)
        { 
            // match: (ADDSS x l:(MOVSSload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSSmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSSload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDSSmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ADDSS l:(MOVSSload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSSmem x [off] {sym} ptr mem)
 
            // match: (ADDSS l:(MOVSSload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ADDSSmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVSSload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ADDSSmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ADDSSmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADDSSmem x [off] {sym} ptr (MOVLstore [off] {sym} ptr y _))
            // cond:
            // result: (ADDSS x (MOVLi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ADDSS);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDL_0(ref Value v)
        { 
            // match: (ANDL x (MOVLconst [c]))
            // cond:
            // result: (ANDLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDL (MOVLconst [c]) x)
            // cond:
            // result: (ANDLconst [c] x)
 
            // match: (ANDL (MOVLconst [c]) x)
            // cond:
            // result: (ANDLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDL x x)
            // cond:
            // result: x
 
            // match: (ANDL x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDLmem x [off] {sym} ptr mem)
 
            // match: (ANDL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ANDLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDLmem x [off] {sym} ptr mem)
 
            // match: (ANDL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ANDLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDLconst_0(ref Value v)
        { 
            // match: (ANDLconst [c] (ANDLconst [d] x))
            // cond:
            // result: (ANDLconst [c & d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDLconst [0xFF] x)
            // cond:
            // result: (MOVBQZX x)
 
            // match: (ANDLconst [0xFF] x)
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                if (v.AuxInt != 0xFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDLconst [0xFFFF] x)
            // cond:
            // result: (MOVWQZX x)
 
            // match: (ANDLconst [0xFFFF] x)
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                if (v.AuxInt != 0xFFFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDLconst [c] _)
            // cond: int32(c)==0
            // result: (MOVLconst [0])
 
            // match: (ANDLconst [c] _)
            // cond: int32(c)==0
            // result: (MOVLconst [0])
            while (true)
            {
                c = v.AuxInt;
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDLconst [c] x)
            // cond: int32(c)==-1
            // result: x
 
            // match: (ANDLconst [c] x)
            // cond: int32(c)==-1
            // result: x
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c&d])
 
            // match: (ANDLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c&d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = c & d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ANDLmem x [off] {sym} ptr (MOVSSstore [off] {sym} ptr y _))
            // cond:
            // result: (ANDL x (MOVLf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ANDL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDQ_0(ref Value v)
        { 
            // match: (ANDQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (ANDQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ANDQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ANDQconst [c] x)
 
            // match: (ANDQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ANDQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ANDQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQ x x)
            // cond:
            // result: x
 
            // match: (ANDQ x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDQmem x [off] {sym} ptr mem)
 
            // match: (ANDQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ANDQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ANDQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDQmem x [off] {sym} ptr mem)
 
            // match: (ANDQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ANDQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ANDQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDQconst_0(ref Value v)
        { 
            // match: (ANDQconst [c] (ANDQconst [d] x))
            // cond:
            // result: (ANDQconst [c & d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ANDQconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQconst [0xFF] x)
            // cond:
            // result: (MOVBQZX x)
 
            // match: (ANDQconst [0xFF] x)
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                if (v.AuxInt != 0xFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQconst [0xFFFF] x)
            // cond:
            // result: (MOVWQZX x)
 
            // match: (ANDQconst [0xFFFF] x)
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                if (v.AuxInt != 0xFFFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQconst [0xFFFFFFFF] x)
            // cond:
            // result: (MOVLQZX x)
 
            // match: (ANDQconst [0xFFFFFFFF] x)
            // cond:
            // result: (MOVLQZX x)
            while (true)
            {
                if (v.AuxInt != 0xFFFFFFFFUL)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64MOVLQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQconst [0] _)
            // cond:
            // result: (MOVQconst [0])
 
            // match: (ANDQconst [0] _)
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDQconst [-1] x)
            // cond:
            // result: x
 
            // match: (ANDQconst [-1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c&d])
 
            // match: (ANDQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c&d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = c & d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ANDQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ANDQmem x [off] {sym} ptr (MOVSDstore [off] {sym} ptr y _))
            // cond:
            // result: (ANDQ x (MOVQf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ANDQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64BSFQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (BSFQ (ORQconst <t> [1<<8] (MOVBQZX x)))
            // cond:
            // result: (BSFQ (ORQconst <t> [1<<8] x))
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ORQconst)
                {
                    break;
                }
                var t = v_0.Type;
                if (v_0.AuxInt != 1L << (int)(8L))
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                v.reset(OpAMD64BSFQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQconst, t);
                v0.AuxInt = 1L << (int)(8L);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (BSFQ (ORQconst <t> [1<<16] (MOVWQZX x)))
            // cond:
            // result: (BSFQ (ORQconst <t> [1<<16] x))
 
            // match: (BSFQ (ORQconst <t> [1<<16] (MOVWQZX x)))
            // cond:
            // result: (BSFQ (ORQconst <t> [1<<16] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ORQconst)
                {
                    break;
                }
                t = v_0.Type;
                if (v_0.AuxInt != 1L << (int)(16L))
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64MOVWQZX)
                {
                    break;
                }
                x = v_0_0.Args[0L];
                v.reset(OpAMD64BSFQ);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQconst, t);
                v0.AuxInt = 1L << (int)(16L);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64BTQconst_0(ref Value v)
        { 
            // match: (BTQconst [c] x)
            // cond: c < 32
            // result: (BTLconst [c] x)
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(c < 32L))
                {
                    break;
                }
                v.reset(OpAMD64BTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMOVQEQ_0(ref Value v)
        { 
            // match: (CMOVQEQ x _ (Select1 (BSFQ (ORQconst [c] _))))
            // cond: c != 0
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpSelect1)
                {
                    break;
                }
                var v_2_0 = v_2.Args[0L];
                if (v_2_0.Op != OpAMD64BSFQ)
                {
                    break;
                }
                var v_2_0_0 = v_2_0.Args[0L];
                if (v_2_0_0.Op != OpAMD64ORQconst)
                {
                    break;
                }
                var c = v_2_0_0.AuxInt;
                if (!(c != 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPB_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPB x (MOVLconst [c]))
            // cond:
            // result: (CMPBconst x [int64(int8(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64CMPBconst);
                v.AuxInt = int64(int8(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPB (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPBconst x [int64(int8(c))]))
 
            // match: (CMPB (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPBconst x [int64(int8(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v0.AuxInt = int64(int8(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPBconst_0(ref Value v)
        { 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)==int8(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int8(x) == int8(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagEQ);
                return true;
            } 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)<int8(y) && uint8(x)<uint8(y)
            // result: (FlagLT_ULT)
 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)<int8(y) && uint8(x)<uint8(y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int8(x) < int8(y) && uint8(x) < uint8(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)<int8(y) && uint8(x)>uint8(y)
            // result: (FlagLT_UGT)
 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)<int8(y) && uint8(x)>uint8(y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int8(x) < int8(y) && uint8(x) > uint8(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_UGT);
                return true;
            } 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)>int8(y) && uint8(x)<uint8(y)
            // result: (FlagGT_ULT)
 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)>int8(y) && uint8(x)<uint8(y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int8(x) > int8(y) && uint8(x) < uint8(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_ULT);
                return true;
            } 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)>int8(y) && uint8(x)>uint8(y)
            // result: (FlagGT_UGT)
 
            // match: (CMPBconst (MOVLconst [x]) [y])
            // cond: int8(x)>int8(y) && uint8(x)>uint8(y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int8(x) > int8(y) && uint8(x) > uint8(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_UGT);
                return true;
            } 
            // match: (CMPBconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int8(m) && int8(m) < int8(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPBconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int8(m) && int8(m) < int8(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= int8(m) && int8(m) < int8(n)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPBconst (ANDL x y) [0])
            // cond:
            // result: (TESTB x y)
 
            // match: (CMPBconst (ANDL x y) [0])
            // cond:
            // result: (TESTB x y)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpAMD64TESTB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPBconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTBconst [int64(int8(c))] x)
 
            // match: (CMPBconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTBconst [int64(int8(c))] x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64TESTBconst);
                v.AuxInt = int64(int8(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPBconst x [0])
            // cond:
            // result: (TESTB x x)
 
            // match: (CMPBconst x [0])
            // cond:
            // result: (TESTB x x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64TESTB);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPL x (MOVLconst [c]))
            // cond:
            // result: (CMPLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64CMPLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPL (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPLconst x [c]))
 
            // match: (CMPL (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPLconst x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPLconst_0(ref Value v)
        { 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)==int32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagEQ);
                return true;
            } 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)<uint32(y)
            // result: (FlagLT_ULT)
 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)<uint32(y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y) && uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)>uint32(y)
            // result: (FlagLT_UGT)
 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)>uint32(y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y) && uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_UGT);
                return true;
            } 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)<uint32(y)
            // result: (FlagGT_ULT)
 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)<uint32(y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y) && uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_ULT);
                return true;
            } 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)>uint32(y)
            // result: (FlagGT_UGT)
 
            // match: (CMPLconst (MOVLconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)>uint32(y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y) && uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_UGT);
                return true;
            } 
            // match: (CMPLconst (SHRLconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPLconst (SHRLconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                if (!(0L <= n && 0L < c && c <= 32L && (1L << (int)(uint64(32L - c))) <= uint64(n)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPLconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPLconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= int32(m) && int32(m) < int32(n)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPLconst (ANDL x y) [0])
            // cond:
            // result: (TESTL x y)
 
            // match: (CMPLconst (ANDL x y) [0])
            // cond:
            // result: (TESTL x y)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpAMD64TESTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPLconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTLconst [c] x)
 
            // match: (CMPLconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTLconst [c] x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64TESTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPLconst x [0])
            // cond:
            // result: (TESTL x x)
 
            // match: (CMPLconst x [0])
            // cond:
            // result: (TESTL x x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64TESTL);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (CMPQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64CMPQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (InvertFlags (CMPQconst x [c]))
 
            // match: (CMPQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (InvertFlags (CMPQconst x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPQconst_0(ref Value v)
        { 
            // match: (CMPQconst (NEGQ (ADDQconst [-16] (ANDQconst [15] _))) [32])
            // cond:
            // result: (FlagLT_ULT)
            while (true)
            {
                if (v.AuxInt != 32L)
                {
                    break;
                }
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (NEGQ (ADDQconst [ -8] (ANDQconst [7] _))) [32])
            // cond:
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (NEGQ (ADDQconst [ -8] (ANDQconst [7] _))) [32])
            // cond:
            // result: (FlagLT_ULT)
            while (true)
            {
                if (v.AuxInt != 32L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x==y
            // result: (FlagEQ)
 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x==y
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(x == y))
                {
                    break;
                }
                v.reset(OpAMD64FlagEQ);
                return true;
            } 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x<y && uint64(x)<uint64(y)
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x<y && uint64(x)<uint64(y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x < y && uint64(x) < uint64(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x<y && uint64(x)>uint64(y)
            // result: (FlagLT_UGT)
 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x<y && uint64(x)>uint64(y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x < y && uint64(x) > uint64(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_UGT);
                return true;
            } 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x>y && uint64(x)<uint64(y)
            // result: (FlagGT_ULT)
 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x>y && uint64(x)<uint64(y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x > y && uint64(x) < uint64(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_ULT);
                return true;
            } 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x>y && uint64(x)>uint64(y)
            // result: (FlagGT_UGT)
 
            // match: (CMPQconst (MOVQconst [x]) [y])
            // cond: x>y && uint64(x)>uint64(y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(x > y && uint64(x) > uint64(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_UGT);
                return true;
            } 
            // match: (CMPQconst (MOVBQZX _) [c])
            // cond: 0xFF < c
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (MOVBQZX _) [c])
            // cond: 0xFF < c
            // result: (FlagLT_ULT)
            while (true)
            {
                var c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                if (!(0xFFUL < c))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (MOVWQZX _) [c])
            // cond: 0xFFFF < c
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (MOVWQZX _) [c])
            // cond: 0xFFFF < c
            // result: (FlagLT_ULT)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVWQZX)
                {
                    break;
                }
                if (!(0xFFFFUL < c))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (MOVLQZX _) [c])
            // cond: 0xFFFFFFFF < c
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (MOVLQZX _) [c])
            // cond: 0xFFFFFFFF < c
            // result: (FlagLT_ULT)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLQZX)
                {
                    break;
                }
                if (!(0xFFFFFFFFUL < c))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPQconst_10(ref Value v)
        { 
            // match: (CMPQconst (SHRQconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 64 && (1<<uint64(64-c)) <= uint64(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                var n = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                if (!(0L <= n && 0L < c && c <= 64L && (1L << (int)(uint64(64L - c))) <= uint64(n)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (ANDQconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (ANDQconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT_ULT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= m && m < n))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (ANDLconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT_ULT)
 
            // match: (CMPQconst (ANDLconst _ [m]) [n])
            // cond: 0 <= m && m < n
            // result: (FlagLT_ULT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                m = v_0.AuxInt;
                if (!(0L <= m && m < n))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPQconst (ANDQ x y) [0])
            // cond:
            // result: (TESTQ x y)
 
            // match: (CMPQconst (ANDQ x y) [0])
            // cond:
            // result: (TESTQ x y)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpAMD64TESTQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPQconst (ANDQconst [c] x) [0])
            // cond:
            // result: (TESTQconst [c] x)
 
            // match: (CMPQconst (ANDQconst [c] x) [0])
            // cond:
            // result: (TESTQconst [c] x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64TESTQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPQconst x [0])
            // cond:
            // result: (TESTQ x x)
 
            // match: (CMPQconst x [0])
            // cond:
            // result: (TESTQ x x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64TESTQ);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPW_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPW x (MOVLconst [c]))
            // cond:
            // result: (CMPWconst x [int64(int16(c))])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64CMPWconst);
                v.AuxInt = int64(int16(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPW (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWconst x [int64(int16(c))]))
 
            // match: (CMPW (MOVLconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPWconst x [int64(int16(c))]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v0.AuxInt = int64(int16(c));
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPWconst_0(ref Value v)
        { 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)==int16(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int16(x) == int16(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagEQ);
                return true;
            } 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)<int16(y) && uint16(x)<uint16(y)
            // result: (FlagLT_ULT)
 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)<int16(y) && uint16(x)<uint16(y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int16(x) < int16(y) && uint16(x) < uint16(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)<int16(y) && uint16(x)>uint16(y)
            // result: (FlagLT_UGT)
 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)<int16(y) && uint16(x)>uint16(y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int16(x) < int16(y) && uint16(x) > uint16(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_UGT);
                return true;
            } 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)>int16(y) && uint16(x)<uint16(y)
            // result: (FlagGT_ULT)
 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)>int16(y) && uint16(x)<uint16(y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int16(x) > int16(y) && uint16(x) < uint16(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_ULT);
                return true;
            } 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)>int16(y) && uint16(x)>uint16(y)
            // result: (FlagGT_UGT)
 
            // match: (CMPWconst (MOVLconst [x]) [y])
            // cond: int16(x)>int16(y) && uint16(x)>uint16(y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int16(x) > int16(y) && uint16(x) > uint16(y)))
                {
                    break;
                }
                v.reset(OpAMD64FlagGT_UGT);
                return true;
            } 
            // match: (CMPWconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int16(m) && int16(m) < int16(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPWconst (ANDLconst _ [m]) [n])
            // cond: 0 <= int16(m) && int16(m) < int16(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= int16(m) && int16(m) < int16(n)))
                {
                    break;
                }
                v.reset(OpAMD64FlagLT_ULT);
                return true;
            } 
            // match: (CMPWconst (ANDL x y) [0])
            // cond:
            // result: (TESTW x y)
 
            // match: (CMPWconst (ANDL x y) [0])
            // cond:
            // result: (TESTW x y)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpAMD64TESTW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPWconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTWconst [int64(int16(c))] x)
 
            // match: (CMPWconst (ANDLconst [c] x) [0])
            // cond:
            // result: (TESTWconst [int64(int16(c))] x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64TESTWconst);
                v.AuxInt = int64(int16(c));
                v.AddArg(x);
                return true;
            } 
            // match: (CMPWconst x [0])
            // cond:
            // result: (TESTW x x)
 
            // match: (CMPWconst x [0])
            // cond:
            // result: (TESTW x x)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64TESTW);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPXCHGLlock_0(ref Value v)
        { 
            // match: (CMPXCHGLlock [off1] {sym} (ADDQconst [off2] ptr) old new_ mem)
            // cond: is32Bit(off1+off2)
            // result: (CMPXCHGLlock [off1+off2] {sym} ptr old new_ mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64CMPXCHGLlock);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64CMPXCHGQlock_0(ref Value v)
        { 
            // match: (CMPXCHGQlock [off1] {sym} (ADDQconst [off2] ptr) old new_ mem)
            // cond: is32Bit(off1+off2)
            // result: (CMPXCHGQlock [off1+off2] {sym} ptr old new_ mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64CMPXCHGQlock);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAL_0(ref Value v)
        { 
            // match: (LEAL [c] {s} (ADDLconst [d] x))
            // cond: is32Bit(c+d)
            // result: (LEAL [c+d] {s} x)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAL);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAQ_0(ref Value v)
        { 
            // match: (LEAQ [c] {s} (ADDQconst [d] x))
            // cond: is32Bit(c+d)
            // result: (LEAQ [c+d] {s} x)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                return true;
            } 
            // match: (LEAQ [c] {s} (ADDQ x y))
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
 
            // match: (LEAQ [c] {s} (ADDQ x y))
            // cond: x.Op != OpSB && y.Op != OpSB
            // result: (LEAQ1 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                if (!(x.Op != OpSB && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ [off1] {sym1} (LEAQ [off2] {sym2} x))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ [off1+off2] {mergeSym(sym1,sym2)} x)
 
            // match: (LEAQ [off1] {sym1} (LEAQ [off2] {sym2} x))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ [off1+off2] {mergeSym(sym1,sym2)} x)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                return true;
            } 
            // match: (LEAQ [off1] {sym1} (LEAQ1 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ [off1] {sym1} (LEAQ1 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ [off1] {sym1} (LEAQ2 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ2 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ [off1] {sym1} (LEAQ2 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ2 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ2)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ [off1] {sym1} (LEAQ4 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ4 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ [off1] {sym1} (LEAQ4 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ4 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ [off1] {sym1} (LEAQ8 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ8 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ [off1] {sym1} (LEAQ8 [off2] {sym2} x y))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (LEAQ8 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAQ1_0(ref Value v)
        { 
            // match: (LEAQ1 [c] {s} (ADDQconst [d] x) y)
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ1 [c+d] {s} x y)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(is32Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} y (ADDQconst [d] x))
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ1 [c+d] {s} x y)
 
            // match: (LEAQ1 [c] {s} y (ADDQconst [d] x))
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ1 [c+d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                x = v_1.Args[0L];
                if (!(is32Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ2 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ2 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} (SHLQconst [1] y) x)
            // cond:
            // result: (LEAQ2 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} (SHLQconst [1] y) x)
            // cond:
            // result: (LEAQ2 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ4 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ4 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} (SHLQconst [2] y) x)
            // cond:
            // result: (LEAQ4 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} (SHLQconst [2] y) x)
            // cond:
            // result: (LEAQ4 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 2L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} x (SHLQconst [3] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} x (SHLQconst [3] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [c] {s} (SHLQconst [3] y) x)
            // cond:
            // result: (LEAQ8 [c] {s} x y)
 
            // match: (LEAQ1 [c] {s} (SHLQconst [3] y) x)
            // cond:
            // result: (LEAQ8 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 3L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ1 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                y = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ1 [off1] {sym1} y (LEAQ [off2] {sym2} x))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ1 [off1] {sym1} y (LEAQ [off2] {sym2} x))
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ1 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                y = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                x = v_1.Args[0L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAQ2_0(ref Value v)
        { 
            // match: (LEAQ2 [c] {s} (ADDQconst [d] x) y)
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ2 [c+d] {s} x y)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(is32Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ2 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+2*d) && y.Op != OpSB
            // result: (LEAQ2 [c+2*d] {s} x y)
 
            // match: (LEAQ2 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+2*d) && y.Op != OpSB
            // result: (LEAQ2 [c+2*d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(is32Bit(c + 2L * d) && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = c + 2L * d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ2 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ4 [c] {s} x y)
 
            // match: (LEAQ2 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ4 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ2 [c] {s} x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
 
            // match: (LEAQ2 [c] {s} x (SHLQconst [2] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ2 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ2 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ2 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ2 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                y = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAQ4_0(ref Value v)
        { 
            // match: (LEAQ4 [c] {s} (ADDQconst [d] x) y)
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ4 [c+d] {s} x y)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(is32Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ4 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+4*d) && y.Op != OpSB
            // result: (LEAQ4 [c+4*d] {s} x y)
 
            // match: (LEAQ4 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+4*d) && y.Op != OpSB
            // result: (LEAQ4 [c+4*d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(is32Bit(c + 4L * d) && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = c + 4L * d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ4 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
 
            // match: (LEAQ4 [c] {s} x (SHLQconst [1] y))
            // cond:
            // result: (LEAQ8 [c] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ4 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ4 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ4 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ4 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                y = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64LEAQ8_0(ref Value v)
        { 
            // match: (LEAQ8 [c] {s} (ADDQconst [d] x) y)
            // cond: is32Bit(c+d)   && x.Op != OpSB
            // result: (LEAQ8 [c+d] {s} x y)
            while (true)
            {
                var c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(is32Bit(c + d) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c + d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ8 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+8*d) && y.Op != OpSB
            // result: (LEAQ8 [c+8*d] {s} x y)
 
            // match: (LEAQ8 [c] {s} x (ADDQconst [d] y))
            // cond: is32Bit(c+8*d) && y.Op != OpSB
            // result: (LEAQ8 [c+8*d] {s} x y)
            while (true)
            {
                c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(is32Bit(c + 8L * d) && y.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = c + 8L * d;
                v.Aux = s;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (LEAQ8 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ8 [off1+off2] {mergeSym(sym1,sym2)} x y)
 
            // match: (LEAQ8 [off1] {sym1} (LEAQ [off2] {sym2} x) y)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && x.Op != OpSB
            // result: (LEAQ8 [off1+off2] {mergeSym(sym1,sym2)} x y)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                x = v_0.Args[0L];
                y = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && x.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBQSX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBQSX x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQSX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQSX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQSX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQSX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQSX (ANDLconst [c] x))
            // cond: c & 0x80 == 0
            // result: (ANDLconst [c & 0x7f] x)
 
            // match: (MOVBQSX (ANDLconst [c] x))
            // cond: c & 0x80 == 0
            // result: (ANDLconst [c & 0x7f] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(c & 0x80UL == 0L))
                {
                    break;
                }
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & 0x7fUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
 
            // match: (MOVBQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBQSXload_0(ref Value v)
        { 
            // match: (MOVBQSXload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBQSX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVBQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBQSXload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBQZX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBQZX x:(MOVBload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQZX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQZX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVWload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQZX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQZX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVBQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQZX x:(MOVBloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx1 <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVBQZX x:(MOVBloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVBloadidx1 <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVBQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c & 0xff] x)
 
            // match: (MOVBQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c & 0xff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & 0xffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
 
            // match: (MOVBQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBload_0(ref Value v)
        { 
            // match: (MOVBload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBQZX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVBload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVBload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVBload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVBload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVBload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVBload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBloadidx1_0(ref Value v)
        { 
            // match: (MOVBloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVBloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVBloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstore_0(ref Value v)
        { 
            // match: (MOVBstore [off] {sym} ptr y:(SETL x) mem)
            // cond: y.Uses == 1
            // result: (SETLmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpAMD64SETL)
                {
                    break;
                }
                var x = y.Args[0L];
                var mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETLE x) mem)
            // cond: y.Uses == 1
            // result: (SETLEmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETLE x) mem)
            // cond: y.Uses == 1
            // result: (SETLEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETLE)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETLEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETG x) mem)
            // cond: y.Uses == 1
            // result: (SETGmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETG x) mem)
            // cond: y.Uses == 1
            // result: (SETGmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETG)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETGmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETGE x) mem)
            // cond: y.Uses == 1
            // result: (SETGEmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETGE x) mem)
            // cond: y.Uses == 1
            // result: (SETGEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETGE)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETGEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETEQ x) mem)
            // cond: y.Uses == 1
            // result: (SETEQmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETEQ x) mem)
            // cond: y.Uses == 1
            // result: (SETEQmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETEQ)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETEQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETNE x) mem)
            // cond: y.Uses == 1
            // result: (SETNEmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETNE x) mem)
            // cond: y.Uses == 1
            // result: (SETNEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETNE)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETNEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETB x) mem)
            // cond: y.Uses == 1
            // result: (SETBmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETB x) mem)
            // cond: y.Uses == 1
            // result: (SETBmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETB)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETBE x) mem)
            // cond: y.Uses == 1
            // result: (SETBEmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETBE x) mem)
            // cond: y.Uses == 1
            // result: (SETBEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETBE)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETBEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETA x) mem)
            // cond: y.Uses == 1
            // result: (SETAmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETA x) mem)
            // cond: y.Uses == 1
            // result: (SETAmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETA)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETAmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr y:(SETAE x) mem)
            // cond: y.Uses == 1
            // result: (SETAEmem [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr y:(SETAE x) mem)
            // cond: y.Uses == 1
            // result: (SETAEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                y = v.Args[1L];
                if (y.Op != OpAMD64SETAE)
                {
                    break;
                }
                x = y.Args[0L];
                mem = v.Args[2L];
                if (!(y.Uses == 1L))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstore_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBstore [off] {sym} ptr (MOVBQSX x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVBQSX)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBQZX x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBQZX x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVBstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVBstoreconst [makeValAndOff(int64(int8(c)),off)] {sym} ptr mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVBstoreconst [makeValAndOff(int64(int8(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(validOff(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = makeValAndOff(int64(int8(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVBstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVBstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVBstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVBstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVBstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w x0:(MOVBstore [i-1] {s} p (SHRWconst [8] w) mem))
            // cond: x0.Uses == 1   && clobber(x0)
            // result: (MOVWstore [i-1] {s} p (ROLWconst <w.Type> [8] w) mem)
 
            // match: (MOVBstore [i] {s} p w x0:(MOVBstore [i-1] {s} p (SHRWconst [8] w) mem))
            // cond: x0.Uses == 1   && clobber(x0)
            // result: (MOVWstore [i-1] {s} p (ROLWconst <w.Type> [8] w) mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var w = v.Args[1L];
                var x0 = v.Args[2L];
                if (x0.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x0.AuxInt != i - 1L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                var x0_1 = x0.Args[1L];
                if (x0_1.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                if (x0_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x0_1.Args[0L])
                {
                    break;
                }
                mem = x0.Args[2L];
                if (!(x0.Uses == 1L && clobber(x0)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, w.Type);
                v0.AuxInt = 8L;
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w x2:(MOVBstore [i-1] {s} p (SHRLconst [8] w) x1:(MOVBstore [i-2] {s} p (SHRLconst [16] w) x0:(MOVBstore [i-3] {s} p (SHRLconst [24] w) mem))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)
            // result: (MOVLstore [i-3] {s} p (BSWAPL <w.Type> w) mem)
 
            // match: (MOVBstore [i] {s} p w x2:(MOVBstore [i-1] {s} p (SHRLconst [8] w) x1:(MOVBstore [i-2] {s} p (SHRLconst [16] w) x0:(MOVBstore [i-3] {s} p (SHRLconst [24] w) mem))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)
            // result: (MOVLstore [i-3] {s} p (BSWAPL <w.Type> w) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                w = v.Args[1L];
                var x2 = v.Args[2L];
                if (x2.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x2.AuxInt != i - 1L)
                {
                    break;
                }
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[2L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                var x2_1 = x2.Args[1L];
                if (x2_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x2_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x2_1.Args[0L])
                {
                    break;
                }
                var x1 = x2.Args[2L];
                if (x1.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x1.AuxInt != i - 2L)
                {
                    break;
                }
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                var x1_1 = x1.Args[1L];
                if (x1_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x1_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x1_1.Args[0L])
                {
                    break;
                }
                x0 = x1.Args[2L];
                if (x0.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x0.AuxInt != i - 3L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                x0_1 = x0.Args[1L];
                if (x0_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x0_1.AuxInt != 24L)
                {
                    break;
                }
                if (w != x0_1.Args[0L])
                {
                    break;
                }
                mem = x0.Args[2L];
                if (!(x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && clobber(x0) && clobber(x1) && clobber(x2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = i - 3L;
                v.Aux = s;
                v.AddArg(p);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, w.Type);
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p w x6:(MOVBstore [i-1] {s} p (SHRQconst [8] w) x5:(MOVBstore [i-2] {s} p (SHRQconst [16] w) x4:(MOVBstore [i-3] {s} p (SHRQconst [24] w) x3:(MOVBstore [i-4] {s} p (SHRQconst [32] w) x2:(MOVBstore [i-5] {s} p (SHRQconst [40] w) x1:(MOVBstore [i-6] {s} p (SHRQconst [48] w) x0:(MOVBstore [i-7] {s} p (SHRQconst [56] w) mem))))))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && x3.Uses == 1   && x4.Uses == 1   && x5.Uses == 1   && x6.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)   && clobber(x3)   && clobber(x4)   && clobber(x5)   && clobber(x6)
            // result: (MOVQstore [i-7] {s} p (BSWAPQ <w.Type> w) mem)
 
            // match: (MOVBstore [i] {s} p w x6:(MOVBstore [i-1] {s} p (SHRQconst [8] w) x5:(MOVBstore [i-2] {s} p (SHRQconst [16] w) x4:(MOVBstore [i-3] {s} p (SHRQconst [24] w) x3:(MOVBstore [i-4] {s} p (SHRQconst [32] w) x2:(MOVBstore [i-5] {s} p (SHRQconst [40] w) x1:(MOVBstore [i-6] {s} p (SHRQconst [48] w) x0:(MOVBstore [i-7] {s} p (SHRQconst [56] w) mem))))))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && x3.Uses == 1   && x4.Uses == 1   && x5.Uses == 1   && x6.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)   && clobber(x3)   && clobber(x4)   && clobber(x5)   && clobber(x6)
            // result: (MOVQstore [i-7] {s} p (BSWAPQ <w.Type> w) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                w = v.Args[1L];
                var x6 = v.Args[2L];
                if (x6.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x6.AuxInt != i - 1L)
                {
                    break;
                }
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[2L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                var x6_1 = x6.Args[1L];
                if (x6_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x6_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x6_1.Args[0L])
                {
                    break;
                }
                var x5 = x6.Args[2L];
                if (x5.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x5.AuxInt != i - 2L)
                {
                    break;
                }
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[2L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                var x5_1 = x5.Args[1L];
                if (x5_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x5_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x5_1.Args[0L])
                {
                    break;
                }
                var x4 = x5.Args[2L];
                if (x4.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x4.AuxInt != i - 3L)
                {
                    break;
                }
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[2L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                var x4_1 = x4.Args[1L];
                if (x4_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x4_1.AuxInt != 24L)
                {
                    break;
                }
                if (w != x4_1.Args[0L])
                {
                    break;
                }
                var x3 = x4.Args[2L];
                if (x3.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x3.AuxInt != i - 4L)
                {
                    break;
                }
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[2L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                var x3_1 = x3.Args[1L];
                if (x3_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x3_1.AuxInt != 32L)
                {
                    break;
                }
                if (w != x3_1.Args[0L])
                {
                    break;
                }
                x2 = x3.Args[2L];
                if (x2.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x2.AuxInt != i - 5L)
                {
                    break;
                }
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[2L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                x2_1 = x2.Args[1L];
                if (x2_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x2_1.AuxInt != 40L)
                {
                    break;
                }
                if (w != x2_1.Args[0L])
                {
                    break;
                }
                x1 = x2.Args[2L];
                if (x1.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x1.AuxInt != i - 6L)
                {
                    break;
                }
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                x1_1 = x1.Args[1L];
                if (x1_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x1_1.AuxInt != 48L)
                {
                    break;
                }
                if (w != x1_1.Args[0L])
                {
                    break;
                }
                x0 = x1.Args[2L];
                if (x0.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x0.AuxInt != i - 7L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                x0_1 = x0.Args[1L];
                if (x0_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x0_1.AuxInt != 56L)
                {
                    break;
                }
                if (w != x0_1.Args[0L])
                {
                    break;
                }
                mem = x0.Args[2L];
                if (!(x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = i - 7L;
                v.Aux = s;
                v.AddArg(p);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, w.Type);
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstore_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVBstore [i] {s} p (SHRQconst [8] w) x:(MOVBstore [i-1] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-1] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p (SHRQconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SHRQconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-1] {s} p w0 mem)
 
            // match: (MOVBstore [i] {s} p (SHRQconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SHRQconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstore [i-1] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i] {s} p x1:(MOVBload [j] {s2} p2 mem) mem2:(MOVBstore [i-1] {s} p x2:(MOVBload [j-1] {s2} p2 mem) mem))
            // cond: x1.Uses == 1   && x2.Uses == 1   && mem2.Uses == 1   && clobber(x1)   && clobber(x2)   && clobber(mem2)
            // result: (MOVWstore [i-1] {s} p (MOVWload [j-1] {s2} p2 mem) mem)
 
            // match: (MOVBstore [i] {s} p x1:(MOVBload [j] {s2} p2 mem) mem2:(MOVBstore [i-1] {s} p x2:(MOVBload [j-1] {s2} p2 mem) mem))
            // cond: x1.Uses == 1   && x2.Uses == 1   && mem2.Uses == 1   && clobber(x1)   && clobber(x2)   && clobber(mem2)
            // result: (MOVWstore [i-1] {s} p (MOVWload [j-1] {s2} p2 mem) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                j = x1.AuxInt;
                var s2 = x1.Aux;
                _ = x1.Args[1L];
                var p2 = x1.Args[0L];
                mem = x1.Args[1L];
                var mem2 = v.Args[2L];
                if (mem2.Op != OpAMD64MOVBstore)
                {
                    break;
                }
                if (mem2.AuxInt != i - 1L)
                {
                    break;
                }
                if (mem2.Aux != s)
                {
                    break;
                }
                _ = mem2.Args[2L];
                if (p != mem2.Args[0L])
                {
                    break;
                }
                var x2 = mem2.Args[1L];
                if (x2.Op != OpAMD64MOVBload)
                {
                    break;
                }
                if (x2.AuxInt != j - 1L)
                {
                    break;
                }
                if (x2.Aux != s2)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p2 != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (mem != mem2.Args[2L])
                {
                    break;
                }
                if (!(x1.Uses == 1L && x2.Uses == 1L && mem2.Uses == 1L && clobber(x1) && clobber(x2) && clobber(mem2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v0.AuxInt = j - 1L;
                v0.Aux = s2;
                v0.AddArg(p2);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVBstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVBstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVBstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstoreconst_0(ref Value v)
        { 
            // match: (MOVBstoreconst [sc] {s} (ADDQconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVBstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVBstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVBstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVBstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVBstoreconstidx1 [x] {sym} ptr idx mem)
 
            // match: (MOVBstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVBstoreconstidx1 [x] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVBstoreconstidx1);
                v.AuxInt = x;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstoreconst [makeValAndOff(ValAndOff(a).Val()&0xff | ValAndOff(c).Val()<<8, ValAndOff(a).Off())] {s} p mem)
 
            // match: (MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstoreconst [makeValAndOff(ValAndOff(a).Val()&0xff | ValAndOff(c).Val()<<8, ValAndOff(a).Off())] {s} p mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64MOVBstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 1L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = makeValAndOff(ValAndOff(a).Val() & 0xffUL | ValAndOff(c).Val() << (int)(8L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVBstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
 
            // match: (MOVBstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVBstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstoreconstidx1_0(ref Value v)
        { 
            // match: (MOVBstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVBstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVBstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVBstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVBstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreconstidx1 [c] {s} p i x:(MOVBstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xff | ValAndOff(c).Val()<<8, ValAndOff(a).Off())] {s} p i mem)
 
            // match: (MOVBstoreconstidx1 [c] {s} p i x:(MOVBstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 1 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVWstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xff | ValAndOff(c).Val()<<8, ValAndOff(a).Off())] {s} p i mem)
            while (true)
            {
                c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var i = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVBstoreconstidx1)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (i != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 1L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx1);
                v.AuxInt = makeValAndOff(ValAndOff(a).Val() & 0xffUL | ValAndOff(c).Val() << (int)(8L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(i);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVBstoreidx1_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVBstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVBstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVBstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVBstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVBstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [i] {s} p idx w x0:(MOVBstoreidx1 [i-1] {s} p idx (SHRWconst [8] w) mem))
            // cond: x0.Uses == 1   && clobber(x0)
            // result: (MOVWstoreidx1 [i-1] {s} p idx (ROLWconst <w.Type> [8] w) mem)
 
            // match: (MOVBstoreidx1 [i] {s} p idx w x0:(MOVBstoreidx1 [i-1] {s} p idx (SHRWconst [8] w) mem))
            // cond: x0.Uses == 1   && clobber(x0)
            // result: (MOVWstoreidx1 [i-1] {s} p idx (ROLWconst <w.Type> [8] w) mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var w = v.Args[2L];
                var x0 = v.Args[3L];
                if (x0.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x0.AuxInt != i - 1L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[3L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                var x0_2 = x0.Args[2L];
                if (x0_2.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                if (x0_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x0_2.Args[0L])
                {
                    break;
                }
                mem = x0.Args[3L];
                if (!(x0.Uses == 1L && clobber(x0)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                var v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, w.Type);
                v0.AuxInt = 8L;
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [i] {s} p idx w x2:(MOVBstoreidx1 [i-1] {s} p idx (SHRLconst [8] w) x1:(MOVBstoreidx1 [i-2] {s} p idx (SHRLconst [16] w) x0:(MOVBstoreidx1 [i-3] {s} p idx (SHRLconst [24] w) mem))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)
            // result: (MOVLstoreidx1 [i-3] {s} p idx (BSWAPL <w.Type> w) mem)
 
            // match: (MOVBstoreidx1 [i] {s} p idx w x2:(MOVBstoreidx1 [i-1] {s} p idx (SHRLconst [8] w) x1:(MOVBstoreidx1 [i-2] {s} p idx (SHRLconst [16] w) x0:(MOVBstoreidx1 [i-3] {s} p idx (SHRLconst [24] w) mem))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)
            // result: (MOVLstoreidx1 [i-3] {s} p idx (BSWAPL <w.Type> w) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                var x2 = v.Args[3L];
                if (x2.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x2.AuxInt != i - 1L)
                {
                    break;
                }
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[3L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (idx != x2.Args[1L])
                {
                    break;
                }
                var x2_2 = x2.Args[2L];
                if (x2_2.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x2_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x2_2.Args[0L])
                {
                    break;
                }
                var x1 = x2.Args[3L];
                if (x1.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x1.AuxInt != i - 2L)
                {
                    break;
                }
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[3L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                var x1_2 = x1.Args[2L];
                if (x1_2.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x1_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x1_2.Args[0L])
                {
                    break;
                }
                x0 = x1.Args[3L];
                if (x0.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x0.AuxInt != i - 3L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[3L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                x0_2 = x0.Args[2L];
                if (x0_2.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                if (x0_2.AuxInt != 24L)
                {
                    break;
                }
                if (w != x0_2.Args[0L])
                {
                    break;
                }
                mem = x0.Args[3L];
                if (!(x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && clobber(x0) && clobber(x1) && clobber(x2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = i - 3L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, w.Type);
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [i] {s} p idx w x6:(MOVBstoreidx1 [i-1] {s} p idx (SHRQconst [8] w) x5:(MOVBstoreidx1 [i-2] {s} p idx (SHRQconst [16] w) x4:(MOVBstoreidx1 [i-3] {s} p idx (SHRQconst [24] w) x3:(MOVBstoreidx1 [i-4] {s} p idx (SHRQconst [32] w) x2:(MOVBstoreidx1 [i-5] {s} p idx (SHRQconst [40] w) x1:(MOVBstoreidx1 [i-6] {s} p idx (SHRQconst [48] w) x0:(MOVBstoreidx1 [i-7] {s} p idx (SHRQconst [56] w) mem))))))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && x3.Uses == 1   && x4.Uses == 1   && x5.Uses == 1   && x6.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)   && clobber(x3)   && clobber(x4)   && clobber(x5)   && clobber(x6)
            // result: (MOVQstoreidx1 [i-7] {s} p idx (BSWAPQ <w.Type> w) mem)
 
            // match: (MOVBstoreidx1 [i] {s} p idx w x6:(MOVBstoreidx1 [i-1] {s} p idx (SHRQconst [8] w) x5:(MOVBstoreidx1 [i-2] {s} p idx (SHRQconst [16] w) x4:(MOVBstoreidx1 [i-3] {s} p idx (SHRQconst [24] w) x3:(MOVBstoreidx1 [i-4] {s} p idx (SHRQconst [32] w) x2:(MOVBstoreidx1 [i-5] {s} p idx (SHRQconst [40] w) x1:(MOVBstoreidx1 [i-6] {s} p idx (SHRQconst [48] w) x0:(MOVBstoreidx1 [i-7] {s} p idx (SHRQconst [56] w) mem))))))))
            // cond: x0.Uses == 1   && x1.Uses == 1   && x2.Uses == 1   && x3.Uses == 1   && x4.Uses == 1   && x5.Uses == 1   && x6.Uses == 1   && clobber(x0)   && clobber(x1)   && clobber(x2)   && clobber(x3)   && clobber(x4)   && clobber(x5)   && clobber(x6)
            // result: (MOVQstoreidx1 [i-7] {s} p idx (BSWAPQ <w.Type> w) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                w = v.Args[2L];
                var x6 = v.Args[3L];
                if (x6.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x6.AuxInt != i - 1L)
                {
                    break;
                }
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[3L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (idx != x6.Args[1L])
                {
                    break;
                }
                var x6_2 = x6.Args[2L];
                if (x6_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x6_2.AuxInt != 8L)
                {
                    break;
                }
                if (w != x6_2.Args[0L])
                {
                    break;
                }
                var x5 = x6.Args[3L];
                if (x5.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x5.AuxInt != i - 2L)
                {
                    break;
                }
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[3L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (idx != x5.Args[1L])
                {
                    break;
                }
                var x5_2 = x5.Args[2L];
                if (x5_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x5_2.AuxInt != 16L)
                {
                    break;
                }
                if (w != x5_2.Args[0L])
                {
                    break;
                }
                var x4 = x5.Args[3L];
                if (x4.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x4.AuxInt != i - 3L)
                {
                    break;
                }
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[3L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (idx != x4.Args[1L])
                {
                    break;
                }
                var x4_2 = x4.Args[2L];
                if (x4_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x4_2.AuxInt != 24L)
                {
                    break;
                }
                if (w != x4_2.Args[0L])
                {
                    break;
                }
                var x3 = x4.Args[3L];
                if (x3.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x3.AuxInt != i - 4L)
                {
                    break;
                }
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[3L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (idx != x3.Args[1L])
                {
                    break;
                }
                var x3_2 = x3.Args[2L];
                if (x3_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x3_2.AuxInt != 32L)
                {
                    break;
                }
                if (w != x3_2.Args[0L])
                {
                    break;
                }
                x2 = x3.Args[3L];
                if (x2.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x2.AuxInt != i - 5L)
                {
                    break;
                }
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[3L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (idx != x2.Args[1L])
                {
                    break;
                }
                x2_2 = x2.Args[2L];
                if (x2_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x2_2.AuxInt != 40L)
                {
                    break;
                }
                if (w != x2_2.Args[0L])
                {
                    break;
                }
                x1 = x2.Args[3L];
                if (x1.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x1.AuxInt != i - 6L)
                {
                    break;
                }
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[3L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                x1_2 = x1.Args[2L];
                if (x1_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x1_2.AuxInt != 48L)
                {
                    break;
                }
                if (w != x1_2.Args[0L])
                {
                    break;
                }
                x0 = x1.Args[3L];
                if (x0.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x0.AuxInt != i - 7L)
                {
                    break;
                }
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[3L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                x0_2 = x0.Args[2L];
                if (x0_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (x0_2.AuxInt != 56L)
                {
                    break;
                }
                if (w != x0_2.Args[0L])
                {
                    break;
                }
                mem = x0.Args[3L];
                if (!(x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = i - 7L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, w.Type);
                v0.AddArg(w);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [i] {s} p idx (SHRQconst [8] w) x:(MOVBstoreidx1 [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx1 [i-1] {s} p idx w mem)
 
            // match: (MOVBstoreidx1 [i] {s} p idx (SHRQconst [8] w) x:(MOVBstoreidx1 [i-1] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx1 [i-1] {s} p idx w mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_2.AuxInt != 8L)
                {
                    break;
                }
                w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVBstoreidx1 [i-1] {s} p idx w0:(SHRQconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx1 [i-1] {s} p idx w0 mem)
 
            // match: (MOVBstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVBstoreidx1 [i-1] {s} p idx w0:(SHRQconst [j-8] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVWstoreidx1 [i-1] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpAMD64MOVBstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 1L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 8L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = i - 1L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLQSX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVLQSX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVLQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQSX (ANDLconst [c] x))
            // cond: c & 0x80000000 == 0
            // result: (ANDLconst [c & 0x7fffffff] x)
 
            // match: (MOVLQSX (ANDLconst [c] x))
            // cond: c & 0x80000000 == 0
            // result: (ANDLconst [c & 0x7fffffff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(c & 0x80000000UL == 0L))
                {
                    break;
                }
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & 0x7fffffffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQSX (MOVLQSX x))
            // cond:
            // result: (MOVLQSX x)
 
            // match: (MOVLQSX (MOVLQSX x))
            // cond:
            // result: (MOVLQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVLQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQSX (MOVWQSX x))
            // cond:
            // result: (MOVWQSX x)
 
            // match: (MOVLQSX (MOVWQSX x))
            // cond:
            // result: (MOVWQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVWQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVWQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
 
            // match: (MOVLQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLQSXload_0(ref Value v)
        { 
            // match: (MOVLQSXload [off] {sym} ptr (MOVLstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVLQSX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVLQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLQSXload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLQZX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVLQZX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVLQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQZX x)
            // cond: zeroUpper32Bits(x,3)
            // result: x
 
            // match: (MOVLQZX x)
            // cond: zeroUpper32Bits(x,3)
            // result: x
            while (true)
            {
                x = v.Args[0L];
                if (!(zeroUpper32Bits(x, 3L)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQZX x:(MOVLloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLloadidx1 <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVLQZX x:(MOVLloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLloadidx1 <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQZX x:(MOVLloadidx4 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLloadidx4 <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVLQZX x:(MOVLloadidx4 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVLloadidx4 <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLloadidx4)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx4, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVLQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c] x)
 
            // match: (MOVLQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQZX (MOVLQZX x))
            // cond:
            // result: (MOVLQZX x)
 
            // match: (MOVLQZX (MOVLQZX x))
            // cond:
            // result: (MOVLQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVLQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQZX (MOVWQZX x))
            // cond:
            // result: (MOVWQZX x)
 
            // match: (MOVLQZX (MOVWQZX x))
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVWQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
 
            // match: (MOVLQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLatomicload_0(ref Value v)
        { 
            // match: (MOVLatomicload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLatomicload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLatomicload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLatomicload [off1] {sym1} (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLatomicload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVLatomicload [off1] {sym1} (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLatomicload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLatomicload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLf2i_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVLf2i <t> (Arg [off] {sym}))
            // cond:
            // result: @b.Func.Entry (Arg <t> [off] {sym})
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpArg)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var sym = v_0.Aux;
                b = b.Func.Entry;
                var v0 = b.NewValue0(v.Pos, OpArg, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLi2f_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVLi2f <t> (Arg [off] {sym}))
            // cond:
            // result: @b.Func.Entry (Arg <t> [off] {sym})
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpArg)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var sym = v_0.Aux;
                b = b.Func.Entry;
                var v0 = b.NewValue0(v.Pos, OpArg, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLload_0(ref Value v)
        { 
            // match: (MOVLload [off] {sym} ptr (MOVLstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVLQZX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVLload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVLload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVLload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVLload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVLload [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVLload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVLloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVLload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVLloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVLload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVLload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLload [off] {sym} ptr (MOVSSstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVLf2i val)
 
            // match: (MOVLload [off] {sym} ptr (MOVSSstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVLf2i val)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var val = v_1.Args[1L];
                v.reset(OpAMD64MOVLf2i);
                v.AddArg(val);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLloadidx1_0(ref Value v)
        { 
            // match: (MOVLloadidx1 [c] {sym} ptr (SHLQconst [2] idx) mem)
            // cond:
            // result: (MOVLloadidx4 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVLloadidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} (SHLQconst [2] idx) ptr mem)
            // cond:
            // result: (MOVLloadidx4 [c] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} (SHLQconst [2] idx) ptr mem)
            // cond:
            // result: (MOVLloadidx4 [c] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 2L)
                {
                    break;
                }
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLloadidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} ptr (SHLQconst [3] idx) mem)
            // cond:
            // result: (MOVLloadidx8 [c] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} ptr (SHLQconst [3] idx) mem)
            // cond:
            // result: (MOVLloadidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLloadidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} (SHLQconst [3] idx) ptr mem)
            // cond:
            // result: (MOVLloadidx8 [c] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} (SHLQconst [3] idx) ptr mem)
            // cond:
            // result: (MOVLloadidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 3L)
                {
                    break;
                }
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLloadidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLloadidx4_0(ref Value v)
        { 
            // match: (MOVLloadidx4 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx4 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx4);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx4 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVLloadidx4 [c+4*d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx4 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVLloadidx4 [c+4*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 4L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx4);
                v.AuxInt = c + 4L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLloadidx8_0(ref Value v)
        { 
            // match: (MOVLloadidx8 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVLloadidx8 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVLloadidx8 [c+8*d] {sym} ptr idx mem)
 
            // match: (MOVLloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVLloadidx8 [c+8*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLloadidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstore_0(ref Value v)
        { 
            // match: (MOVLstore [off] {sym} ptr (MOVLQSX x) mem)
            // cond:
            // result: (MOVLstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLQSX)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off] {sym} ptr (MOVLQZX x) mem)
            // cond:
            // result: (MOVLstore [off] {sym} ptr x mem)
 
            // match: (MOVLstore [off] {sym} ptr (MOVLQZX x) mem)
            // cond:
            // result: (MOVLstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLQZX)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVLstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVLstoreconst [makeValAndOff(int64(int32(c)),off)] {sym} ptr mem)
 
            // match: (MOVLstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVLstoreconst [makeValAndOff(int64(int32(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(validOff(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = makeValAndOff(int64(int32(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVLstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVLstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVLstore [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVLstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVLstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVLstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVLstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVLstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [i] {s} p (SHRQconst [32] w) x:(MOVLstore [i-4] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstore [i-4] {s} p w mem)
 
            // match: (MOVLstore [i] {s} p (SHRQconst [32] w) x:(MOVLstore [i-4] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstore [i-4] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 32L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstore_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVLstore [i] {s} p (SHRQconst [j] w) x:(MOVLstore [i-4] {s} p w0:(SHRQconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstore [i-4] {s} p w0 mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_1.AuxInt;
                var w = v_1.Args[0L];
                var x = v.Args[2L];
                if (x.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                var mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [i] {s} p x1:(MOVLload [j] {s2} p2 mem) mem2:(MOVLstore [i-4] {s} p x2:(MOVLload [j-4] {s2} p2 mem) mem))
            // cond: x1.Uses == 1   && x2.Uses == 1   && mem2.Uses == 1   && clobber(x1)   && clobber(x2)   && clobber(mem2)
            // result: (MOVQstore [i-4] {s} p (MOVQload [j-4] {s2} p2 mem) mem)
 
            // match: (MOVLstore [i] {s} p x1:(MOVLload [j] {s2} p2 mem) mem2:(MOVLstore [i-4] {s} p x2:(MOVLload [j-4] {s2} p2 mem) mem))
            // cond: x1.Uses == 1   && x2.Uses == 1   && mem2.Uses == 1   && clobber(x1)   && clobber(x2)   && clobber(mem2)
            // result: (MOVQstore [i-4] {s} p (MOVQload [j-4] {s2} p2 mem) mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                var x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVLload)
                {
                    break;
                }
                j = x1.AuxInt;
                var s2 = x1.Aux;
                _ = x1.Args[1L];
                var p2 = x1.Args[0L];
                mem = x1.Args[1L];
                var mem2 = v.Args[2L];
                if (mem2.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (mem2.AuxInt != i - 4L)
                {
                    break;
                }
                if (mem2.Aux != s)
                {
                    break;
                }
                _ = mem2.Args[2L];
                if (p != mem2.Args[0L])
                {
                    break;
                }
                var x2 = mem2.Args[1L];
                if (x2.Op != OpAMD64MOVLload)
                {
                    break;
                }
                if (x2.AuxInt != j - 4L)
                {
                    break;
                }
                if (x2.Aux != s2)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p2 != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (mem != mem2.Args[2L])
                {
                    break;
                }
                if (!(x1.Uses == 1L && x2.Uses == 1L && mem2.Uses == 1L && clobber(x1) && clobber(x2) && clobber(mem2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v0.AuxInt = j - 4L;
                v0.Aux = s2;
                v0.AddArg(p2);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVLstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVLstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVLstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off] {sym} ptr a:(ADDLconst [c] l:(MOVLload [off] {sym} ptr2 mem)) mem)
            // cond: isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c,off)
            // result: (ADDLconstmem {sym} [makeValAndOff(c,off)] ptr mem)
 
            // match: (MOVLstore [off] {sym} ptr a:(ADDLconst [c] l:(MOVLload [off] {sym} ptr2 mem)) mem)
            // cond: isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c,off)
            // result: (ADDLconstmem {sym} [makeValAndOff(c,off)] ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var a = v.Args[1L];
                if (a.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                var c = a.AuxInt;
                var l = a.Args[0L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                if (l.AuxInt != off)
                {
                    break;
                }
                if (l.Aux != sym)
                {
                    break;
                }
                _ = l.Args[1L];
                var ptr2 = l.Args[0L];
                mem = l.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(ptr, ptr2) && a.Uses == 1L && l.Uses == 1L && validValAndOff(c, off)))
                {
                    break;
                }
                v.reset(OpAMD64ADDLconstmem);
                v.AuxInt = makeValAndOff(c, off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstore [off] {sym} ptr (MOVLf2i val) mem)
            // cond:
            // result: (MOVSSstore [off] {sym} ptr val mem)
 
            // match: (MOVLstore [off] {sym} ptr (MOVLf2i val) mem)
            // cond:
            // result: (MOVSSstore [off] {sym} ptr val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLf2i)
                {
                    break;
                }
                val = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVSSstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVLstoreconst [sc] {s} (ADDQconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVLstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVLstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [x] {sym1} (LEAQ4 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVLstoreconstidx4 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVLstoreconst [x] {sym1} (LEAQ4 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVLstoreconstidx4 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx4);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVLstoreconstidx1 [x] {sym} ptr idx mem)
 
            // match: (MOVLstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVLstoreconstidx1 [x] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = x;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [c] {s} p x:(MOVLstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstore [ValAndOff(a).Off()] {s} p (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
 
            // match: (MOVLstoreconst [c] {s} p x:(MOVLstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstore [ValAndOff(a).Off()] {s} p (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64MOVLstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 4L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = ValAndOff(a).Off();
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v0.AuxInt = ValAndOff(a).Val() & 0xffffffffUL | ValAndOff(c).Val() << (int)(32L);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVLstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
 
            // match: (MOVLstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVLstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreconstidx1_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVLstoreconstidx1 [c] {sym} ptr (SHLQconst [2] idx) mem)
            // cond:
            // result: (MOVLstoreconstidx4 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVLstoreconstidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVLstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVLstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVLstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconstidx1 [c] {s} p i x:(MOVLstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstoreidx1 [ValAndOff(a).Off()] {s} p i (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
 
            // match: (MOVLstoreconstidx1 [c] {s} p i x:(MOVLstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstoreidx1 [ValAndOff(a).Off()] {s} p i (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
            while (true)
            {
                c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var i = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVLstoreconstidx1)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (i != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 4L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = ValAndOff(a).Off();
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(i);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v0.AuxInt = ValAndOff(a).Val() & 0xffffffffUL | ValAndOff(c).Val() << (int)(32L);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreconstidx4_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVLstoreconstidx4 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVLstoreconstidx4 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx4);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconstidx4 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(4*c)
            // result: (MOVLstoreconstidx4 [ValAndOff(x).add(4*c)] {sym} ptr idx mem)
 
            // match: (MOVLstoreconstidx4 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(4*c)
            // result: (MOVLstoreconstidx4 [ValAndOff(x).add(4*c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(4L * c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx4);
                v.AuxInt = ValAndOff(x).add(4L * c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreconstidx4 [c] {s} p i x:(MOVLstoreconstidx4 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstoreidx1 [ValAndOff(a).Off()] {s} p (SHLQconst <i.Type> [2] i) (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
 
            // match: (MOVLstoreconstidx4 [c] {s} p i x:(MOVLstoreconstidx4 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 4 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVQstoreidx1 [ValAndOff(a).Off()] {s} p (SHLQconst <i.Type> [2] i) (MOVQconst [ValAndOff(a).Val()&0xffffffff | ValAndOff(c).Val()<<32]) mem)
            while (true)
            {
                c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var i = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVLstoreconstidx4)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (i != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 4L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = ValAndOff(a).Off();
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, i.Type);
                v0.AuxInt = 2L;
                v0.AddArg(i);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v1.AuxInt = ValAndOff(a).Val() & 0xffffffffUL | ValAndOff(c).Val() << (int)(32L);
                v.AddArg(v1);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreidx1_0(ref Value v)
        { 
            // match: (MOVLstoreidx1 [c] {sym} ptr (SHLQconst [2] idx) val mem)
            // cond:
            // result: (MOVLstoreidx4 [c] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64MOVLstoreidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx1 [c] {sym} ptr (SHLQconst [3] idx) val mem)
            // cond:
            // result: (MOVLstoreidx8 [c] {sym} ptr idx val mem)
 
            // match: (MOVLstoreidx1 [c] {sym} ptr (SHLQconst [3] idx) val mem)
            // cond:
            // result: (MOVLstoreidx8 [c] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpAMD64MOVLstoreidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVLstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVLstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx1 [i] {s} p idx (SHRQconst [32] w) x:(MOVLstoreidx1 [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p idx w mem)
 
            // match: (MOVLstoreidx1 [i] {s} p idx (SHRQconst [32] w) x:(MOVLstoreidx1 [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpAMD64MOVLstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVLstoreidx1 [i-4] {s} p idx w0:(SHRQconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p idx w0 mem)
 
            // match: (MOVLstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVLstoreidx1 [i-4] {s} p idx w0:(SHRQconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpAMD64MOVLstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreidx4_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVLstoreidx4 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx4 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx4);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx4 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVLstoreidx4 [c+4*d] {sym} ptr idx val mem)
 
            // match: (MOVLstoreidx4 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVLstoreidx4 [c+4*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 4L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx4);
                v.AuxInt = c + 4L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx4 [i] {s} p idx (SHRQconst [32] w) x:(MOVLstoreidx4 [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p (SHLQconst <idx.Type> [2] idx) w mem)
 
            // match: (MOVLstoreidx4 [i] {s} p idx (SHRQconst [32] w) x:(MOVLstoreidx4 [i-4] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p (SHLQconst <idx.Type> [2] idx) w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_2.AuxInt != 32L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpAMD64MOVLstoreidx4)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type);
                v0.AuxInt = 2L;
                v0.AddArg(idx);
                v.AddArg(v0);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx4 [i] {s} p idx (SHRQconst [j] w) x:(MOVLstoreidx4 [i-4] {s} p idx w0:(SHRQconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p (SHLQconst <idx.Type> [2] idx) w0 mem)
 
            // match: (MOVLstoreidx4 [i] {s} p idx (SHRQconst [j] w) x:(MOVLstoreidx4 [i-4] {s} p idx w0:(SHRQconst [j-32] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVQstoreidx1 [i-4] {s} p (SHLQconst <idx.Type> [2] idx) w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpAMD64MOVLstoreidx4)
                {
                    break;
                }
                if (x.AuxInt != i - 4L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 32L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = i - 4L;
                v.Aux = s;
                v.AddArg(p);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type);
                v0.AuxInt = 2L;
                v0.AddArg(idx);
                v.AddArg(v0);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVLstoreidx8_0(ref Value v)
        { 
            // match: (MOVLstoreidx8 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVLstoreidx8 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVLstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVLstoreidx8 [c+8*d] {sym} ptr idx val mem)
 
            // match: (MOVLstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVLstoreidx8 [c+8*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVOload_0(ref Value v)
        { 
            // match: (MOVOload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVOload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVOload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVOload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVOload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVOload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVOload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVOload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVOstore_0(ref Value v)
        { 
            // match: (MOVOstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVOstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVOstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVOstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVOstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVOstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQatomicload_0(ref Value v)
        { 
            // match: (MOVQatomicload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQatomicload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQatomicload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQatomicload [off1] {sym1} (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQatomicload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVQatomicload [off1] {sym1} (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQatomicload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQatomicload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQf2i_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVQf2i <t> (Arg [off] {sym}))
            // cond:
            // result: @b.Func.Entry (Arg <t> [off] {sym})
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpArg)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var sym = v_0.Aux;
                b = b.Func.Entry;
                var v0 = b.NewValue0(v.Pos, OpArg, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQi2f_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVQi2f <t> (Arg [off] {sym}))
            // cond:
            // result: @b.Func.Entry (Arg <t> [off] {sym})
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpArg)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var sym = v_0.Aux;
                b = b.Func.Entry;
                var v0 = b.NewValue0(v.Pos, OpArg, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQload_0(ref Value v)
        { 
            // match: (MOVQload [off] {sym} ptr (MOVQstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVQload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVQload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVQload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVQload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVQload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVQloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVQload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVQloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVQload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVQload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQload [off] {sym} ptr (MOVSDstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVQf2i val)
 
            // match: (MOVQload [off] {sym} ptr (MOVSDstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVQf2i val)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var val = v_1.Args[1L];
                v.reset(OpAMD64MOVQf2i);
                v.AddArg(val);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQloadidx1_0(ref Value v)
        { 
            // match: (MOVQloadidx1 [c] {sym} ptr (SHLQconst [3] idx) mem)
            // cond:
            // result: (MOVQloadidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVQloadidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx1 [c] {sym} (SHLQconst [3] idx) ptr mem)
            // cond:
            // result: (MOVQloadidx8 [c] {sym} ptr idx mem)
 
            // match: (MOVQloadidx1 [c] {sym} (SHLQconst [3] idx) ptr mem)
            // cond:
            // result: (MOVQloadidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 3L)
                {
                    break;
                }
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVQloadidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVQloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVQloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVQloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVQloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQloadidx8_0(ref Value v)
        { 
            // match: (MOVQloadidx8 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVQloadidx8 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVQloadidx8 [c+8*d] {sym} ptr idx mem)
 
            // match: (MOVQloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVQloadidx8 [c+8*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQloadidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstore_0(ref Value v)
        { 
            // match: (MOVQstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off] {sym} ptr (MOVQconst [c]) mem)
            // cond: validValAndOff(c,off)
            // result: (MOVQstoreconst [makeValAndOff(c,off)] {sym} ptr mem)
 
            // match: (MOVQstore [off] {sym} ptr (MOVQconst [c]) mem)
            // cond: validValAndOff(c,off)
            // result: (MOVQstoreconst [makeValAndOff(c,off)] {sym} ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(validValAndOff(c, off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = makeValAndOff(c, off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVQstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVQstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVQstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVQstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVQstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVQstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVQstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVQstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVQstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVQstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVQstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVQstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off] {sym} ptr a:(ADDQconst [c] l:(MOVQload [off] {sym} ptr2 mem)) mem)
            // cond: isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c,off)
            // result: (ADDQconstmem {sym} [makeValAndOff(c,off)] ptr mem)
 
            // match: (MOVQstore [off] {sym} ptr a:(ADDQconst [c] l:(MOVQload [off] {sym} ptr2 mem)) mem)
            // cond: isSamePtr(ptr, ptr2) && a.Uses == 1 && l.Uses == 1 && validValAndOff(c,off)
            // result: (ADDQconstmem {sym} [makeValAndOff(c,off)] ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var a = v.Args[1L];
                if (a.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = a.AuxInt;
                var l = a.Args[0L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                if (l.AuxInt != off)
                {
                    break;
                }
                if (l.Aux != sym)
                {
                    break;
                }
                _ = l.Args[1L];
                var ptr2 = l.Args[0L];
                mem = l.Args[1L];
                if (mem != v.Args[2L])
                {
                    break;
                }
                if (!(isSamePtr(ptr, ptr2) && a.Uses == 1L && l.Uses == 1L && validValAndOff(c, off)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconstmem);
                v.AuxInt = makeValAndOff(c, off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstore [off] {sym} ptr (MOVQf2i val) mem)
            // cond:
            // result: (MOVSDstore [off] {sym} ptr val mem)
 
            // match: (MOVQstore [off] {sym} ptr (MOVQf2i val) mem)
            // cond:
            // result: (MOVSDstore [off] {sym} ptr val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQf2i)
                {
                    break;
                }
                val = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVSDstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstoreconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVQstoreconst [sc] {s} (ADDQconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVQstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVQstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [x] {sym1} (LEAQ8 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVQstoreconstidx8 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVQstoreconst [x] {sym1} (LEAQ8 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVQstoreconstidx8 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx8);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVQstoreconstidx1 [x] {sym} ptr idx mem)
 
            // match: (MOVQstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVQstoreconstidx1 [x] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVQstoreconstidx1);
                v.AuxInt = x;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [c] {s} p x:(MOVQstoreconst [c2] {s} p mem))
            // cond: config.useSSE   && x.Uses == 1   && ValAndOff(c2).Off() + 8 == ValAndOff(c).Off()   && ValAndOff(c).Val() == 0   && ValAndOff(c2).Val() == 0   && clobber(x)
            // result: (MOVOstore [ValAndOff(c2).Off()] {s} p (MOVOconst [0]) mem)
 
            // match: (MOVQstoreconst [c] {s} p x:(MOVQstoreconst [c2] {s} p mem))
            // cond: config.useSSE   && x.Uses == 1   && ValAndOff(c2).Off() + 8 == ValAndOff(c).Off()   && ValAndOff(c).Val() == 0   && ValAndOff(c2).Val() == 0   && clobber(x)
            // result: (MOVOstore [ValAndOff(c2).Off()] {s} p (MOVOconst [0]) mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64MOVQstoreconst)
                {
                    break;
                }
                var c2 = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(config.useSSE && x.Uses == 1L && ValAndOff(c2).Off() + 8L == ValAndOff(c).Off() && ValAndOff(c).Val() == 0L && ValAndOff(c2).Val() == 0L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v.AuxInt = ValAndOff(c2).Off();
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVQstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
 
            // match: (MOVQstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVQstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstoreconstidx1_0(ref Value v)
        { 
            // match: (MOVQstoreconstidx1 [c] {sym} ptr (SHLQconst [3] idx) mem)
            // cond:
            // result: (MOVQstoreconstidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVQstoreconstidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVQstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVQstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVQstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstoreconstidx8_0(ref Value v)
        { 
            // match: (MOVQstoreconstidx8 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVQstoreconstidx8 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx8);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreconstidx8 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(8*c)
            // result: (MOVQstoreconstidx8 [ValAndOff(x).add(8*c)] {sym} ptr idx mem)
 
            // match: (MOVQstoreconstidx8 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(8*c)
            // result: (MOVQstoreconstidx8 [ValAndOff(x).add(8*c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(8L * c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconstidx8);
                v.AuxInt = ValAndOff(x).add(8L * c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstoreidx1_0(ref Value v)
        { 
            // match: (MOVQstoreidx1 [c] {sym} ptr (SHLQconst [3] idx) val mem)
            // cond:
            // result: (MOVQstoreidx8 [c] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64MOVQstoreidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVQstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVQstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVQstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVQstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVQstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVQstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVQstoreidx8_0(ref Value v)
        { 
            // match: (MOVQstoreidx8 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVQstoreidx8 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVQstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVQstoreidx8 [c+8*d] {sym} ptr idx val mem)
 
            // match: (MOVQstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVQstoreidx8 [c+8*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDload_0(ref Value v)
        { 
            // match: (MOVSDload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVSDload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVSDload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVSDload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVSDload [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDloadidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSDloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVSDload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSDloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDload [off] {sym} ptr (MOVQstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVQi2f val)
 
            // match: (MOVSDload [off] {sym} ptr (MOVQstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVQi2f val)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var val = v_1.Args[1L];
                v.reset(OpAMD64MOVQi2f);
                v.AddArg(val);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDloadidx1_0(ref Value v)
        { 
            // match: (MOVSDloadidx1 [c] {sym} ptr (SHLQconst [3] idx) mem)
            // cond:
            // result: (MOVSDloadidx8 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVSDloadidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVSDloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVSDloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDloadidx8_0(ref Value v)
        { 
            // match: (MOVSDloadidx8 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDloadidx8 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVSDloadidx8 [c+8*d] {sym} ptr idx mem)
 
            // match: (MOVSDloadidx8 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVSDloadidx8 [c+8*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDloadidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDstore_0(ref Value v)
        { 
            // match: (MOVSDstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVSDstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVSDstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVSDstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVSDstore [off1] {sym1} (LEAQ8 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSDstoreidx8 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ8)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx8);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSDstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVSDstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSDstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstore [off] {sym} ptr (MOVQi2f val) mem)
            // cond:
            // result: (MOVQstore  [off] {sym} ptr val mem)
 
            // match: (MOVSDstore [off] {sym} ptr (MOVQi2f val) mem)
            // cond:
            // result: (MOVQstore  [off] {sym} ptr val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQi2f)
                {
                    break;
                }
                val = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDstoreidx1_0(ref Value v)
        { 
            // match: (MOVSDstoreidx1 [c] {sym} ptr (SHLQconst [3] idx) val mem)
            // cond:
            // result: (MOVSDstoreidx8 [c] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 3L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64MOVSDstoreidx8);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVSDstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVSDstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSDstoreidx8_0(ref Value v)
        { 
            // match: (MOVSDstoreidx8 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSDstoreidx8 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx8);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSDstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVSDstoreidx8 [c+8*d] {sym} ptr idx val mem)
 
            // match: (MOVSDstoreidx8 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+8*d)
            // result: (MOVSDstoreidx8 [c+8*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 8L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstoreidx8);
                v.AuxInt = c + 8L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSload_0(ref Value v)
        { 
            // match: (MOVSSload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVSSload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVSSload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVSSload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSload [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSloadidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVSSload [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSloadidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSSloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVSSload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSSloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSload [off] {sym} ptr (MOVLstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVLi2f val)
 
            // match: (MOVSSload [off] {sym} ptr (MOVLstore [off] {sym} ptr val _))
            // cond:
            // result: (MOVLi2f val)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var val = v_1.Args[1L];
                v.reset(OpAMD64MOVLi2f);
                v.AddArg(val);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSloadidx1_0(ref Value v)
        { 
            // match: (MOVSSloadidx1 [c] {sym} ptr (SHLQconst [2] idx) mem)
            // cond:
            // result: (MOVSSloadidx4 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVSSloadidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVSSloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVSSloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSloadidx4_0(ref Value v)
        { 
            // match: (MOVSSloadidx4 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSloadidx4 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx4);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSloadidx4 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVSSloadidx4 [c+4*d] {sym} ptr idx mem)
 
            // match: (MOVSSloadidx4 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVSSloadidx4 [c+4*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 4L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSloadidx4);
                v.AuxInt = c + 4L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSstore_0(ref Value v)
        { 
            // match: (MOVSSstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVSSstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVSSstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVSSstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstore [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstoreidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVSSstore [off1] {sym1} (LEAQ4 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVSSstoreidx4 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ4)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx4);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSSstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVSSstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVSSstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstore [off] {sym} ptr (MOVLi2f val) mem)
            // cond:
            // result: (MOVLstore  [off] {sym} ptr val mem)
 
            // match: (MOVSSstore [off] {sym} ptr (MOVLi2f val) mem)
            // cond:
            // result: (MOVLstore  [off] {sym} ptr val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLi2f)
                {
                    break;
                }
                val = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSstoreidx1_0(ref Value v)
        { 
            // match: (MOVSSstoreidx1 [c] {sym} ptr (SHLQconst [2] idx) val mem)
            // cond:
            // result: (MOVSSstoreidx4 [c] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 2L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64MOVSSstoreidx4);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVSSstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVSSstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVSSstoreidx4_0(ref Value v)
        { 
            // match: (MOVSSstoreidx4 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVSSstoreidx4 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx4);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVSSstoreidx4 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVSSstoreidx4 [c+4*d] {sym} ptr idx val mem)
 
            // match: (MOVSSstoreidx4 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+4*d)
            // result: (MOVSSstoreidx4 [c+4*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 4L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstoreidx4);
                v.AuxInt = c + 4L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWQSX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWQSX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVWload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQSX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWQSX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWQSXload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWQSX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWQSXload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWQSXload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQSX (ANDLconst [c] x))
            // cond: c & 0x8000 == 0
            // result: (ANDLconst [c & 0x7fff] x)
 
            // match: (MOVWQSX (ANDLconst [c] x))
            // cond: c & 0x8000 == 0
            // result: (ANDLconst [c & 0x7fff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(c & 0x8000UL == 0L))
                {
                    break;
                }
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & 0x7fffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWQSX (MOVWQSX x))
            // cond:
            // result: (MOVWQSX x)
 
            // match: (MOVWQSX (MOVWQSX x))
            // cond:
            // result: (MOVWQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVWQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVWQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
 
            // match: (MOVWQSX (MOVBQSX x))
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQSX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWQSXload_0(ref Value v)
        { 
            // match: (MOVWQSXload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVWQSX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVWstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWQSX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVWQSXload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWQSXload [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWQSXload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWQZX_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWQZX x:(MOVWload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpAMD64MOVWload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQZX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWQZX x:(MOVLload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVLload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
 
            // match: (MOVWQZX x:(MOVQload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[1L];
                ptr = x.Args[0L];
                mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQZX x:(MOVWloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx1 <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVWQZX x:(MOVWloadidx1 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx1 <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                var idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQZX x:(MOVWloadidx2 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx2 <v.Type> [off] {sym} ptr idx mem)
 
            // match: (MOVWQZX x:(MOVWloadidx2 [off] {sym} ptr idx mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVWloadidx2 <v.Type> [off] {sym} ptr idx mem)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpAMD64MOVWloadidx2)
                {
                    break;
                }
                off = x.AuxInt;
                sym = x.Aux;
                _ = x.Args[2L];
                ptr = x.Args[0L];
                idx = x.Args[1L];
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx2, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (MOVWQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c & 0xffff] x)
 
            // match: (MOVWQZX (ANDLconst [c] x))
            // cond:
            // result: (ANDLconst [c & 0xffff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpAMD64ANDLconst);
                v.AuxInt = c & 0xffffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWQZX (MOVWQZX x))
            // cond:
            // result: (MOVWQZX x)
 
            // match: (MOVWQZX (MOVWQZX x))
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVWQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
 
            // match: (MOVWQZX (MOVBQZX x))
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVBQZX)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWload_0(ref Value v)
        { 
            // match: (MOVWload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVWQZX x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVWstore)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVWload [off1] {sym} (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVWload [off1] {sym1} (LEAQ [off2] {sym2} base) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWload [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (LEAQ2 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx2 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWload [off1] {sym1} (LEAQ2 [off2] {sym2} ptr idx) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWloadidx2 [off1+off2] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ2)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx2);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWloadidx1 [off] {sym} ptr idx mem)
 
            // match: (MOVWload [off] {sym} (ADDQ ptr idx) mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWloadidx1 [off] {sym} ptr idx mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
 
            // match: (MOVWload [off1] {sym1} (LEAL [off2] {sym2} base) mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {mergeSym(sym1,sym2)} base mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                @base = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
 
            // match: (MOVWload [off1] {sym} (ADDLconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWload  [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWloadidx1_0(ref Value v)
        { 
            // match: (MOVWloadidx1 [c] {sym} ptr (SHLQconst [1] idx) mem)
            // cond:
            // result: (MOVWloadidx2 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVWloadidx2);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx1 [c] {sym} (SHLQconst [1] idx) ptr mem)
            // cond:
            // result: (MOVWloadidx2 [c] {sym} ptr idx mem)
 
            // match: (MOVWloadidx1 [c] {sym} (SHLQconst [1] idx) ptr mem)
            // cond:
            // result: (MOVWloadidx2 [c] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVWloadidx2);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx1 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx1 [c] {sym} idx (ADDQconst [d] ptr) mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                idx = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx1 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx1 [c] {sym} (ADDQconst [d] idx) ptr mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx1 [c+d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWloadidx2_0(ref Value v)
        { 
            // match: (MOVWloadidx2 [c] {sym} (ADDQconst [d] ptr) idx mem)
            // cond: is32Bit(c+d)
            // result: (MOVWloadidx2 [c+d] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx2);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx2 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+2*d)
            // result: (MOVWloadidx2 [c+2*d] {sym} ptr idx mem)
 
            // match: (MOVWloadidx2 [c] {sym} ptr (ADDQconst [d] idx) mem)
            // cond: is32Bit(c+2*d)
            // result: (MOVWloadidx2 [c+2*d] {sym} ptr idx mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(c + 2L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWloadidx2);
                v.AuxInt = c + 2L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstore_0(ref Value v)
        { 
            // match: (MOVWstore [off] {sym} ptr (MOVWQSX x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVWQSX)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVWQZX x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVWQZX x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVWQZX)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVWstore [off1] {sym} (ADDQconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVWstoreconst [makeValAndOff(int64(int16(c)),off)] {sym} ptr mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVLconst [c]) mem)
            // cond: validOff(off)
            // result: (MOVWstoreconst [makeValAndOff(int64(int16(c)),off)] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(validOff(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = makeValAndOff(int64(int16(c)), off);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVWstore [off1] {sym1} (LEAQ [off2] {sym2} base) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVWstore [off1] {sym1} (LEAQ1 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx1 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (LEAQ2 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx2 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
 
            // match: (MOVWstore [off1] {sym1} (LEAQ2 [off2] {sym2} ptr idx) val mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2)
            // result: (MOVWstoreidx2 [off1+off2] {mergeSym(sym1,sym2)} ptr idx val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ2)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx2);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWstoreidx1 [off] {sym} ptr idx val mem)
 
            // match: (MOVWstore [off] {sym} (ADDQ ptr idx) val mem)
            // cond: ptr.Op != OpSB
            // result: (MOVWstoreidx1 [off] {sym} ptr idx val mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p (SHRQconst [16] w) x:(MOVWstore [i-2] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstore [i-2] {s} p w mem)
 
            // match: (MOVWstore [i] {s} p (SHRQconst [16] w) x:(MOVWstore [i-2] {s} p w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstore [i-2] {s} p w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 16L)
                {
                    break;
                }
                var w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVWstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (w != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [i] {s} p (SHRQconst [j] w) x:(MOVWstore [i-2] {s} p w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstore [i-2] {s} p w0 mem)
 
            // match: (MOVWstore [i] {s} p (SHRQconst [j] w) x:(MOVWstore [i-2] {s} p w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstore [i-2] {s} p w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_1.AuxInt;
                w = v_1.Args[0L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVWstore)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                var w0 = x.Args[1L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstore_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MOVWstore [i] {s} p x1:(MOVWload [j] {s2} p2 mem) mem2:(MOVWstore [i-2] {s} p x2:(MOVWload [j-2] {s2} p2 mem) mem))
            // cond: x1.Uses == 1   && x2.Uses == 1   && mem2.Uses == 1   && clobber(x1)   && clobber(x2)   && clobber(mem2)
            // result: (MOVLstore [i-2] {s} p (MOVLload [j-2] {s2} p2 mem) mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                var j = x1.AuxInt;
                var s2 = x1.Aux;
                _ = x1.Args[1L];
                var p2 = x1.Args[0L];
                var mem = x1.Args[1L];
                var mem2 = v.Args[2L];
                if (mem2.Op != OpAMD64MOVWstore)
                {
                    break;
                }
                if (mem2.AuxInt != i - 2L)
                {
                    break;
                }
                if (mem2.Aux != s)
                {
                    break;
                }
                _ = mem2.Args[2L];
                if (p != mem2.Args[0L])
                {
                    break;
                }
                var x2 = mem2.Args[1L];
                if (x2.Op != OpAMD64MOVWload)
                {
                    break;
                }
                if (x2.AuxInt != j - 2L)
                {
                    break;
                }
                if (x2.Aux != s2)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p2 != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (mem != mem2.Args[2L])
                {
                    break;
                }
                if (!(x1.Uses == 1L && x2.Uses == 1L && mem2.Uses == 1L && clobber(x1) && clobber(x2) && clobber(mem2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v0.AuxInt = j - 2L;
                v0.Aux = s2;
                v0.AddArg(p2);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
 
            // match: (MOVWstore [off1] {sym1} (LEAL [off2] {sym2} base) val mem)
            // cond: canMergeSym(sym1, sym2) && is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {mergeSym(sym1,sym2)} base val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                var @base = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(base);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
 
            // match: (MOVWstore [off1] {sym} (ADDLconst [off2] ptr) val mem)
            // cond: is32Bit(off1+off2)
            // result: (MOVWstore  [off1+off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstoreconst_0(ref Value v)
        { 
            // match: (MOVWstoreconst [sc] {s} (ADDQconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                var sc = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVWstoreconst [sc] {sym1} (LEAQ [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWstoreconst [x] {sym1} (LEAQ1 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ1)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [x] {sym1} (LEAQ2 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVWstoreconstidx2 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
 
            // match: (MOVWstoreconst [x] {sym1} (LEAQ2 [off] {sym2} ptr idx) mem)
            // cond: canMergeSym(sym1, sym2)
            // result: (MOVWstoreconstidx2 [ValAndOff(x).add(off)] {mergeSym(sym1,sym2)} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAQ2)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx2);
                v.AuxInt = ValAndOff(x).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVWstoreconstidx1 [x] {sym} ptr idx mem)
 
            // match: (MOVWstoreconst [x] {sym} (ADDQ ptr idx) mem)
            // cond:
            // result: (MOVWstoreconstidx1 [x] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVWstoreconstidx1);
                v.AuxInt = x;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconst [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p mem)
 
            // match: (MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconst [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p mem)
            while (true)
            {
                var c = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64MOVWstoreconst)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[1L];
                if (p != x.Args[0L])
                {
                    break;
                }
                mem = x.Args[1L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 2L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = makeValAndOff(ValAndOff(a).Val() & 0xffffUL | ValAndOff(c).Val() << (int)(16L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
 
            // match: (MOVWstoreconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem)
            // cond: canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {mergeSym(sym1, sym2)} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64LEAL)
                {
                    break;
                }
                off = v_0.AuxInt;
                sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
 
            // match: (MOVWstoreconst [sc] {s} (ADDLconst [off] ptr) mem)
            // cond: ValAndOff(sc).canAdd(off)
            // result: (MOVWstoreconst [ValAndOff(sc).add(off)] {s} ptr mem)
            while (true)
            {
                sc = v.AuxInt;
                s = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                off = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(ValAndOff(sc).canAdd(off)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = ValAndOff(sc).add(off);
                v.Aux = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstoreconstidx1_0(ref Value v)
        { 
            // match: (MOVWstoreconstidx1 [c] {sym} ptr (SHLQconst [1] idx) mem)
            // cond:
            // result: (MOVWstoreconstidx2 [c] {sym} ptr idx mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVWstoreconstidx2);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVWstoreconstidx1 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
 
            // match: (MOVWstoreconstidx1 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVWstoreconstidx1 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx1);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconstidx1 [c] {s} p i x:(MOVWstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p i mem)
 
            // match: (MOVWstoreconstidx1 [c] {s} p i x:(MOVWstoreconstidx1 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p i mem)
            while (true)
            {
                c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var i = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVWstoreconstidx1)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (i != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 2L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = makeValAndOff(ValAndOff(a).Val() & 0xffffUL | ValAndOff(c).Val() << (int)(16L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(i);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstoreconstidx2_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWstoreconstidx2 [x] {sym} (ADDQconst [c] ptr) idx mem)
            // cond: ValAndOff(x).canAdd(c)
            // result: (MOVWstoreconstidx2 [ValAndOff(x).add(c)] {sym} ptr idx mem)
            while (true)
            {
                var x = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx2);
                v.AuxInt = ValAndOff(x).add(c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconstidx2 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(2*c)
            // result: (MOVWstoreconstidx2 [ValAndOff(x).add(2*c)] {sym} ptr idx mem)
 
            // match: (MOVWstoreconstidx2 [x] {sym} ptr (ADDQconst [c] idx) mem)
            // cond: ValAndOff(x).canAdd(2*c)
            // result: (MOVWstoreconstidx2 [ValAndOff(x).add(2*c)] {sym} ptr idx mem)
            while (true)
            {
                x = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(ValAndOff(x).canAdd(2L * c)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreconstidx2);
                v.AuxInt = ValAndOff(x).add(2L * c);
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreconstidx2 [c] {s} p i x:(MOVWstoreconstidx2 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p (SHLQconst <i.Type> [1] i) mem)
 
            // match: (MOVWstoreconstidx2 [c] {s} p i x:(MOVWstoreconstidx2 [a] {s} p i mem))
            // cond: x.Uses == 1   && ValAndOff(a).Off() + 2 == ValAndOff(c).Off()   && clobber(x)
            // result: (MOVLstoreconstidx1 [makeValAndOff(ValAndOff(a).Val()&0xffff | ValAndOff(c).Val()<<16, ValAndOff(a).Off())] {s} p (SHLQconst <i.Type> [1] i) mem)
            while (true)
            {
                c = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                var i = v.Args[1L];
                x = v.Args[2L];
                if (x.Op != OpAMD64MOVWstoreconstidx2)
                {
                    break;
                }
                var a = x.AuxInt;
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[2L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (i != x.Args[1L])
                {
                    break;
                }
                mem = x.Args[2L];
                if (!(x.Uses == 1L && ValAndOff(a).Off() + 2L == ValAndOff(c).Off() && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreconstidx1);
                v.AuxInt = makeValAndOff(ValAndOff(a).Val() & 0xffffUL | ValAndOff(c).Val() << (int)(16L), ValAndOff(a).Off());
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, i.Type);
                v0.AuxInt = 1L;
                v0.AddArg(i);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstoreidx1_0(ref Value v)
        { 
            // match: (MOVWstoreidx1 [c] {sym} ptr (SHLQconst [1] idx) val mem)
            // cond:
            // result: (MOVWstoreidx2 [c] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                var idx = v_1.Args[0L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64MOVWstoreidx2);
                v.AuxInt = c;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVWstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx1 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVWstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                ptr = v_0.Args[0L];
                idx = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVWstoreidx1 [c+d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx1 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+d)
            // result: (MOVWstoreidx1 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx1);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx1 [i] {s} p idx (SHRQconst [16] w) x:(MOVWstoreidx1 [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p idx w mem)
 
            // match: (MOVWstoreidx1 [i] {s} p idx (SHRQconst [16] w) x:(MOVWstoreidx1 [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p idx w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpAMD64MOVWstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVWstoreidx1 [i-2] {s} p idx w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p idx w0 mem)
 
            // match: (MOVWstoreidx1 [i] {s} p idx (SHRQconst [j] w) x:(MOVWstoreidx1 [i-2] {s} p idx w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p idx w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpAMD64MOVWstoreidx1)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(idx);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MOVWstoreidx2_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MOVWstoreidx2 [c] {sym} (ADDQconst [d] ptr) idx val mem)
            // cond: is32Bit(c+d)
            // result: (MOVWstoreidx2 [c+d] {sym} ptr idx val mem)
            while (true)
            {
                var c = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var idx = v.Args[1L];
                var val = v.Args[2L];
                var mem = v.Args[3L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx2);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx2 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+2*d)
            // result: (MOVWstoreidx2 [c+2*d] {sym} ptr idx val mem)
 
            // match: (MOVWstoreidx2 [c] {sym} ptr (ADDQconst [d] idx) val mem)
            // cond: is32Bit(c+2*d)
            // result: (MOVWstoreidx2 [c+2*d] {sym} ptr idx val mem)
            while (true)
            {
                c = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[3L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                if (!(is32Bit(c + 2L * d)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstoreidx2);
                v.AuxInt = c + 2L * d;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx2 [i] {s} p idx (SHRQconst [16] w) x:(MOVWstoreidx2 [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p (SHLQconst <idx.Type> [1] idx) w mem)
 
            // match: (MOVWstoreidx2 [i] {s} p idx (SHRQconst [16] w) x:(MOVWstoreidx2 [i-2] {s} p idx w mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p (SHLQconst <idx.Type> [1] idx) w mem)
            while (true)
            {
                var i = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[3L];
                var p = v.Args[0L];
                idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (v_2.AuxInt != 16L)
                {
                    break;
                }
                var w = v_2.Args[0L];
                var x = v.Args[3L];
                if (x.Op != OpAMD64MOVWstoreidx2)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                if (w != x.Args[2L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type);
                v0.AuxInt = 1L;
                v0.AddArg(idx);
                v.AddArg(v0);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx2 [i] {s} p idx (SHRQconst [j] w) x:(MOVWstoreidx2 [i-2] {s} p idx w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p (SHLQconst <idx.Type> [1] idx) w0 mem)
 
            // match: (MOVWstoreidx2 [i] {s} p idx (SHRQconst [j] w) x:(MOVWstoreidx2 [i-2] {s} p idx w0:(SHRQconst [j-16] w) mem))
            // cond: x.Uses == 1   && clobber(x)
            // result: (MOVLstoreidx1 [i-2] {s} p (SHLQconst <idx.Type> [1] idx) w0 mem)
            while (true)
            {
                i = v.AuxInt;
                s = v.Aux;
                _ = v.Args[3L];
                p = v.Args[0L];
                idx = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var j = v_2.AuxInt;
                w = v_2.Args[0L];
                x = v.Args[3L];
                if (x.Op != OpAMD64MOVWstoreidx2)
                {
                    break;
                }
                if (x.AuxInt != i - 2L)
                {
                    break;
                }
                if (x.Aux != s)
                {
                    break;
                }
                _ = x.Args[3L];
                if (p != x.Args[0L])
                {
                    break;
                }
                if (idx != x.Args[1L])
                {
                    break;
                }
                var w0 = x.Args[2L];
                if (w0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                if (w0.AuxInt != j - 16L)
                {
                    break;
                }
                if (w != w0.Args[0L])
                {
                    break;
                }
                mem = x.Args[3L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstoreidx1);
                v.AuxInt = i - 2L;
                v.Aux = s;
                v.AddArg(p);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, idx.Type);
                v0.AuxInt = 1L;
                v0.AddArg(idx);
                v.AddArg(v0);
                v.AddArg(w0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULL_0(ref Value v)
        { 
            // match: (MULL x (MOVLconst [c]))
            // cond:
            // result: (MULLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64MULLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MULL (MOVLconst [c]) x)
            // cond:
            // result: (MULLconst [c] x)
 
            // match: (MULL (MOVLconst [c]) x)
            // cond:
            // result: (MULLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64MULLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULLconst_0(ref Value v)
        { 
            // match: (MULLconst [c] (MULLconst [d] x))
            // cond:
            // result: (MULLconst [int64(int32(c * d))] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MULLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64MULLconst);
                v.AuxInt = int64(int32(c * d));
                v.AddArg(x);
                return true;
            } 
            // match: (MULLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [int64(int32(c*d))])
 
            // match: (MULLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [int64(int32(c*d))])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = int64(int32(c * d));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULQ_0(ref Value v)
        { 
            // match: (MULQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (MULQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64MULQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MULQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (MULQconst [c] x)
 
            // match: (MULQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (MULQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64MULQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULQconst_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULQconst [c] (MULQconst [d] x))
            // cond: is32Bit(c*d)
            // result: (MULQconst [c * d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MULQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(is32Bit(c * d)))
                {
                    break;
                }
                v.reset(OpAMD64MULQconst);
                v.AuxInt = c * d;
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [-1] x)
            // cond:
            // result: (NEGQ x)
 
            // match: (MULQconst [-1] x)
            // cond:
            // result: (NEGQ x)
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64NEGQ);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [0] _)
            // cond:
            // result: (MOVQconst [0])
 
            // match: (MULQconst [0] _)
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (MULQconst [1] x)
            // cond:
            // result: x
 
            // match: (MULQconst [1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [3] x)
            // cond:
            // result: (LEAQ2 x x)
 
            // match: (MULQconst [3] x)
            // cond:
            // result: (LEAQ2 x x)
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [5] x)
            // cond:
            // result: (LEAQ4 x x)
 
            // match: (MULQconst [5] x)
            // cond:
            // result: (LEAQ4 x x)
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [7] x)
            // cond:
            // result: (LEAQ8 (NEGQ <v.Type> x) x)
 
            // match: (MULQconst [7] x)
            // cond:
            // result: (LEAQ8 (NEGQ <v.Type> x) x)
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ8);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, v.Type);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [9] x)
            // cond:
            // result: (LEAQ8 x x)
 
            // match: (MULQconst [9] x)
            // cond:
            // result: (LEAQ8 x x)
            while (true)
            {
                if (v.AuxInt != 9L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [11] x)
            // cond:
            // result: (LEAQ2 x (LEAQ4 <v.Type> x x))
 
            // match: (MULQconst [11] x)
            // cond:
            // result: (LEAQ2 x (LEAQ4 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 11L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ2);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [13] x)
            // cond:
            // result: (LEAQ4 x (LEAQ2 <v.Type> x x))
 
            // match: (MULQconst [13] x)
            // cond:
            // result: (LEAQ4 x (LEAQ2 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 13L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULQconst_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULQconst [21] x)
            // cond:
            // result: (LEAQ4 x (LEAQ4 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 21L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [25] x)
            // cond:
            // result: (LEAQ8 x (LEAQ2 <v.Type> x x))
 
            // match: (MULQconst [25] x)
            // cond:
            // result: (LEAQ8 x (LEAQ2 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 25L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [37] x)
            // cond:
            // result: (LEAQ4 x (LEAQ8 <v.Type> x x))
 
            // match: (MULQconst [37] x)
            // cond:
            // result: (LEAQ4 x (LEAQ8 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 37L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ4);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [41] x)
            // cond:
            // result: (LEAQ8 x (LEAQ4 <v.Type> x x))
 
            // match: (MULQconst [41] x)
            // cond:
            // result: (LEAQ8 x (LEAQ4 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 41L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [73] x)
            // cond:
            // result: (LEAQ8 x (LEAQ8 <v.Type> x x))
 
            // match: (MULQconst [73] x)
            // cond:
            // result: (LEAQ8 x (LEAQ8 <v.Type> x x))
            while (true)
            {
                if (v.AuxInt != 73L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpAMD64LEAQ8);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUBQ (SHLQconst <v.Type> [log2(c+1)] x) x)
 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c+1) && c >= 15
            // result: (SUBQ (SHLQconst <v.Type> [log2(c+1)] x) x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c + 1L) && c >= 15L))
                {
                    break;
                }
                v.reset(OpAMD64SUBQ);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (LEAQ1 (SHLQconst <v.Type> [log2(c-1)] x) x)
 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-1) && c >= 17
            // result: (LEAQ1 (SHLQconst <v.Type> [log2(c-1)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 1L) && c >= 17L))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ1);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-2) && c >= 34
            // result: (LEAQ2 (SHLQconst <v.Type> [log2(c-2)] x) x)
 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-2) && c >= 34
            // result: (LEAQ2 (SHLQconst <v.Type> [log2(c-2)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 2L) && c >= 34L))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ2);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v0.AuxInt = log2(c - 2L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-4) && c >= 68
            // result: (LEAQ4 (SHLQconst <v.Type> [log2(c-4)] x) x)
 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-4) && c >= 68
            // result: (LEAQ4 (SHLQconst <v.Type> [log2(c-4)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 4L) && c >= 68L))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ4);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v0.AuxInt = log2(c - 4L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-8) && c >= 136
            // result: (LEAQ8 (SHLQconst <v.Type> [log2(c-8)] x) x)
 
            // match: (MULQconst [c] x)
            // cond: isPowerOfTwo(c-8) && c >= 136
            // result: (LEAQ8 (SHLQconst <v.Type> [log2(c-8)] x) x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(isPowerOfTwo(c - 8L) && c >= 136L))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ8);
                v0 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v0.AuxInt = log2(c - 8L);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULQconst_20(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULQconst [c] x)
            // cond: c%3 == 0 && isPowerOfTwo(c/3)
            // result: (SHLQconst [log2(c/3)] (LEAQ2 <v.Type> x x))
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L)))
                {
                    break;
                }
                v.reset(OpAMD64SHLQconst);
                v.AuxInt = log2(c / 3L);
                var v0 = b.NewValue0(v.Pos, OpAMD64LEAQ2, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: c%5 == 0 && isPowerOfTwo(c/5)
            // result: (SHLQconst [log2(c/5)] (LEAQ4 <v.Type> x x))
 
            // match: (MULQconst [c] x)
            // cond: c%5 == 0 && isPowerOfTwo(c/5)
            // result: (SHLQconst [log2(c/5)] (LEAQ4 <v.Type> x x))
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L)))
                {
                    break;
                }
                v.reset(OpAMD64SHLQconst);
                v.AuxInt = log2(c / 5L);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ4, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [c] x)
            // cond: c%9 == 0 && isPowerOfTwo(c/9)
            // result: (SHLQconst [log2(c/9)] (LEAQ8 <v.Type> x x))
 
            // match: (MULQconst [c] x)
            // cond: c%9 == 0 && isPowerOfTwo(c/9)
            // result: (SHLQconst [log2(c/9)] (LEAQ8 <v.Type> x x))
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L)))
                {
                    break;
                }
                v.reset(OpAMD64SHLQconst);
                v.AuxInt = log2(c / 9L);
                v0 = b.NewValue0(v.Pos, OpAMD64LEAQ8, v.Type);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MULQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c*d])
 
            // match: (MULQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c*d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = c * d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULSD_0(ref Value v)
        { 
            // match: (MULSD x l:(MOVSDload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSDmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSDload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64MULSDmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULSD l:(MOVSDload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSDmem x [off] {sym} ptr mem)
 
            // match: (MULSD l:(MOVSDload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSDmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVSDload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64MULSDmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULSDmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MULSDmem x [off] {sym} ptr (MOVQstore [off] {sym} ptr y _))
            // cond:
            // result: (MULSD x (MOVQi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVQstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64MULSD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULSS_0(ref Value v)
        { 
            // match: (MULSS x l:(MOVSSload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSSmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSSload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64MULSSmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MULSS l:(MOVSSload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSSmem x [off] {sym} ptr mem)
 
            // match: (MULSS l:(MOVSSload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (MULSSmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVSSload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64MULSSmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64MULSSmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MULSSmem x [off] {sym} ptr (MOVLstore [off] {sym} ptr y _))
            // cond:
            // result: (MULSS x (MOVLi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64MULSS);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64NEGL_0(ref Value v)
        { 
            // match: (NEGL (MOVLconst [c]))
            // cond:
            // result: (MOVLconst [int64(int32(-c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = int64(int32(-c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64NEGQ_0(ref Value v)
        { 
            // match: (NEGQ (MOVQconst [c]))
            // cond:
            // result: (MOVQconst [-c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = -c;
                return true;
            } 
            // match: (NEGQ (ADDQconst [c] (NEGQ x)))
            // cond: c != -(1<<31)
            // result: (ADDQconst [-c] x)
 
            // match: (NEGQ (ADDQconst [c] (NEGQ x)))
            // cond: c != -(1<<31)
            // result: (ADDQconst [-c] x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var x = v_0_0.Args[0L];
                if (!(c != -(1L << (int)(31L))))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = -c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64NOTL_0(ref Value v)
        { 
            // match: (NOTL (MOVLconst [c]))
            // cond:
            // result: (MOVLconst [^c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64NOTQ_0(ref Value v)
        { 
            // match: (NOTQ (MOVQconst [c]))
            // cond:
            // result: (MOVQconst [^c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = ~c;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_0(ref Value v)
        { 
            // match: (ORL x (MOVLconst [c]))
            // cond:
            // result: (ORLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ORLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL (MOVLconst [c]) x)
            // cond:
            // result: (ORLconst [c] x)
 
            // match: (ORL (MOVLconst [c]) x)
            // cond:
            // result: (ORLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64ORLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (ORL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (ORL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (ORL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (ORL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (ORL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (ORL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL (SHLL x y) (ANDL (SHRL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (SHLL x y) (ANDL (SHRL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x y) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHRL x (NEGQ y))))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (SHLL x y) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHRL x (NEGQ y))))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_10(ref Value v)
        { 
            // match: (ORL (ANDL (SHRL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_0_0_1.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHRL x (NEGQ y))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHRL x (NEGQ y))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 32L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x y) (ANDL (SHRL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (SHLL x y) (ANDL (SHRL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x y) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHRL x (NEGL y))))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (SHLL x y) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHRL x (NEGL y))))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHRL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (ANDL (SHRL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHRL x (NEGL y))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHRL x (NEGL y))) (SHLL x y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRL x y) (ANDL (SHLL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (SHRL x y) (ANDL (SHLL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRL x y) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHLL x (NEGQ y))))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (SHRL x y) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHLL x (NEGQ y))))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHLL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))) (SHRL x y))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (ANDL (SHLL x (NEGQ y)) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32]))) (SHRL x y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHLL x (NEGQ y))) (SHRL x y))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [31]) [-32])) [32])) (SHLL x (NEGQ y))) (SHRL x y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_20(ref Value v)
        { 
            // match: (ORL (SHRL x y) (ANDL (SHLL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRL x y) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHLL x (NEGL y))))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (SHRL x y) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHLL x (NEGL y))))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 32L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHLL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))) (SHRL x y))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (ANDL (SHLL x (NEGL y)) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32]))) (SHRL x y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHLL x (NEGL y))) (SHRL x y))
            // cond:
            // result: (RORL x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [31]) [-32])) [32])) (SHLL x (NEGL y))) (SHRL x y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 32L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -32L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDQconst y [15])) (ANDL (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16]))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (SHLL x (ANDQconst y [15])) (ANDL (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16]))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_1_0 = v_1_0_1.Args[0L];
                if (v_1_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_1_0_1_0_0 = v_1_0_1_0.Args[0L];
                if (v_1_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_0_1_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 16L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDQconst y [15])) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16])) (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16])))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (SHLL x (ANDQconst y [15])) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16])) (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16])))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 16L)
                {
                    break;
                }
                v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_1_0 = v_1_1_1.Args[0L];
                if (v_1_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_1_1_1_0_0 = v_1_1_1_0.Args[0L];
                if (v_1_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16]))) (SHLL x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (ANDL (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16]))) (SHLL x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_0_1_0 = v_0_0_1.Args[0L];
                if (v_0_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_0_1_0_0 = v_0_0_1_0.Args[0L];
                if (v_0_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_0_1_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 16L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16])) (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16])))) (SHLL x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [15]) [-16])) [16])) (SHRW x (NEGQ (ADDQconst (ANDQconst y [15]) [-16])))) (SHLL x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 16L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_1_1_0 = v_0_1_1.Args[0L];
                if (v_0_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_1_1_0_0 = v_0_1_1_0.Args[0L];
                if (v_0_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_0_1_1_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDLconst y [15])) (ANDL (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16]))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (SHLL x (ANDLconst y [15])) (ANDL (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16]))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_0_1_0 = v_1_0_1.Args[0L];
                if (v_1_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_0_1_0_0 = v_1_0_1_0.Args[0L];
                if (v_1_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_0_1_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 16L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDLconst y [15])) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16])) (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16])))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (SHLL x (ANDLconst y [15])) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16])) (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16])))))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 16L)
                {
                    break;
                }
                v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_1_0 = v_1_1_1.Args[0L];
                if (v_1_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_1_1_0_0 = v_1_1_1_0.Args[0L];
                if (v_1_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_30(ref Value v)
        { 
            // match: (ORL (ANDL (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16]))) (SHLL x (ANDLconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_1_0 = v_0_0_1.Args[0L];
                if (v_0_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_0_1_0_0 = v_0_0_1_0.Args[0L];
                if (v_0_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                var y = v_0_0_1_0_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 16L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16])) (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16])))) (SHLL x (ANDLconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [15]) [-16])) [16])) (SHRW x (NEGL (ADDLconst (ANDLconst y [15]) [-16])))) (SHLL x (ANDLconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 16L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_1_0 = v_0_1_1.Args[0L];
                if (v_0_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_0_1_1_0_0 = v_0_1_1_0.Args[0L];
                if (v_0_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_0_1_1_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRW x (ANDQconst y [15])) (SHLL x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
 
            // match: (ORL (SHRW x (ANDQconst y [15])) (SHLL x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SHRW x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
 
            // match: (ORL (SHLL x (NEGQ (ADDQconst (ANDQconst y [15]) [-16]))) (SHRW x (ANDQconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRW x (ANDLconst y [15])) (SHLL x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
 
            // match: (ORL (SHRW x (ANDLconst y [15])) (SHLL x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != -16L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))) (SHRW x (ANDLconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
 
            // match: (ORL (SHLL x (NEGL (ADDLconst (ANDLconst y [15]) [-16]))) (SHRW x (ANDLconst y [15])))
            // cond: v.Type.Size() == 2
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != -16L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0.AuxInt != 15L)
                {
                    break;
                }
                y = v_0_1_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 15L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDQconst y [ 7])) (ANDL (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8]))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (SHLL x (ANDQconst y [ 7])) (ANDL (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8]))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_1_0 = v_1_0_1.Args[0L];
                if (v_1_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_0_1_0_0 = v_1_0_1_0.Args[0L];
                if (v_1_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_0_1_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 8L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDQconst y [ 7])) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (SHLL x (ANDQconst y [ 7])) (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 8L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_1_0 = v_1_1_1.Args[0L];
                if (v_1_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_1_1_0_0 = v_1_1_1_0.Args[0L];
                if (v_1_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8]))) (SHLL x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (ANDL (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8]))) (SHLL x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0_1_0 = v_0_0_1.Args[0L];
                if (v_0_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_0_1_0_0 = v_0_0_1_0.Args[0L];
                if (v_0_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_0_1_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 8L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])))) (SHLL x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8])))) (SHLL x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 8L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_1_0 = v_0_1_1.Args[0L];
                if (v_0_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_1_1_0_0 = v_0_1_1_0.Args[0L];
                if (v_0_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_0_1_1_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_40(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL (SHLL x (ANDLconst y [ 7])) (ANDL (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8]))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                var y = v_0_1.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_0_1_0 = v_1_0_1.Args[0L];
                if (v_1_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_0_1_0_0 = v_1_0_1_0.Args[0L];
                if (v_1_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_0_1_0_0.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 8L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (ANDLconst y [ 7])) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (SHLL x (ANDLconst y [ 7])) (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])))))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 8L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_1_1_1_0 = v_1_1_1.Args[0L];
                if (v_1_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_1_1_1_0_0 = v_1_1_1_0.Args[0L];
                if (v_1_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8]))) (SHLL x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (ANDL (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))) (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8]))) (SHLL x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_1_0 = v_0_0_1.Args[0L];
                if (v_0_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_0_0_1_0_0 = v_0_0_1_0.Args[0L];
                if (v_0_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_0_1_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 8L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])))) (SHLL x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
 
            // match: (ORL (ANDL (SBBLcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])) [ 8])) (SHRB x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8])))) (SHLL x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBLcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 8L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -8L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_1_0 = v_0_1_1.Args[0L];
                if (v_0_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                var v_0_1_1_0_0 = v_0_1_1_0.Args[0L];
                if (v_0_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_0_1_1_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRB x (ANDQconst y [ 7])) (SHLL x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
 
            // match: (ORL (SHRB x (ANDQconst y [ 7])) (SHLL x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SHRB x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
 
            // match: (ORL (SHLL x (NEGQ (ADDQconst (ANDQconst y [ 7]) [ -8]))) (SHRB x (ANDQconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHRB x (ANDLconst y [ 7])) (SHLL x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
 
            // match: (ORL (SHRB x (ANDLconst y [ 7])) (SHLL x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1_0_0.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL (SHLL x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))) (SHRB x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
 
            // match: (ORL (SHLL x (NEGL (ADDLconst (ANDLconst y [ 7]) [ -8]))) (SHRB x (ANDLconst y [ 7])))
            // cond: v.Type.Size() == 1
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != -8L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0.AuxInt != 7L)
                {
                    break;
                }
                y = v_0_1_0_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRB)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 7L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                if (!(v.Type.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORL x x)
            // cond:
            // result: x
 
            // match: (ORL x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORL x0:(MOVBload [i0] {s} p mem) sh:(SHLLconst [8] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
 
            // match: (ORL x0:(MOVBload [i0] {s} p mem) sh:(SHLLconst [8] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_50(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBload [i1] {s} p mem)) x0:(MOVBload [i0] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                var mem = x1.Args[1L];
                var x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVWload [i0] {s} p mem) sh:(SHLLconst [16] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
 
            // match: (ORL x0:(MOVWload [i0] {s} p mem) sh:(SHLLconst [16] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWload [i1] {s} p mem)) x0:(MOVWload [i0] {s} p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWload [i1] {s} p mem)) x0:(MOVWload [i0] {s} p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) y) s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) y) s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem))) s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem))) s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                var idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_60(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_70(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORL sh:(SHLLconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_80(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORL or:(ORL y s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL x1:(MOVBload [i1] {s} p mem) sh:(SHLLconst [8] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
 
            // match: (ORL x1:(MOVBload [i1] {s} p mem) sh:(SHLLconst [8] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_90(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBload [i0] {s} p mem)) x1:(MOVBload [i1] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                var r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) y) s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem)) y) s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem))) s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBload [i1] {s} p mem))) s0:(SHLLconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                var idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_100(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_110(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORL sh:(SHLLconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_120(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORL s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORL or:(ORL y s1:(SHLLconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLLconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORL <v.Type> (SHLLconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORL)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLLconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORLmem x [off] {sym} ptr mem)
 
            // match: (ORL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ORLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORL_130(ref Value v)
        { 
            // match: (ORL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var l = v.Args[0L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                var x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ORLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORLconst_0(ref Value v)
        { 
            // match: (ORLconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORLconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVLconst [-1])
 
            // match: (ORLconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVLconst [-1])
            while (true)
            {
                c = v.AuxInt;
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c|d])
 
            // match: (ORLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c|d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = c | d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORLmem x [off] {sym} ptr (MOVSSstore [off] {sym} ptr y _))
            // cond:
            // result: ( ORL x (MOVLf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ORL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_0(ref Value v)
        { 
            // match: (ORQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (ORQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ORQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ORQconst [c] x)
 
            // match: (ORQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (ORQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64ORQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (ORQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (ORQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQ (SHLQ x y) (ANDQ (SHRQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (SHLQ x y) (ANDQ (SHRQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHLQ x y) (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHRQ x (NEGQ y))))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (SHLQ x y) (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHRQ x (NEGQ y))))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SHRQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (ANDQ (SHRQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHRQ x (NEGQ y))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHRQ x (NEGQ y))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHLQ x y) (ANDQ (SHRQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (SHLQ x y) (ANDQ (SHRQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHLQ x y) (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHRQ x (NEGL y))))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (SHLQ x y) (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHRQ x (NEGL y))))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_10(ref Value v)
        { 
            // match: (ORQ (ANDQ (SHRQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var x = v_0_0.Args[0L];
                var v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                var y = v_0_0_1.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHRQ x (NEGL y))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHRQ x (NEGL y))) (SHLQ x y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                var v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHRQ x y) (ANDQ (SHLQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (SHRQ x y) (ANDQ (SHLQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                var v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHRQ x y) (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHLQ x (NEGQ y))))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (SHRQ x y) (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHLQ x (NEGQ y))))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                var v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SHLQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (ANDQ (SHLQ x (NEGQ y)) (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64]))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHLQ x (NEGQ y))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPQconst (NEGQ (ADDQconst (ANDQconst y [63]) [-64])) [64])) (SHLQ x (NEGQ y))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 64L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGQ)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHRQ x y) (ANDQ (SHLQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (SHRQ x y) (ANDQ (SHLQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                if (x != v_1_0.Args[0L])
                {
                    break;
                }
                v_1_0_1 = v_1_0.Args[1L];
                if (v_1_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_0_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1_0_0 = v_1_1_0.Args[0L];
                if (v_1_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_1_0_0_0 = v_1_1_0_0.Args[0L];
                if (v_1_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_1_1_0_0_0_0 = v_1_1_0_0_0.Args[0L];
                if (v_1_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (SHRQ x y) (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHLQ x (NEGL y))))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (SHRQ x y) (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHLQ x (NEGL y))))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_0_0_0 = v_1_0_0.Args[0L];
                if (v_1_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_1_0_0_0_0 = v_1_0_0_0.Args[0L];
                if (v_1_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_1_0_0_0_0_0 = v_1_0_0_0_0.Args[0L];
                if (v_1_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_1_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_0_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                if (x != v_1_1.Args[0L])
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SHLQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (ANDQ (SHLQ x (NEGL y)) (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64]))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                x = v_0_0.Args[0L];
                v_0_0_1 = v_0_0.Args[1L];
                if (v_0_0_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_0_0_1.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_0_1_0_0 = v_0_1_0.Args[0L];
                if (v_0_1_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_1_0_0_0 = v_0_1_0_0.Args[0L];
                if (v_0_1_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_0_1_0_0_0_0 = v_0_1_0_0_0.Args[0L];
                if (v_0_1_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_1_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_0_1_0_0_0_0.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHLQ x (NEGL y))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
 
            // match: (ORQ (ANDQ (SBBQcarrymask (CMPLconst (NEGL (ADDLconst (ANDLconst y [63]) [-64])) [64])) (SHLQ x (NEGL y))) (SHRQ x y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ANDQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SBBQcarrymask)
                {
                    break;
                }
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64CMPLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 64L)
                {
                    break;
                }
                v_0_0_0_0 = v_0_0_0.Args[0L];
                if (v_0_0_0_0.Op != OpAMD64NEGL)
                {
                    break;
                }
                v_0_0_0_0_0 = v_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0.AuxInt != -64L)
                {
                    break;
                }
                v_0_0_0_0_0_0 = v_0_0_0_0_0.Args[0L];
                if (v_0_0_0_0_0_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                if (v_0_0_0_0_0_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_0_0_0_0_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                x = v_0_1.Args[0L];
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                if (y != v_0_1_1.Args[0L])
                {
                    break;
                }
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQ x0:(MOVBload [i0] {s} p mem) sh:(SHLQconst [8] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
 
            // match: (ORQ x0:(MOVBload [i0] {s} p mem) sh:(SHLQconst [8] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                var x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBload [i1] {s} p mem)) x0:(MOVBload [i0] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBload [i1] {s} p mem)) x0:(MOVBload [i0] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVWload [i0] {s} p mem) sh:(SHLQconst [16] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
 
            // match: (ORQ x0:(MOVWload [i0] {s} p mem) sh:(SHLQconst [16] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWload [i1] {s} p mem)) x0:(MOVWload [i0] {s} p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWload [i1] {s} p mem)) x0:(MOVWload [i0] {s} p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVLload [i0] {s} p mem) sh:(SHLQconst [32] x1:(MOVLload [i1] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQload [i0] {s} p mem)
 
            // match: (ORQ x0:(MOVLload [i0] {s} p mem) sh:(SHLQconst [32] x1:(MOVLload [i1] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLload [i1] {s} p mem)) x0:(MOVLload [i0] {s} p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQload [i0] {s} p mem)
 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLload [i1] {s} p mem)) x0:(MOVLload [i0] {s} p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQload [i0] {s} p mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) y) s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) y) s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_30(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem))) s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem)) y) s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem)) y) s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem))) s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWload [i0] {s} p mem))) s1:(SHLQconst [j1] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLload [i0] {s} p mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                var idx = x0.Args[1L];
                mem = x0.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVBloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_40(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} p idx mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [8] x1:(MOVBloadidx1 [i1] {s} idx p mem)) x0:(MOVBloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVWloadidx1 <v.Type> [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVWloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} p idx mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_50(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ sh:(SHLQconst [16] x1:(MOVWloadidx1 [i1] {s} idx p mem)) x0:(MOVWloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVLloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} p idx mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ x0:(MOVLloadidx1 [i0] {s} idx p mem) sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                x0 = v.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)) x0:(MOVLloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)) x0:(MOVLloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)) x0:(MOVLloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)) x0:(MOVLloadidx1 [i0] {s} p idx mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)) x0:(MOVLloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} p idx mem)) x0:(MOVLloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)) x0:(MOVLloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
 
            // match: (ORQ sh:(SHLQconst [32] x1:(MOVLloadidx1 [i1] {s} idx p mem)) x0:(MOVLloadidx1 [i0] {s} idx p mem))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (MOVQloadidx1 [i0] {s} p idx mem)
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                x1 = sh.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                x0 = v.Args[1L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(idx);
                v0.AddArg(mem);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_60(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_70(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0+8   && j0 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVWloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 + 8L && j0 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_80(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)) or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem)) y) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s0 = or.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                y = or.Args[1L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} p idx mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_90(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s0:(SHLQconst [j0] x0:(MOVWloadidx1 [i0] {s} idx p mem))) s1:(SHLQconst [j1] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && j1 == j0+16   && j0 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j0] (MOVLloadidx1 [i0] {s} p idx mem)) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s0 = or.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var s1 = v.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 + 16L && j0 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j0;
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v2.AuxInt = i0;
                v2.Aux = s;
                v2.AddArg(p);
                v2.AddArg(idx);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ x1:(MOVBload [i1] {s} p mem) sh:(SHLQconst [8] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
 
            // match: (ORQ x1:(MOVBload [i1] {s} p mem) sh:(SHLQconst [8] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBload [i0] {s} p mem)) x1:(MOVBload [i1] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBload [i0] {s} p mem)) x1:(MOVBload [i1] {s} p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                var r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(BSWAPL x1:(MOVLload [i1] {s} p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLload [i0] {s} p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQload [i0] {s} p mem))
 
            // match: (ORQ r1:(BSWAPL x1:(MOVLload [i1] {s} p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLload [i0] {s} p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLload [i0] {s} p mem))) r1:(BSWAPL x1:(MOVLload [i1] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQload [i0] {s} p mem))
 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLload [i0] {s} p mem))) r1:(BSWAPL x1:(MOVLload [i1] {s} p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQload [i0] {s} p mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) y) s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem)) y) s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_100(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBload [i1] {s} p mem))) s0:(SHLQconst [j0] x0:(MOVBload [i0] {s} p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[1L];
                var p = x1.Args[0L];
                var mem = x1.Args[1L];
                var s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWload [i1] {s} p mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWload [i0] {s} p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLload [i0] {s} p mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                var idx = x1.Args[1L];
                mem = x1.Args[2L];
                var sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} p idx mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ x1:(MOVBloadidx1 [i1] {s} idx p mem) sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                x1 = v.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_110(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} p idx mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                var x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} p idx mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [8] x0:(MOVBloadidx1 [i0] {s} idx p mem)) x1:(MOVBloadidx1 [i1] {s} idx p mem))
            // cond: i1 == i0+1   && x0.Uses == 1   && x1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (ROLWconst <v.Type> [8] (MOVWloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 8L)
                {
                    break;
                }
                x0 = sh.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                x1 = v.Args[1L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ROLWconst, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = 8L;
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_120(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ sh:(SHLQconst [16] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+2   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPL <v.Type> (MOVLloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                var sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 16L)
                {
                    break;
                }
                var r0 = sh.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var r1 = v.Args[1L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64BSWAPL, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)) sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                r1 = v.Args[0L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                sh = v.Args[1L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} p idx mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} p idx mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
 
            // match: (ORQ sh:(SHLQconst [32] r0:(BSWAPL x0:(MOVLloadidx1 [i0] {s} idx p mem))) r1:(BSWAPL x1:(MOVLloadidx1 [i1] {s} idx p mem)))
            // cond: i1 == i0+4   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && sh.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(sh)
            // result: @mergePoint(b,x0,x1) (BSWAPQ <v.Type> (MOVQloadidx1 [i0] {s} p idx mem))
            while (true)
            {
                _ = v.Args[1L];
                sh = v.Args[0L];
                if (sh.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                if (sh.AuxInt != 32L)
                {
                    break;
                }
                r0 = sh.Args[0L];
                if (r0.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                r1 = v.Args[1L];
                if (r1.Op != OpAMD64BSWAPL)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVLloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 4L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && sh.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(sh)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64BSWAPQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQloadidx1, typ.UInt64);
                v1.AuxInt = i0;
                v1.Aux = s;
                v1.AddArg(p);
                v1.AddArg(idx);
                v1.AddArg(mem);
                v0.AddArg(v1);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_130(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                var y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)) or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_140(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} p idx mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem)) y) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} p idx mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] x1:(MOVBloadidx1 [i1] {s} idx p mem))) s0:(SHLQconst [j0] x0:(MOVBloadidx1 [i0] {s} idx p mem)))
            // cond: i1 == i0+1   && j1 == j0-8   && j1 % 16 == 0   && x0.Uses == 1   && x1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (ROLWconst <typ.UInt16> [8] (MOVWloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                x1 = s1.Args[0L];
                if (x1.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                x0 = s0.Args[0L];
                if (x0.Op != OpAMD64MOVBloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 1L && j1 == j0 - 8L && j1 % 16L == 0L && x0.Uses == 1L && x1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64ROLWconst, typ.UInt16);
                v2.AuxInt = 8L;
                v3 = b.NewValue0(v.Pos, OpAMD64MOVWloadidx1, typ.UInt16);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                y = or.Args[1L];
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_150(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[2L];
                var idx = x0.Args[0L];
                var p = x0.Args[1L];
                var mem = x0.Args[2L];
                var or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (idx != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                p = x0.Args[0L];
                idx = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))) or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                s0 = v.Args[0L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[2L];
                idx = x0.Args[0L];
                p = x0.Args[1L];
                mem = x0.Args[2L];
                or = v.Args[1L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (idx != x1.Args[0L])
                {
                    break;
                }
                if (p != x1.Args[1L])
                {
                    break;
                }
                if (mem != x1.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} p idx mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (idx != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem))) y) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                s1 = or.Args[0L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                idx = x1.Args[0L];
                p = x1.Args[1L];
                mem = x1.Args[2L];
                y = or.Args[1L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} p idx mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                y = or.Args[0L];
                s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j1 = s1.AuxInt;
                r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[2L];
                p = x1.Args[0L];
                idx = x1.Args[1L];
                mem = x1.Args[2L];
                s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                j0 = s0.AuxInt;
                r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQ_160(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQ or:(ORQ y s1:(SHLQconst [j1] r1:(ROLWconst [8] x1:(MOVWloadidx1 [i1] {s} idx p mem)))) s0:(SHLQconst [j0] r0:(ROLWconst [8] x0:(MOVWloadidx1 [i0] {s} idx p mem))))
            // cond: i1 == i0+2   && j1 == j0-16   && j1 % 32 == 0   && x0.Uses == 1   && x1.Uses == 1   && r0.Uses == 1   && r1.Uses == 1   && s0.Uses == 1   && s1.Uses == 1   && or.Uses == 1   && mergePoint(b,x0,x1) != nil   && clobber(x0)   && clobber(x1)   && clobber(r0)   && clobber(r1)   && clobber(s0)   && clobber(s1)   && clobber(or)
            // result: @mergePoint(b,x0,x1) (ORQ <v.Type> (SHLQconst <v.Type> [j1] (BSWAPL <typ.UInt32> (MOVLloadidx1 [i0] {s} p idx mem))) y)
            while (true)
            {
                _ = v.Args[1L];
                var or = v.Args[0L];
                if (or.Op != OpAMD64ORQ)
                {
                    break;
                }
                _ = or.Args[1L];
                var y = or.Args[0L];
                var s1 = or.Args[1L];
                if (s1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j1 = s1.AuxInt;
                var r1 = s1.Args[0L];
                if (r1.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r1.AuxInt != 8L)
                {
                    break;
                }
                var x1 = r1.Args[0L];
                if (x1.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                var s = x1.Aux;
                _ = x1.Args[2L];
                var idx = x1.Args[0L];
                var p = x1.Args[1L];
                var mem = x1.Args[2L];
                var s0 = v.Args[1L];
                if (s0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                var j0 = s0.AuxInt;
                var r0 = s0.Args[0L];
                if (r0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                if (r0.AuxInt != 8L)
                {
                    break;
                }
                var x0 = r0.Args[0L];
                if (x0.Op != OpAMD64MOVWloadidx1)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (idx != x0.Args[0L])
                {
                    break;
                }
                if (p != x0.Args[1L])
                {
                    break;
                }
                if (mem != x0.Args[2L])
                {
                    break;
                }
                if (!(i1 == i0 + 2L && j1 == j0 - 16L && j1 % 32L == 0L && x0.Uses == 1L && x1.Uses == 1L && r0.Uses == 1L && r1.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && or.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(r0) && clobber(r1) && clobber(s0) && clobber(s1) && clobber(or)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, v.Type);
                v.reset(OpCopy);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SHLQconst, v.Type);
                v1.AuxInt = j1;
                var v2 = b.NewValue0(v.Pos, OpAMD64BSWAPL, typ.UInt32);
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVLloadidx1, typ.UInt32);
                v3.AuxInt = i0;
                v3.Aux = s;
                v3.AddArg(p);
                v3.AddArg(idx);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v0.AddArg(y);
                return true;
            } 
            // match: (ORQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORQmem x [off] {sym} ptr mem)
 
            // match: (ORQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ORQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (ORQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORQmem x [off] {sym} ptr mem)
 
            // match: (ORQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (ORQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64ORQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQconst_0(ref Value v)
        { 
            // match: (ORQconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORQconst [-1] _)
            // cond:
            // result: (MOVQconst [-1])
 
            // match: (ORQconst [-1] _)
            // cond:
            // result: (MOVQconst [-1])
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c|d])
 
            // match: (ORQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c|d])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = c | d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ORQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ORQmem x [off] {sym} ptr (MOVSDstore [off] {sym} ptr y _))
            // cond:
            // result: ( ORQ x (MOVQf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64ORQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLB_0(ref Value v)
        { 
            // match: (ROLB x (NEGQ y))
            // cond:
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLB x (NEGL y))
            // cond:
            // result: (RORB x y)
 
            // match: (ROLB x (NEGL y))
            // cond:
            // result: (RORB x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64RORB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLB x (MOVQconst [c]))
            // cond:
            // result: (ROLBconst [c&7 ] x)
 
            // match: (ROLB x (MOVQconst [c]))
            // cond:
            // result: (ROLBconst [c&7 ] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c & 7L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLB x (MOVLconst [c]))
            // cond:
            // result: (ROLBconst [c&7 ] x)
 
            // match: (ROLB x (MOVLconst [c]))
            // cond:
            // result: (ROLBconst [c&7 ] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c & 7L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLBconst_0(ref Value v)
        { 
            // match: (ROLBconst [c] (ROLBconst [d] x))
            // cond:
            // result: (ROLBconst [(c+d)& 7] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ROLBconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = (c + d) & 7L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLBconst x [0])
            // cond:
            // result: x
 
            // match: (ROLBconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLL_0(ref Value v)
        { 
            // match: (ROLL x (NEGQ y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLL x (NEGL y))
            // cond:
            // result: (RORL x y)
 
            // match: (ROLL x (NEGL y))
            // cond:
            // result: (RORL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64RORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLL x (MOVQconst [c]))
            // cond:
            // result: (ROLLconst [c&31] x)
 
            // match: (ROLL x (MOVQconst [c]))
            // cond:
            // result: (ROLLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLL x (MOVLconst [c]))
            // cond:
            // result: (ROLLconst [c&31] x)
 
            // match: (ROLL x (MOVLconst [c]))
            // cond:
            // result: (ROLLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLLconst_0(ref Value v)
        { 
            // match: (ROLLconst [c] (ROLLconst [d] x))
            // cond:
            // result: (ROLLconst [(c+d)&31] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ROLLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = (c + d) & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLLconst x [0])
            // cond:
            // result: x
 
            // match: (ROLLconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLQ_0(ref Value v)
        { 
            // match: (ROLQ x (NEGQ y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLQ x (NEGL y))
            // cond:
            // result: (RORQ x y)
 
            // match: (ROLQ x (NEGL y))
            // cond:
            // result: (RORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64RORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLQ x (MOVQconst [c]))
            // cond:
            // result: (ROLQconst [c&63] x)
 
            // match: (ROLQ x (MOVQconst [c]))
            // cond:
            // result: (ROLQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLQ x (MOVLconst [c]))
            // cond:
            // result: (ROLQconst [c&63] x)
 
            // match: (ROLQ x (MOVLconst [c]))
            // cond:
            // result: (ROLQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLQconst_0(ref Value v)
        { 
            // match: (ROLQconst [c] (ROLQconst [d] x))
            // cond:
            // result: (ROLQconst [(c+d)&63] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ROLQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = (c + d) & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLQconst x [0])
            // cond:
            // result: x
 
            // match: (ROLQconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLW_0(ref Value v)
        { 
            // match: (ROLW x (NEGQ y))
            // cond:
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLW x (NEGL y))
            // cond:
            // result: (RORW x y)
 
            // match: (ROLW x (NEGL y))
            // cond:
            // result: (RORW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64RORW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ROLW x (MOVQconst [c]))
            // cond:
            // result: (ROLWconst [c&15] x)
 
            // match: (ROLW x (MOVQconst [c]))
            // cond:
            // result: (ROLWconst [c&15] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c & 15L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLW x (MOVLconst [c]))
            // cond:
            // result: (ROLWconst [c&15] x)
 
            // match: (ROLW x (MOVLconst [c]))
            // cond:
            // result: (ROLWconst [c&15] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c & 15L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64ROLWconst_0(ref Value v)
        { 
            // match: (ROLWconst [c] (ROLWconst [d] x))
            // cond:
            // result: (ROLWconst [(c+d)&15] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64ROLWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = (c + d) & 15L;
                v.AddArg(x);
                return true;
            } 
            // match: (ROLWconst x [0])
            // cond:
            // result: x
 
            // match: (ROLWconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64RORB_0(ref Value v)
        { 
            // match: (RORB x (NEGQ y))
            // cond:
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORB x (NEGL y))
            // cond:
            // result: (ROLB x y)
 
            // match: (RORB x (NEGL y))
            // cond:
            // result: (ROLB x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64ROLB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORB x (MOVQconst [c]))
            // cond:
            // result: (ROLBconst [(-c)&7 ] x)
 
            // match: (RORB x (MOVQconst [c]))
            // cond:
            // result: (ROLBconst [(-c)&7 ] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = (-c) & 7L;
                v.AddArg(x);
                return true;
            } 
            // match: (RORB x (MOVLconst [c]))
            // cond:
            // result: (ROLBconst [(-c)&7 ] x)
 
            // match: (RORB x (MOVLconst [c]))
            // cond:
            // result: (ROLBconst [(-c)&7 ] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = (-c) & 7L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64RORL_0(ref Value v)
        { 
            // match: (RORL x (NEGQ y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORL x (NEGL y))
            // cond:
            // result: (ROLL x y)
 
            // match: (RORL x (NEGL y))
            // cond:
            // result: (ROLL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64ROLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORL x (MOVQconst [c]))
            // cond:
            // result: (ROLLconst [(-c)&31] x)
 
            // match: (RORL x (MOVQconst [c]))
            // cond:
            // result: (ROLLconst [(-c)&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = (-c) & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (RORL x (MOVLconst [c]))
            // cond:
            // result: (ROLLconst [(-c)&31] x)
 
            // match: (RORL x (MOVLconst [c]))
            // cond:
            // result: (ROLLconst [(-c)&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = (-c) & 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64RORQ_0(ref Value v)
        { 
            // match: (RORQ x (NEGQ y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORQ x (NEGL y))
            // cond:
            // result: (ROLQ x y)
 
            // match: (RORQ x (NEGL y))
            // cond:
            // result: (ROLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64ROLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORQ x (MOVQconst [c]))
            // cond:
            // result: (ROLQconst [(-c)&63] x)
 
            // match: (RORQ x (MOVQconst [c]))
            // cond:
            // result: (ROLQconst [(-c)&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = (-c) & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (RORQ x (MOVLconst [c]))
            // cond:
            // result: (ROLQconst [(-c)&63] x)
 
            // match: (RORQ x (MOVLconst [c]))
            // cond:
            // result: (ROLQconst [(-c)&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = (-c) & 63L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64RORW_0(ref Value v)
        { 
            // match: (RORW x (NEGQ y))
            // cond:
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORW x (NEGL y))
            // cond:
            // result: (ROLW x y)
 
            // match: (RORW x (NEGL y))
            // cond:
            // result: (ROLW x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpAMD64ROLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RORW x (MOVQconst [c]))
            // cond:
            // result: (ROLWconst [(-c)&15] x)
 
            // match: (RORW x (MOVQconst [c]))
            // cond:
            // result: (ROLWconst [(-c)&15] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = (-c) & 15L;
                v.AddArg(x);
                return true;
            } 
            // match: (RORW x (MOVLconst [c]))
            // cond:
            // result: (ROLWconst [(-c)&15] x)
 
            // match: (RORW x (MOVLconst [c]))
            // cond:
            // result: (ROLWconst [(-c)&15] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = (-c) & 15L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARB_0(ref Value v)
        { 
            // match: (SARB x (MOVQconst [c]))
            // cond:
            // result: (SARBconst [min(c&31,7)] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SARBconst);
                v.AuxInt = min(c & 31L, 7L);
                v.AddArg(x);
                return true;
            } 
            // match: (SARB x (MOVLconst [c]))
            // cond:
            // result: (SARBconst [min(c&31,7)] x)
 
            // match: (SARB x (MOVLconst [c]))
            // cond:
            // result: (SARBconst [min(c&31,7)] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SARBconst);
                v.AuxInt = min(c & 31L, 7L);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARBconst_0(ref Value v)
        { 
            // match: (SARBconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SARBconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int8(d))>>uint64(c)])
 
            // match: (SARBconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int8(d))>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = int64(int8(d)) >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SARL x (MOVQconst [c]))
            // cond:
            // result: (SARLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SARLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SARL x (MOVLconst [c]))
            // cond:
            // result: (SARLconst [c&31] x)
 
            // match: (SARL x (MOVLconst [c]))
            // cond:
            // result: (SARLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SARLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SARL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SARL x y)
 
            // match: (SARL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SARL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SARL x (NEGQ <t> y))
 
            // match: (SARL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SARL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SARL x y)
 
            // match: (SARL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SARL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SARL x (NEGQ <t> y))
 
            // match: (SARL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SARL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SARL x y)
 
            // match: (SARL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SARL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SARL x (NEGL <t> y))
 
            // match: (SARL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SARL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SARL x y)
 
            // match: (SARL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SARL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SARL x (NEGL <t> y))
 
            // match: (SARL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SARL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SARL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARLconst_0(ref Value v)
        { 
            // match: (SARLconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SARLconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int32(d))>>uint64(c)])
 
            // match: (SARLconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int32(d))>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = int64(int32(d)) >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SARQ x (MOVQconst [c]))
            // cond:
            // result: (SARQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SARQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SARQ x (MOVLconst [c]))
            // cond:
            // result: (SARQconst [c&63] x)
 
            // match: (SARQ x (MOVLconst [c]))
            // cond:
            // result: (SARQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SARQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SARQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SARQ x y)
 
            // match: (SARQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SARQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SARQ x (NEGQ <t> y))
 
            // match: (SARQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SARQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SARQ x y)
 
            // match: (SARQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SARQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SARQ x (NEGQ <t> y))
 
            // match: (SARQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SARQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SARQ x y)
 
            // match: (SARQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SARQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SARQ x (NEGL <t> y))
 
            // match: (SARQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SARQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SARQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SARQ x y)
 
            // match: (SARQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SARQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SARQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SARQ x (NEGL <t> y))
 
            // match: (SARQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SARQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SARQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARQconst_0(ref Value v)
        { 
            // match: (SARQconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SARQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [d>>uint64(c)])
 
            // match: (SARQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [d>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = d >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARW_0(ref Value v)
        { 
            // match: (SARW x (MOVQconst [c]))
            // cond:
            // result: (SARWconst [min(c&31,15)] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SARWconst);
                v.AuxInt = min(c & 31L, 15L);
                v.AddArg(x);
                return true;
            } 
            // match: (SARW x (MOVLconst [c]))
            // cond:
            // result: (SARWconst [min(c&31,15)] x)
 
            // match: (SARW x (MOVLconst [c]))
            // cond:
            // result: (SARWconst [min(c&31,15)] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SARWconst);
                v.AuxInt = min(c & 31L, 15L);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SARWconst_0(ref Value v)
        { 
            // match: (SARWconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SARWconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int16(d))>>uint64(c)])
 
            // match: (SARWconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [int64(int16(d))>>uint64(c)])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = int64(int16(d)) >> (int)(uint64(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SBBLcarrymask_0(ref Value v)
        { 
            // match: (SBBLcarrymask (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SBBLcarrymask (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [-1])
 
            // match: (SBBLcarrymask (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SBBLcarrymask (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SBBLcarrymask (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SBBLcarrymask (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [-1])
 
            // match: (SBBLcarrymask (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SBBLcarrymask (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SBBLcarrymask (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SBBQcarrymask_0(ref Value v)
        { 
            // match: (SBBQcarrymask (FlagEQ))
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SBBQcarrymask (FlagLT_ULT))
            // cond:
            // result: (MOVQconst [-1])
 
            // match: (SBBQcarrymask (FlagLT_ULT))
            // cond:
            // result: (MOVQconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SBBQcarrymask (FlagLT_UGT))
            // cond:
            // result: (MOVQconst [0])
 
            // match: (SBBQcarrymask (FlagLT_UGT))
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SBBQcarrymask (FlagGT_ULT))
            // cond:
            // result: (MOVQconst [-1])
 
            // match: (SBBQcarrymask (FlagGT_ULT))
            // cond:
            // result: (MOVQconst [-1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (SBBQcarrymask (FlagGT_UGT))
            // cond:
            // result: (MOVQconst [0])
 
            // match: (SBBQcarrymask (FlagGT_UGT))
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETA_0(ref Value v)
        { 
            // match: (SETA (InvertFlags x))
            // cond:
            // result: (SETB x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETB);
                v.AddArg(x);
                return true;
            } 
            // match: (SETA (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETA (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETA (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETA (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETA (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETA (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETA (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETA (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETA (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETA (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETAE_0(ref Value v)
        { 
            // match: (SETAE (InvertFlags x))
            // cond:
            // result: (SETBE x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETBE);
                v.AddArg(x);
                return true;
            } 
            // match: (SETAE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETAE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETAE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETAE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETAE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETAE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETAE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETAE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETAE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETAE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETAEmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETAEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETBEmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETBEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETAEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETAEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETAEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETAEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETAEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETAmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETAmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETBmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETAmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETAmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETAmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETAmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETAmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETAmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETB_0(ref Value v)
        { 
            // match: (SETB (InvertFlags x))
            // cond:
            // result: (SETA x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETA);
                v.AddArg(x);
                return true;
            } 
            // match: (SETB (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETB (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETB (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETB (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETB (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETB (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETB (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETB (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETB (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETB (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETBE_0(ref Value v)
        { 
            // match: (SETBE (InvertFlags x))
            // cond:
            // result: (SETAE x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETAE);
                v.AddArg(x);
                return true;
            } 
            // match: (SETBE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETBE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETBE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETBE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETBE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETBE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETBE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETBE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETBE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETBE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETBEmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETBEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETAEmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETBEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETBEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETBEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETBEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETBEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETBmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETBmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETAmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETAmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETBmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETBmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETBmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETBmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETBmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETBmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETEQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (SETEQ (TESTL (SHLL (MOVLconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETAE (BTL x y))
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v_0_0.Args[1L];
                var y = v_0.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                var v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTL y (SHLL (MOVLconst [1]) x)))
            // cond: !config.nacl
            // result: (SETAE (BTL x y))
 
            // match: (SETEQ (TESTL y (SHLL (MOVLconst [1]) x)))
            // cond: !config.nacl
            // result: (SETAE (BTL x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_1.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTQ (SHLQ (MOVQconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETAE (BTQ x y))
 
            // match: (SETEQ (TESTQ (SHLQ (MOVQconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETAE (BTQ x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_0.Args[1L];
                y = v_0.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTQ y (SHLQ (MOVQconst [1]) x)))
            // cond: !config.nacl
            // result: (SETAE (BTQ x y))
 
            // match: (SETEQ (TESTQ y (SHLQ (MOVQconst [1]) x)))
            // cond: !config.nacl
            // result: (SETAE (BTQ x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_1.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTLconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETAE (BTLconst [log2(c)] x))
 
            // match: (SETEQ (TESTLconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETAE (BTLconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTQconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
 
            // match: (SETEQ (TESTQconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTQ (MOVQconst [c]) x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
 
            // match: (SETEQ (TESTQ (MOVQconst [c]) x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (TESTQ x (MOVQconst [c])))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
 
            // match: (SETEQ (TESTQ x (MOVQconst [c])))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAE (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAE);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETEQ (InvertFlags x))
            // cond:
            // result: (SETEQ x)
 
            // match: (SETEQ (InvertFlags x))
            // cond:
            // result: (SETEQ x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETEQ);
                v.AddArg(x);
                return true;
            } 
            // match: (SETEQ (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETEQ (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETEQ_10(ref Value v)
        { 
            // match: (SETEQ (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETEQ (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETEQ (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETEQ (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETEQ (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETEQ (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETEQ (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETEQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (SETEQmem [off] {sym} ptr (TESTL (SHLL (MOVLconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTL x y) mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v_1_0.Args[1L];
                var y = v_1.Args[1L];
                var mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTL y (SHLL (MOVLconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTL x y) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTL y (SHLL (MOVLconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTL x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTQ (SHLQ (MOVQconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQ x y) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTQ (SHLQ (MOVQconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQ x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_0.Args[1L];
                y = v_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTQ y (SHLQ (MOVQconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQ x y) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTQ y (SHLQ (MOVQconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQ x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTLconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTLconst [log2(c)] x) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTLconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTLconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                x = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTQconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTQconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                x = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTQ (MOVQconst [c]) x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTQ (MOVQconst [c]) x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                x = v_1.Args[1L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (TESTQ x (MOVQconst [c])) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETEQmem [off] {sym} ptr (TESTQ x (MOVQconst [c])) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETAEmem [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1_1.AuxInt;
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETAEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETEQmem [off] {sym} ptr x mem)
 
            // match: (SETEQmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETEQmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64SETEQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETEQmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETEQmem_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETEQmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETEQmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETEQmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETEQmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETEQmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETG_0(ref Value v)
        { 
            // match: (SETG (InvertFlags x))
            // cond:
            // result: (SETL x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETL);
                v.AddArg(x);
                return true;
            } 
            // match: (SETG (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETG (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETG (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETG (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETG (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETG (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETG (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETG (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETG (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETG (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETGE_0(ref Value v)
        { 
            // match: (SETGE (InvertFlags x))
            // cond:
            // result: (SETLE x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETLE);
                v.AddArg(x);
                return true;
            } 
            // match: (SETGE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETGE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETGE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETGE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETGE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETGE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETGE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETGE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETGE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETGE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETGEmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETGEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETLEmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETLEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETGEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETGEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETGEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETGEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETGEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETGmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETGmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETLmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETGmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETGmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETGmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETGmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETGmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETGmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETL_0(ref Value v)
        { 
            // match: (SETL (InvertFlags x))
            // cond:
            // result: (SETG x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETG);
                v.AddArg(x);
                return true;
            } 
            // match: (SETL (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETL (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETL (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETL (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETL (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETL (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETL (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETL (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETL (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETL (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETLE_0(ref Value v)
        { 
            // match: (SETLE (InvertFlags x))
            // cond:
            // result: (SETGE x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETGE);
                v.AddArg(x);
                return true;
            } 
            // match: (SETLE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETLE (FlagEQ))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETLE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETLE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETLE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETLE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETLE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETLE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SETLE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETLE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETLEmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETLEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETGEmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETGEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETLEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETLEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETLEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETLEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETLEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETLmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETGmem [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpAMD64SETGmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETLmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETLmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETLmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETLmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETLmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETLmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETNE_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (SETNE (TESTL (SHLL (MOVLconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETB  (BTL x y))
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                var v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v_0_0.Args[1L];
                var y = v_0.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTL y (SHLL (MOVLconst [1]) x)))
            // cond: !config.nacl
            // result: (SETB  (BTL x y))
 
            // match: (SETNE (TESTL y (SHLL (MOVLconst [1]) x)))
            // cond: !config.nacl
            // result: (SETB  (BTL x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_1.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTQ (SHLQ (MOVQconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETB  (BTQ x y))
 
            // match: (SETNE (TESTQ (SHLQ (MOVQconst [1]) x) y))
            // cond: !config.nacl
            // result: (SETB  (BTQ x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_0.Args[1L];
                v_0_0_0 = v_0_0.Args[0L];
                if (v_0_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_0_0_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_0.Args[1L];
                y = v_0.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTQ y (SHLQ (MOVQconst [1]) x)))
            // cond: !config.nacl
            // result: (SETB  (BTQ x y))
 
            // match: (SETNE (TESTQ y (SHLQ (MOVQconst [1]) x)))
            // cond: !config.nacl
            // result: (SETB  (BTQ x y))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_0_1.Args[1L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTLconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETB  (BTLconst [log2(c)] x))
 
            // match: (SETNE (TESTLconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETB  (BTLconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTQconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
 
            // match: (SETNE (TESTQconst [c] x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTQ (MOVQconst [c]) x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
 
            // match: (SETNE (TESTQ (MOVQconst [c]) x))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                x = v_0.Args[1L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (TESTQ x (MOVQconst [c])))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
 
            // match: (SETNE (TESTQ x (MOVQconst [c])))
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETB  (BTQconst [log2(c)] x))
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0_1.AuxInt;
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SETNE (InvertFlags x))
            // cond:
            // result: (SETNE x)
 
            // match: (SETNE (InvertFlags x))
            // cond:
            // result: (SETNE x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETNE);
                v.AddArg(x);
                return true;
            } 
            // match: (SETNE (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SETNE (FlagEQ))
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETNE_10(ref Value v)
        { 
            // match: (SETNE (FlagLT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETNE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETNE (FlagLT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETNE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETNE (FlagGT_ULT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (SETNE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
 
            // match: (SETNE (FlagGT_UGT))
            // cond:
            // result: (MOVLconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETNEmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (SETNEmem [off] {sym} ptr (TESTL (SHLL (MOVLconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTL x y) mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                var v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 1L)
                {
                    break;
                }
                var x = v_1_0.Args[1L];
                var y = v_1.Args[1L];
                var mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTL y (SHLL (MOVLconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTL x y) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTL y (SHLL (MOVLconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTL x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLL)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTQ (SHLQ (MOVQconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQ x y) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTQ (SHLQ (MOVQconst [1]) x) y) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQ x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_0.Args[1L];
                v_1_0_0 = v_1_0.Args[0L];
                if (v_1_0_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_1_0_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_0.Args[1L];
                y = v_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTQ y (SHLQ (MOVQconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQ x y) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTQ y (SHLQ (MOVQconst [1]) x)) mem)
            // cond: !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQ x y) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64SHLQ)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 1L)
                {
                    break;
                }
                x = v_1_1.Args[1L];
                mem = v.Args[2L];
                if (!(!config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTLconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTLconst [log2(c)] x) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTLconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTLconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                x = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTQconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTQconst [c] x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                x = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTQ (MOVQconst [c]) x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTQ (MOVQconst [c]) x) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                x = v_1.Args[1L];
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (TESTQ x (MOVQconst [c])) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
 
            // match: (SETNEmem [off] {sym} ptr (TESTQ x (MOVQconst [c])) mem)
            // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
            // result: (SETBmem  [off] {sym} ptr (BTQconst [log2(c)] x) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64TESTQ)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1_1.AuxInt;
                mem = v.Args[2L];
                if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                {
                    break;
                }
                v.reset(OpAMD64SETBmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETNEmem [off] {sym} ptr x mem)
 
            // match: (SETNEmem [off] {sym} ptr (InvertFlags x) mem)
            // cond:
            // result: (SETNEmem [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64InvertFlags)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpAMD64SETNEmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
 
            // match: (SETNEmem [off] {sym} ptr x:(FlagEQ) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [0]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagEQ)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SETNEmem_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SETNEmem [off] {sym} ptr x:(FlagLT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_ULT)
                {
                    break;
                }
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETNEmem [off] {sym} ptr x:(FlagLT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagLT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETNEmem [off] {sym} ptr x:(FlagGT_ULT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_ULT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (SETNEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
 
            // match: (SETNEmem [off] {sym} ptr x:(FlagGT_UGT) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr (MOVLconst <x.Type> [1]) mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                x = v.Args[1L];
                if (x.Op != OpAMD64FlagGT_UGT)
                {
                    break;
                }
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLconst, x.Type);
                v0.AuxInt = 1L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SHLL x (MOVQconst [c]))
            // cond:
            // result: (SHLLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SHLLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHLL x (MOVLconst [c]))
            // cond:
            // result: (SHLLconst [c&31] x)
 
            // match: (SHLL x (MOVLconst [c]))
            // cond:
            // result: (SHLLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SHLLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHLL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SHLL x y)
 
            // match: (SHLL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SHLL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHLL x (NEGQ <t> y))
 
            // match: (SHLL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHLL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SHLL x y)
 
            // match: (SHLL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SHLL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHLL x (NEGQ <t> y))
 
            // match: (SHLL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHLL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SHLL x y)
 
            // match: (SHLL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SHLL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHLL x (NEGL <t> y))
 
            // match: (SHLL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHLL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SHLL x y)
 
            // match: (SHLL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SHLL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHLL x (NEGL <t> y))
 
            // match: (SHLL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHLL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHLL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHLLconst_0(ref Value v)
        { 
            // match: (SHLLconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHLQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SHLQ x (MOVQconst [c]))
            // cond:
            // result: (SHLQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SHLQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHLQ x (MOVLconst [c]))
            // cond:
            // result: (SHLQconst [c&63] x)
 
            // match: (SHLQ x (MOVLconst [c]))
            // cond:
            // result: (SHLQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SHLQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHLQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SHLQ x y)
 
            // match: (SHLQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SHLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHLQ x (NEGQ <t> y))
 
            // match: (SHLQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHLQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SHLQ x y)
 
            // match: (SHLQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SHLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHLQ x (NEGQ <t> y))
 
            // match: (SHLQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHLQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SHLQ x y)
 
            // match: (SHLQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SHLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHLQ x (NEGL <t> y))
 
            // match: (SHLQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHLQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHLQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SHLQ x y)
 
            // match: (SHLQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SHLQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHLQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHLQ x (NEGL <t> y))
 
            // match: (SHLQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHLQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHLQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHLQconst_0(ref Value v)
        { 
            // match: (SHLQconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRB_0(ref Value v)
        { 
            // match: (SHRB x (MOVQconst [c]))
            // cond: c&31 < 8
            // result: (SHRBconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(c & 31L < 8L))
                {
                    break;
                }
                v.reset(OpAMD64SHRBconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRB x (MOVLconst [c]))
            // cond: c&31 < 8
            // result: (SHRBconst [c&31] x)
 
            // match: (SHRB x (MOVLconst [c]))
            // cond: c&31 < 8
            // result: (SHRBconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L < 8L))
                {
                    break;
                }
                v.reset(OpAMD64SHRBconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRB _ (MOVQconst [c]))
            // cond: c&31 >= 8
            // result: (MOVLconst [0])
 
            // match: (SHRB _ (MOVQconst [c]))
            // cond: c&31 >= 8
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L >= 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SHRB _ (MOVLconst [c]))
            // cond: c&31 >= 8
            // result: (MOVLconst [0])
 
            // match: (SHRB _ (MOVLconst [c]))
            // cond: c&31 >= 8
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L >= 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRBconst_0(ref Value v)
        { 
            // match: (SHRBconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SHRL x (MOVQconst [c]))
            // cond:
            // result: (SHRLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SHRLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRL x (MOVLconst [c]))
            // cond:
            // result: (SHRLconst [c&31] x)
 
            // match: (SHRL x (MOVLconst [c]))
            // cond:
            // result: (SHRLconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SHRLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SHRL x y)
 
            // match: (SHRL x (ADDQconst [c] y))
            // cond: c & 31 == 0
            // result: (SHRL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHRL x (NEGQ <t> y))
 
            // match: (SHRL x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHRL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SHRL x y)
 
            // match: (SHRL x (ANDQconst [c] y))
            // cond: c & 31 == 31
            // result: (SHRL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHRL x (NEGQ <t> y))
 
            // match: (SHRL x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHRL x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SHRL x y)
 
            // match: (SHRL x (ADDLconst [c] y))
            // cond: c & 31 == 0
            // result: (SHRL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHRL x (NEGL <t> y))
 
            // match: (SHRL x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 31 == 0
            // result: (SHRL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SHRL x y)
 
            // match: (SHRL x (ANDLconst [c] y))
            // cond: c & 31 == 31
            // result: (SHRL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHRL x (NEGL <t> y))
 
            // match: (SHRL x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 31 == 31
            // result: (SHRL x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 31L == 31L))
                {
                    break;
                }
                v.reset(OpAMD64SHRL);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRLconst_0(ref Value v)
        { 
            // match: (SHRLconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SHRQ x (MOVQconst [c]))
            // cond:
            // result: (SHRQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SHRQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRQ x (MOVLconst [c]))
            // cond:
            // result: (SHRQconst [c&63] x)
 
            // match: (SHRQ x (MOVLconst [c]))
            // cond:
            // result: (SHRQconst [c&63] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64SHRQconst);
                v.AuxInt = c & 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SHRQ x y)
 
            // match: (SHRQ x (ADDQconst [c] y))
            // cond: c & 63 == 0
            // result: (SHRQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHRQ x (NEGQ <t> y))
 
            // match: (SHRQ x (NEGQ <t> (ADDQconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHRQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                var t = v_1.Type;
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SHRQ x y)
 
            // match: (SHRQ x (ANDQconst [c] y))
            // cond: c & 63 == 63
            // result: (SHRQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHRQ x (NEGQ <t> y))
 
            // match: (SHRQ x (NEGQ <t> (ANDQconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHRQ x (NEGQ <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGQ)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDQconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SHRQ x y)
 
            // match: (SHRQ x (ADDLconst [c] y))
            // cond: c & 63 == 0
            // result: (SHRQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHRQ x (NEGL <t> y))
 
            // match: (SHRQ x (NEGL <t> (ADDLconst [c] y)))
            // cond: c & 63 == 0
            // result: (SHRQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ADDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SHRQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SHRQ x y)
 
            // match: (SHRQ x (ANDLconst [c] y))
            // cond: c & 63 == 63
            // result: (SHRQ x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SHRQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHRQ x (NEGL <t> y))
 
            // match: (SHRQ x (NEGL <t> (ANDLconst [c] y)))
            // cond: c & 63 == 63
            // result: (SHRQ x (NEGL <t> y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64NEGL)
                {
                    break;
                }
                t = v_1.Type;
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpAMD64ANDLconst)
                {
                    break;
                }
                c = v_1_0.AuxInt;
                y = v_1_0.Args[0L];
                if (!(c & 63L == 63L))
                {
                    break;
                }
                v.reset(OpAMD64SHRQ);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpAMD64NEGL, t);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRQconst_0(ref Value v)
        { 
            // match: (SHRQconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRW_0(ref Value v)
        { 
            // match: (SHRW x (MOVQconst [c]))
            // cond: c&31 < 16
            // result: (SHRWconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(c & 31L < 16L))
                {
                    break;
                }
                v.reset(OpAMD64SHRWconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRW x (MOVLconst [c]))
            // cond: c&31 < 16
            // result: (SHRWconst [c&31] x)
 
            // match: (SHRW x (MOVLconst [c]))
            // cond: c&31 < 16
            // result: (SHRWconst [c&31] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L < 16L))
                {
                    break;
                }
                v.reset(OpAMD64SHRWconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SHRW _ (MOVQconst [c]))
            // cond: c&31 >= 16
            // result: (MOVLconst [0])
 
            // match: (SHRW _ (MOVQconst [c]))
            // cond: c&31 >= 16
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L >= 16L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SHRW _ (MOVLconst [c]))
            // cond: c&31 >= 16
            // result: (MOVLconst [0])
 
            // match: (SHRW _ (MOVLconst [c]))
            // cond: c&31 >= 16
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c & 31L >= 16L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SHRWconst_0(ref Value v)
        { 
            // match: (SHRWconst x [0])
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBL x (MOVLconst [c]))
            // cond:
            // result: (SUBLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64SUBLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBL (MOVLconst [c]) x)
            // cond:
            // result: (NEGL (SUBLconst <v.Type> x [c]))
 
            // match: (SUBL (MOVLconst [c]) x)
            // cond:
            // result: (NEGL (SUBLconst <v.Type> x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64NEGL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SUBLconst, v.Type);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBL x x)
            // cond:
            // result: (MOVLconst [0])
 
            // match: (SUBL x x)
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SUBL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBLmem x [off] {sym} ptr mem)
 
            // match: (SUBL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64SUBLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBLconst_0(ref Value v)
        { 
            // match: (SUBLconst [c] x)
            // cond: int32(c) == 0
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBLconst [c] x)
            // cond:
            // result: (ADDLconst [int64(int32(-c))] x)
 
            // match: (SUBLconst [c] x)
            // cond:
            // result: (ADDLconst [int64(int32(-c))] x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = int64(int32(-c));
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAMD64SUBLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (SUBLmem x [off] {sym} ptr (MOVSSstore [off] {sym} ptr y _))
            // cond:
            // result: (SUBL x (MOVLf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBQ_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (SUBQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64SUBQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (NEGQ (SUBQconst <v.Type> x [c]))
 
            // match: (SUBQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (NEGQ (SUBQconst <v.Type> x [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64NEGQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SUBQconst, v.Type);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBQ x x)
            // cond:
            // result: (MOVQconst [0])
 
            // match: (SUBQ x x)
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SUBQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBQmem x [off] {sym} ptr mem)
 
            // match: (SUBQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64SUBQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBQconst_0(ref Value v)
        { 
            // match: (SUBQconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBQconst [c] x)
            // cond: c != -(1<<31)
            // result: (ADDQconst [-c] x)
 
            // match: (SUBQconst [c] x)
            // cond: c != -(1<<31)
            // result: (ADDQconst [-c] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(c != -(1L << (int)(31L))))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = -c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBQconst (MOVQconst [d]) [c])
            // cond:
            // result: (MOVQconst [d-c])
 
            // match: (SUBQconst (MOVQconst [d]) [c])
            // cond:
            // result: (MOVQconst [d-c])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = d - c;
                return true;
            } 
            // match: (SUBQconst (SUBQconst x [d]) [c])
            // cond: is32Bit(-c-d)
            // result: (ADDQconst [-c-d] x)
 
            // match: (SUBQconst (SUBQconst x [d]) [c])
            // cond: is32Bit(-c-d)
            // result: (ADDQconst [-c-d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SUBQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(is32Bit(-c - d)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = -c - d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (SUBQmem x [off] {sym} ptr (MOVSDstore [off] {sym} ptr y _))
            // cond:
            // result: (SUBQ x (MOVQf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64SUBQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBSD_0(ref Value v)
        { 
            // match: (SUBSD x l:(MOVSDload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBSDmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSDload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64SUBSDmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBSDmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (SUBSDmem x [off] {sym} ptr (MOVQstore [off] {sym} ptr y _))
            // cond:
            // result: (SUBSD x (MOVQi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVQstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64SUBSD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQi2f, typ.Float64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBSS_0(ref Value v)
        { 
            // match: (SUBSS x l:(MOVSSload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (SUBSSmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVSSload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64SUBSSmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64SUBSSmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (SUBSSmem x [off] {sym} ptr (MOVLstore [off] {sym} ptr y _))
            // cond:
            // result: (SUBSS x (MOVLi2f y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVLstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64SUBSS);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLi2f, typ.Float32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64TESTB_0(ref Value v)
        { 
            // match: (TESTB (MOVLconst [c]) x)
            // cond:
            // result: (TESTBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpAMD64TESTBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TESTB x (MOVLconst [c]))
            // cond:
            // result: (TESTBconst [c] x)
 
            // match: (TESTB x (MOVLconst [c]))
            // cond:
            // result: (TESTBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64TESTBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64TESTL_0(ref Value v)
        { 
            // match: (TESTL (MOVLconst [c]) x)
            // cond:
            // result: (TESTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpAMD64TESTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TESTL x (MOVLconst [c]))
            // cond:
            // result: (TESTLconst [c] x)
 
            // match: (TESTL x (MOVLconst [c]))
            // cond:
            // result: (TESTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64TESTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64TESTQ_0(ref Value v)
        { 
            // match: (TESTQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (TESTQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64TESTQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TESTQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (TESTQconst [c] x)
 
            // match: (TESTQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (TESTQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64TESTQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64TESTW_0(ref Value v)
        { 
            // match: (TESTW (MOVLconst [c]) x)
            // cond:
            // result: (TESTWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpAMD64TESTWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TESTW x (MOVLconst [c]))
            // cond:
            // result: (TESTWconst [c] x)
 
            // match: (TESTW x (MOVLconst [c]))
            // cond:
            // result: (TESTWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpAMD64TESTWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XADDLlock_0(ref Value v)
        { 
            // match: (XADDLlock [off1] {sym} val (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (XADDLlock [off1+off2] {sym} val ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var val = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64XADDLlock);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XADDQlock_0(ref Value v)
        { 
            // match: (XADDQlock [off1] {sym} val (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (XADDQlock [off1+off2] {sym} val ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var val = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64XADDQlock);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XCHGL_0(ref Value v)
        { 
            // match: (XCHGL [off1] {sym} val (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (XCHGL [off1+off2] {sym} val ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var val = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64XCHGL);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XCHGL [off1] {sym1} val (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB
            // result: (XCHGL [off1+off2] {mergeSym(sym1,sym2)} val ptr mem)
 
            // match: (XCHGL [off1] {sym1} val (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB
            // result: (XCHGL [off1+off2] {mergeSym(sym1,sym2)} val ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                val = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64XCHGL);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XCHGQ_0(ref Value v)
        { 
            // match: (XCHGQ [off1] {sym} val (ADDQconst [off2] ptr) mem)
            // cond: is32Bit(off1+off2)
            // result: (XCHGQ [off1+off2] {sym} val ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var val = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64ADDQconst)
                {
                    break;
                }
                var off2 = v_1.AuxInt;
                var ptr = v_1.Args[0L];
                var mem = v.Args[2L];
                if (!(is32Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpAMD64XCHGQ);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XCHGQ [off1] {sym1} val (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB
            // result: (XCHGQ [off1+off2] {mergeSym(sym1,sym2)} val ptr mem)
 
            // match: (XCHGQ [off1] {sym1} val (LEAQ [off2] {sym2} ptr) mem)
            // cond: is32Bit(off1+off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB
            // result: (XCHGQ [off1+off2] {mergeSym(sym1,sym2)} val ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                val = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64LEAQ)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                var sym2 = v_1.Aux;
                ptr = v_1.Args[0L];
                mem = v.Args[2L];
                if (!(is32Bit(off1 + off2) && canMergeSym(sym1, sym2) && ptr.Op != OpSB))
                {
                    break;
                }
                v.reset(OpAMD64XCHGQ);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORL_0(ref Value v)
        { 
            // match: (XORL x (MOVLconst [c]))
            // cond:
            // result: (XORLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpAMD64XORLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL (MOVLconst [c]) x)
            // cond:
            // result: (XORLconst [c] x)
 
            // match: (XORL (MOVLconst [c]) x)
            // cond:
            // result: (XORLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpAMD64XORLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (XORL (SHLLconst x [c]) (SHRLconst x [d]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
 
            // match: (XORL (SHRLconst x [d]) (SHLLconst x [c]))
            // cond: d==32-c
            // result: (ROLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (XORL <t> (SHLLconst x [c]) (SHRWconst x [d]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
 
            // match: (XORL <t> (SHRWconst x [d]) (SHLLconst x [c]))
            // cond: d==16-c && c < 16 && t.Size() == 2
            // result: (ROLWconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 16L - c && c < 16L && t.Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64ROLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (XORL <t> (SHLLconst x [c]) (SHRBconst x [d]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
 
            // match: (XORL <t> (SHRBconst x [d]) (SHLLconst x [c]))
            // cond: d==8-c  && c < 8 && t.Size() == 1
            // result: (ROLBconst x [c])
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 8L - c && c < 8L && t.Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64ROLBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORL x x)
            // cond:
            // result: (MOVLconst [0])
 
            // match: (XORL x x)
            // cond:
            // result: (MOVLconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (XORL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORLmem x [off] {sym} ptr mem)
 
            // match: (XORL x l:(MOVLload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64XORLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORL_10(ref Value v)
        { 
            // match: (XORL l:(MOVLload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORLmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var l = v.Args[0L];
                if (l.Op != OpAMD64MOVLload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                var x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64XORLmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORLconst_0(ref Value v)
        { 
            // match: (XORLconst [1] (SETNE x))
            // cond:
            // result: (SETEQ x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETNE)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpAMD64SETEQ);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETEQ x))
            // cond:
            // result: (SETNE x)
 
            // match: (XORLconst [1] (SETEQ x))
            // cond:
            // result: (SETNE x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETEQ)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETNE);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETL x))
            // cond:
            // result: (SETGE x)
 
            // match: (XORLconst [1] (SETL x))
            // cond:
            // result: (SETGE x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETL)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETGE);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETGE x))
            // cond:
            // result: (SETL  x)
 
            // match: (XORLconst [1] (SETGE x))
            // cond:
            // result: (SETL  x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETGE)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETL);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETLE x))
            // cond:
            // result: (SETG  x)
 
            // match: (XORLconst [1] (SETLE x))
            // cond:
            // result: (SETG  x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETLE)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETG);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETG x))
            // cond:
            // result: (SETLE x)
 
            // match: (XORLconst [1] (SETG x))
            // cond:
            // result: (SETLE x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETG)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETLE);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETB x))
            // cond:
            // result: (SETAE x)
 
            // match: (XORLconst [1] (SETB x))
            // cond:
            // result: (SETAE x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETB)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETAE);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETAE x))
            // cond:
            // result: (SETB  x)
 
            // match: (XORLconst [1] (SETAE x))
            // cond:
            // result: (SETB  x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETAE)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETB);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETBE x))
            // cond:
            // result: (SETA  x)
 
            // match: (XORLconst [1] (SETBE x))
            // cond:
            // result: (SETA  x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETBE)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETA);
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [1] (SETA x))
            // cond:
            // result: (SETBE x)
 
            // match: (XORLconst [1] (SETA x))
            // cond:
            // result: (SETBE x)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SETA)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpAMD64SETBE);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORLconst_10(ref Value v)
        { 
            // match: (XORLconst [c] (XORLconst [d] x))
            // cond:
            // result: (XORLconst [c ^ d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64XORLconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64XORLconst);
                v.AuxInt = c ^ d;
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [c] x)
            // cond: int32(c)==0
            // result: x
 
            // match: (XORLconst [c] x)
            // cond: int32(c)==0
            // result: x
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(int32(c) == 0L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (XORLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c^d])
 
            // match: (XORLconst [c] (MOVLconst [d]))
            // cond:
            // result: (MOVLconst [c^d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVLconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = c ^ d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORLmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (XORLmem x [off] {sym} ptr (MOVSSstore [off] {sym} ptr y _))
            // cond:
            // result: (XORL x (MOVLf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSSstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64XORL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLf2i, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORQ_0(ref Value v)
        { 
            // match: (XORQ x (MOVQconst [c]))
            // cond: is32Bit(c)
            // result: (XORQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64XORQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (XORQconst [c] x)
 
            // match: (XORQ (MOVQconst [c]) x)
            // cond: is32Bit(c)
            // result: (XORQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpAMD64XORQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (XORQ (SHLQconst x [c]) (SHRQconst x [d]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
 
            // match: (XORQ (SHRQconst x [d]) (SHLQconst x [c]))
            // cond: d==64-c
            // result: (ROLQconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64SHRQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpAMD64SHLQconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpAMD64ROLQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQ x x)
            // cond:
            // result: (MOVQconst [0])
 
            // match: (XORQ x x)
            // cond:
            // result: (MOVQconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (XORQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORQmem x [off] {sym} ptr mem)
 
            // match: (XORQ x l:(MOVQload [off] {sym} ptr mem))
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var l = v.Args[1L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                var off = l.AuxInt;
                var sym = l.Aux;
                _ = l.Args[1L];
                var ptr = l.Args[0L];
                var mem = l.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64XORQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (XORQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORQmem x [off] {sym} ptr mem)
 
            // match: (XORQ l:(MOVQload [off] {sym} ptr mem) x)
            // cond: canMergeLoad(v, l, x) && clobber(l)
            // result: (XORQmem x [off] {sym} ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                l = v.Args[0L];
                if (l.Op != OpAMD64MOVQload)
                {
                    break;
                }
                off = l.AuxInt;
                sym = l.Aux;
                _ = l.Args[1L];
                ptr = l.Args[0L];
                mem = l.Args[1L];
                x = v.Args[1L];
                if (!(canMergeLoad(v, l, x) && clobber(l)))
                {
                    break;
                }
                v.reset(OpAMD64XORQmem);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORQconst_0(ref Value v)
        { 
            // match: (XORQconst [c] (XORQconst [d] x))
            // cond:
            // result: (XORQconst [c ^ d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64XORQconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpAMD64XORQconst);
                v.AuxInt = c ^ d;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQconst [0] x)
            // cond:
            // result: x
 
            // match: (XORQconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (XORQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c^d])
 
            // match: (XORQconst [c] (MOVQconst [d]))
            // cond:
            // result: (MOVQconst [c^d])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64MOVQconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = c ^ d;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAMD64XORQmem_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (XORQmem x [off] {sym} ptr (MOVSDstore [off] {sym} ptr y _))
            // cond:
            // result: (XORQ x (MOVQf2i y))
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var x = v.Args[0L];
                var ptr = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpAMD64MOVSDstore)
                {
                    break;
                }
                if (v_2.AuxInt != off)
                {
                    break;
                }
                if (v_2.Aux != sym)
                {
                    break;
                }
                _ = v_2.Args[2L];
                if (ptr != v_2.Args[0L])
                {
                    break;
                }
                var y = v_2.Args[1L];
                v.reset(OpAMD64XORQ);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQf2i, typ.UInt64);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAdd16_0(ref Value v)
        { 
            // match: (Add16 x y)
            // cond:
            // result: (ADDL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAdd32_0(ref Value v)
        { 
            // match: (Add32 x y)
            // cond:
            // result: (ADDL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAdd32F_0(ref Value v)
        { 
            // match: (Add32F x y)
            // cond:
            // result: (ADDSS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDSS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAdd64_0(ref Value v)
        { 
            // match: (Add64 x y)
            // cond:
            // result: (ADDQ  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAdd64F_0(ref Value v)
        { 
            // match: (Add64F x y)
            // cond:
            // result: (ADDSD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDSD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAdd8_0(ref Value v)
        { 
            // match: (Add8 x y)
            // cond:
            // result: (ADDL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ADDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAddPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (AddPtr x y)
            // cond: config.PtrSize == 8
            // result: (ADDQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64ADDQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AddPtr x y)
            // cond: config.PtrSize == 4
            // result: (ADDL x y)
 
            // match: (AddPtr x y)
            // cond: config.PtrSize == 4
            // result: (ADDL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64ADDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAddr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Addr {sym} base)
            // cond: config.PtrSize == 8
            // result: (LEAQ {sym} base)
            while (true)
            {
                var sym = v.Aux;
                var @base = v.Args[0L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64LEAQ);
                v.Aux = sym;
                v.AddArg(base);
                return true;
            } 
            // match: (Addr {sym} base)
            // cond: config.PtrSize == 4
            // result: (LEAL {sym} base)
 
            // match: (Addr {sym} base)
            // cond: config.PtrSize == 4
            // result: (LEAL {sym} base)
            while (true)
            {
                sym = v.Aux;
                @base = v.Args[0L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64LEAL);
                v.Aux = sym;
                v.AddArg(base);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAnd16_0(ref Value v)
        { 
            // match: (And16 x y)
            // cond:
            // result: (ANDL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAnd32_0(ref Value v)
        { 
            // match: (And32 x y)
            // cond:
            // result: (ANDL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAnd64_0(ref Value v)
        { 
            // match: (And64 x y)
            // cond:
            // result: (ANDQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAnd8_0(ref Value v)
        { 
            // match: (And8 x y)
            // cond:
            // result: (ANDL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAndB_0(ref Value v)
        { 
            // match: (AndB x y)
            // cond:
            // result: (ANDL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicAdd32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicAdd32 ptr val mem)
            // cond:
            // result: (AddTupleFirst32 val (XADDLlock val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64AddTupleFirst32);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpAMD64XADDLlock, types.NewTuple(typ.UInt32, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicAdd64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicAdd64 ptr val mem)
            // cond:
            // result: (AddTupleFirst64 val (XADDQlock val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64AddTupleFirst64);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpAMD64XADDQlock, types.NewTuple(typ.UInt64, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicAnd8_0(ref Value v)
        { 
            // match: (AtomicAnd8 ptr val mem)
            // cond:
            // result: (ANDBlock ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64ANDBlock);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicCompareAndSwap32_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap32 ptr old new_ mem)
            // cond:
            // result: (CMPXCHGLlock ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64CMPXCHGLlock);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicCompareAndSwap64_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap64 ptr old new_ mem)
            // cond:
            // result: (CMPXCHGQlock ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpAMD64CMPXCHGQlock);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicExchange32_0(ref Value v)
        { 
            // match: (AtomicExchange32 ptr val mem)
            // cond:
            // result: (XCHGL val ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64XCHGL);
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicExchange64_0(ref Value v)
        { 
            // match: (AtomicExchange64 ptr val mem)
            // cond:
            // result: (XCHGQ val ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64XCHGQ);
                v.AddArg(val);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicLoad32_0(ref Value v)
        { 
            // match: (AtomicLoad32 ptr mem)
            // cond:
            // result: (MOVLatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpAMD64MOVLatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicLoad64_0(ref Value v)
        { 
            // match: (AtomicLoad64 ptr mem)
            // cond:
            // result: (MOVQatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpAMD64MOVQatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicLoadPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (AtomicLoadPtr ptr mem)
            // cond: config.PtrSize == 8
            // result: (MOVQatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (AtomicLoadPtr ptr mem)
            // cond: config.PtrSize == 4
            // result: (MOVLatomicload ptr mem)
 
            // match: (AtomicLoadPtr ptr mem)
            // cond: config.PtrSize == 4
            // result: (MOVLatomicload ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLatomicload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAtomicOr8_0(ref Value v)
        { 
            // match: (AtomicOr8 ptr val mem)
            // cond:
            // result: (ORBlock ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64ORBlock);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicStore32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicStore32 ptr val mem)
            // cond:
            // result: (Select1 (XCHGL <types.NewTuple(typ.UInt32,types.TypeMem)> val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64XCHGL, types.NewTuple(typ.UInt32, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicStore64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicStore64 ptr val mem)
            // cond:
            // result: (Select1 (XCHGQ <types.NewTuple(typ.UInt64,types.TypeMem)> val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64XCHGQ, types.NewTuple(typ.UInt64, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpAtomicStorePtrNoWB_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (AtomicStorePtrNoWB ptr val mem)
            // cond: config.PtrSize == 8
            // result: (Select1 (XCHGQ <types.NewTuple(typ.BytePtr,types.TypeMem)> val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64XCHGQ, types.NewTuple(typ.BytePtr, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (AtomicStorePtrNoWB ptr val mem)
            // cond: config.PtrSize == 4
            // result: (Select1 (XCHGL <types.NewTuple(typ.BytePtr,types.TypeMem)> val ptr mem))
 
            // match: (AtomicStorePtrNoWB ptr val mem)
            // cond: config.PtrSize == 4
            // result: (Select1 (XCHGL <types.NewTuple(typ.BytePtr,types.TypeMem)> val ptr mem))
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpSelect1);
                v0 = b.NewValue0(v.Pos, OpAMD64XCHGL, types.NewTuple(typ.BytePtr, types.TypeMem));
                v0.AddArg(val);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpAvg64u_0(ref Value v)
        { 
            // match: (Avg64u x y)
            // cond:
            // result: (AVGQU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64AVGQU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpBitLen32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (BitLen32 x)
            // cond:
            // result: (BitLen64 (MOVLQZX <typ.UInt64> x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpBitLen64);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLQZX, typ.UInt64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpBitLen64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (BitLen64 <t> x)
            // cond:
            // result: (ADDQconst [1] (CMOVQEQ <t> (Select0 <t> (BSRQ x)) (MOVQconst <t> [-1]) (Select1 <types.TypeFlags> (BSRQ x))))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = 1L;
                var v0 = b.NewValue0(v.Pos, OpAMD64CMOVQEQ, t);
                var v1 = b.NewValue0(v.Pos, OpSelect0, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64BSRQ, types.NewTuple(typ.UInt64, types.TypeFlags));
                v2.AddArg(x);
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVQconst, t);
                v3.AuxInt = -1L;
                v0.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpSelect1, types.TypeFlags);
                var v5 = b.NewValue0(v.Pos, OpAMD64BSRQ, types.NewTuple(typ.UInt64, types.TypeFlags));
                v5.AddArg(x);
                v4.AddArg(v5);
                v0.AddArg(v4);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpBswap32_0(ref Value v)
        { 
            // match: (Bswap32 x)
            // cond:
            // result: (BSWAPL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64BSWAPL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpBswap64_0(ref Value v)
        { 
            // match: (Bswap64 x)
            // cond:
            // result: (BSWAPQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64BSWAPQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCeil_0(ref Value v)
        { 
            // match: (Ceil x)
            // cond:
            // result: (ROUNDSD [2] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64ROUNDSD);
                v.AuxInt = 2L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpClosureCall_0(ref Value v)
        { 
            // match: (ClosureCall [argwid] entry closure mem)
            // cond:
            // result: (CALLclosure [argwid] entry closure mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[2L];
                var entry = v.Args[0L];
                var closure = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64CALLclosure);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(closure);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCom16_0(ref Value v)
        { 
            // match: (Com16 x)
            // cond:
            // result: (NOTL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NOTL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCom32_0(ref Value v)
        { 
            // match: (Com32 x)
            // cond:
            // result: (NOTL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NOTL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCom64_0(ref Value v)
        { 
            // match: (Com64 x)
            // cond:
            // result: (NOTQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NOTQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCom8_0(ref Value v)
        { 
            // match: (Com8 x)
            // cond:
            // result: (NOTL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NOTL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst16_0(ref Value v)
        { 
            // match: (Const16 [val])
            // cond:
            // result: (MOVLconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst32_0(ref Value v)
        { 
            // match: (Const32 [val])
            // cond:
            // result: (MOVLconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst32F_0(ref Value v)
        { 
            // match: (Const32F [val])
            // cond:
            // result: (MOVSSconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVSSconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst64_0(ref Value v)
        { 
            // match: (Const64 [val])
            // cond:
            // result: (MOVQconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst64F_0(ref Value v)
        { 
            // match: (Const64F [val])
            // cond:
            // result: (MOVSDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVSDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConst8_0(ref Value v)
        { 
            // match: (Const8 [val])
            // cond:
            // result: (MOVLconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConstBool_0(ref Value v)
        { 
            // match: (ConstBool [b])
            // cond:
            // result: (MOVLconst [b])
            while (true)
            {
                var b = v.AuxInt;
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = b;
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpConstNil_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (ConstNil)
            // cond: config.PtrSize == 8
            // result: (MOVQconst [0])
            while (true)
            {
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ConstNil)
            // cond: config.PtrSize == 4
            // result: (MOVLconst [0])
 
            // match: (ConstNil)
            // cond: config.PtrSize == 4
            // result: (MOVLconst [0])
            while (true)
            {
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpConvert_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Convert <t> x mem)
            // cond: config.PtrSize == 8
            // result: (MOVQconvert <t> x mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var mem = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQconvert);
                v.Type = t;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (Convert <t> x mem)
            // cond: config.PtrSize == 4
            // result: (MOVLconvert <t> x mem)
 
            // match: (Convert <t> x mem)
            // cond: config.PtrSize == 4
            // result: (MOVLconvert <t> x mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                x = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLconvert);
                v.Type = t;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpCtz32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz32 x)
            // cond:
            // result: (Select0 (BSFQ (ORQ <typ.UInt64> (MOVQconst [1<<32]) x)))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, types.TypeFlags));
                var v1 = b.NewValue0(v.Pos, OpAMD64ORQ, typ.UInt64);
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v2.AuxInt = 1L << (int)(32L);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCtz64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz64 <t> x)
            // cond:
            // result: (CMOVQEQ (Select0 <t> (BSFQ x)) (MOVQconst <t> [64]) (Select1 <types.TypeFlags> (BSFQ x)))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpAMD64CMOVQEQ);
                var v0 = b.NewValue0(v.Pos, OpSelect0, t);
                var v1 = b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, types.TypeFlags));
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVQconst, t);
                v2.AuxInt = 64L;
                v.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpSelect1, types.TypeFlags);
                var v4 = b.NewValue0(v.Pos, OpAMD64BSFQ, types.NewTuple(typ.UInt64, types.TypeFlags));
                v4.AddArg(x);
                v3.AddArg(v4);
                v.AddArg(v3);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt32Fto32_0(ref Value v)
        { 
            // match: (Cvt32Fto32 x)
            // cond:
            // result: (CVTTSS2SL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTTSS2SL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt32Fto64_0(ref Value v)
        { 
            // match: (Cvt32Fto64 x)
            // cond:
            // result: (CVTTSS2SQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTTSS2SQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt32Fto64F_0(ref Value v)
        { 
            // match: (Cvt32Fto64F x)
            // cond:
            // result: (CVTSS2SD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSS2SD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt32to32F_0(ref Value v)
        { 
            // match: (Cvt32to32F x)
            // cond:
            // result: (CVTSL2SS x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSL2SS);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt32to64F_0(ref Value v)
        { 
            // match: (Cvt32to64F x)
            // cond:
            // result: (CVTSL2SD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSL2SD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt64Fto32_0(ref Value v)
        { 
            // match: (Cvt64Fto32 x)
            // cond:
            // result: (CVTTSD2SL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTTSD2SL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt64Fto32F_0(ref Value v)
        { 
            // match: (Cvt64Fto32F x)
            // cond:
            // result: (CVTSD2SS x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSD2SS);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt64Fto64_0(ref Value v)
        { 
            // match: (Cvt64Fto64 x)
            // cond:
            // result: (CVTTSD2SQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTTSD2SQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt64to32F_0(ref Value v)
        { 
            // match: (Cvt64to32F x)
            // cond:
            // result: (CVTSQ2SS x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSQ2SS);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpCvt64to64F_0(ref Value v)
        { 
            // match: (Cvt64to64F x)
            // cond:
            // result: (CVTSQ2SD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64CVTSQ2SD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv128u_0(ref Value v)
        { 
            // match: (Div128u xhi xlo y)
            // cond:
            // result: (DIVQU2 xhi xlo y)
            while (true)
            {
                _ = v.Args[2L];
                var xhi = v.Args[0L];
                var xlo = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpAMD64DIVQU2);
                v.AddArg(xhi);
                v.AddArg(xlo);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16 x y)
            // cond:
            // result: (Select0 (DIVW  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16u x y)
            // cond:
            // result: (Select0 (DIVWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32 x y)
            // cond:
            // result: (Select0 (DIVL  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVL, types.NewTuple(typ.Int32, typ.Int32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv32F_0(ref Value v)
        { 
            // match: (Div32F x y)
            // cond:
            // result: (DIVSS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64DIVSS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32u x y)
            // cond:
            // result: (Select0 (DIVLU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVLU, types.NewTuple(typ.UInt32, typ.UInt32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div64 x y)
            // cond:
            // result: (Select0 (DIVQ  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVQ, types.NewTuple(typ.Int64, typ.Int64));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv64F_0(ref Value v)
        { 
            // match: (Div64F x y)
            // cond:
            // result: (DIVSD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64DIVSD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div64u x y)
            // cond:
            // result: (Select0 (DIVQU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVQU, types.NewTuple(typ.UInt64, typ.UInt64));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8 x y)
            // cond:
            // result: (Select0 (DIVW  (SignExt8to16 x) (SignExt8to16 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16));
                var v1 = b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpDiv8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8u x y)
            // cond:
            // result: (Select0 (DIVWU (ZeroExt8to16 x) (ZeroExt8to16 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16));
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq16 x y)
            // cond:
            // result: (SETEQ (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32 x y)
            // cond:
            // result: (SETEQ (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32F x y)
            // cond:
            // result: (SETEQF (UCOMISS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64 x y)
            // cond:
            // result: (SETEQ (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64F x y)
            // cond:
            // result: (SETEQF (UCOMISD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq8 x y)
            // cond:
            // result: (SETEQ (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (EqB x y)
            // cond:
            // result: (SETEQ (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpEqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (EqPtr x y)
            // cond: config.PtrSize == 8
            // result: (SETEQ (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SETEQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (EqPtr x y)
            // cond: config.PtrSize == 4
            // result: (SETEQ (CMPL x y))
 
            // match: (EqPtr x y)
            // cond: config.PtrSize == 4
            // result: (SETEQ (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SETEQ);
                v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpFloor_0(ref Value v)
        { 
            // match: (Floor x)
            // cond:
            // result: (ROUNDSD [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64ROUNDSD);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq16 x y)
            // cond:
            // result: (SETGE (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq16U x y)
            // cond:
            // result: (SETAE (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETAE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32 x y)
            // cond:
            // result: (SETGE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32F x y)
            // cond:
            // result: (SETGEF (UCOMISS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32U x y)
            // cond:
            // result: (SETAE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETAE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64 x y)
            // cond:
            // result: (SETGE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64F x y)
            // cond:
            // result: (SETGEF (UCOMISD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64U x y)
            // cond:
            // result: (SETAE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETAE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq8 x y)
            // cond:
            // result: (SETGE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq8U x y)
            // cond:
            // result: (SETAE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETAE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGetCallerPC_0(ref Value v)
        { 
            // match: (GetCallerPC)
            // cond:
            // result: (LoweredGetCallerPC)
            while (true)
            {
                v.reset(OpAMD64LoweredGetCallerPC);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGetCallerSP_0(ref Value v)
        { 
            // match: (GetCallerSP)
            // cond:
            // result: (LoweredGetCallerSP)
            while (true)
            {
                v.reset(OpAMD64LoweredGetCallerSP);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGetClosurePtr_0(ref Value v)
        { 
            // match: (GetClosurePtr)
            // cond:
            // result: (LoweredGetClosurePtr)
            while (true)
            {
                v.reset(OpAMD64LoweredGetClosurePtr);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGetG_0(ref Value v)
        { 
            // match: (GetG mem)
            // cond:
            // result: (LoweredGetG mem)
            while (true)
            {
                var mem = v.Args[0L];
                v.reset(OpAMD64LoweredGetG);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater16 x y)
            // cond:
            // result: (SETG (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETG);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater16U x y)
            // cond:
            // result: (SETA (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETA);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32 x y)
            // cond:
            // result: (SETG (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETG);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32F x y)
            // cond:
            // result: (SETGF (UCOMISS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32U x y)
            // cond:
            // result: (SETA (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETA);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64 x y)
            // cond:
            // result: (SETG (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETG);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64F x y)
            // cond:
            // result: (SETGF (UCOMISD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64U x y)
            // cond:
            // result: (SETA (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETA);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater8 x y)
            // cond:
            // result: (SETG (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETG);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpGreater8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater8U x y)
            // cond:
            // result: (SETA (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETA);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpHmul32_0(ref Value v)
        { 
            // match: (Hmul32 x y)
            // cond:
            // result: (HMULL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64HMULL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpHmul32u_0(ref Value v)
        { 
            // match: (Hmul32u x y)
            // cond:
            // result: (HMULLU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64HMULLU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpHmul64_0(ref Value v)
        { 
            // match: (Hmul64 x y)
            // cond:
            // result: (HMULQ  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64HMULQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpHmul64u_0(ref Value v)
        { 
            // match: (Hmul64u x y)
            // cond:
            // result: (HMULQU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64HMULQU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpInt64Hi_0(ref Value v)
        { 
            // match: (Int64Hi x)
            // cond:
            // result: (SHRQconst [32] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64SHRQconst);
                v.AuxInt = 32L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpInterCall_0(ref Value v)
        { 
            // match: (InterCall [argwid] entry mem)
            // cond:
            // result: (CALLinter [argwid] entry mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[1L];
                var entry = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpAMD64CALLinter);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpIsInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (IsInBounds idx len)
            // cond: config.PtrSize == 8
            // result: (SETB (CMPQ idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            } 
            // match: (IsInBounds idx len)
            // cond: config.PtrSize == 4
            // result: (SETB (CMPL idx len))
 
            // match: (IsInBounds idx len)
            // cond: config.PtrSize == 4
            // result: (SETB (CMPL idx len))
            while (true)
            {
                _ = v.Args[1L];
                idx = v.Args[0L];
                len = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SETB);
                v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpIsNonNil_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (IsNonNil p)
            // cond: config.PtrSize == 8
            // result: (SETNE (TESTQ p p))
            while (true)
            {
                var p = v.Args[0L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64TESTQ, types.TypeFlags);
                v0.AddArg(p);
                v0.AddArg(p);
                v.AddArg(v0);
                return true;
            } 
            // match: (IsNonNil p)
            // cond: config.PtrSize == 4
            // result: (SETNE (TESTL p p))
 
            // match: (IsNonNil p)
            // cond: config.PtrSize == 4
            // result: (SETNE (TESTL p p))
            while (true)
            {
                p = v.Args[0L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SETNE);
                v0 = b.NewValue0(v.Pos, OpAMD64TESTL, types.TypeFlags);
                v0.AddArg(p);
                v0.AddArg(p);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpIsSliceInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (IsSliceInBounds idx len)
            // cond: config.PtrSize == 8
            // result: (SETBE (CMPQ idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SETBE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            } 
            // match: (IsSliceInBounds idx len)
            // cond: config.PtrSize == 4
            // result: (SETBE (CMPL idx len))
 
            // match: (IsSliceInBounds idx len)
            // cond: config.PtrSize == 4
            // result: (SETBE (CMPL idx len))
            while (true)
            {
                _ = v.Args[1L];
                idx = v.Args[0L];
                len = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SETBE);
                v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpLeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq16 x y)
            // cond:
            // result: (SETLE (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETLE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq16U x y)
            // cond:
            // result: (SETBE (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETBE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32 x y)
            // cond:
            // result: (SETLE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETLE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32F x y)
            // cond:
            // result: (SETGEF (UCOMISS y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32U x y)
            // cond:
            // result: (SETBE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETBE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64 x y)
            // cond:
            // result: (SETLE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETLE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64F x y)
            // cond:
            // result: (SETGEF (UCOMISD y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64U x y)
            // cond:
            // result: (SETBE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETBE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq8 x y)
            // cond:
            // result: (SETLE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETLE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq8U x y)
            // cond:
            // result: (SETBE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETBE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less16 x y)
            // cond:
            // result: (SETL (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETL);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less16U x y)
            // cond:
            // result: (SETB (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32 x y)
            // cond:
            // result: (SETL (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETL);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32F x y)
            // cond:
            // result: (SETGF (UCOMISS y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32U x y)
            // cond:
            // result: (SETB (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64 x y)
            // cond:
            // result: (SETL (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETL);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64F x y)
            // cond:
            // result: (SETGF (UCOMISD y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETGF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64U x y)
            // cond:
            // result: (SETB (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less8 x y)
            // cond:
            // result: (SETL (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETL);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLess8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less8U x y)
            // cond:
            // result: (SETB (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETB);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLoad_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Load <t> ptr mem)
            // cond: (is64BitInt(t) || isPtr(t) && config.PtrSize == 8)
            // result: (MOVQload ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(is64BitInt(t) || isPtr(t) && config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is32BitInt(t) || isPtr(t) && config.PtrSize == 4)
            // result: (MOVLload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is32BitInt(t) || isPtr(t) && config.PtrSize == 4)
            // result: (MOVLload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) || isPtr(t) && config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t)
            // result: (MOVWload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t)
            // result: (MOVWload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t)))
                {
                    break;
                }
                v.reset(OpAMD64MOVWload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (t.IsBoolean() || is8BitInt(t))
            // result: (MOVBload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (t.IsBoolean() || is8BitInt(t))
            // result: (MOVBload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsBoolean() || is8BitInt(t)))
                {
                    break;
                }
                v.reset(OpAMD64MOVBload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (MOVSSload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (MOVSSload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitFloat(t)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (MOVSDload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (MOVSDload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is64BitFloat(t)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpLsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x16 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPWconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x32 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPLconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x64 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPQconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x8 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPBconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x16 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPWconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x32 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPLconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x64 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPQconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x8 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPBconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x16 <t> x y)
            // cond:
            // result: (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPWconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x32 <t> x y)
            // cond:
            // result: (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPLconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x64 <t> x y)
            // cond:
            // result: (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPQconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh64x8 <t> x y)
            // cond:
            // result: (ANDQ (SHLQ <t> x y) (SBBQcarrymask <t> (CMPBconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x16 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPWconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x32 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPLconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x64 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPQconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpLsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x8 <t> x y)
            // cond:
            // result: (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMPBconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHLL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16 x y)
            // cond:
            // result: (Select1 (DIVW  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16u x y)
            // cond:
            // result: (Select1 (DIVWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32 x y)
            // cond:
            // result: (Select1 (DIVL  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVL, types.NewTuple(typ.Int32, typ.Int32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32u x y)
            // cond:
            // result: (Select1 (DIVLU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVLU, types.NewTuple(typ.UInt32, typ.UInt32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod64 x y)
            // cond:
            // result: (Select1 (DIVQ  x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVQ, types.NewTuple(typ.Int64, typ.Int64));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod64u x y)
            // cond:
            // result: (Select1 (DIVQU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVQU, types.NewTuple(typ.UInt64, typ.UInt64));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8 x y)
            // cond:
            // result: (Select1 (DIVW  (SignExt8to16 x) (SignExt8to16 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVW, types.NewTuple(typ.Int16, typ.Int16));
                var v1 = b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to16, typ.Int16);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMod8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8u x y)
            // cond:
            // result: (Select1 (DIVWU (ZeroExt8to16 x) (ZeroExt8to16 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                var v0 = b.NewValue0(v.Pos, OpAMD64DIVWU, types.NewTuple(typ.UInt16, typ.UInt16));
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to16, typ.UInt16);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMove_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [0] _ _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[2L];
                var mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBload src mem) mem)
 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWload src mem) mem)
 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVWstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVLstore dst (MOVLload src mem) mem)
 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVLstore dst (MOVLload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVLstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVQstore dst (MOVQload src mem) mem)
 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVQstore dst (MOVQload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVQstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [16] dst src mem)
            // cond: config.useSSE
            // result: (MOVOstore dst (MOVOload src mem) mem)
 
            // match: (Move [16] dst src mem)
            // cond: config.useSSE
            // result: (MOVOstore dst (MOVOload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVOload, types.TypeInt128);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [16] dst src mem)
            // cond: !config.useSSE
            // result: (MOVQstore [8] dst (MOVQload [8] src mem)         (MOVQstore dst (MOVQload src mem) mem))
 
            // match: (Move [16] dst src mem)
            // cond: !config.useSSE
            // result: (MOVQstore [8] dst (MOVQload [8] src mem)         (MOVQstore dst (MOVQload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(!config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = 8L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v0.AuxInt = 8L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVQstore, types.TypeMem);
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBload [2] src mem)         (MOVWstore dst (MOVWload src mem) mem))
 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBload [2] src mem)         (MOVWstore dst (MOVWload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = 2L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8);
                v0.AuxInt = 2L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVWstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBload [4] src mem)         (MOVLstore dst (MOVLload src mem) mem))
 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBload [4] src mem)         (MOVLstore dst (MOVLload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVBstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVBload, typ.UInt8);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVWstore [4] dst (MOVWload [4] src mem)         (MOVLstore dst (MOVLload src mem) mem))
 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVWstore [4] dst (MOVWload [4] src mem)         (MOVLstore dst (MOVLload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpAMD64MOVWstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVWload, typ.UInt16);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVLstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpMove_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [7] dst src mem)
            // cond:
            // result: (MOVLstore [3] dst (MOVLload [3] src mem)         (MOVLstore dst (MOVLload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64MOVLstore);
                v.AuxInt = 3L;
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v0.AuxInt = 3L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVLstore, types.TypeMem);
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVLload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 8 && s < 16
            // result: (MOVQstore [s-8] dst (MOVQload [s-8] src mem)         (MOVQstore dst (MOVQload src mem) mem))
 
            // match: (Move [s] dst src mem)
            // cond: s > 8 && s < 16
            // result: (MOVQstore [s-8] dst (MOVQload [s-8] src mem)         (MOVQstore dst (MOVQload src mem) mem))
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 8L && s < 16L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AuxInt = s - 8L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v0.AuxInt = s - 8L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 <= 8
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVQstore dst (MOVQload src mem) mem))
 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 <= 8
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVQstore dst (MOVQload src mem) mem))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 16L && s % 16L != 0L && s % 16L <= 8L))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = s - s % 16L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, dst.Type);
                v0.AuxInt = s % 16L;
                v0.AddArg(dst);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpOffPtr, src.Type);
                v1.AuxInt = s % 16L;
                v1.AddArg(src);
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVQstore, types.TypeMem);
                v2.AddArg(dst);
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v3.AddArg(src);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 > 8 && config.useSSE
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVOstore dst (MOVOload src mem) mem))
 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 > 8 && config.useSSE
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVOstore dst (MOVOload src mem) mem))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 16L && s % 16L != 0L && s % 16L > 8L && config.useSSE))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = s - s % 16L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, dst.Type);
                v0.AuxInt = s % 16L;
                v0.AddArg(dst);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpOffPtr, src.Type);
                v1.AuxInt = s % 16L;
                v1.AddArg(src);
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v2.AddArg(dst);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVOload, types.TypeInt128);
                v3.AddArg(src);
                v3.AddArg(mem);
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 > 8 && !config.useSSE
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVQstore [8] dst (MOVQload [8] src mem)             (MOVQstore dst (MOVQload src mem) mem)))
 
            // match: (Move [s] dst src mem)
            // cond: s > 16 && s%16 != 0 && s%16 > 8 && !config.useSSE
            // result: (Move [s-s%16]         (OffPtr <dst.Type> dst [s%16])         (OffPtr <src.Type> src [s%16])         (MOVQstore [8] dst (MOVQload [8] src mem)             (MOVQstore dst (MOVQload src mem) mem)))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s > 16L && s % 16L != 0L && s % 16L > 8L && !config.useSSE))
                {
                    break;
                }
                v.reset(OpMove);
                v.AuxInt = s - s % 16L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, dst.Type);
                v0.AuxInt = s % 16L;
                v0.AddArg(dst);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpOffPtr, src.Type);
                v1.AuxInt = s % 16L;
                v1.AddArg(src);
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVQstore, types.TypeMem);
                v2.AuxInt = 8L;
                v2.AddArg(dst);
                v3 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v3.AuxInt = 8L;
                v3.AddArg(src);
                v3.AddArg(mem);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpAMD64MOVQstore, types.TypeMem);
                v4.AddArg(dst);
                var v5 = b.NewValue0(v.Pos, OpAMD64MOVQload, typ.UInt64);
                v5.AddArg(src);
                v5.AddArg(mem);
                v4.AddArg(v5);
                v4.AddArg(mem);
                v2.AddArg(v4);
                v.AddArg(v2);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: s >= 32 && s <= 16*64 && s%16 == 0     && !config.noDuffDevice
            // result: (DUFFCOPY [14*(64-s/16)] dst src mem)
 
            // match: (Move [s] dst src mem)
            // cond: s >= 32 && s <= 16*64 && s%16 == 0     && !config.noDuffDevice
            // result: (DUFFCOPY [14*(64-s/16)] dst src mem)
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s >= 32L && s <= 16L * 64L && s % 16L == 0L && !config.noDuffDevice))
                {
                    break;
                }
                v.reset(OpAMD64DUFFCOPY);
                v.AuxInt = 14L * (64L - s / 16L);
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [s] dst src mem)
            // cond: (s > 16*64 || config.noDuffDevice) && s%8 == 0
            // result: (REPMOVSQ dst src (MOVQconst [s/8]) mem)
 
            // match: (Move [s] dst src mem)
            // cond: (s > 16*64 || config.noDuffDevice) && s%8 == 0
            // result: (REPMOVSQ dst src (MOVQconst [s/8]) mem)
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!((s > 16L * 64L || config.noDuffDevice) && s % 8L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64REPMOVSQ);
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v0.AuxInt = s / 8L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpMul16_0(ref Value v)
        { 
            // match: (Mul16 x y)
            // cond:
            // result: (MULL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul32_0(ref Value v)
        { 
            // match: (Mul32 x y)
            // cond:
            // result: (MULL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul32F_0(ref Value v)
        { 
            // match: (Mul32F x y)
            // cond:
            // result: (MULSS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULSS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul64_0(ref Value v)
        { 
            // match: (Mul64 x y)
            // cond:
            // result: (MULQ  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul64F_0(ref Value v)
        { 
            // match: (Mul64F x y)
            // cond:
            // result: (MULSD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULSD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul64uhilo_0(ref Value v)
        { 
            // match: (Mul64uhilo x y)
            // cond:
            // result: (MULQU2 x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULQU2);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpMul8_0(ref Value v)
        { 
            // match: (Mul8 x y)
            // cond:
            // result: (MULL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64MULL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg16_0(ref Value v)
        { 
            // match: (Neg16 x)
            // cond:
            // result: (NEGL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NEGL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg32_0(ref Value v)
        { 
            // match: (Neg32 x)
            // cond:
            // result: (NEGL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NEGL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neg32F x)
            // cond:
            // result: (PXOR x (MOVSSconst <typ.Float32> [f2i(math.Copysign(0, -1))]))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64PXOR);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVSSconst, typ.Float32);
                v0.AuxInt = f2i(math.Copysign(0L, -1L));
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg64_0(ref Value v)
        { 
            // match: (Neg64 x)
            // cond:
            // result: (NEGQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NEGQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neg64F x)
            // cond:
            // result: (PXOR x (MOVSDconst <typ.Float64> [f2i(math.Copysign(0, -1))]))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64PXOR);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVSDconst, typ.Float64);
                v0.AuxInt = f2i(math.Copysign(0L, -1L));
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeg8_0(ref Value v)
        { 
            // match: (Neg8 x)
            // cond:
            // result: (NEGL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64NEGL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq16 x y)
            // cond:
            // result: (SETNE (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32 x y)
            // cond:
            // result: (SETNE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32F x y)
            // cond:
            // result: (SETNEF (UCOMISS x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISS, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64 x y)
            // cond:
            // result: (SETNE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64F x y)
            // cond:
            // result: (SETNEF (UCOMISD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNEF);
                var v0 = b.NewValue0(v.Pos, OpAMD64UCOMISD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq8 x y)
            // cond:
            // result: (SETNE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (NeqB x y)
            // cond:
            // result: (SETNE (CMPB x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPB, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNeqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (NeqPtr x y)
            // cond: config.PtrSize == 8
            // result: (SETNE (CMPQ x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SETNE);
                var v0 = b.NewValue0(v.Pos, OpAMD64CMPQ, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (NeqPtr x y)
            // cond: config.PtrSize == 4
            // result: (SETNE (CMPL x y))
 
            // match: (NeqPtr x y)
            // cond: config.PtrSize == 4
            // result: (SETNE (CMPL x y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SETNE);
                v0 = b.NewValue0(v.Pos, OpAMD64CMPL, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpNilCheck_0(ref Value v)
        { 
            // match: (NilCheck ptr mem)
            // cond:
            // result: (LoweredNilCheck ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpAMD64LoweredNilCheck);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpNot_0(ref Value v)
        { 
            // match: (Not x)
            // cond:
            // result: (XORLconst [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64XORLconst);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpOffPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OffPtr [off] ptr)
            // cond: config.PtrSize == 8 && is32Bit(off)
            // result: (ADDQconst [off] ptr)
            while (true)
            {
                var off = v.AuxInt;
                var ptr = v.Args[0L];
                if (!(config.PtrSize == 8L && is32Bit(off)))
                {
                    break;
                }
                v.reset(OpAMD64ADDQconst);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            } 
            // match: (OffPtr [off] ptr)
            // cond: config.PtrSize == 8
            // result: (ADDQ (MOVQconst [off]) ptr)
 
            // match: (OffPtr [off] ptr)
            // cond: config.PtrSize == 8
            // result: (ADDQ (MOVQconst [off]) ptr)
            while (true)
            {
                off = v.AuxInt;
                ptr = v.Args[0L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64ADDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v0.AuxInt = off;
                v.AddArg(v0);
                v.AddArg(ptr);
                return true;
            } 
            // match: (OffPtr [off] ptr)
            // cond: config.PtrSize == 4
            // result: (ADDLconst [off] ptr)
 
            // match: (OffPtr [off] ptr)
            // cond: config.PtrSize == 4
            // result: (ADDLconst [off] ptr)
            while (true)
            {
                off = v.AuxInt;
                ptr = v.Args[0L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64ADDLconst);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpOr16_0(ref Value v)
        { 
            // match: (Or16 x y)
            // cond:
            // result: (ORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpOr32_0(ref Value v)
        { 
            // match: (Or32 x y)
            // cond:
            // result: (ORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpOr64_0(ref Value v)
        { 
            // match: (Or64 x y)
            // cond:
            // result: (ORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpOr8_0(ref Value v)
        { 
            // match: (Or8 x y)
            // cond:
            // result: (ORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpOrB_0(ref Value v)
        { 
            // match: (OrB x y)
            // cond:
            // result: (ORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpPopCount16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PopCount16 x)
            // cond:
            // result: (POPCNTL (MOVWQZX <typ.UInt32> x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64POPCNTL);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWQZX, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpPopCount32_0(ref Value v)
        { 
            // match: (PopCount32 x)
            // cond:
            // result: (POPCNTL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64POPCNTL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpPopCount64_0(ref Value v)
        { 
            // match: (PopCount64 x)
            // cond:
            // result: (POPCNTQ x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64POPCNTQ);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpPopCount8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PopCount8 x)
            // cond:
            // result: (POPCNTL (MOVBQZX <typ.UInt32> x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64POPCNTL);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVBQZX, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRound32F_0(ref Value v)
        { 
            // match: (Round32F x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRound64F_0(ref Value v)
        { 
            // match: (Round64F x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRoundToEven_0(ref Value v)
        { 
            // match: (RoundToEven x)
            // cond:
            // result: (ROUNDSD [0] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64ROUNDSD);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux16 <t> x y)
            // cond:
            // result: (ANDL (SHRW <t> x y) (SBBLcarrymask <t> (CMPWconst y [16])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 16L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux32 <t> x y)
            // cond:
            // result: (ANDL (SHRW <t> x y) (SBBLcarrymask <t> (CMPLconst y [16])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 16L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux64 <t> x y)
            // cond:
            // result: (ANDL (SHRW <t> x y) (SBBLcarrymask <t> (CMPQconst y [16])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 16L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16Ux8 <t> x y)
            // cond:
            // result: (ANDL (SHRW <t> x y) (SBBLcarrymask <t> (CMPBconst y [16])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRW, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 16L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x16 <t> x y)
            // cond:
            // result: (SARW <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst y [16])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v3.AuxInt = 16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x32 <t> x y)
            // cond:
            // result: (SARW <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst y [16])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v3.AuxInt = 16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x64 <t> x y)
            // cond:
            // result: (SARW <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst y [16])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v3.AuxInt = 16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh16x8 <t> x y)
            // cond:
            // result: (SARW <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst y [16])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARW);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v3.AuxInt = 16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux16 <t> x y)
            // cond:
            // result: (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPWconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux32 <t> x y)
            // cond:
            // result: (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPLconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux64 <t> x y)
            // cond:
            // result: (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPQconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux8 <t> x y)
            // cond:
            // result: (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMPBconst y [32])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRL, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x16 <t> x y)
            // cond:
            // result: (SARL <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst y [32])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARL);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v3.AuxInt = 32L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x32 <t> x y)
            // cond:
            // result: (SARL <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst y [32])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARL);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v3.AuxInt = 32L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x64 <t> x y)
            // cond:
            // result: (SARL <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst y [32])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARL);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v3.AuxInt = 32L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x8 <t> x y)
            // cond:
            // result: (SARL <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst y [32])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARL);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v3.AuxInt = 32L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux16 <t> x y)
            // cond:
            // result: (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPWconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux32 <t> x y)
            // cond:
            // result: (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPLconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux64 <t> x y)
            // cond:
            // result: (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPQconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64Ux8 <t> x y)
            // cond:
            // result: (ANDQ (SHRQ <t> x y) (SBBQcarrymask <t> (CMPBconst y [64])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDQ);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRQ, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x16 <t> x y)
            // cond:
            // result: (SARQ <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst y [64])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARQ);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v3.AuxInt = 64L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x32 <t> x y)
            // cond:
            // result: (SARQ <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst y [64])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARQ);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v3.AuxInt = 64L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x64 <t> x y)
            // cond:
            // result: (SARQ <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst y [64])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARQ);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v3.AuxInt = 64L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh64x8 <t> x y)
            // cond:
            // result: (SARQ <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst y [64])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARQ);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v3.AuxInt = 64L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux16 <t> x y)
            // cond:
            // result: (ANDL (SHRB <t> x y) (SBBLcarrymask <t> (CMPWconst y [8])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRB, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v2.AuxInt = 8L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux32 <t> x y)
            // cond:
            // result: (ANDL (SHRB <t> x y) (SBBLcarrymask <t> (CMPLconst y [8])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRB, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v2.AuxInt = 8L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux64 <t> x y)
            // cond:
            // result: (ANDL (SHRB <t> x y) (SBBLcarrymask <t> (CMPQconst y [8])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRB, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v2.AuxInt = 8L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8Ux8 <t> x y)
            // cond:
            // result: (ANDL (SHRB <t> x y) (SBBLcarrymask <t> (CMPBconst y [8])))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64ANDL);
                var v0 = b.NewValue0(v.Pos, OpAMD64SHRB, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, t);
                var v2 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v2.AuxInt = 8L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x16 <t> x y)
            // cond:
            // result: (SARB <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPWconst y [8])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARB);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPWconst, types.TypeFlags);
                v3.AuxInt = 8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x32 <t> x y)
            // cond:
            // result: (SARB <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPLconst y [8])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARB);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPLconst, types.TypeFlags);
                v3.AuxInt = 8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x64 <t> x y)
            // cond:
            // result: (SARB <t> x (ORQ <y.Type> y (NOTQ <y.Type> (SBBQcarrymask <y.Type> (CMPQconst y [8])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARB);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORQ, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTQ, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBQcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPQconst, types.TypeFlags);
                v3.AuxInt = 8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpRsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh8x8 <t> x y)
            // cond:
            // result: (SARB <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMPBconst y [8])))))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SARB);
                v.Type = t;
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpAMD64ORL, y.Type);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpAMD64NOTL, y.Type);
                var v2 = b.NewValue0(v.Pos, OpAMD64SBBLcarrymask, y.Type);
                var v3 = b.NewValue0(v.Pos, OpAMD64CMPBconst, types.TypeFlags);
                v3.AuxInt = 8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSelect0_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Select0 <t> (AddTupleFirst32 val tuple))
            // cond:
            // result: (ADDL val (Select0 <t> tuple))
            while (true)
            {
                var t = v.Type;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64AddTupleFirst32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var val = v_0.Args[0L];
                var tuple = v_0.Args[1L];
                v.reset(OpAMD64ADDL);
                v.AddArg(val);
                var v0 = b.NewValue0(v.Pos, OpSelect0, t);
                v0.AddArg(tuple);
                v.AddArg(v0);
                return true;
            } 
            // match: (Select0 <t> (AddTupleFirst64 val tuple))
            // cond:
            // result: (ADDQ val (Select0 <t> tuple))
 
            // match: (Select0 <t> (AddTupleFirst64 val tuple))
            // cond:
            // result: (ADDQ val (Select0 <t> tuple))
            while (true)
            {
                t = v.Type;
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64AddTupleFirst64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                val = v_0.Args[0L];
                tuple = v_0.Args[1L];
                v.reset(OpAMD64ADDQ);
                v.AddArg(val);
                v0 = b.NewValue0(v.Pos, OpSelect0, t);
                v0.AddArg(tuple);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpSelect1_0(ref Value v)
        { 
            // match: (Select1 (AddTupleFirst32 _ tuple))
            // cond:
            // result: (Select1 tuple)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64AddTupleFirst32)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var tuple = v_0.Args[1L];
                v.reset(OpSelect1);
                v.AddArg(tuple);
                return true;
            } 
            // match: (Select1 (AddTupleFirst64 _ tuple))
            // cond:
            // result: (Select1 tuple)
 
            // match: (Select1 (AddTupleFirst64 _ tuple))
            // cond:
            // result: (Select1 tuple)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpAMD64AddTupleFirst64)
                {
                    break;
                }
                _ = v_0.Args[1L];
                tuple = v_0.Args[1L];
                v.reset(OpSelect1);
                v.AddArg(tuple);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpSignExt16to32_0(ref Value v)
        { 
            // match: (SignExt16to32 x)
            // cond:
            // result: (MOVWQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVWQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSignExt16to64_0(ref Value v)
        { 
            // match: (SignExt16to64 x)
            // cond:
            // result: (MOVWQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVWQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSignExt32to64_0(ref Value v)
        { 
            // match: (SignExt32to64 x)
            // cond:
            // result: (MOVLQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVLQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSignExt8to16_0(ref Value v)
        { 
            // match: (SignExt8to16 x)
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSignExt8to32_0(ref Value v)
        { 
            // match: (SignExt8to32 x)
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSignExt8to64_0(ref Value v)
        { 
            // match: (SignExt8to64 x)
            // cond:
            // result: (MOVBQSX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQSX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSlicemask_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Slicemask <t> x)
            // cond:
            // result: (SARQconst (NEGQ <t> x) [63])
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpAMD64SARQconst);
                v.AuxInt = 63L;
                var v0 = b.NewValue0(v.Pos, OpAMD64NEGQ, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSqrt_0(ref Value v)
        { 
            // match: (Sqrt x)
            // cond:
            // result: (SQRTSD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64SQRTSD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpStaticCall_0(ref Value v)
        { 
            // match: (StaticCall [argwid] {target} mem)
            // cond:
            // result: (CALLstatic [argwid] {target} mem)
            while (true)
            {
                var argwid = v.AuxInt;
                var target = v.Aux;
                var mem = v.Args[0L];
                v.reset(OpAMD64CALLstatic);
                v.AuxInt = argwid;
                v.Aux = target;
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpStore_0(ref Value v)
        { 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
            // result: (MOVSDstore ptr val mem)
            while (true)
            {
                var t = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && is64BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (MOVSSstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (MOVSSstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpAMD64MOVSSstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8
            // result: (MOVQstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8
            // result: (MOVQstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4
            // result: (MOVLstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4
            // result: (MOVLstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L))
                {
                    break;
                }
                v.reset(OpAMD64MOVLstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVWstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVWstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 2L))
                {
                    break;
                }
                v.reset(OpAMD64MOVWstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 1L))
                {
                    break;
                }
                v.reset(OpAMD64MOVBstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpSub16_0(ref Value v)
        { 
            // match: (Sub16 x y)
            // cond:
            // result: (SUBL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSub32_0(ref Value v)
        { 
            // match: (Sub32 x y)
            // cond:
            // result: (SUBL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSub32F_0(ref Value v)
        { 
            // match: (Sub32F x y)
            // cond:
            // result: (SUBSS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBSS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSub64_0(ref Value v)
        { 
            // match: (Sub64 x y)
            // cond:
            // result: (SUBQ  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSub64F_0(ref Value v)
        { 
            // match: (Sub64F x y)
            // cond:
            // result: (SUBSD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBSD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSub8_0(ref Value v)
        { 
            // match: (Sub8 x y)
            // cond:
            // result: (SUBL  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpSubPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (SubPtr x y)
            // cond: config.PtrSize == 8
            // result: (SUBQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(config.PtrSize == 8L))
                {
                    break;
                }
                v.reset(OpAMD64SUBQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SubPtr x y)
            // cond: config.PtrSize == 4
            // result: (SUBL x y)
 
            // match: (SubPtr x y)
            // cond: config.PtrSize == 4
            // result: (SUBL x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                if (!(config.PtrSize == 4L))
                {
                    break;
                }
                v.reset(OpAMD64SUBL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpTrunc_0(ref Value v)
        { 
            // match: (Trunc x)
            // cond:
            // result: (ROUNDSD [3] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64ROUNDSD);
                v.AuxInt = 3L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc16to8_0(ref Value v)
        { 
            // match: (Trunc16to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc32to16_0(ref Value v)
        { 
            // match: (Trunc32to16 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc32to8_0(ref Value v)
        { 
            // match: (Trunc32to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc64to16_0(ref Value v)
        { 
            // match: (Trunc64to16 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc64to32_0(ref Value v)
        { 
            // match: (Trunc64to32 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpTrunc64to8_0(ref Value v)
        { 
            // match: (Trunc64to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpWB_0(ref Value v)
        { 
            // match: (WB {fn} destptr srcptr mem)
            // cond:
            // result: (LoweredWB {fn} destptr srcptr mem)
            while (true)
            {
                var fn = v.Aux;
                _ = v.Args[2L];
                var destptr = v.Args[0L];
                var srcptr = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpAMD64LoweredWB);
                v.Aux = fn;
                v.AddArg(destptr);
                v.AddArg(srcptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpXor16_0(ref Value v)
        { 
            // match: (Xor16 x y)
            // cond:
            // result: (XORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64XORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpXor32_0(ref Value v)
        { 
            // match: (Xor32 x y)
            // cond:
            // result: (XORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64XORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpXor64_0(ref Value v)
        { 
            // match: (Xor64 x y)
            // cond:
            // result: (XORQ x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64XORQ);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpXor8_0(ref Value v)
        { 
            // match: (Xor8 x y)
            // cond:
            // result: (XORL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpAMD64XORL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZero_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Zero [0] _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[1L];
                var mem = v.Args[1L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstoreconst [0] destptr mem)
 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVWstoreconst [0] destptr mem)
 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVWstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVLstoreconst [0] destptr mem)
 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVLstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVQstoreconst [0] destptr mem)
 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVQstoreconst [0] destptr mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = 0L;
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,2)] destptr         (MOVWstoreconst [0] destptr mem))
 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,2)] destptr         (MOVWstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = makeValAndOff(0L, 2L);
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVWstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,4)] destptr         (MOVLstoreconst [0] destptr mem))
 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstoreconst [makeValAndOff(0,4)] destptr         (MOVLstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVBstoreconst);
                v.AuxInt = makeValAndOff(0L, 4L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVWstoreconst [makeValAndOff(0,4)] destptr         (MOVLstoreconst [0] destptr mem))
 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVWstoreconst [makeValAndOff(0,4)] destptr         (MOVLstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVWstoreconst);
                v.AuxInt = makeValAndOff(0L, 4L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVLstoreconst [makeValAndOff(0,3)] destptr         (MOVLstoreconst [0] destptr mem))
 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVLstoreconst [makeValAndOff(0,3)] destptr         (MOVLstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpAMD64MOVLstoreconst);
                v.AuxInt = makeValAndOff(0L, 3L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVLstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: s%8 != 0 && s > 8 && !config.useSSE
            // result: (Zero [s-s%8] (OffPtr <destptr.Type> destptr [s%8])         (MOVQstoreconst [0] destptr mem))
 
            // match: (Zero [s] destptr mem)
            // cond: s%8 != 0 && s > 8 && !config.useSSE
            // result: (Zero [s-s%8] (OffPtr <destptr.Type> destptr [s%8])         (MOVQstoreconst [0] destptr mem))
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s % 8L != 0L && s > 8L && !config.useSSE))
                {
                    break;
                }
                v.reset(OpZero);
                v.AuxInt = s - s % 8L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = s % 8L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(destptr);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpZero_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (Zero [16] destptr mem)
            // cond: !config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,8)] destptr         (MOVQstoreconst [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(!config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = makeValAndOff(0L, 8L);
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [24] destptr mem)
            // cond: !config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,16)] destptr         (MOVQstoreconst [makeValAndOff(0,8)] destptr             (MOVQstoreconst [0] destptr mem)))
 
            // match: (Zero [24] destptr mem)
            // cond: !config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,16)] destptr         (MOVQstoreconst [makeValAndOff(0,8)] destptr             (MOVQstoreconst [0] destptr mem)))
            while (true)
            {
                if (v.AuxInt != 24L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(!config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = makeValAndOff(0L, 16L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v0.AuxInt = makeValAndOff(0L, 8L);
                v0.AddArg(destptr);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(destptr);
                v1.AddArg(mem);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [32] destptr mem)
            // cond: !config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,24)] destptr         (MOVQstoreconst [makeValAndOff(0,16)] destptr             (MOVQstoreconst [makeValAndOff(0,8)] destptr                 (MOVQstoreconst [0] destptr mem))))
 
            // match: (Zero [32] destptr mem)
            // cond: !config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,24)] destptr         (MOVQstoreconst [makeValAndOff(0,16)] destptr             (MOVQstoreconst [makeValAndOff(0,8)] destptr                 (MOVQstoreconst [0] destptr mem))))
            while (true)
            {
                if (v.AuxInt != 32L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(!config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = makeValAndOff(0L, 24L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v0.AuxInt = makeValAndOff(0L, 16L);
                v0.AddArg(destptr);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v1.AuxInt = makeValAndOff(0L, 8L);
                v1.AddArg(destptr);
                var v2 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v2.AuxInt = 0L;
                v2.AddArg(destptr);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: s > 8 && s < 16 && config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,s-8)] destptr         (MOVQstoreconst [0] destptr mem))
 
            // match: (Zero [s] destptr mem)
            // cond: s > 8 && s < 16 && config.useSSE
            // result: (MOVQstoreconst [makeValAndOff(0,s-8)] destptr         (MOVQstoreconst [0] destptr mem))
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s > 8L && s < 16L && config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVQstoreconst);
                v.AuxInt = makeValAndOff(0L, s - 8L);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: s%16 != 0 && s > 16 && s%16 > 8 && config.useSSE
            // result: (Zero [s-s%16] (OffPtr <destptr.Type> destptr [s%16])         (MOVOstore destptr (MOVOconst [0]) mem))
 
            // match: (Zero [s] destptr mem)
            // cond: s%16 != 0 && s > 16 && s%16 > 8 && config.useSSE
            // result: (Zero [s-s%16] (OffPtr <destptr.Type> destptr [s%16])         (MOVOstore destptr (MOVOconst [0]) mem))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s % 16L != 0L && s > 16L && s % 16L > 8L && config.useSSE))
                {
                    break;
                }
                v.reset(OpZero);
                v.AuxInt = s - s % 16L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = s % 16L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v1.AddArg(destptr);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v2.AuxInt = 0L;
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: s%16 != 0 && s > 16 && s%16 <= 8 && config.useSSE
            // result: (Zero [s-s%16] (OffPtr <destptr.Type> destptr [s%16])         (MOVQstoreconst [0] destptr mem))
 
            // match: (Zero [s] destptr mem)
            // cond: s%16 != 0 && s > 16 && s%16 <= 8 && config.useSSE
            // result: (Zero [s-s%16] (OffPtr <destptr.Type> destptr [s%16])         (MOVQstoreconst [0] destptr mem))
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s % 16L != 0L && s > 16L && s % 16L <= 8L && config.useSSE))
                {
                    break;
                }
                v.reset(OpZero);
                v.AuxInt = s - s % 16L;
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = s % 16L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVQstoreconst, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(destptr);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [16] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore destptr (MOVOconst [0]) mem)
 
            // match: (Zero [16] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore destptr (MOVOconst [0]) mem)
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [32] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])         (MOVOstore destptr (MOVOconst [0]) mem))
 
            // match: (Zero [32] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])         (MOVOstore destptr (MOVOconst [0]) mem))
            while (true)
            {
                if (v.AuxInt != 32L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = 16L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v2.AddArg(destptr);
                var v3 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v3.AuxInt = 0L;
                v2.AddArg(v3);
                v2.AddArg(mem);
                v.AddArg(v2);
                return true;
            } 
            // match: (Zero [48] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [32]) (MOVOconst [0])         (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])             (MOVOstore destptr (MOVOconst [0]) mem)))
 
            // match: (Zero [48] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [32]) (MOVOconst [0])         (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])             (MOVOstore destptr (MOVOconst [0]) mem)))
            while (true)
            {
                if (v.AuxInt != 48L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = 32L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v3 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v3.AuxInt = 16L;
                v3.AddArg(destptr);
                v2.AddArg(v3);
                var v4 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v4.AuxInt = 0L;
                v2.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v5.AddArg(destptr);
                var v6 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v6.AuxInt = 0L;
                v5.AddArg(v6);
                v5.AddArg(mem);
                v2.AddArg(v5);
                v.AddArg(v2);
                return true;
            } 
            // match: (Zero [64] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [48]) (MOVOconst [0])         (MOVOstore (OffPtr <destptr.Type> destptr [32]) (MOVOconst [0])             (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])                 (MOVOstore destptr (MOVOconst [0]) mem))))
 
            // match: (Zero [64] destptr mem)
            // cond: config.useSSE
            // result: (MOVOstore (OffPtr <destptr.Type> destptr [48]) (MOVOconst [0])         (MOVOstore (OffPtr <destptr.Type> destptr [32]) (MOVOconst [0])             (MOVOstore (OffPtr <destptr.Type> destptr [16]) (MOVOconst [0])                 (MOVOstore destptr (MOVOconst [0]) mem))))
            while (true)
            {
                if (v.AuxInt != 64L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(config.useSSE))
                {
                    break;
                }
                v.reset(OpAMD64MOVOstore);
                v0 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v0.AuxInt = 48L;
                v0.AddArg(destptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v3 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v3.AuxInt = 32L;
                v3.AddArg(destptr);
                v2.AddArg(v3);
                v4 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v4.AuxInt = 0L;
                v2.AddArg(v4);
                v5 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v6 = b.NewValue0(v.Pos, OpOffPtr, destptr.Type);
                v6.AuxInt = 16L;
                v6.AddArg(destptr);
                v5.AddArg(v6);
                var v7 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v7.AuxInt = 0L;
                v5.AddArg(v7);
                var v8 = b.NewValue0(v.Pos, OpAMD64MOVOstore, types.TypeMem);
                v8.AddArg(destptr);
                var v9 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v9.AuxInt = 0L;
                v8.AddArg(v9);
                v8.AddArg(mem);
                v5.AddArg(v8);
                v2.AddArg(v5);
                v.AddArg(v2);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpZero_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Zero [s] destptr mem)
            // cond: s > 64 && s <= 1024 && s%16 == 0 && !config.noDuffDevice
            // result: (DUFFZERO [s] destptr (MOVOconst [0]) mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(s > 64L && s <= 1024L && s % 16L == 0L && !config.noDuffDevice))
                {
                    break;
                }
                v.reset(OpAMD64DUFFZERO);
                v.AuxInt = s;
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpAMD64MOVOconst, types.TypeInt128);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [s] destptr mem)
            // cond: (s > 1024 || (config.noDuffDevice && s > 64 || !config.useSSE && s > 32))     && s%8 == 0
            // result: (REPSTOSQ destptr (MOVQconst [s/8]) (MOVQconst [0]) mem)
 
            // match: (Zero [s] destptr mem)
            // cond: (s > 1024 || (config.noDuffDevice && s > 64 || !config.useSSE && s > 32))     && s%8 == 0
            // result: (REPSTOSQ destptr (MOVQconst [s/8]) (MOVQconst [0]) mem)
            while (true)
            {
                s = v.AuxInt;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!((s > 1024L || (config.noDuffDevice && s > 64L || !config.useSSE && s > 32L)) && s % 8L == 0L))
                {
                    break;
                }
                v.reset(OpAMD64REPSTOSQ);
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v0.AuxInt = s / 8L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpAMD64MOVQconst, typ.UInt64);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueAMD64_OpZeroExt16to32_0(ref Value v)
        { 
            // match: (ZeroExt16to32 x)
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZeroExt16to64_0(ref Value v)
        { 
            // match: (ZeroExt16to64 x)
            // cond:
            // result: (MOVWQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVWQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZeroExt32to64_0(ref Value v)
        { 
            // match: (ZeroExt32to64 x)
            // cond:
            // result: (MOVLQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVLQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZeroExt8to16_0(ref Value v)
        { 
            // match: (ZeroExt8to16 x)
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZeroExt8to32_0(ref Value v)
        { 
            // match: (ZeroExt8to32 x)
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueAMD64_OpZeroExt8to64_0(ref Value v)
        { 
            // match: (ZeroExt8to64 x)
            // cond:
            // result: (MOVBQZX x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpAMD64MOVBQZX);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteBlockAMD64(ref Block b)
        {
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref config.Types;
            _ = typ;

            if (b.Kind == BlockAMD64EQ) 
                // match: (EQ (TESTL (SHLL (MOVLconst [1]) x) y))
                // cond: !config.nacl
                // result: (UGE (BTL x y))
                while (true)
                {
                    var v = b.Control;
                    if (v.Op != OpAMD64TESTL)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    var v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SHLL)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    var v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpAMD64MOVLconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 1L)
                    {
                        break;
                    }
                    var x = v_0.Args[1L];
                    var y = v.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    var v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTL y (SHLL (MOVLconst [1]) x)))
                // cond: !config.nacl
                // result: (UGE (BTL x y))
 
                // match: (EQ (TESTL y (SHLL (MOVLconst [1]) x)))
                // cond: !config.nacl
                // result: (UGE (BTL x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTL)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    y = v.Args[0L];
                    var v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SHLL)
                    {
                        break;
                    }
                    _ = v_1.Args[1L];
                    var v_1_0 = v_1.Args[0L];
                    if (v_1_0.Op != OpAMD64MOVLconst)
                    {
                        break;
                    }
                    if (v_1_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_1.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTQ (SHLQ (MOVQconst [1]) x) y))
                // cond: !config.nacl
                // result: (UGE (BTQ x y))
 
                // match: (EQ (TESTQ (SHLQ (MOVQconst [1]) x) y))
                // cond: !config.nacl
                // result: (UGE (BTQ x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SHLQ)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_0.Args[1L];
                    y = v.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTQ y (SHLQ (MOVQconst [1]) x)))
                // cond: !config.nacl
                // result: (UGE (BTQ x y))
 
                // match: (EQ (TESTQ y (SHLQ (MOVQconst [1]) x)))
                // cond: !config.nacl
                // result: (UGE (BTQ x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    y = v.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SHLQ)
                    {
                        break;
                    }
                    _ = v_1.Args[1L];
                    v_1_0 = v_1.Args[0L];
                    if (v_1_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    if (v_1_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_1.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTLconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
                // result: (UGE (BTLconst [log2(c)] x))
 
                // match: (EQ (TESTLconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
                // result: (UGE (BTLconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTLconst)
                    {
                        break;
                    }
                    var c = v.AuxInt;
                    x = v.Args[0L];
                    if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTQconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
 
                // match: (EQ (TESTQconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQconst)
                    {
                        break;
                    }
                    c = v.AuxInt;
                    x = v.Args[0L];
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTQ (MOVQconst [c]) x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
 
                // match: (EQ (TESTQ (MOVQconst [c]) x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v.Args[1L];
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (TESTQ x (MOVQconst [c])))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
 
                // match: (EQ (TESTQ x (MOVQconst [c])))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (UGE (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    x = v.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    c = v_1.AuxInt;
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    var cmp = v.Args[0L];
                    b.Kind = BlockAMD64EQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockAMD64GE) 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64LE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockAMD64GT) 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64LT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockIf) 
                // match: (If (SETL cmp) yes no)
                // cond:
                // result: (LT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETL)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64LT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETLE cmp) yes no)
                // cond:
                // result: (LE  cmp yes no)
 
                // match: (If (SETLE cmp) yes no)
                // cond:
                // result: (LE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETLE)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64LE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETG cmp) yes no)
                // cond:
                // result: (GT  cmp yes no)
 
                // match: (If (SETG cmp) yes no)
                // cond:
                // result: (GT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETG)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64GT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETGE cmp) yes no)
                // cond:
                // result: (GE  cmp yes no)
 
                // match: (If (SETGE cmp) yes no)
                // cond:
                // result: (GE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETGE)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64GE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETEQ cmp) yes no)
                // cond:
                // result: (EQ  cmp yes no)
 
                // match: (If (SETEQ cmp) yes no)
                // cond:
                // result: (EQ  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETEQ)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64EQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETNE cmp) yes no)
                // cond:
                // result: (NE  cmp yes no)
 
                // match: (If (SETNE cmp) yes no)
                // cond:
                // result: (NE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETNE)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64NE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETB cmp) yes no)
                // cond:
                // result: (ULT cmp yes no)
 
                // match: (If (SETB cmp) yes no)
                // cond:
                // result: (ULT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETB)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64ULT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETBE cmp) yes no)
                // cond:
                // result: (ULE cmp yes no)
 
                // match: (If (SETBE cmp) yes no)
                // cond:
                // result: (ULE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETBE)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64ULE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETA cmp) yes no)
                // cond:
                // result: (UGT cmp yes no)
 
                // match: (If (SETA cmp) yes no)
                // cond:
                // result: (UGT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETA)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETAE cmp) yes no)
                // cond:
                // result: (UGE cmp yes no)
 
                // match: (If (SETAE cmp) yes no)
                // cond:
                // result: (UGE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETAE)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETGF cmp) yes no)
                // cond:
                // result: (UGT  cmp yes no)
 
                // match: (If (SETGF cmp) yes no)
                // cond:
                // result: (UGT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETGF)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETGEF cmp) yes no)
                // cond:
                // result: (UGE  cmp yes no)
 
                // match: (If (SETGEF cmp) yes no)
                // cond:
                // result: (UGE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETGEF)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETEQF cmp) yes no)
                // cond:
                // result: (EQF  cmp yes no)
 
                // match: (If (SETEQF cmp) yes no)
                // cond:
                // result: (EQF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETEQF)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64EQF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (SETNEF cmp) yes no)
                // cond:
                // result: (NEF  cmp yes no)
 
                // match: (If (SETNEF cmp) yes no)
                // cond:
                // result: (NEF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64SETNEF)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64NEF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (If cond yes no)
                // cond:
                // result: (NE (TESTB cond cond) yes no)
 
                // match: (If cond yes no)
                // cond:
                // result: (NE (TESTB cond cond) yes no)
                while (true)
                {
                    v = b.Control;
                    _ = v;
                    var cond = b.Control;
                    b.Kind = BlockAMD64NE;
                    v0 = b.NewValue0(v.Pos, OpAMD64TESTB, types.TypeFlags);
                    v0.AddArg(cond);
                    v0.AddArg(cond);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockAMD64LE) 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64GE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockAMD64LT) 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64GT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockAMD64NE) 
                // match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
                // cond:
                // result: (LT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETL)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETL)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64LT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
                // cond:
                // result: (LT  cmp yes no)
 
                // match: (NE (TESTB (SETL cmp) (SETL cmp)) yes no)
                // cond:
                // result: (LT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETL)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETL)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64LT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
                // cond:
                // result: (LE  cmp yes no)
 
                // match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
                // cond:
                // result: (LE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETLE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETLE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64LE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
                // cond:
                // result: (LE  cmp yes no)
 
                // match: (NE (TESTB (SETLE cmp) (SETLE cmp)) yes no)
                // cond:
                // result: (LE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETLE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETLE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64LE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
                // cond:
                // result: (GT  cmp yes no)
 
                // match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
                // cond:
                // result: (GT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETG)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETG)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64GT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
                // cond:
                // result: (GT  cmp yes no)
 
                // match: (NE (TESTB (SETG cmp) (SETG cmp)) yes no)
                // cond:
                // result: (GT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETG)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETG)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64GT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
                // cond:
                // result: (GE  cmp yes no)
 
                // match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
                // cond:
                // result: (GE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64GE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
                // cond:
                // result: (GE  cmp yes no)
 
                // match: (NE (TESTB (SETGE cmp) (SETGE cmp)) yes no)
                // cond:
                // result: (GE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64GE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
                // cond:
                // result: (EQ  cmp yes no)
 
                // match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
                // cond:
                // result: (EQ  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETEQ)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETEQ)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64EQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
                // cond:
                // result: (EQ  cmp yes no)
 
                // match: (NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no)
                // cond:
                // result: (EQ  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETEQ)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETEQ)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64EQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
                // cond:
                // result: (NE  cmp yes no)
 
                // match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
                // cond:
                // result: (NE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETNE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETNE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64NE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
                // cond:
                // result: (NE  cmp yes no)
 
                // match: (NE (TESTB (SETNE cmp) (SETNE cmp)) yes no)
                // cond:
                // result: (NE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETNE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETNE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64NE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
                // cond:
                // result: (ULT cmp yes no)
 
                // match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
                // cond:
                // result: (ULT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETB)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETB)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
                // cond:
                // result: (ULT cmp yes no)
 
                // match: (NE (TESTB (SETB cmp) (SETB cmp)) yes no)
                // cond:
                // result: (ULT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETB)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETB)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
                // cond:
                // result: (ULE cmp yes no)
 
                // match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
                // cond:
                // result: (ULE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETBE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETBE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
                // cond:
                // result: (ULE cmp yes no)
 
                // match: (NE (TESTB (SETBE cmp) (SETBE cmp)) yes no)
                // cond:
                // result: (ULE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETBE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETBE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
                // cond:
                // result: (UGT cmp yes no)
 
                // match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
                // cond:
                // result: (UGT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETA)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETA)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
                // cond:
                // result: (UGT cmp yes no)
 
                // match: (NE (TESTB (SETA cmp) (SETA cmp)) yes no)
                // cond:
                // result: (UGT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETA)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETA)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
                // cond:
                // result: (UGE cmp yes no)
 
                // match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
                // cond:
                // result: (UGE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETAE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETAE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
                // cond:
                // result: (UGE cmp yes no)
 
                // match: (NE (TESTB (SETAE cmp) (SETAE cmp)) yes no)
                // cond:
                // result: (UGE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETAE)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETAE)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTL (SHLL (MOVLconst [1]) x) y))
                // cond: !config.nacl
                // result: (ULT (BTL x y))
 
                // match: (NE (TESTL (SHLL (MOVLconst [1]) x) y))
                // cond: !config.nacl
                // result: (ULT (BTL x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTL)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SHLL)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpAMD64MOVLconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_0.Args[1L];
                    y = v.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTL y (SHLL (MOVLconst [1]) x)))
                // cond: !config.nacl
                // result: (ULT (BTL x y))
 
                // match: (NE (TESTL y (SHLL (MOVLconst [1]) x)))
                // cond: !config.nacl
                // result: (ULT (BTL x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTL)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    y = v.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SHLL)
                    {
                        break;
                    }
                    _ = v_1.Args[1L];
                    v_1_0 = v_1.Args[0L];
                    if (v_1_0.Op != OpAMD64MOVLconst)
                    {
                        break;
                    }
                    if (v_1_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_1.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTL, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTQ (SHLQ (MOVQconst [1]) x) y))
                // cond: !config.nacl
                // result: (ULT (BTQ x y))
 
                // match: (NE (TESTQ (SHLQ (MOVQconst [1]) x) y))
                // cond: !config.nacl
                // result: (ULT (BTQ x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SHLQ)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    v_0_0 = v_0.Args[0L];
                    if (v_0_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    if (v_0_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_0.Args[1L];
                    y = v.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTQ y (SHLQ (MOVQconst [1]) x)))
                // cond: !config.nacl
                // result: (ULT (BTQ x y))
 
                // match: (NE (TESTQ y (SHLQ (MOVQconst [1]) x)))
                // cond: !config.nacl
                // result: (ULT (BTQ x y))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    y = v.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SHLQ)
                    {
                        break;
                    }
                    _ = v_1.Args[1L];
                    v_1_0 = v_1.Args[0L];
                    if (v_1_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    if (v_1_0.AuxInt != 1L)
                    {
                        break;
                    }
                    x = v_1.Args[1L];
                    if (!(!config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTLconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
                // result: (ULT (BTLconst [log2(c)] x))
 
                // match: (NE (TESTLconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 32 && !config.nacl
                // result: (ULT (BTLconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTLconst)
                    {
                        break;
                    }
                    c = v.AuxInt;
                    x = v.Args[0L];
                    if (!(isPowerOfTwo(c) && log2(c) < 32L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTLconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTQconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
 
                // match: (NE (TESTQconst [c] x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQconst)
                    {
                        break;
                    }
                    c = v.AuxInt;
                    x = v.Args[0L];
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTQ (MOVQconst [c]) x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
 
                // match: (NE (TESTQ (MOVQconst [c]) x))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v.Args[1L];
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTQ x (MOVQconst [c])))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
 
                // match: (NE (TESTQ x (MOVQconst [c])))
                // cond: isPowerOfTwo(c) && log2(c) < 64 && !config.nacl
                // result: (ULT (BTQconst [log2(c)] x))
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTQ)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    x = v.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64MOVQconst)
                    {
                        break;
                    }
                    c = v_1.AuxInt;
                    if (!(isPowerOfTwo(c) && log2(c) < 64L && !config.nacl))
                    {
                        break;
                    }
                    b.Kind = BlockAMD64ULT;
                    v0 = b.NewValue0(v.Pos, OpAMD64BTQconst, types.TypeFlags);
                    v0.AuxInt = log2(c);
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
                // cond:
                // result: (UGT  cmp yes no)
 
                // match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
                // cond:
                // result: (UGT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
                // cond:
                // result: (UGT  cmp yes no)
 
                // match: (NE (TESTB (SETGF cmp) (SETGF cmp)) yes no)
                // cond:
                // result: (UGT  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
                // cond:
                // result: (UGE  cmp yes no)
 
                // match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
                // cond:
                // result: (UGE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGEF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGEF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
                // cond:
                // result: (UGE  cmp yes no)
 
                // match: (NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no)
                // cond:
                // result: (UGE  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETGEF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETGEF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
                // cond:
                // result: (EQF  cmp yes no)
 
                // match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
                // cond:
                // result: (EQF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETEQF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETEQF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64EQF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
                // cond:
                // result: (EQF  cmp yes no)
 
                // match: (NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no)
                // cond:
                // result: (EQF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETEQF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETEQF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64EQF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
                // cond:
                // result: (NEF  cmp yes no)
 
                // match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
                // cond:
                // result: (NEF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETNEF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETNEF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64NEF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
                // cond:
                // result: (NEF  cmp yes no)
 
                // match: (NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no)
                // cond:
                // result: (NEF  cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64TESTB)
                    {
                        break;
                    }
                    _ = v.Args[1L];
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpAMD64SETNEF)
                    {
                        break;
                    }
                    cmp = v_0.Args[0L];
                    v_1 = v.Args[1L];
                    if (v_1.Op != OpAMD64SETNEF)
                    {
                        break;
                    }
                    if (cmp != v_1.Args[0L])
                    {
                        break;
                    }
                    b.Kind = BlockAMD64NEF;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64NE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (NE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockAMD64UGE) 
                // match: (UGE (InvertFlags cmp) yes no)
                // cond:
                // result: (ULE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64ULE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockAMD64UGT) 
                // match: (UGT (InvertFlags cmp) yes no)
                // cond:
                // result: (ULT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64ULT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockAMD64ULE) 
                // match: (ULE (InvertFlags cmp) yes no)
                // cond:
                // result: (UGE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
            else if (b.Kind == BlockAMD64ULT) 
                // match: (ULT (InvertFlags cmp) yes no)
                // cond:
                // result: (UGT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockAMD64UGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpAMD64FlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                }
                        return false;
        }
    }
}}}}
