// Code generated from gen/PPC64.rules; DO NOT EDIT.
// generated with: cd gen; go run *.go

// package ssa -- go2cs converted at 2020 August 29 09:19:13 UTC
// import "cmd/compile/internal/ssa" ==> using ssa = go.cmd.compile.@internal.ssa_package
// Original source: C:\Go\src\cmd\compile\internal\ssa\rewritePPC64.go
using math = go.math_package;
using obj = go.cmd.@internal.obj_package;
using objabi = go.cmd.@internal.objabi_package;
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        private static var _ = math.MinInt8; // in case not otherwise used
        private static var _ = obj.ANOP; // in case not otherwise used
        private static var _ = objabi.GOROOT; // in case not otherwise used
        private static var _ = types.TypeMem; // in case not otherwise used

        private static bool rewriteValuePPC64(ref Value v)
        {

            if (v.Op == OpAbs) 
                return rewriteValuePPC64_OpAbs_0(v);
            else if (v.Op == OpAdd16) 
                return rewriteValuePPC64_OpAdd16_0(v);
            else if (v.Op == OpAdd32) 
                return rewriteValuePPC64_OpAdd32_0(v);
            else if (v.Op == OpAdd32F) 
                return rewriteValuePPC64_OpAdd32F_0(v);
            else if (v.Op == OpAdd64) 
                return rewriteValuePPC64_OpAdd64_0(v);
            else if (v.Op == OpAdd64F) 
                return rewriteValuePPC64_OpAdd64F_0(v);
            else if (v.Op == OpAdd8) 
                return rewriteValuePPC64_OpAdd8_0(v);
            else if (v.Op == OpAddPtr) 
                return rewriteValuePPC64_OpAddPtr_0(v);
            else if (v.Op == OpAddr) 
                return rewriteValuePPC64_OpAddr_0(v);
            else if (v.Op == OpAnd16) 
                return rewriteValuePPC64_OpAnd16_0(v);
            else if (v.Op == OpAnd32) 
                return rewriteValuePPC64_OpAnd32_0(v);
            else if (v.Op == OpAnd64) 
                return rewriteValuePPC64_OpAnd64_0(v);
            else if (v.Op == OpAnd8) 
                return rewriteValuePPC64_OpAnd8_0(v);
            else if (v.Op == OpAndB) 
                return rewriteValuePPC64_OpAndB_0(v);
            else if (v.Op == OpAtomicAdd32) 
                return rewriteValuePPC64_OpAtomicAdd32_0(v);
            else if (v.Op == OpAtomicAdd64) 
                return rewriteValuePPC64_OpAtomicAdd64_0(v);
            else if (v.Op == OpAtomicAnd8) 
                return rewriteValuePPC64_OpAtomicAnd8_0(v);
            else if (v.Op == OpAtomicCompareAndSwap32) 
                return rewriteValuePPC64_OpAtomicCompareAndSwap32_0(v);
            else if (v.Op == OpAtomicCompareAndSwap64) 
                return rewriteValuePPC64_OpAtomicCompareAndSwap64_0(v);
            else if (v.Op == OpAtomicExchange32) 
                return rewriteValuePPC64_OpAtomicExchange32_0(v);
            else if (v.Op == OpAtomicExchange64) 
                return rewriteValuePPC64_OpAtomicExchange64_0(v);
            else if (v.Op == OpAtomicLoad32) 
                return rewriteValuePPC64_OpAtomicLoad32_0(v);
            else if (v.Op == OpAtomicLoad64) 
                return rewriteValuePPC64_OpAtomicLoad64_0(v);
            else if (v.Op == OpAtomicLoadPtr) 
                return rewriteValuePPC64_OpAtomicLoadPtr_0(v);
            else if (v.Op == OpAtomicOr8) 
                return rewriteValuePPC64_OpAtomicOr8_0(v);
            else if (v.Op == OpAtomicStore32) 
                return rewriteValuePPC64_OpAtomicStore32_0(v);
            else if (v.Op == OpAtomicStore64) 
                return rewriteValuePPC64_OpAtomicStore64_0(v);
            else if (v.Op == OpAvg64u) 
                return rewriteValuePPC64_OpAvg64u_0(v);
            else if (v.Op == OpBitLen32) 
                return rewriteValuePPC64_OpBitLen32_0(v);
            else if (v.Op == OpBitLen64) 
                return rewriteValuePPC64_OpBitLen64_0(v);
            else if (v.Op == OpCeil) 
                return rewriteValuePPC64_OpCeil_0(v);
            else if (v.Op == OpClosureCall) 
                return rewriteValuePPC64_OpClosureCall_0(v);
            else if (v.Op == OpCom16) 
                return rewriteValuePPC64_OpCom16_0(v);
            else if (v.Op == OpCom32) 
                return rewriteValuePPC64_OpCom32_0(v);
            else if (v.Op == OpCom64) 
                return rewriteValuePPC64_OpCom64_0(v);
            else if (v.Op == OpCom8) 
                return rewriteValuePPC64_OpCom8_0(v);
            else if (v.Op == OpConst16) 
                return rewriteValuePPC64_OpConst16_0(v);
            else if (v.Op == OpConst32) 
                return rewriteValuePPC64_OpConst32_0(v);
            else if (v.Op == OpConst32F) 
                return rewriteValuePPC64_OpConst32F_0(v);
            else if (v.Op == OpConst64) 
                return rewriteValuePPC64_OpConst64_0(v);
            else if (v.Op == OpConst64F) 
                return rewriteValuePPC64_OpConst64F_0(v);
            else if (v.Op == OpConst8) 
                return rewriteValuePPC64_OpConst8_0(v);
            else if (v.Op == OpConstBool) 
                return rewriteValuePPC64_OpConstBool_0(v);
            else if (v.Op == OpConstNil) 
                return rewriteValuePPC64_OpConstNil_0(v);
            else if (v.Op == OpConvert) 
                return rewriteValuePPC64_OpConvert_0(v);
            else if (v.Op == OpCopysign) 
                return rewriteValuePPC64_OpCopysign_0(v);
            else if (v.Op == OpCtz32) 
                return rewriteValuePPC64_OpCtz32_0(v);
            else if (v.Op == OpCtz64) 
                return rewriteValuePPC64_OpCtz64_0(v);
            else if (v.Op == OpCvt32Fto32) 
                return rewriteValuePPC64_OpCvt32Fto32_0(v);
            else if (v.Op == OpCvt32Fto64) 
                return rewriteValuePPC64_OpCvt32Fto64_0(v);
            else if (v.Op == OpCvt32Fto64F) 
                return rewriteValuePPC64_OpCvt32Fto64F_0(v);
            else if (v.Op == OpCvt32to32F) 
                return rewriteValuePPC64_OpCvt32to32F_0(v);
            else if (v.Op == OpCvt32to64F) 
                return rewriteValuePPC64_OpCvt32to64F_0(v);
            else if (v.Op == OpCvt64Fto32) 
                return rewriteValuePPC64_OpCvt64Fto32_0(v);
            else if (v.Op == OpCvt64Fto32F) 
                return rewriteValuePPC64_OpCvt64Fto32F_0(v);
            else if (v.Op == OpCvt64Fto64) 
                return rewriteValuePPC64_OpCvt64Fto64_0(v);
            else if (v.Op == OpCvt64to32F) 
                return rewriteValuePPC64_OpCvt64to32F_0(v);
            else if (v.Op == OpCvt64to64F) 
                return rewriteValuePPC64_OpCvt64to64F_0(v);
            else if (v.Op == OpDiv16) 
                return rewriteValuePPC64_OpDiv16_0(v);
            else if (v.Op == OpDiv16u) 
                return rewriteValuePPC64_OpDiv16u_0(v);
            else if (v.Op == OpDiv32) 
                return rewriteValuePPC64_OpDiv32_0(v);
            else if (v.Op == OpDiv32F) 
                return rewriteValuePPC64_OpDiv32F_0(v);
            else if (v.Op == OpDiv32u) 
                return rewriteValuePPC64_OpDiv32u_0(v);
            else if (v.Op == OpDiv64) 
                return rewriteValuePPC64_OpDiv64_0(v);
            else if (v.Op == OpDiv64F) 
                return rewriteValuePPC64_OpDiv64F_0(v);
            else if (v.Op == OpDiv64u) 
                return rewriteValuePPC64_OpDiv64u_0(v);
            else if (v.Op == OpDiv8) 
                return rewriteValuePPC64_OpDiv8_0(v);
            else if (v.Op == OpDiv8u) 
                return rewriteValuePPC64_OpDiv8u_0(v);
            else if (v.Op == OpEq16) 
                return rewriteValuePPC64_OpEq16_0(v);
            else if (v.Op == OpEq32) 
                return rewriteValuePPC64_OpEq32_0(v);
            else if (v.Op == OpEq32F) 
                return rewriteValuePPC64_OpEq32F_0(v);
            else if (v.Op == OpEq64) 
                return rewriteValuePPC64_OpEq64_0(v);
            else if (v.Op == OpEq64F) 
                return rewriteValuePPC64_OpEq64F_0(v);
            else if (v.Op == OpEq8) 
                return rewriteValuePPC64_OpEq8_0(v);
            else if (v.Op == OpEqB) 
                return rewriteValuePPC64_OpEqB_0(v);
            else if (v.Op == OpEqPtr) 
                return rewriteValuePPC64_OpEqPtr_0(v);
            else if (v.Op == OpFloor) 
                return rewriteValuePPC64_OpFloor_0(v);
            else if (v.Op == OpGeq16) 
                return rewriteValuePPC64_OpGeq16_0(v);
            else if (v.Op == OpGeq16U) 
                return rewriteValuePPC64_OpGeq16U_0(v);
            else if (v.Op == OpGeq32) 
                return rewriteValuePPC64_OpGeq32_0(v);
            else if (v.Op == OpGeq32F) 
                return rewriteValuePPC64_OpGeq32F_0(v);
            else if (v.Op == OpGeq32U) 
                return rewriteValuePPC64_OpGeq32U_0(v);
            else if (v.Op == OpGeq64) 
                return rewriteValuePPC64_OpGeq64_0(v);
            else if (v.Op == OpGeq64F) 
                return rewriteValuePPC64_OpGeq64F_0(v);
            else if (v.Op == OpGeq64U) 
                return rewriteValuePPC64_OpGeq64U_0(v);
            else if (v.Op == OpGeq8) 
                return rewriteValuePPC64_OpGeq8_0(v);
            else if (v.Op == OpGeq8U) 
                return rewriteValuePPC64_OpGeq8U_0(v);
            else if (v.Op == OpGetCallerSP) 
                return rewriteValuePPC64_OpGetCallerSP_0(v);
            else if (v.Op == OpGetClosurePtr) 
                return rewriteValuePPC64_OpGetClosurePtr_0(v);
            else if (v.Op == OpGreater16) 
                return rewriteValuePPC64_OpGreater16_0(v);
            else if (v.Op == OpGreater16U) 
                return rewriteValuePPC64_OpGreater16U_0(v);
            else if (v.Op == OpGreater32) 
                return rewriteValuePPC64_OpGreater32_0(v);
            else if (v.Op == OpGreater32F) 
                return rewriteValuePPC64_OpGreater32F_0(v);
            else if (v.Op == OpGreater32U) 
                return rewriteValuePPC64_OpGreater32U_0(v);
            else if (v.Op == OpGreater64) 
                return rewriteValuePPC64_OpGreater64_0(v);
            else if (v.Op == OpGreater64F) 
                return rewriteValuePPC64_OpGreater64F_0(v);
            else if (v.Op == OpGreater64U) 
                return rewriteValuePPC64_OpGreater64U_0(v);
            else if (v.Op == OpGreater8) 
                return rewriteValuePPC64_OpGreater8_0(v);
            else if (v.Op == OpGreater8U) 
                return rewriteValuePPC64_OpGreater8U_0(v);
            else if (v.Op == OpHmul32) 
                return rewriteValuePPC64_OpHmul32_0(v);
            else if (v.Op == OpHmul32u) 
                return rewriteValuePPC64_OpHmul32u_0(v);
            else if (v.Op == OpHmul64) 
                return rewriteValuePPC64_OpHmul64_0(v);
            else if (v.Op == OpHmul64u) 
                return rewriteValuePPC64_OpHmul64u_0(v);
            else if (v.Op == OpInterCall) 
                return rewriteValuePPC64_OpInterCall_0(v);
            else if (v.Op == OpIsInBounds) 
                return rewriteValuePPC64_OpIsInBounds_0(v);
            else if (v.Op == OpIsNonNil) 
                return rewriteValuePPC64_OpIsNonNil_0(v);
            else if (v.Op == OpIsSliceInBounds) 
                return rewriteValuePPC64_OpIsSliceInBounds_0(v);
            else if (v.Op == OpLeq16) 
                return rewriteValuePPC64_OpLeq16_0(v);
            else if (v.Op == OpLeq16U) 
                return rewriteValuePPC64_OpLeq16U_0(v);
            else if (v.Op == OpLeq32) 
                return rewriteValuePPC64_OpLeq32_0(v);
            else if (v.Op == OpLeq32F) 
                return rewriteValuePPC64_OpLeq32F_0(v);
            else if (v.Op == OpLeq32U) 
                return rewriteValuePPC64_OpLeq32U_0(v);
            else if (v.Op == OpLeq64) 
                return rewriteValuePPC64_OpLeq64_0(v);
            else if (v.Op == OpLeq64F) 
                return rewriteValuePPC64_OpLeq64F_0(v);
            else if (v.Op == OpLeq64U) 
                return rewriteValuePPC64_OpLeq64U_0(v);
            else if (v.Op == OpLeq8) 
                return rewriteValuePPC64_OpLeq8_0(v);
            else if (v.Op == OpLeq8U) 
                return rewriteValuePPC64_OpLeq8U_0(v);
            else if (v.Op == OpLess16) 
                return rewriteValuePPC64_OpLess16_0(v);
            else if (v.Op == OpLess16U) 
                return rewriteValuePPC64_OpLess16U_0(v);
            else if (v.Op == OpLess32) 
                return rewriteValuePPC64_OpLess32_0(v);
            else if (v.Op == OpLess32F) 
                return rewriteValuePPC64_OpLess32F_0(v);
            else if (v.Op == OpLess32U) 
                return rewriteValuePPC64_OpLess32U_0(v);
            else if (v.Op == OpLess64) 
                return rewriteValuePPC64_OpLess64_0(v);
            else if (v.Op == OpLess64F) 
                return rewriteValuePPC64_OpLess64F_0(v);
            else if (v.Op == OpLess64U) 
                return rewriteValuePPC64_OpLess64U_0(v);
            else if (v.Op == OpLess8) 
                return rewriteValuePPC64_OpLess8_0(v);
            else if (v.Op == OpLess8U) 
                return rewriteValuePPC64_OpLess8U_0(v);
            else if (v.Op == OpLoad) 
                return rewriteValuePPC64_OpLoad_0(v);
            else if (v.Op == OpLsh16x16) 
                return rewriteValuePPC64_OpLsh16x16_0(v);
            else if (v.Op == OpLsh16x32) 
                return rewriteValuePPC64_OpLsh16x32_0(v);
            else if (v.Op == OpLsh16x64) 
                return rewriteValuePPC64_OpLsh16x64_0(v);
            else if (v.Op == OpLsh16x8) 
                return rewriteValuePPC64_OpLsh16x8_0(v);
            else if (v.Op == OpLsh32x16) 
                return rewriteValuePPC64_OpLsh32x16_0(v);
            else if (v.Op == OpLsh32x32) 
                return rewriteValuePPC64_OpLsh32x32_0(v);
            else if (v.Op == OpLsh32x64) 
                return rewriteValuePPC64_OpLsh32x64_0(v);
            else if (v.Op == OpLsh32x8) 
                return rewriteValuePPC64_OpLsh32x8_0(v);
            else if (v.Op == OpLsh64x16) 
                return rewriteValuePPC64_OpLsh64x16_0(v);
            else if (v.Op == OpLsh64x32) 
                return rewriteValuePPC64_OpLsh64x32_0(v);
            else if (v.Op == OpLsh64x64) 
                return rewriteValuePPC64_OpLsh64x64_0(v);
            else if (v.Op == OpLsh64x8) 
                return rewriteValuePPC64_OpLsh64x8_0(v);
            else if (v.Op == OpLsh8x16) 
                return rewriteValuePPC64_OpLsh8x16_0(v);
            else if (v.Op == OpLsh8x32) 
                return rewriteValuePPC64_OpLsh8x32_0(v);
            else if (v.Op == OpLsh8x64) 
                return rewriteValuePPC64_OpLsh8x64_0(v);
            else if (v.Op == OpLsh8x8) 
                return rewriteValuePPC64_OpLsh8x8_0(v);
            else if (v.Op == OpMod16) 
                return rewriteValuePPC64_OpMod16_0(v);
            else if (v.Op == OpMod16u) 
                return rewriteValuePPC64_OpMod16u_0(v);
            else if (v.Op == OpMod32) 
                return rewriteValuePPC64_OpMod32_0(v);
            else if (v.Op == OpMod32u) 
                return rewriteValuePPC64_OpMod32u_0(v);
            else if (v.Op == OpMod64) 
                return rewriteValuePPC64_OpMod64_0(v);
            else if (v.Op == OpMod64u) 
                return rewriteValuePPC64_OpMod64u_0(v);
            else if (v.Op == OpMod8) 
                return rewriteValuePPC64_OpMod8_0(v);
            else if (v.Op == OpMod8u) 
                return rewriteValuePPC64_OpMod8u_0(v);
            else if (v.Op == OpMove) 
                return rewriteValuePPC64_OpMove_0(v) || rewriteValuePPC64_OpMove_10(v);
            else if (v.Op == OpMul16) 
                return rewriteValuePPC64_OpMul16_0(v);
            else if (v.Op == OpMul32) 
                return rewriteValuePPC64_OpMul32_0(v);
            else if (v.Op == OpMul32F) 
                return rewriteValuePPC64_OpMul32F_0(v);
            else if (v.Op == OpMul64) 
                return rewriteValuePPC64_OpMul64_0(v);
            else if (v.Op == OpMul64F) 
                return rewriteValuePPC64_OpMul64F_0(v);
            else if (v.Op == OpMul8) 
                return rewriteValuePPC64_OpMul8_0(v);
            else if (v.Op == OpNeg16) 
                return rewriteValuePPC64_OpNeg16_0(v);
            else if (v.Op == OpNeg32) 
                return rewriteValuePPC64_OpNeg32_0(v);
            else if (v.Op == OpNeg32F) 
                return rewriteValuePPC64_OpNeg32F_0(v);
            else if (v.Op == OpNeg64) 
                return rewriteValuePPC64_OpNeg64_0(v);
            else if (v.Op == OpNeg64F) 
                return rewriteValuePPC64_OpNeg64F_0(v);
            else if (v.Op == OpNeg8) 
                return rewriteValuePPC64_OpNeg8_0(v);
            else if (v.Op == OpNeq16) 
                return rewriteValuePPC64_OpNeq16_0(v);
            else if (v.Op == OpNeq32) 
                return rewriteValuePPC64_OpNeq32_0(v);
            else if (v.Op == OpNeq32F) 
                return rewriteValuePPC64_OpNeq32F_0(v);
            else if (v.Op == OpNeq64) 
                return rewriteValuePPC64_OpNeq64_0(v);
            else if (v.Op == OpNeq64F) 
                return rewriteValuePPC64_OpNeq64F_0(v);
            else if (v.Op == OpNeq8) 
                return rewriteValuePPC64_OpNeq8_0(v);
            else if (v.Op == OpNeqB) 
                return rewriteValuePPC64_OpNeqB_0(v);
            else if (v.Op == OpNeqPtr) 
                return rewriteValuePPC64_OpNeqPtr_0(v);
            else if (v.Op == OpNilCheck) 
                return rewriteValuePPC64_OpNilCheck_0(v);
            else if (v.Op == OpNot) 
                return rewriteValuePPC64_OpNot_0(v);
            else if (v.Op == OpOffPtr) 
                return rewriteValuePPC64_OpOffPtr_0(v);
            else if (v.Op == OpOr16) 
                return rewriteValuePPC64_OpOr16_0(v);
            else if (v.Op == OpOr32) 
                return rewriteValuePPC64_OpOr32_0(v);
            else if (v.Op == OpOr64) 
                return rewriteValuePPC64_OpOr64_0(v);
            else if (v.Op == OpOr8) 
                return rewriteValuePPC64_OpOr8_0(v);
            else if (v.Op == OpOrB) 
                return rewriteValuePPC64_OpOrB_0(v);
            else if (v.Op == OpPPC64ADD) 
                return rewriteValuePPC64_OpPPC64ADD_0(v);
            else if (v.Op == OpPPC64ADDconst) 
                return rewriteValuePPC64_OpPPC64ADDconst_0(v);
            else if (v.Op == OpPPC64AND) 
                return rewriteValuePPC64_OpPPC64AND_0(v);
            else if (v.Op == OpPPC64ANDconst) 
                return rewriteValuePPC64_OpPPC64ANDconst_0(v);
            else if (v.Op == OpPPC64CMP) 
                return rewriteValuePPC64_OpPPC64CMP_0(v);
            else if (v.Op == OpPPC64CMPU) 
                return rewriteValuePPC64_OpPPC64CMPU_0(v);
            else if (v.Op == OpPPC64CMPUconst) 
                return rewriteValuePPC64_OpPPC64CMPUconst_0(v);
            else if (v.Op == OpPPC64CMPW) 
                return rewriteValuePPC64_OpPPC64CMPW_0(v);
            else if (v.Op == OpPPC64CMPWU) 
                return rewriteValuePPC64_OpPPC64CMPWU_0(v);
            else if (v.Op == OpPPC64CMPWUconst) 
                return rewriteValuePPC64_OpPPC64CMPWUconst_0(v);
            else if (v.Op == OpPPC64CMPWconst) 
                return rewriteValuePPC64_OpPPC64CMPWconst_0(v);
            else if (v.Op == OpPPC64CMPconst) 
                return rewriteValuePPC64_OpPPC64CMPconst_0(v);
            else if (v.Op == OpPPC64Equal) 
                return rewriteValuePPC64_OpPPC64Equal_0(v);
            else if (v.Op == OpPPC64FABS) 
                return rewriteValuePPC64_OpPPC64FABS_0(v);
            else if (v.Op == OpPPC64FADD) 
                return rewriteValuePPC64_OpPPC64FADD_0(v);
            else if (v.Op == OpPPC64FADDS) 
                return rewriteValuePPC64_OpPPC64FADDS_0(v);
            else if (v.Op == OpPPC64FCEIL) 
                return rewriteValuePPC64_OpPPC64FCEIL_0(v);
            else if (v.Op == OpPPC64FFLOOR) 
                return rewriteValuePPC64_OpPPC64FFLOOR_0(v);
            else if (v.Op == OpPPC64FMOVDload) 
                return rewriteValuePPC64_OpPPC64FMOVDload_0(v);
            else if (v.Op == OpPPC64FMOVDstore) 
                return rewriteValuePPC64_OpPPC64FMOVDstore_0(v);
            else if (v.Op == OpPPC64FMOVSload) 
                return rewriteValuePPC64_OpPPC64FMOVSload_0(v);
            else if (v.Op == OpPPC64FMOVSstore) 
                return rewriteValuePPC64_OpPPC64FMOVSstore_0(v);
            else if (v.Op == OpPPC64FNEG) 
                return rewriteValuePPC64_OpPPC64FNEG_0(v);
            else if (v.Op == OpPPC64FSQRT) 
                return rewriteValuePPC64_OpPPC64FSQRT_0(v);
            else if (v.Op == OpPPC64FSUB) 
                return rewriteValuePPC64_OpPPC64FSUB_0(v);
            else if (v.Op == OpPPC64FSUBS) 
                return rewriteValuePPC64_OpPPC64FSUBS_0(v);
            else if (v.Op == OpPPC64FTRUNC) 
                return rewriteValuePPC64_OpPPC64FTRUNC_0(v);
            else if (v.Op == OpPPC64GreaterEqual) 
                return rewriteValuePPC64_OpPPC64GreaterEqual_0(v);
            else if (v.Op == OpPPC64GreaterThan) 
                return rewriteValuePPC64_OpPPC64GreaterThan_0(v);
            else if (v.Op == OpPPC64LessEqual) 
                return rewriteValuePPC64_OpPPC64LessEqual_0(v);
            else if (v.Op == OpPPC64LessThan) 
                return rewriteValuePPC64_OpPPC64LessThan_0(v);
            else if (v.Op == OpPPC64MFVSRD) 
                return rewriteValuePPC64_OpPPC64MFVSRD_0(v);
            else if (v.Op == OpPPC64MOVBZload) 
                return rewriteValuePPC64_OpPPC64MOVBZload_0(v);
            else if (v.Op == OpPPC64MOVBZreg) 
                return rewriteValuePPC64_OpPPC64MOVBZreg_0(v);
            else if (v.Op == OpPPC64MOVBreg) 
                return rewriteValuePPC64_OpPPC64MOVBreg_0(v);
            else if (v.Op == OpPPC64MOVBstore) 
                return rewriteValuePPC64_OpPPC64MOVBstore_0(v);
            else if (v.Op == OpPPC64MOVBstorezero) 
                return rewriteValuePPC64_OpPPC64MOVBstorezero_0(v);
            else if (v.Op == OpPPC64MOVDload) 
                return rewriteValuePPC64_OpPPC64MOVDload_0(v);
            else if (v.Op == OpPPC64MOVDstore) 
                return rewriteValuePPC64_OpPPC64MOVDstore_0(v);
            else if (v.Op == OpPPC64MOVDstorezero) 
                return rewriteValuePPC64_OpPPC64MOVDstorezero_0(v);
            else if (v.Op == OpPPC64MOVHZload) 
                return rewriteValuePPC64_OpPPC64MOVHZload_0(v);
            else if (v.Op == OpPPC64MOVHZreg) 
                return rewriteValuePPC64_OpPPC64MOVHZreg_0(v);
            else if (v.Op == OpPPC64MOVHload) 
                return rewriteValuePPC64_OpPPC64MOVHload_0(v);
            else if (v.Op == OpPPC64MOVHreg) 
                return rewriteValuePPC64_OpPPC64MOVHreg_0(v);
            else if (v.Op == OpPPC64MOVHstore) 
                return rewriteValuePPC64_OpPPC64MOVHstore_0(v);
            else if (v.Op == OpPPC64MOVHstorezero) 
                return rewriteValuePPC64_OpPPC64MOVHstorezero_0(v);
            else if (v.Op == OpPPC64MOVWZload) 
                return rewriteValuePPC64_OpPPC64MOVWZload_0(v);
            else if (v.Op == OpPPC64MOVWZreg) 
                return rewriteValuePPC64_OpPPC64MOVWZreg_0(v);
            else if (v.Op == OpPPC64MOVWload) 
                return rewriteValuePPC64_OpPPC64MOVWload_0(v);
            else if (v.Op == OpPPC64MOVWreg) 
                return rewriteValuePPC64_OpPPC64MOVWreg_0(v);
            else if (v.Op == OpPPC64MOVWstore) 
                return rewriteValuePPC64_OpPPC64MOVWstore_0(v);
            else if (v.Op == OpPPC64MOVWstorezero) 
                return rewriteValuePPC64_OpPPC64MOVWstorezero_0(v);
            else if (v.Op == OpPPC64MTVSRD) 
                return rewriteValuePPC64_OpPPC64MTVSRD_0(v);
            else if (v.Op == OpPPC64MaskIfNotCarry) 
                return rewriteValuePPC64_OpPPC64MaskIfNotCarry_0(v);
            else if (v.Op == OpPPC64NotEqual) 
                return rewriteValuePPC64_OpPPC64NotEqual_0(v);
            else if (v.Op == OpPPC64OR) 
                return rewriteValuePPC64_OpPPC64OR_0(v) || rewriteValuePPC64_OpPPC64OR_10(v) || rewriteValuePPC64_OpPPC64OR_20(v) || rewriteValuePPC64_OpPPC64OR_30(v) || rewriteValuePPC64_OpPPC64OR_40(v) || rewriteValuePPC64_OpPPC64OR_50(v) || rewriteValuePPC64_OpPPC64OR_60(v) || rewriteValuePPC64_OpPPC64OR_70(v) || rewriteValuePPC64_OpPPC64OR_80(v) || rewriteValuePPC64_OpPPC64OR_90(v) || rewriteValuePPC64_OpPPC64OR_100(v) || rewriteValuePPC64_OpPPC64OR_110(v) || rewriteValuePPC64_OpPPC64OR_120(v) || rewriteValuePPC64_OpPPC64OR_130(v) || rewriteValuePPC64_OpPPC64OR_140(v);
            else if (v.Op == OpPPC64ORN) 
                return rewriteValuePPC64_OpPPC64ORN_0(v);
            else if (v.Op == OpPPC64ORconst) 
                return rewriteValuePPC64_OpPPC64ORconst_0(v);
            else if (v.Op == OpPPC64SUB) 
                return rewriteValuePPC64_OpPPC64SUB_0(v);
            else if (v.Op == OpPPC64XOR) 
                return rewriteValuePPC64_OpPPC64XOR_0(v) || rewriteValuePPC64_OpPPC64XOR_10(v);
            else if (v.Op == OpPPC64XORconst) 
                return rewriteValuePPC64_OpPPC64XORconst_0(v);
            else if (v.Op == OpPopCount16) 
                return rewriteValuePPC64_OpPopCount16_0(v);
            else if (v.Op == OpPopCount32) 
                return rewriteValuePPC64_OpPopCount32_0(v);
            else if (v.Op == OpPopCount64) 
                return rewriteValuePPC64_OpPopCount64_0(v);
            else if (v.Op == OpPopCount8) 
                return rewriteValuePPC64_OpPopCount8_0(v);
            else if (v.Op == OpRound32F) 
                return rewriteValuePPC64_OpRound32F_0(v);
            else if (v.Op == OpRound64F) 
                return rewriteValuePPC64_OpRound64F_0(v);
            else if (v.Op == OpRsh16Ux16) 
                return rewriteValuePPC64_OpRsh16Ux16_0(v);
            else if (v.Op == OpRsh16Ux32) 
                return rewriteValuePPC64_OpRsh16Ux32_0(v);
            else if (v.Op == OpRsh16Ux64) 
                return rewriteValuePPC64_OpRsh16Ux64_0(v);
            else if (v.Op == OpRsh16Ux8) 
                return rewriteValuePPC64_OpRsh16Ux8_0(v);
            else if (v.Op == OpRsh16x16) 
                return rewriteValuePPC64_OpRsh16x16_0(v);
            else if (v.Op == OpRsh16x32) 
                return rewriteValuePPC64_OpRsh16x32_0(v);
            else if (v.Op == OpRsh16x64) 
                return rewriteValuePPC64_OpRsh16x64_0(v);
            else if (v.Op == OpRsh16x8) 
                return rewriteValuePPC64_OpRsh16x8_0(v);
            else if (v.Op == OpRsh32Ux16) 
                return rewriteValuePPC64_OpRsh32Ux16_0(v);
            else if (v.Op == OpRsh32Ux32) 
                return rewriteValuePPC64_OpRsh32Ux32_0(v);
            else if (v.Op == OpRsh32Ux64) 
                return rewriteValuePPC64_OpRsh32Ux64_0(v);
            else if (v.Op == OpRsh32Ux8) 
                return rewriteValuePPC64_OpRsh32Ux8_0(v);
            else if (v.Op == OpRsh32x16) 
                return rewriteValuePPC64_OpRsh32x16_0(v);
            else if (v.Op == OpRsh32x32) 
                return rewriteValuePPC64_OpRsh32x32_0(v);
            else if (v.Op == OpRsh32x64) 
                return rewriteValuePPC64_OpRsh32x64_0(v);
            else if (v.Op == OpRsh32x8) 
                return rewriteValuePPC64_OpRsh32x8_0(v);
            else if (v.Op == OpRsh64Ux16) 
                return rewriteValuePPC64_OpRsh64Ux16_0(v);
            else if (v.Op == OpRsh64Ux32) 
                return rewriteValuePPC64_OpRsh64Ux32_0(v);
            else if (v.Op == OpRsh64Ux64) 
                return rewriteValuePPC64_OpRsh64Ux64_0(v);
            else if (v.Op == OpRsh64Ux8) 
                return rewriteValuePPC64_OpRsh64Ux8_0(v);
            else if (v.Op == OpRsh64x16) 
                return rewriteValuePPC64_OpRsh64x16_0(v);
            else if (v.Op == OpRsh64x32) 
                return rewriteValuePPC64_OpRsh64x32_0(v);
            else if (v.Op == OpRsh64x64) 
                return rewriteValuePPC64_OpRsh64x64_0(v);
            else if (v.Op == OpRsh64x8) 
                return rewriteValuePPC64_OpRsh64x8_0(v);
            else if (v.Op == OpRsh8Ux16) 
                return rewriteValuePPC64_OpRsh8Ux16_0(v);
            else if (v.Op == OpRsh8Ux32) 
                return rewriteValuePPC64_OpRsh8Ux32_0(v);
            else if (v.Op == OpRsh8Ux64) 
                return rewriteValuePPC64_OpRsh8Ux64_0(v);
            else if (v.Op == OpRsh8Ux8) 
                return rewriteValuePPC64_OpRsh8Ux8_0(v);
            else if (v.Op == OpRsh8x16) 
                return rewriteValuePPC64_OpRsh8x16_0(v);
            else if (v.Op == OpRsh8x32) 
                return rewriteValuePPC64_OpRsh8x32_0(v);
            else if (v.Op == OpRsh8x64) 
                return rewriteValuePPC64_OpRsh8x64_0(v);
            else if (v.Op == OpRsh8x8) 
                return rewriteValuePPC64_OpRsh8x8_0(v);
            else if (v.Op == OpSignExt16to32) 
                return rewriteValuePPC64_OpSignExt16to32_0(v);
            else if (v.Op == OpSignExt16to64) 
                return rewriteValuePPC64_OpSignExt16to64_0(v);
            else if (v.Op == OpSignExt32to64) 
                return rewriteValuePPC64_OpSignExt32to64_0(v);
            else if (v.Op == OpSignExt8to16) 
                return rewriteValuePPC64_OpSignExt8to16_0(v);
            else if (v.Op == OpSignExt8to32) 
                return rewriteValuePPC64_OpSignExt8to32_0(v);
            else if (v.Op == OpSignExt8to64) 
                return rewriteValuePPC64_OpSignExt8to64_0(v);
            else if (v.Op == OpSlicemask) 
                return rewriteValuePPC64_OpSlicemask_0(v);
            else if (v.Op == OpSqrt) 
                return rewriteValuePPC64_OpSqrt_0(v);
            else if (v.Op == OpStaticCall) 
                return rewriteValuePPC64_OpStaticCall_0(v);
            else if (v.Op == OpStore) 
                return rewriteValuePPC64_OpStore_0(v);
            else if (v.Op == OpSub16) 
                return rewriteValuePPC64_OpSub16_0(v);
            else if (v.Op == OpSub32) 
                return rewriteValuePPC64_OpSub32_0(v);
            else if (v.Op == OpSub32F) 
                return rewriteValuePPC64_OpSub32F_0(v);
            else if (v.Op == OpSub64) 
                return rewriteValuePPC64_OpSub64_0(v);
            else if (v.Op == OpSub64F) 
                return rewriteValuePPC64_OpSub64F_0(v);
            else if (v.Op == OpSub8) 
                return rewriteValuePPC64_OpSub8_0(v);
            else if (v.Op == OpSubPtr) 
                return rewriteValuePPC64_OpSubPtr_0(v);
            else if (v.Op == OpTrunc) 
                return rewriteValuePPC64_OpTrunc_0(v);
            else if (v.Op == OpTrunc16to8) 
                return rewriteValuePPC64_OpTrunc16to8_0(v);
            else if (v.Op == OpTrunc32to16) 
                return rewriteValuePPC64_OpTrunc32to16_0(v);
            else if (v.Op == OpTrunc32to8) 
                return rewriteValuePPC64_OpTrunc32to8_0(v);
            else if (v.Op == OpTrunc64to16) 
                return rewriteValuePPC64_OpTrunc64to16_0(v);
            else if (v.Op == OpTrunc64to32) 
                return rewriteValuePPC64_OpTrunc64to32_0(v);
            else if (v.Op == OpTrunc64to8) 
                return rewriteValuePPC64_OpTrunc64to8_0(v);
            else if (v.Op == OpXor16) 
                return rewriteValuePPC64_OpXor16_0(v);
            else if (v.Op == OpXor32) 
                return rewriteValuePPC64_OpXor32_0(v);
            else if (v.Op == OpXor64) 
                return rewriteValuePPC64_OpXor64_0(v);
            else if (v.Op == OpXor8) 
                return rewriteValuePPC64_OpXor8_0(v);
            else if (v.Op == OpZero) 
                return rewriteValuePPC64_OpZero_0(v) || rewriteValuePPC64_OpZero_10(v);
            else if (v.Op == OpZeroExt16to32) 
                return rewriteValuePPC64_OpZeroExt16to32_0(v);
            else if (v.Op == OpZeroExt16to64) 
                return rewriteValuePPC64_OpZeroExt16to64_0(v);
            else if (v.Op == OpZeroExt32to64) 
                return rewriteValuePPC64_OpZeroExt32to64_0(v);
            else if (v.Op == OpZeroExt8to16) 
                return rewriteValuePPC64_OpZeroExt8to16_0(v);
            else if (v.Op == OpZeroExt8to32) 
                return rewriteValuePPC64_OpZeroExt8to32_0(v);
            else if (v.Op == OpZeroExt8to64) 
                return rewriteValuePPC64_OpZeroExt8to64_0(v);
                        return false;
        }
        private static bool rewriteValuePPC64_OpAbs_0(ref Value v)
        { 
            // match: (Abs x)
            // cond:
            // result: (FABS x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FABS);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd16_0(ref Value v)
        { 
            // match: (Add16 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd32_0(ref Value v)
        { 
            // match: (Add32 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd32F_0(ref Value v)
        { 
            // match: (Add32F x y)
            // cond:
            // result: (FADDS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FADDS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd64_0(ref Value v)
        { 
            // match: (Add64 x y)
            // cond:
            // result: (ADD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd64F_0(ref Value v)
        { 
            // match: (Add64F x y)
            // cond:
            // result: (FADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAdd8_0(ref Value v)
        { 
            // match: (Add8 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAddPtr_0(ref Value v)
        { 
            // match: (AddPtr x y)
            // cond:
            // result: (ADD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAddr_0(ref Value v)
        { 
            // match: (Addr {sym} base)
            // cond:
            // result: (MOVDaddr {sym} base)
            while (true)
            {
                var sym = v.Aux;
                var @base = v.Args[0L];
                v.reset(OpPPC64MOVDaddr);
                v.Aux = sym;
                v.AddArg(base);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAnd16_0(ref Value v)
        { 
            // match: (And16 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64AND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAnd32_0(ref Value v)
        { 
            // match: (And32 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64AND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAnd64_0(ref Value v)
        { 
            // match: (And64 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64AND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAnd8_0(ref Value v)
        { 
            // match: (And8 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64AND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAndB_0(ref Value v)
        { 
            // match: (AndB x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64AND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicAdd32_0(ref Value v)
        { 
            // match: (AtomicAdd32 ptr val mem)
            // cond:
            // result: (LoweredAtomicAdd32 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicAdd32);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicAdd64_0(ref Value v)
        { 
            // match: (AtomicAdd64 ptr val mem)
            // cond:
            // result: (LoweredAtomicAdd64 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicAdd64);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicAnd8_0(ref Value v)
        { 
            // match: (AtomicAnd8 ptr val mem)
            // cond:
            // result: (LoweredAtomicAnd8 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicAnd8);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicCompareAndSwap32_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap32 ptr old new_ mem)
            // cond:
            // result: (LoweredAtomicCas32 ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpPPC64LoweredAtomicCas32);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicCompareAndSwap64_0(ref Value v)
        { 
            // match: (AtomicCompareAndSwap64 ptr old new_ mem)
            // cond:
            // result: (LoweredAtomicCas64 ptr old new_ mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var old = v.Args[1L];
                var new_ = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpPPC64LoweredAtomicCas64);
                v.AddArg(ptr);
                v.AddArg(old);
                v.AddArg(new_);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicExchange32_0(ref Value v)
        { 
            // match: (AtomicExchange32 ptr val mem)
            // cond:
            // result: (LoweredAtomicExchange32 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicExchange32);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicExchange64_0(ref Value v)
        { 
            // match: (AtomicExchange64 ptr val mem)
            // cond:
            // result: (LoweredAtomicExchange64 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicExchange64);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicLoad32_0(ref Value v)
        { 
            // match: (AtomicLoad32 ptr mem)
            // cond:
            // result: (LoweredAtomicLoad32 ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64LoweredAtomicLoad32);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicLoad64_0(ref Value v)
        { 
            // match: (AtomicLoad64 ptr mem)
            // cond:
            // result: (LoweredAtomicLoad64 ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64LoweredAtomicLoad64);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicLoadPtr_0(ref Value v)
        { 
            // match: (AtomicLoadPtr ptr mem)
            // cond:
            // result: (LoweredAtomicLoadPtr ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64LoweredAtomicLoadPtr);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicOr8_0(ref Value v)
        { 
            // match: (AtomicOr8 ptr val mem)
            // cond:
            // result: (LoweredAtomicOr8  ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicOr8);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicStore32_0(ref Value v)
        { 
            // match: (AtomicStore32 ptr val mem)
            // cond:
            // result: (LoweredAtomicStore32 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicStore32);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAtomicStore64_0(ref Value v)
        { 
            // match: (AtomicStore64 ptr val mem)
            // cond:
            // result: (LoweredAtomicStore64 ptr val mem)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64LoweredAtomicStore64);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpAvg64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Avg64u <t> x y)
            // cond:
            // result: (ADD (SRDconst <t> (SUB <t> x y) [1]) y)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ADD);
                var v0 = b.NewValue0(v.Pos, OpPPC64SRDconst, t);
                v0.AuxInt = 1L;
                var v1 = b.NewValue0(v.Pos, OpPPC64SUB, t);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpBitLen32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (BitLen32 x)
            // cond:
            // result: (SUB (MOVDconst [32]) (CNTLZW <typ.Int> x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64SUB);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v0.AuxInt = 32L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64CNTLZW, typ.Int);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpBitLen64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (BitLen64 x)
            // cond:
            // result: (SUB (MOVDconst [64]) (CNTLZD <typ.Int> x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64SUB);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v0.AuxInt = 64L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64CNTLZD, typ.Int);
                v1.AddArg(x);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCeil_0(ref Value v)
        { 
            // match: (Ceil x)
            // cond:
            // result: (FCEIL x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FCEIL);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpClosureCall_0(ref Value v)
        { 
            // match: (ClosureCall [argwid] entry closure mem)
            // cond:
            // result: (CALLclosure [argwid] entry closure mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[2L];
                var entry = v.Args[0L];
                var closure = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpPPC64CALLclosure);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(closure);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCom16_0(ref Value v)
        { 
            // match: (Com16 x)
            // cond:
            // result: (NOR x x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NOR);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCom32_0(ref Value v)
        { 
            // match: (Com32 x)
            // cond:
            // result: (NOR x x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NOR);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCom64_0(ref Value v)
        { 
            // match: (Com64 x)
            // cond:
            // result: (NOR x x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NOR);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCom8_0(ref Value v)
        { 
            // match: (Com8 x)
            // cond:
            // result: (NOR x x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NOR);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst16_0(ref Value v)
        { 
            // match: (Const16 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst32_0(ref Value v)
        { 
            // match: (Const32 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst32F_0(ref Value v)
        { 
            // match: (Const32F [val])
            // cond:
            // result: (FMOVSconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64FMOVSconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst64_0(ref Value v)
        { 
            // match: (Const64 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst64F_0(ref Value v)
        { 
            // match: (Const64F [val])
            // cond:
            // result: (FMOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConst8_0(ref Value v)
        { 
            // match: (Const8 [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConstBool_0(ref Value v)
        { 
            // match: (ConstBool [b])
            // cond:
            // result: (MOVDconst [b])
            while (true)
            {
                var b = v.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = b;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConstNil_0(ref Value v)
        { 
            // match: (ConstNil)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpConvert_0(ref Value v)
        { 
            // match: (Convert <t> x mem)
            // cond:
            // result: (MOVDconvert <t> x mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64MOVDconvert);
                v.Type = t;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCopysign_0(ref Value v)
        { 
            // match: (Copysign x y)
            // cond:
            // result: (FCPSGN y x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FCPSGN);
                v.AddArg(y);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCtz32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz32 x)
            // cond:
            // result: (POPCNTW (MOVWZreg (ANDN <typ.Int> (ADDconst <typ.Int> [-1] x) x)))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTW);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVWZreg, typ.Int64);
                var v1 = b.NewValue0(v.Pos, OpPPC64ANDN, typ.Int);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconst, typ.Int);
                v2.AuxInt = -1L;
                v2.AddArg(x);
                v1.AddArg(v2);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCtz64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Ctz64 x)
            // cond:
            // result: (POPCNTD (ANDN <typ.Int64> (ADDconst <typ.Int64> [-1] x) x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTD);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDN, typ.Int64);
                var v1 = b.NewValue0(v.Pos, OpPPC64ADDconst, typ.Int64);
                v1.AuxInt = -1L;
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt32Fto32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt32Fto32 x)
            // cond:
            // result: (MFVSRD (FCTIWZ x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MFVSRD);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCTIWZ, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt32Fto64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt32Fto64 x)
            // cond:
            // result: (MFVSRD (FCTIDZ x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MFVSRD);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCTIDZ, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt32Fto64F_0(ref Value v)
        { 
            // match: (Cvt32Fto64F x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt32to32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt32to32F x)
            // cond:
            // result: (FCFIDS (MTVSRD (SignExt32to64 x)))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FCFIDS);
                var v0 = b.NewValue0(v.Pos, OpPPC64MTVSRD, typ.Float64);
                var v1 = b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt32to64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt32to64F x)
            // cond:
            // result: (FCFID (MTVSRD (SignExt32to64 x)))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FCFID);
                var v0 = b.NewValue0(v.Pos, OpPPC64MTVSRD, typ.Float64);
                var v1 = b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt64Fto32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt64Fto32 x)
            // cond:
            // result: (MFVSRD (FCTIWZ x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MFVSRD);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCTIWZ, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt64Fto32F_0(ref Value v)
        { 
            // match: (Cvt64Fto32F x)
            // cond:
            // result: (FRSP x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FRSP);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt64Fto64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt64Fto64 x)
            // cond:
            // result: (MFVSRD (FCTIDZ x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MFVSRD);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCTIDZ, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt64to32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt64to32F x)
            // cond:
            // result: (FCFIDS (MTVSRD x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FCFIDS);
                var v0 = b.NewValue0(v.Pos, OpPPC64MTVSRD, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpCvt64to64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Cvt64to64F x)
            // cond:
            // result: (FCFID (MTVSRD x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FCFID);
                var v0 = b.NewValue0(v.Pos, OpPPC64MTVSRD, typ.Float64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16 x y)
            // cond:
            // result: (DIVW  (SignExt16to32 x) (SignExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVW);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16u x y)
            // cond:
            // result: (DIVWU (ZeroExt16to32 x) (ZeroExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVWU);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv32_0(ref Value v)
        { 
            // match: (Div32 x y)
            // cond:
            // result: (DIVW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv32F_0(ref Value v)
        { 
            // match: (Div32F x y)
            // cond:
            // result: (FDIVS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FDIVS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv32u_0(ref Value v)
        { 
            // match: (Div32u x y)
            // cond:
            // result: (DIVWU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVWU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv64_0(ref Value v)
        { 
            // match: (Div64 x y)
            // cond:
            // result: (DIVD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv64F_0(ref Value v)
        { 
            // match: (Div64F x y)
            // cond:
            // result: (FDIV x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FDIV);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv64u_0(ref Value v)
        { 
            // match: (Div64u x y)
            // cond:
            // result: (DIVDU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVDU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8 x y)
            // cond:
            // result: (DIVW  (SignExt8to32 x) (SignExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVW);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpDiv8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8u x y)
            // cond:
            // result: (DIVWU (ZeroExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64DIVWU);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq16 x y)
            // cond: isSigned(x.Type) && isSigned(y.Type)
            // result: (Equal (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(isSigned(x.Type) && isSigned(y.Type)))
                {
                    break;
                }
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Eq16 x y)
            // cond:
            // result: (Equal (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
 
            // match: (Eq16 x y)
            // cond:
            // result: (Equal (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64Equal);
                v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32 x y)
            // cond:
            // result: (Equal (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32F x y)
            // cond:
            // result: (Equal (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64 x y)
            // cond:
            // result: (Equal (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64F x y)
            // cond:
            // result: (Equal (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq8 x y)
            // cond: isSigned(x.Type) && isSigned(y.Type)
            // result: (Equal (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(isSigned(x.Type) && isSigned(y.Type)))
                {
                    break;
                }
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Eq8 x y)
            // cond:
            // result: (Equal (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
 
            // match: (Eq8 x y)
            // cond:
            // result: (Equal (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64Equal);
                v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqB x y)
            // cond:
            // result: (ANDconst [1] (EQV x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = 1L;
                var v0 = b.NewValue0(v.Pos, OpPPC64EQV, typ.Int64);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpEqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (EqPtr x y)
            // cond:
            // result: (Equal (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64Equal);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpFloor_0(ref Value v)
        { 
            // match: (Floor x)
            // cond:
            // result: (FFLOOR x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FFLOOR);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16 x y)
            // cond:
            // result: (GreaterEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16U x y)
            // cond:
            // result: (GreaterEqual (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32 x y)
            // cond:
            // result: (GreaterEqual (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32F x y)
            // cond:
            // result: (FGreaterEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32U x y)
            // cond:
            // result: (GreaterEqual (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64 x y)
            // cond:
            // result: (GreaterEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64F x y)
            // cond:
            // result: (FGreaterEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64U x y)
            // cond:
            // result: (GreaterEqual (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8 x y)
            // cond:
            // result: (GreaterEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8U x y)
            // cond:
            // result: (GreaterEqual (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGetCallerSP_0(ref Value v)
        { 
            // match: (GetCallerSP)
            // cond:
            // result: (LoweredGetCallerSP)
            while (true)
            {
                v.reset(OpPPC64LoweredGetCallerSP);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGetClosurePtr_0(ref Value v)
        { 
            // match: (GetClosurePtr)
            // cond:
            // result: (LoweredGetClosurePtr)
            while (true)
            {
                v.reset(OpPPC64LoweredGetClosurePtr);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16 x y)
            // cond:
            // result: (GreaterThan (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16U x y)
            // cond:
            // result: (GreaterThan (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32 x y)
            // cond:
            // result: (GreaterThan (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32F x y)
            // cond:
            // result: (FGreaterThan (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32U x y)
            // cond:
            // result: (GreaterThan (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64 x y)
            // cond:
            // result: (GreaterThan (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64F x y)
            // cond:
            // result: (FGreaterThan (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64U x y)
            // cond:
            // result: (GreaterThan (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8 x y)
            // cond:
            // result: (GreaterThan (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpGreater8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8U x y)
            // cond:
            // result: (GreaterThan (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64GreaterThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpHmul32_0(ref Value v)
        { 
            // match: (Hmul32 x y)
            // cond:
            // result: (MULHW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULHW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpHmul32u_0(ref Value v)
        { 
            // match: (Hmul32u x y)
            // cond:
            // result: (MULHWU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULHWU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpHmul64_0(ref Value v)
        { 
            // match: (Hmul64 x y)
            // cond:
            // result: (MULHD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULHD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpHmul64u_0(ref Value v)
        { 
            // match: (Hmul64u x y)
            // cond:
            // result: (MULHDU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULHDU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpInterCall_0(ref Value v)
        { 
            // match: (InterCall [argwid] entry mem)
            // cond:
            // result: (CALLinter [argwid] entry mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[1L];
                var entry = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64CALLinter);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpIsInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsInBounds idx len)
            // cond:
            // result: (LessThan (CMPU idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpIsNonNil_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsNonNil ptr)
            // cond:
            // result: (NotEqual (CMPconst [0] ptr))
            while (true)
            {
                var ptr = v.Args[0L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPconst, types.TypeFlags);
                v0.AuxInt = 0L;
                v0.AddArg(ptr);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpIsSliceInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsSliceInBounds idx len)
            // cond:
            // result: (LessEqual (CMPU idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16 x y)
            // cond:
            // result: (LessEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16U x y)
            // cond:
            // result: (LessEqual (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32 x y)
            // cond:
            // result: (LessEqual (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32F x y)
            // cond:
            // result: (FLessEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FLessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32U x y)
            // cond:
            // result: (LessEqual (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64 x y)
            // cond:
            // result: (LessEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64F x y)
            // cond:
            // result: (FLessEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FLessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64U x y)
            // cond:
            // result: (LessEqual (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8 x y)
            // cond:
            // result: (LessEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8U x y)
            // cond:
            // result: (LessEqual (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16 x y)
            // cond:
            // result: (LessThan (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16U x y)
            // cond:
            // result: (LessThan (CMPWU (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32 x y)
            // cond:
            // result: (LessThan (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32F x y)
            // cond:
            // result: (FLessThan (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FLessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32U x y)
            // cond:
            // result: (LessThan (CMPWU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64 x y)
            // cond:
            // result: (LessThan (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64F x y)
            // cond:
            // result: (FLessThan (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FLessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess64U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64U x y)
            // cond:
            // result: (LessThan (CMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8 x y)
            // cond:
            // result: (LessThan (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLess8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8U x y)
            // cond:
            // result: (LessThan (CMPWU (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64LessThan);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWU, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLoad_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Load <t> ptr mem)
            // cond: (is64BitInt(t) || isPtr(t))
            // result: (MOVDload ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(is64BitInt(t) || isPtr(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && isSigned(t)
            // result: (MOVWload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && isSigned(t)
            // result: (MOVWload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && !isSigned(t)
            // result: (MOVWZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitInt(t) && !isSigned(t)
            // result: (MOVWZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && isSigned(t)
            // result: (MOVHload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && isSigned(t)
            // result: (MOVHload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && !isSigned(t)
            // result: (MOVHZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is16BitInt(t) && !isSigned(t)
            // result: (MOVHZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: t.IsBoolean()
            // result: (MOVBZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: t.IsBoolean()
            // result: (MOVBZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t.IsBoolean()))
                {
                    break;
                }
                v.reset(OpPPC64MOVBZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVBreg (MOVBZload ptr mem))
 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && isSigned(t)
            // result: (MOVBreg (MOVBZload ptr mem))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is8BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBreg);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8);
                v0.AddArg(ptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && !isSigned(t)
            // result: (MOVBZload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is8BitInt(t) && !isSigned(t)
            // result: (MOVBZload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is8BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBZload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (FMOVSload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (FMOVSload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitFloat(t)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (FMOVDload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (FMOVDload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is64BitFloat(t)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpLsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x16 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -16L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x32 x (Const64 [c]))
            // cond: uint32(c) < 16
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SLWconst x [c])
 
            // match: (Lsh16x32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x32 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
 
            // match: (Lsh16x32 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -16L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (MOVDconst [0])
 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh16x64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SLWconst x [c])
 
            // match: (Lsh16x64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x64 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
 
            // match: (Lsh16x64 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -16L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x8 x y)
            // cond:
            // result: (SLW  x                 (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -16L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x16 x y)
            // cond:
            // result: (SLW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x32 x (Const64 [c]))
            // cond: uint32(c) < 32
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SLWconst x [c])
 
            // match: (Lsh32x32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x32 x y)
            // cond:
            // result: (SLW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
 
            // match: (Lsh32x32 x y)
            // cond:
            // result: (SLW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (MOVDconst [0])
 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh32x64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SLWconst x [c])
 
            // match: (Lsh32x64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Lsh32x64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Lsh32x64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x64 x (ANDconst <typ.Int32> [31] y))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Lsh32x64 x (ANDconst <typ.Int32> [31] y))
            // cond:
            // result: (SLW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh32x64 x y)
            // cond:
            // result: (SLW  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
 
            // match: (Lsh32x64 x y)
            // cond:
            // result: (SLW  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x8 x y)
            // cond:
            // result: (SLW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x16 x y)
            // cond:
            // result: (SLD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x32 x (Const64 [c]))
            // cond: uint32(c) < 64
            // result: (SLDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh64x32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SLDconst x [c])
 
            // match: (Lsh64x32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SLDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh64x32 x y)
            // cond:
            // result: (SLD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
 
            // match: (Lsh64x32 x y)
            // cond:
            // result: (SLD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x64 x (Const64 [c]))
            // cond: uint64(c) < 64
            // result: (SLDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh64x64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (MOVDconst [0])
 
            // match: (Lsh64x64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 64L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh64x64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SLDconst x [c])
 
            // match: (Lsh64x64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SLDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SLDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh64x64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Lsh64x64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Lsh64x64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x64 x (ANDconst <typ.Int64> [63] y))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Lsh64x64 x (ANDconst <typ.Int64> [63] y))
            // cond:
            // result: (SLD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Lsh64x64 x y)
            // cond:
            // result: (SLD  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
 
            // match: (Lsh64x64 x y)
            // cond:
            // result: (SLD  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh64x8 x y)
            // cond:
            // result: (SLD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x16 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -8L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x32 x (Const64 [c]))
            // cond: uint32(c) < 8
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SLWconst x [c])
 
            // match: (Lsh8x32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x32 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
 
            // match: (Lsh8x32 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -8L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (MOVDconst [0])
 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Lsh8x64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SLWconst x [c])
 
            // match: (Lsh8x64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SLWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x64 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
 
            // match: (Lsh8x64 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -8L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpLsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x8 x y)
            // cond:
            // result: (SLW  x                (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SLW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -8L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16 x y)
            // cond:
            // result: (Mod32 (SignExt16to32 x) (SignExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16u x y)
            // cond:
            // result: (Mod32u (ZeroExt16to32 x) (ZeroExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32 x y)
            // cond:
            // result: (SUB x (MULLW y (DIVW x y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64MULLW, typ.Int32);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64DIVW, typ.Int32);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32u x y)
            // cond:
            // result: (SUB x (MULLW y (DIVWU x y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64MULLW, typ.Int32);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64DIVWU, typ.Int32);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod64 x y)
            // cond:
            // result: (SUB x (MULLD y (DIVD x y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64MULLD, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64DIVD, typ.Int64);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod64u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod64u x y)
            // cond:
            // result: (SUB x (MULLD y (DIVDU x y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64MULLD, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64DIVDU, typ.Int64);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8 x y)
            // cond:
            // result: (Mod32 (SignExt8to32 x) (SignExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMod8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8u x y)
            // cond:
            // result: (Mod32u (ZeroExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMove_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [0] _ _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[2L];
                var mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBZload src mem) mem)
 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVHstore dst (MOVHZload src mem) mem)
 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVHstore dst (MOVHZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVHstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVHZload, typ.UInt16);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWZload src mem) mem)
 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVWstore dst (MOVWZload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVWstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [8] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstore dst (MOVDload src mem) mem)
 
            // match: (Move [8] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstore dst (MOVDload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                var t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, typ.Int64);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVWstore [4] dst (MOVWZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
 
            // match: (Move [8] dst src mem)
            // cond:
            // result: (MOVWstore [4] dst (MOVWZload [4] src mem)         (MOVWstore dst (MOVWZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem);
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBZload [2] src mem)                 (MOVHstore dst (MOVHload src mem) mem))
 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBZload [2] src mem)                 (MOVHstore dst (MOVHload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = 2L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8);
                v0.AuxInt = 2L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVHstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpPPC64MOVHload, typ.Int16);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBZload [4] src mem)                 (MOVWstore dst (MOVWZload src mem) mem))
 
            // match: (Move [5] dst src mem)
            // cond:
            // result: (MOVBstore [4] dst (MOVBZload [4] src mem)                 (MOVWstore dst (MOVWZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVHstore [4] dst (MOVHZload [4] src mem)                 (MOVWstore dst (MOVWZload src mem) mem))
 
            // match: (Move [6] dst src mem)
            // cond:
            // result: (MOVHstore [4] dst (MOVHZload [4] src mem)                 (MOVWstore dst (MOVWZload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = 4L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVHZload, typ.UInt16);
                v0.AuxInt = 4L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [7] dst src mem)
            // cond:
            // result: (MOVBstore [6] dst (MOVBZload [6] src mem)                 (MOVHstore [4] dst (MOVHZload [4] src mem)                         (MOVWstore dst (MOVWZload src mem) mem)))
 
            // match: (Move [7] dst src mem)
            // cond:
            // result: (MOVBstore [6] dst (MOVBZload [6] src mem)                 (MOVHstore [4] dst (MOVHZload [4] src mem)                         (MOVWstore dst (MOVWZload src mem) mem)))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = 6L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVBZload, typ.UInt8);
                v0.AuxInt = 6L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVHstore, types.TypeMem);
                v1.AuxInt = 4L;
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpPPC64MOVHZload, typ.UInt16);
                v2.AuxInt = 4L;
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpPPC64MOVWstore, types.TypeMem);
                v3.AddArg(dst);
                var v4 = b.NewValue0(v.Pos, OpPPC64MOVWZload, typ.UInt32);
                v4.AddArg(src);
                v4.AddArg(mem);
                v3.AddArg(v4);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpMove_10(ref Value v)
        { 
            // match: (Move [s] dst src mem)
            // cond: s > 8
            // result: (LoweredMove [s] dst src mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                var mem = v.Args[2L];
                if (!(s > 8L))
                {
                    break;
                }
                v.reset(OpPPC64LoweredMove);
                v.AuxInt = s;
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpMul16_0(ref Value v)
        { 
            // match: (Mul16 x y)
            // cond:
            // result: (MULLW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMul32_0(ref Value v)
        { 
            // match: (Mul32 x y)
            // cond:
            // result: (MULLW  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMul32F_0(ref Value v)
        { 
            // match: (Mul32F x y)
            // cond:
            // result: (FMULS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FMULS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMul64_0(ref Value v)
        { 
            // match: (Mul64 x y)
            // cond:
            // result: (MULLD  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULLD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMul64F_0(ref Value v)
        { 
            // match: (Mul64F x y)
            // cond:
            // result: (FMUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpMul8_0(ref Value v)
        { 
            // match: (Mul8 x y)
            // cond:
            // result: (MULLW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64MULLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg16_0(ref Value v)
        { 
            // match: (Neg16 x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg32_0(ref Value v)
        { 
            // match: (Neg32 x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg32F_0(ref Value v)
        { 
            // match: (Neg32F x)
            // cond:
            // result: (FNEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FNEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg64_0(ref Value v)
        { 
            // match: (Neg64 x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg64F_0(ref Value v)
        { 
            // match: (Neg64F x)
            // cond:
            // result: (FNEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FNEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeg8_0(ref Value v)
        { 
            // match: (Neg8 x)
            // cond:
            // result: (NEG x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64NEG);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq16 x y)
            // cond: isSigned(x.Type) && isSigned(y.Type)
            // result: (NotEqual (CMPW (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(isSigned(x.Type) && isSigned(y.Type)))
                {
                    break;
                }
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Neq16 x y)
            // cond:
            // result: (NotEqual (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
 
            // match: (Neq16 x y)
            // cond:
            // result: (NotEqual (CMPW (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32 x y)
            // cond:
            // result: (NotEqual (CMPW x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32F x y)
            // cond:
            // result: (NotEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq64_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64 x y)
            // cond:
            // result: (NotEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64F x y)
            // cond:
            // result: (NotEqual (FCMPU x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64FCMPU, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq8 x y)
            // cond: isSigned(x.Type) && isSigned(y.Type)
            // result: (NotEqual (CMPW (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                if (!(isSigned(x.Type) && isSigned(y.Type)))
                {
                    break;
                }
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Neq8 x y)
            // cond:
            // result: (NotEqual (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
 
            // match: (Neq8 x y)
            // cond:
            // result: (NotEqual (CMPW (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                v0 = b.NewValue0(v.Pos, OpPPC64CMPW, types.TypeFlags);
                v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeqB_0(ref Value v)
        { 
            // match: (NeqB x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNeqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (NeqPtr x y)
            // cond:
            // result: (NotEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64NotEqual);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNilCheck_0(ref Value v)
        { 
            // match: (NilCheck ptr mem)
            // cond:
            // result: (LoweredNilCheck ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpPPC64LoweredNilCheck);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpNot_0(ref Value v)
        { 
            // match: (Not x)
            // cond:
            // result: (XORconst [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64XORconst);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOffPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OffPtr [off] ptr)
            // cond:
            // result: (ADD (MOVDconst <typ.Int64> [off]) ptr)
            while (true)
            {
                var off = v.AuxInt;
                var ptr = v.Args[0L];
                v.reset(OpPPC64ADD);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v0.AuxInt = off;
                v.AddArg(v0);
                v.AddArg(ptr);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOr16_0(ref Value v)
        { 
            // match: (Or16 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64OR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOr32_0(ref Value v)
        { 
            // match: (Or32 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64OR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOr64_0(ref Value v)
        { 
            // match: (Or64 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64OR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOr8_0(ref Value v)
        { 
            // match: (Or8 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64OR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpOrB_0(ref Value v)
        { 
            // match: (OrB x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64OR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpPPC64ADD_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (ADD (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v_0.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
 
            // match: (ADD (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (ADD (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (ADD (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
 
            // match: (ADD (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
 
            // match: (ADD (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
 
            // match: (ADD (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_0_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
 
            // match: (ADD (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
 
            // match: (ADD x (MOVDconst [c]))
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
 
            // match: (ADD (MOVDconst [c]) x)
            // cond: is32Bit(c)
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(is32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64ADDconst_0(ref Value v)
        { 
            // match: (ADDconst [c] (ADDconst [d] x))
            // cond: is32Bit(c+d)
            // result: (ADDconst [c+d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(is32Bit(c + d)))
                {
                    break;
                }
                v.reset(OpPPC64ADDconst);
                v.AuxInt = c + d;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (MOVDaddr [d] {sym} x))
            // cond:
            // result: (MOVDaddr [c+d] {sym} x)
 
            // match: (ADDconst [c] (MOVDaddr [d] {sym} x))
            // cond:
            // result: (MOVDaddr [c+d] {sym} x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                d = v_0.AuxInt;
                var sym = v_0.Aux;
                x = v_0.Args[0L];
                v.reset(OpPPC64MOVDaddr);
                v.AuxInt = c + d;
                v.Aux = sym;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64AND_0(ref Value v)
        { 
            // match: (AND x (NOR y y))
            // cond:
            // result: (ANDN x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64NOR)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                if (y != v_1.Args[1L])
                {
                    break;
                }
                v.reset(OpPPC64ANDN);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (NOR y y) x)
            // cond:
            // result: (ANDN x y)
 
            // match: (AND (NOR y y) x)
            // cond:
            // result: (ANDN x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64NOR)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                if (y != v_0.Args[1L])
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpPPC64ANDN);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (AND (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (AND (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c&d])
 
            // match: (AND (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c&d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (AND x (MOVDconst [c]))
            // cond: isU16Bit(c)
            // result: (ANDconst [c] x)
 
            // match: (AND x (MOVDconst [c]))
            // cond: isU16Bit(c)
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [c]) x)
            // cond: isU16Bit(c)
            // result: (ANDconst [c] x)
 
            // match: (AND (MOVDconst [c]) x)
            // cond: isU16Bit(c)
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [c]) x:(MOVBZload _ _))
            // cond:
            // result: (ANDconst [c&0xFF] x)
 
            // match: (AND (MOVDconst [c]) x:(MOVBZload _ _))
            // cond:
            // result: (ANDconst [c&0xFF] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (x.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFUL;
                v.AddArg(x);
                return true;
            } 
            // match: (AND x:(MOVBZload _ _) (MOVDconst [c]))
            // cond:
            // result: (ANDconst [c&0xFF] x)
 
            // match: (AND x:(MOVBZload _ _) (MOVDconst [c]))
            // cond:
            // result: (ANDconst [c&0xFF] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFUL;
                v.AddArg(x);
                return true;
            } 
            // match: (AND x:(MOVBZload _ _) (MOVDconst [c]))
            // cond:
            // result: (ANDconst [c&0xFF] x)
 
            // match: (AND x:(MOVBZload _ _) (MOVDconst [c]))
            // cond:
            // result: (ANDconst [c&0xFF] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFUL;
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVDconst [c]) x:(MOVBZload _ _))
            // cond:
            // result: (ANDconst [c&0xFF] x)
 
            // match: (AND (MOVDconst [c]) x:(MOVBZload _ _))
            // cond:
            // result: (ANDconst [c&0xFF] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (x.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFUL;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64ANDconst_0(ref Value v)
        { 
            // match: (ANDconst [c] (ANDconst [d] x))
            // cond:
            // result: (ANDconst [c&d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [-1] x)
            // cond:
            // result: x
 
            // match: (ANDconst [-1] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
 
            // match: (ANDconst [0] _)
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDconst [c] y:(MOVBZreg _))
            // cond: c&0xFF == 0xFF
            // result: y
 
            // match: (ANDconst [c] y:(MOVBZreg _))
            // cond: c&0xFF == 0xFF
            // result: y
            while (true)
            {
                c = v.AuxInt;
                var y = v.Args[0L];
                if (y.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                if (!(c & 0xFFUL == 0xFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (ANDconst [c] y:(MOVHZreg _))
            // cond: c&0xFFFF == 0xFFFF
            // result: y
 
            // match: (ANDconst [c] y:(MOVHZreg _))
            // cond: c&0xFFFF == 0xFFFF
            // result: y
            while (true)
            {
                c = v.AuxInt;
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                if (!(c & 0xFFFFUL == 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (ANDconst [c] y:(MOVWZreg _))
            // cond: c&0xFFFFFFFF == 0xFFFFFFFF
            // result: y
 
            // match: (ANDconst [c] y:(MOVWZreg _))
            // cond: c&0xFFFFFFFF == 0xFFFFFFFF
            // result: y
            while (true)
            {
                c = v.AuxInt;
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                if (!(c & 0xFFFFFFFFUL == 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (ANDconst [c] (MOVBZreg x))
            // cond:
            // result: (ANDconst [c&0xFF] x)
 
            // match: (ANDconst [c] (MOVBZreg x))
            // cond:
            // result: (ANDconst [c&0xFF] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFUL;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [c] (MOVHZreg x))
            // cond:
            // result: (ANDconst [c&0xFFFF] x)
 
            // match: (ANDconst [c] (MOVHZreg x))
            // cond:
            // result: (ANDconst [c&0xFFFF] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFFFUL;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [c] (MOVWZreg x))
            // cond:
            // result: (ANDconst [c&0xFFFFFFFF] x)
 
            // match: (ANDconst [c] (MOVWZreg x))
            // cond:
            // result: (ANDconst [c&0xFFFFFFFF] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpPPC64ANDconst);
                v.AuxInt = c & 0xFFFFFFFFUL;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMP_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMP x (MOVDconst [c]))
            // cond: is16Bit(c)
            // result: (CMPconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64CMPconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMP (MOVDconst [c]) y)
            // cond: is16Bit(c)
            // result: (InvertFlags (CMPconst y [c]))
 
            // match: (CMP (MOVDconst [c]) y)
            // cond: is16Bit(c)
            // result: (InvertFlags (CMPconst y [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var y = v.Args[1L];
                if (!(is16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPU_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPU x (MOVDconst [c]))
            // cond: isU16Bit(c)
            // result: (CMPUconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64CMPUconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPU (MOVDconst [c]) y)
            // cond: isU16Bit(c)
            // result: (InvertFlags (CMPUconst y [c]))
 
            // match: (CMPU (MOVDconst [c]) y)
            // cond: isU16Bit(c)
            // result: (InvertFlags (CMPUconst y [c]))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var y = v.Args[1L];
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPUconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPUconst_0(ref Value v)
        { 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: int64(x)==int64(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int64(x) == int64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagEQ);
                return true;
            } 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)<uint64(y)
            // result: (FlagLT)
 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)<uint64(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint64(x) < uint64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagLT);
                return true;
            } 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)>uint64(y)
            // result: (FlagGT)
 
            // match: (CMPUconst (MOVDconst [x]) [y])
            // cond: uint64(x)>uint64(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint64(x) > uint64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPW_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPW x (MOVWreg y))
            // cond:
            // result: (CMPW x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVWreg)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpPPC64CMPW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPW (MOVWreg x) y)
            // cond:
            // result: (CMPW x y)
 
            // match: (CMPW (MOVWreg x) y)
            // cond:
            // result: (CMPW x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVWreg)
                {
                    break;
                }
                x = v_0.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64CMPW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPW x (MOVDconst [c]))
            // cond: is16Bit(c)
            // result: (CMPWconst x [c])
 
            // match: (CMPW x (MOVDconst [c]))
            // cond: is16Bit(c)
            // result: (CMPWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64CMPWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPW (MOVDconst [c]) y)
            // cond: is16Bit(c)
            // result: (InvertFlags (CMPWconst y [c]))
 
            // match: (CMPW (MOVDconst [c]) y)
            // cond: is16Bit(c)
            // result: (InvertFlags (CMPWconst y [c]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v.Args[1L];
                if (!(is16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPWU_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPWU x (MOVWZreg y))
            // cond:
            // result: (CMPWU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                var y = v_1.Args[0L];
                v.reset(OpPPC64CMPWU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPWU (MOVWZreg x) y)
            // cond:
            // result: (CMPWU x y)
 
            // match: (CMPWU (MOVWZreg x) y)
            // cond:
            // result: (CMPWU x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                x = v_0.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64CMPWU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMPWU x (MOVDconst [c]))
            // cond: isU16Bit(c)
            // result: (CMPWUconst x [c])
 
            // match: (CMPWU x (MOVDconst [c]))
            // cond: isU16Bit(c)
            // result: (CMPWUconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64CMPWUconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMPWU (MOVDconst [c]) y)
            // cond: isU16Bit(c)
            // result: (InvertFlags (CMPWUconst y [c]))
 
            // match: (CMPWU (MOVDconst [c]) y)
            // cond: isU16Bit(c)
            // result: (InvertFlags (CMPWUconst y [c]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v.Args[1L];
                if (!(isU16Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64InvertFlags);
                var v0 = b.NewValue0(v.Pos, OpPPC64CMPWUconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPWUconst_0(ref Value v)
        { 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: int32(x)==int32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagEQ);
                return true;
            } 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)<uint32(y)
            // result: (FlagLT)
 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)<uint32(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagLT);
                return true;
            } 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)>uint32(y)
            // result: (FlagGT)
 
            // match: (CMPWUconst (MOVDconst [x]) [y])
            // cond: uint32(x)>uint32(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPWconst_0(ref Value v)
        { 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)==int32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagEQ);
                return true;
            } 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)<int32(y)
            // result: (FlagLT)
 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)<int32(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagLT);
                return true;
            } 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)>int32(y)
            // result: (FlagGT)
 
            // match: (CMPWconst (MOVDconst [x]) [y])
            // cond: int32(x)>int32(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64CMPconst_0(ref Value v)
        { 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: int64(x)==int64(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int64(x) == int64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagEQ);
                return true;
            } 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: int64(x)<int64(y)
            // result: (FlagLT)
 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: int64(x)<int64(y)
            // result: (FlagLT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int64(x) < int64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagLT);
                return true;
            } 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: int64(x)>int64(y)
            // result: (FlagGT)
 
            // match: (CMPconst (MOVDconst [x]) [y])
            // cond: int64(x)>int64(y)
            // result: (FlagGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int64(x) > int64(y)))
                {
                    break;
                }
                v.reset(OpPPC64FlagGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64Equal_0(ref Value v)
        { 
            // match: (Equal (FlagEQ))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Equal (FlagLT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (Equal (FlagLT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (FlagGT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (Equal (FlagGT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (InvertFlags x))
            // cond:
            // result: (Equal x)
 
            // match: (Equal (InvertFlags x))
            // cond:
            // result: (Equal x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64Equal);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FABS_0(ref Value v)
        { 
            // match: (FABS (FMOVDconst [x]))
            // cond:
            // result: (FMOVDconst [f2i(math.Abs(i2f(x)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = f2i(math.Abs(i2f(x)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FADD_0(ref Value v)
        { 
            // match: (FADD (FMUL x y) z)
            // cond:
            // result: (FMADD x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                var z = v.Args[1L];
                v.reset(OpPPC64FMADD);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (FADD z (FMUL x y))
            // cond:
            // result: (FMADD x y z)
 
            // match: (FADD z (FMUL x y))
            // cond:
            // result: (FMADD x y z)
            while (true)
            {
                _ = v.Args[1L];
                z = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64FMUL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                v.reset(OpPPC64FMADD);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FADDS_0(ref Value v)
        { 
            // match: (FADDS (FMULS x y) z)
            // cond:
            // result: (FMADDS x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMULS)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                var z = v.Args[1L];
                v.reset(OpPPC64FMADDS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (FADDS z (FMULS x y))
            // cond:
            // result: (FMADDS x y z)
 
            // match: (FADDS z (FMULS x y))
            // cond:
            // result: (FMADDS x y z)
            while (true)
            {
                _ = v.Args[1L];
                z = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64FMULS)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                v.reset(OpPPC64FMADDS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FCEIL_0(ref Value v)
        { 
            // match: (FCEIL (FMOVDconst [x]))
            // cond:
            // result: (FMOVDconst [f2i(math.Ceil(i2f(x)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = f2i(math.Ceil(i2f(x)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FFLOOR_0(ref Value v)
        { 
            // match: (FFLOOR (FMOVDconst [x]))
            // cond:
            // result: (FMOVDconst [f2i(math.Floor(i2f(x)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = f2i(math.Floor(i2f(x)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FMOVDload_0(ref Value v)
        { 
            // match: (FMOVDload [off] {sym} ptr (MOVDstore [off] {sym} ptr x _))
            // cond:
            // result: (MTVSRD x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var x = v_1.Args[1L];
                v.reset(OpPPC64MTVSRD);
                v.AddArg(x);
                return true;
            } 
            // match: (FMOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (FMOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVDload [off1+off2] {sym} ptr mem)
 
            // match: (FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVDload [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FMOVDstore_0(ref Value v)
        { 
            // match: (FMOVDstore [off] {sym} ptr (MTVSRD x) mem)
            // cond:
            // result: (MOVDstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MTVSRD)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpPPC64MOVDstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVDstore [off1+off2] {sym} ptr val mem)
 
            // match: (FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVDstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (FMOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FMOVSload_0(ref Value v)
        { 
            // match: (FMOVSload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVSload [off1+off2] {sym} ptr mem)
 
            // match: (FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVSload [off1+off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FMOVSstore_0(ref Value v)
        { 
            // match: (FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond: is16Bit(off1+off2)
            // result: (FMOVSstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (FMOVSstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (FMOVSstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FNEG_0(ref Value v)
        { 
            // match: (FNEG (FABS x))
            // cond:
            // result: (FNABS x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FABS)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64FNABS);
                v.AddArg(x);
                return true;
            } 
            // match: (FNEG (FNABS x))
            // cond:
            // result: (FABS x)
 
            // match: (FNEG (FNABS x))
            // cond:
            // result: (FABS x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FNABS)
                {
                    break;
                }
                x = v_0.Args[0L];
                v.reset(OpPPC64FABS);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FSQRT_0(ref Value v)
        { 
            // match: (FSQRT (FMOVDconst [x]))
            // cond:
            // result: (FMOVDconst [f2i(math.Sqrt(i2f(x)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = f2i(math.Sqrt(i2f(x)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FSUB_0(ref Value v)
        { 
            // match: (FSUB (FMUL x y) z)
            // cond:
            // result: (FMSUB x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                var z = v.Args[1L];
                v.reset(OpPPC64FMSUB);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FSUBS_0(ref Value v)
        { 
            // match: (FSUBS (FMULS x y) z)
            // cond:
            // result: (FMSUBS x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMULS)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                var z = v.Args[1L];
                v.reset(OpPPC64FMSUBS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64FTRUNC_0(ref Value v)
        { 
            // match: (FTRUNC (FMOVDconst [x]))
            // cond:
            // result: (FMOVDconst [f2i(math.Trunc(i2f(x)))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = f2i(math.Trunc(i2f(x)));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64GreaterEqual_0(ref Value v)
        { 
            // match: (GreaterEqual (FlagEQ))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqual (FlagLT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (GreaterEqual (FlagLT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterEqual (FlagGT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (GreaterEqual (FlagGT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqual (InvertFlags x))
            // cond:
            // result: (LessEqual x)
 
            // match: (GreaterEqual (InvertFlags x))
            // cond:
            // result: (LessEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64LessEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64GreaterThan_0(ref Value v)
        { 
            // match: (GreaterThan (FlagEQ))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThan (FlagLT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (GreaterThan (FlagLT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThan (FlagGT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (GreaterThan (FlagGT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterThan (InvertFlags x))
            // cond:
            // result: (LessThan x)
 
            // match: (GreaterThan (InvertFlags x))
            // cond:
            // result: (LessThan x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64LessThan);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64LessEqual_0(ref Value v)
        { 
            // match: (LessEqual (FlagEQ))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqual (FlagLT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (LessEqual (FlagLT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqual (FlagGT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (LessEqual (FlagGT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessEqual (InvertFlags x))
            // cond:
            // result: (GreaterEqual x)
 
            // match: (LessEqual (InvertFlags x))
            // cond:
            // result: (GreaterEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64GreaterEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64LessThan_0(ref Value v)
        { 
            // match: (LessThan (FlagEQ))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThan (FlagLT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (LessThan (FlagLT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessThan (FlagGT))
            // cond:
            // result: (MOVDconst [0])
 
            // match: (LessThan (FlagGT))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThan (InvertFlags x))
            // cond:
            // result: (GreaterThan x)
 
            // match: (LessThan (InvertFlags x))
            // cond:
            // result: (GreaterThan x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64GreaterThan);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MFVSRD_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MFVSRD (FMOVDconst [c]))
            // cond:
            // result: (MOVDconst [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FMOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (MFVSRD x:(FMOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload [off] {sym} ptr mem)
 
            // match: (MFVSRD x:(FMOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (MOVDload [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpPPC64FMOVDload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, typ.Int64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVBZload_0(ref Value v)
        { 
            // match: (MOVBZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVBZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVBZload [off1+off2] {sym} x mem)
 
            // match: (MOVBZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVBZload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVBZreg_0(ref Value v)
        { 
            // match: (MOVBZreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0xFF
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0xFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVBZreg y:(MOVBZreg _))
            // cond:
            // result: y
 
            // match: (MOVBZreg y:(MOVBZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVBZreg (MOVBreg x))
            // cond:
            // result: (MOVBZreg x)
 
            // match: (MOVBZreg (MOVBreg x))
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVBreg)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64MOVBZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg x:(MOVBZload _ _))
            // cond:
            // result: x
 
            // match: (MOVBZreg x:(MOVBZload _ _))
            // cond:
            // result: x
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint8(c))])
 
            // match: (MOVBZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint8(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = int64(uint8(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVBreg_0(ref Value v)
        { 
            // match: (MOVBreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0x7F
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0x7FUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVBreg y:(MOVBreg _))
            // cond:
            // result: y
 
            // match: (MOVBreg y:(MOVBreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVBreg (MOVBZreg x))
            // cond:
            // result: (MOVBreg x)
 
            // match: (MOVBreg (MOVBZreg x))
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int8(c))])
 
            // match: (MOVBreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int8(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = int64(int8(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVBstore_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVBstore [off1] {sym} (ADDconst [off2] x) val mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVBstore [off1+off2] {sym} x val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVBstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVBstorezero [off] {sym} ptr mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVBstorezero [off] {sym} ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(c == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVBreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBZreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBZreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i1] {s} p (SRWconst (MOVHZreg w) [8]) x0:(MOVBstore [i0] {s} p w mem))
            // cond: !config.BigEndian     && x0.Uses == 1     && i1 == i0+1     && clobber(x0)
            // result: (MOVHstore [i0] {s} p w mem)
 
            // match: (MOVBstore [i1] {s} p (SRWconst (MOVHZreg w) [8]) x0:(MOVBstore [i0] {s} p w mem))
            // cond: !config.BigEndian     && x0.Uses == 1     && i1 == i0+1     && clobber(x0)
            // result: (MOVHstore [i0] {s} p w mem)
            while (true)
            {
                var i1 = v.AuxInt;
                var s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 8L)
                {
                    break;
                }
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                var w = v_1_0.Args[0L];
                var x0 = v.Args[2L];
                if (x0.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (w != x0.Args[1L])
                {
                    break;
                }
                mem = x0.Args[2L];
                if (!(!config.BigEndian && x0.Uses == 1L && i1 == i0 + 1L && clobber(x0)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = i0;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i3] {s} p (SRWconst w [24]) x0:(MOVBstore [i2] {s} p (SRWconst w [16]) x1:(MOVBstore [i1] {s} p (SRWconst w [8]) x2:(MOVBstore [i0] {s} p w mem))))
            // cond: !config.BigEndian     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1     && i1 == i0+1 && i2 == i0+2 && i3 == i0+3     && clobber(x0) && clobber(x1) && clobber(x2)
            // result: (MOVWstore [i0] {s} p w mem)
 
            // match: (MOVBstore [i3] {s} p (SRWconst w [24]) x0:(MOVBstore [i2] {s} p (SRWconst w [16]) x1:(MOVBstore [i1] {s} p (SRWconst w [8]) x2:(MOVBstore [i0] {s} p w mem))))
            // cond: !config.BigEndian     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1     && i1 == i0+1 && i2 == i0+2 && i3 == i0+3     && clobber(x0) && clobber(x1) && clobber(x2)
            // result: (MOVWstore [i0] {s} p w mem)
            while (true)
            {
                var i3 = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 24L)
                {
                    break;
                }
                w = v_1.Args[0L];
                x0 = v.Args[2L];
                if (x0.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                var i2 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                var x0_1 = x0.Args[1L];
                if (x0_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                if (x0_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x0_1.Args[0L])
                {
                    break;
                }
                var x1 = x0.Args[2L];
                if (x1.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                var x1_1 = x1.Args[1L];
                if (x1_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                if (x1_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x1_1.Args[0L])
                {
                    break;
                }
                var x2 = x1.Args[2L];
                if (x2.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i0 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[2L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (w != x2.Args[1L])
                {
                    break;
                }
                mem = x2.Args[2L];
                if (!(!config.BigEndian && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && clobber(x0) && clobber(x1) && clobber(x2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = i0;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [i7] {s} p (SRDconst w [56]) x0:(MOVBstore [i6] {s} p (SRDconst w [48]) x1:(MOVBstore [i5] {s} p (SRDconst w [40]) x2:(MOVBstore [i4] {s} p (SRDconst w [32]) x3:(MOVBstore [i3] {s} p (SRDconst w [24]) x4:(MOVBstore [i2] {s} p (SRDconst w [16]) x5:(MOVBstore [i1] {s} p (SRDconst w [8]) x6:(MOVBstore [i0] {s} p w mem))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1     && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)
            // result: (MOVDstore [i0] {s} p w mem)
 
            // match: (MOVBstore [i7] {s} p (SRDconst w [56]) x0:(MOVBstore [i6] {s} p (SRDconst w [48]) x1:(MOVBstore [i5] {s} p (SRDconst w [40]) x2:(MOVBstore [i4] {s} p (SRDconst w [32]) x3:(MOVBstore [i3] {s} p (SRDconst w [24]) x4:(MOVBstore [i2] {s} p (SRDconst w [16]) x5:(MOVBstore [i1] {s} p (SRDconst w [8]) x6:(MOVBstore [i0] {s} p w mem))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses == 1     && i1 == i0+1 && i2 == i0+2 && i3 == i0+3 && i4 == i0+4 && i5 == i0+5 && i6 == i0+6 && i7 == i0+7     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)
            // result: (MOVDstore [i0] {s} p w mem)
            while (true)
            {
                var i7 = v.AuxInt;
                s = v.Aux;
                _ = v.Args[2L];
                p = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 56L)
                {
                    break;
                }
                w = v_1.Args[0L];
                x0 = v.Args[2L];
                if (x0.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                var i6 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[2L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                x0_1 = x0.Args[1L];
                if (x0_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x0_1.AuxInt != 48L)
                {
                    break;
                }
                if (w != x0_1.Args[0L])
                {
                    break;
                }
                x1 = x0.Args[2L];
                if (x1.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                var i5 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[2L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                x1_1 = x1.Args[1L];
                if (x1_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x1_1.AuxInt != 40L)
                {
                    break;
                }
                if (w != x1_1.Args[0L])
                {
                    break;
                }
                x2 = x1.Args[2L];
                if (x2.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                var i4 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[2L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                var x2_1 = x2.Args[1L];
                if (x2_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x2_1.AuxInt != 32L)
                {
                    break;
                }
                if (w != x2_1.Args[0L])
                {
                    break;
                }
                var x3 = x2.Args[2L];
                if (x3.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[2L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                var x3_1 = x3.Args[1L];
                if (x3_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x3_1.AuxInt != 24L)
                {
                    break;
                }
                if (w != x3_1.Args[0L])
                {
                    break;
                }
                var x4 = x3.Args[2L];
                if (x4.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i2 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[2L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                var x4_1 = x4.Args[1L];
                if (x4_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x4_1.AuxInt != 16L)
                {
                    break;
                }
                if (w != x4_1.Args[0L])
                {
                    break;
                }
                var x5 = x4.Args[2L];
                if (x5.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i1 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[2L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                var x5_1 = x5.Args[1L];
                if (x5_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                if (x5_1.AuxInt != 8L)
                {
                    break;
                }
                if (w != x5_1.Args[0L])
                {
                    break;
                }
                var x6 = x5.Args[2L];
                if (x6.Op != OpPPC64MOVBstore)
                {
                    break;
                }
                i0 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[2L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (w != x6.Args[1L])
                {
                    break;
                }
                mem = x6.Args[2L];
                if (!(!config.BigEndian && i0 % 4L == 0L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstore);
                v.AuxInt = i0;
                v.Aux = s;
                v.AddArg(p);
                v.AddArg(w);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVBstorezero_0(ref Value v)
        { 
            // match: (MOVBstorezero [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVBstorezero [off1+off2] {sym} x mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVBstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
 
            // match: (MOVBstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVBstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                x = p.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (x.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVDload_0(ref Value v)
        { 
            // match: (MOVDload [off] {sym} ptr (FMOVDstore [off] {sym} ptr x _))
            // cond:
            // result: (MFVSRD x)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64FMOVDstore)
                {
                    break;
                }
                if (v_1.AuxInt != off)
                {
                    break;
                }
                if (v_1.Aux != sym)
                {
                    break;
                }
                _ = v_1.Args[2L];
                if (ptr != v_1.Args[0L])
                {
                    break;
                }
                var x = v_1.Args[1L];
                v.reset(OpPPC64MFVSRD);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVDload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVDload [off1+off2] {sym} x mem)
 
            // match: (MOVDload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVDload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVDstore_0(ref Value v)
        { 
            // match: (MOVDstore [off] {sym} ptr (MFVSRD x) mem)
            // cond:
            // result: (FMOVDstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MFVSRD)
                {
                    break;
                }
                var x = v_1.Args[0L];
                var mem = v.Args[2L];
                v.reset(OpPPC64FMOVDstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym} (ADDconst [off2] x) val mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVDstore [off1+off2] {sym} x val mem)
 
            // match: (MOVDstore [off1] {sym} (ADDconst [off2] x) val mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVDstore [off1+off2] {sym} x val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                x = v_0.Args[0L];
                var val = v.Args[1L];
                mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVDstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVDstorezero [off] {sym} ptr mem)
 
            // match: (MOVDstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVDstorezero [off] {sym} ptr mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(c == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVDstorezero_0(ref Value v)
        { 
            // match: (MOVDstorezero [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVDstorezero [off1+off2] {sym} x mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVDstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
 
            // match: (MOVDstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVDstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                x = p.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (x.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHZload_0(ref Value v)
        { 
            // match: (MOVHZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVHZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHZload [off1+off2] {sym} x mem)
 
            // match: (MOVHZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHZload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHZreg_0(ref Value v)
        { 
            // match: (MOVHZreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0xFFFF
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHZreg y:(MOVHZreg _))
            // cond:
            // result: y
 
            // match: (MOVHZreg y:(MOVHZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHZreg y:(MOVBZreg _))
            // cond:
            // result: y
 
            // match: (MOVHZreg y:(MOVBZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHZreg y:(MOVHreg x))
            // cond:
            // result: (MOVHZreg x)
 
            // match: (MOVHZreg y:(MOVHreg x))
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHreg)
                {
                    break;
                }
                var x = y.Args[0L];
                v.reset(OpPPC64MOVHZreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg x:(MOVHZload _ _))
            // cond:
            // result: x
 
            // match: (MOVHZreg x:(MOVHZload _ _))
            // cond:
            // result: x
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpPPC64MOVHZload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint16(c))])
 
            // match: (MOVHZreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(uint16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = int64(uint16(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHload_0(ref Value v)
        { 
            // match: (MOVHload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHload [off1+off2] {sym} x mem)
 
            // match: (MOVHload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHreg_0(ref Value v)
        { 
            // match: (MOVHreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0x7FFF
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0x7FFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHreg y:(MOVHreg _))
            // cond:
            // result: y
 
            // match: (MOVHreg y:(MOVHreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHreg y:(MOVBreg _))
            // cond:
            // result: y
 
            // match: (MOVHreg y:(MOVBreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVHreg y:(MOVHZreg x))
            // cond:
            // result: (MOVHreg x)
 
            // match: (MOVHreg y:(MOVHZreg x))
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                var x = y.Args[0L];
                v.reset(OpPPC64MOVHreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: x
 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: x
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpPPC64MOVHload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int16(c))])
 
            // match: (MOVHreg (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [int64(int16(c))])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = int64(int16(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHstore_0(ref Value v)
        { 
            // match: (MOVHstore [off1] {sym} (ADDconst [off2] x) val mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHstore [off1+off2] {sym} x val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVHstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVHstorezero [off] {sym} ptr mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVHstorezero [off] {sym} ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(c == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstorezero);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVHreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVHZreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVHZreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVHstorezero_0(ref Value v)
        { 
            // match: (MOVHstorezero [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVHstorezero [off1+off2] {sym} x mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVHstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
 
            // match: (MOVHstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVHstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                x = p.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (x.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWZload_0(ref Value v)
        { 
            // match: (MOVWZload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVWZload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWZload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWZload [off1+off2] {sym} x mem)
 
            // match: (MOVWZload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWZload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWZload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWZreg_0(ref Value v)
        { 
            // match: (MOVWZreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0xFFFFFFFF
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(AND (MOVDconst [c]) _))
            // cond: uint64(c) <= 0xFFFFFFFF
            // result: y
 
            // match: (MOVWZreg y:(AND (MOVDconst [c]) _))
            // cond: uint64(c) <= 0xFFFFFFFF
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64AND)
                {
                    break;
                }
                _ = y.Args[1L];
                var y_0 = y.Args[0L];
                if (y_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = y_0.AuxInt;
                if (!(uint64(c) <= 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(AND _ (MOVDconst [c])))
            // cond: uint64(c) <= 0xFFFFFFFF
            // result: y
 
            // match: (MOVWZreg y:(AND _ (MOVDconst [c])))
            // cond: uint64(c) <= 0xFFFFFFFF
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64AND)
                {
                    break;
                }
                _ = y.Args[1L];
                var y_1 = y.Args[1L];
                if (y_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = y_1.AuxInt;
                if (!(uint64(c) <= 0xFFFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(MOVWZreg _))
            // cond:
            // result: y
 
            // match: (MOVWZreg y:(MOVWZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(MOVHZreg _))
            // cond:
            // result: y
 
            // match: (MOVWZreg y:(MOVHZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(MOVBZreg _))
            // cond:
            // result: y
 
            // match: (MOVWZreg y:(MOVBZreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBZreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWZreg y:(MOVWreg x))
            // cond:
            // result: (MOVWZreg x)
 
            // match: (MOVWZreg y:(MOVWreg x))
            // cond:
            // result: (MOVWZreg x)
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVWreg)
                {
                    break;
                }
                var x = y.Args[0L];
                v.reset(OpPPC64MOVWZreg);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWload_0(ref Value v)
        { 
            // match: (MOVWload [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                var off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                var mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWload [off1+off2] {sym} x mem)
 
            // match: (MOVWload [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWload [off1+off2] {sym} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWreg_0(ref Value v)
        { 
            // match: (MOVWreg y:(ANDconst [c] _))
            // cond: uint64(c) <= 0xFFFF
            // result: y
            while (true)
            {
                var y = v.Args[0L];
                if (y.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var c = y.AuxInt;
                if (!(uint64(c) <= 0xFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(AND (MOVDconst [c]) _))
            // cond: uint64(c) <= 0x7FFFFFFF
            // result: y
 
            // match: (MOVWreg y:(AND (MOVDconst [c]) _))
            // cond: uint64(c) <= 0x7FFFFFFF
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64AND)
                {
                    break;
                }
                _ = y.Args[1L];
                var y_0 = y.Args[0L];
                if (y_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = y_0.AuxInt;
                if (!(uint64(c) <= 0x7FFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(AND _ (MOVDconst [c])))
            // cond: uint64(c) <= 0x7FFFFFFF
            // result: y
 
            // match: (MOVWreg y:(AND _ (MOVDconst [c])))
            // cond: uint64(c) <= 0x7FFFFFFF
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64AND)
                {
                    break;
                }
                _ = y.Args[1L];
                var y_1 = y.Args[1L];
                if (y_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = y_1.AuxInt;
                if (!(uint64(c) <= 0x7FFFFFFFUL))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(MOVWreg _))
            // cond:
            // result: y
 
            // match: (MOVWreg y:(MOVWreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVWreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(MOVHreg _))
            // cond:
            // result: y
 
            // match: (MOVWreg y:(MOVHreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVHreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(MOVBreg _))
            // cond:
            // result: y
 
            // match: (MOVWreg y:(MOVBreg _))
            // cond:
            // result: y
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVBreg)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            } 
            // match: (MOVWreg y:(MOVWZreg x))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVWreg y:(MOVWZreg x))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                y = v.Args[0L];
                if (y.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                var x = y.Args[0L];
                v.reset(OpPPC64MOVWreg);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWstore_0(ref Value v)
        { 
            // match: (MOVWstore [off1] {sym} (ADDconst [off2] x) val mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWstore [off1+off2] {sym} x val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVWstore [off1] {sym1} p:(MOVDaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)     && (ptr.Op != OpSB || p.Uses == 1)
            // result: (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                var ptr = p.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2) && (ptr.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVWstorezero [off] {sym} ptr mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVDconst [c]) mem)
            // cond: c == 0
            // result: (MOVWstorezero [off] {sym} ptr mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                mem = v.Args[2L];
                if (!(c == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstorezero);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVWreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVWreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVWreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off] {sym} ptr (MOVWZreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
 
            // match: (MOVWstore [off] {sym} ptr (MOVWZreg x) mem)
            // cond:
            // result: (MOVWstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVWZreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpPPC64MOVWstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MOVWstorezero_0(ref Value v)
        { 
            // match: (MOVWstorezero [off1] {sym} (ADDconst [off2] x) mem)
            // cond: is16Bit(off1+off2)
            // result: (MOVWstorezero [off1+off2] {sym} x mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var x = v_0.Args[0L];
                var mem = v.Args[1L];
                if (!(is16Bit(off1 + off2)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVWstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
 
            // match: (MOVWstorezero [off1] {sym1} p:(MOVDaddr [off2] {sym2} x) mem)
            // cond: canMergeSym(sym1,sym2)     && (x.Op != OpSB || p.Uses == 1)
            // result: (MOVWstorezero [off1+off2] {mergeSym(sym1,sym2)} x mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                var p = v.Args[0L];
                if (p.Op != OpPPC64MOVDaddr)
                {
                    break;
                }
                off2 = p.AuxInt;
                var sym2 = p.Aux;
                x = p.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2) && (x.Op != OpSB || p.Uses == 1L)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstorezero);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MTVSRD_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (MTVSRD (MOVDconst [c]))
            // cond:
            // result: (FMOVDconst [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpPPC64FMOVDconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (MTVSRD x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (FMOVDload [off] {sym} ptr mem)
 
            // match: (MTVSRD x:(MOVDload [off] {sym} ptr mem))
            // cond: x.Uses == 1 && clobber(x)
            // result: @x.Block (FMOVDload [off] {sym} ptr mem)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpPPC64MOVDload)
                {
                    break;
                }
                var off = x.AuxInt;
                var sym = x.Aux;
                _ = x.Args[1L];
                var ptr = x.Args[0L];
                var mem = x.Args[1L];
                if (!(x.Uses == 1L && clobber(x)))
                {
                    break;
                }
                b = x.Block;
                var v0 = b.NewValue0(v.Pos, OpPPC64FMOVDload, typ.Float64);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = off;
                v0.Aux = sym;
                v0.AddArg(ptr);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64MaskIfNotCarry_0(ref Value v)
        { 
            // match: (MaskIfNotCarry (ADDconstForCarry [c] (ANDconst [d] _)))
            // cond: c < 0 && d > 0 && c + d < 0
            // result: (MOVDconst [-1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ADDconstForCarry)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpPPC64ANDconst)
                {
                    break;
                }
                var d = v_0_0.AuxInt;
                if (!(c < 0L && d > 0L && c + d < 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = -1L;
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64NotEqual_0(ref Value v)
        { 
            // match: (NotEqual (FlagEQ))
            // cond:
            // result: (MOVDconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagEQ)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (NotEqual (FlagLT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (NotEqual (FlagLT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagLT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (FlagGT))
            // cond:
            // result: (MOVDconst [1])
 
            // match: (NotEqual (FlagGT))
            // cond:
            // result: (MOVDconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64FlagGT)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (InvertFlags x))
            // cond:
            // result: (NotEqual x)
 
            // match: (NotEqual (InvertFlags x))
            // cond:
            // result: (NotEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64InvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpPPC64NotEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (OR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v_0.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
 
            // match: (OR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (OR (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (OR (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
 
            // match: (OR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
 
            // match: (OR (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
 
            // match: (OR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_0_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
 
            // match: (OR (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
 
            // match: (OR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (OR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c|d])
 
            // match: (OR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c|d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c | d;
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_10(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR x (MOVDconst [c]))
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
 
            // match: (OR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64ORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR <t> x0:(MOVBZload [i0] {s} p mem) o1:(SLWconst x1:(MOVBZload [i1] {s} p mem) [8]))
            // cond: !config.BigEndian     && i1 == i0+1     && x0.Uses ==1 && x1.Uses == 1     && o1.Uses == 1     && mergePoint(b, x0, x1) != nil     && clobber(x0) && clobber(x1) && clobber(o1)
            // result: @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
 
            // match: (OR <t> x0:(MOVBZload [i0] {s} p mem) o1:(SLWconst x1:(MOVBZload [i1] {s} p mem) [8]))
            // cond: !config.BigEndian     && i1 == i0+1     && x0.Uses ==1 && x1.Uses == 1     && o1.Uses == 1     && mergePoint(b, x0, x1) != nil     && clobber(x0) && clobber(x1) && clobber(o1)
            // result: @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x0 = v.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                var s = x0.Aux;
                _ = x0.Args[1L];
                var p = x0.Args[0L];
                var mem = x0.Args[1L];
                var o1 = v.Args[1L];
                if (o1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (o1.AuxInt != 8L)
                {
                    break;
                }
                var x1 = o1.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && o1.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(o1)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVHZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o1:(SLWconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))
            // cond: !config.BigEndian     && i1 == i0+1     && x0.Uses ==1 && x1.Uses == 1     && o1.Uses == 1     && mergePoint(b, x0, x1) != nil     && clobber(x0) && clobber(x1) && clobber(o1)
            // result: @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
 
            // match: (OR <t> o1:(SLWconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))
            // cond: !config.BigEndian     && i1 == i0+1     && x0.Uses ==1 && x1.Uses == 1     && o1.Uses == 1     && mergePoint(b, x0, x1) != nil     && clobber(x0) && clobber(x1) && clobber(o1)
            // result: @mergePoint(b,x0,x1) (MOVHZload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o1 = v.Args[0L];
                if (o1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (o1.AuxInt != 8L)
                {
                    break;
                }
                x1 = o1.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = v.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i1 == i0 + 1L && x0.Uses == 1L && x1.Uses == 1L && o1.Uses == 1L && mergePoint(b, x0, x1) != null && clobber(x0) && clobber(x1) && clobber(o1)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVHZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
            // match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var s1 = v.Args[0L];
                if (s1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s1.AuxInt != 24L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x2.AuxInt;
                s = x2.Aux;
                _ = x2.Args[1L];
                p = x2.Args[0L];
                mem = x2.Args[1L];
                var o0 = v.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s0.AuxInt != 16L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i2 == i0 + 2L && i3 == i0 + 3L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && o0.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && mergePoint(b, x0, x1, x2) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
            // match: (OR <t> s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]) o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s1 = v.Args[0L];
                if (s1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s1.AuxInt != 24L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x2.AuxInt;
                s = x2.Aux;
                _ = x2.Args[1L];
                p = x2.Args[0L];
                mem = x2.Args[1L];
                o0 = v.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s0.AuxInt != 16L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i2 == i0 + 2L && i3 == i0 + 3L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && o0.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && mergePoint(b, x0, x1, x2) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
            // match: (OR <t> o0:(OR <t> s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16]) x0:(MOVHZload [i0] {s} p mem)) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o0 = v.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s0.AuxInt != 16L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = v.Args[1L];
                if (s1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s1.AuxInt != 24L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i2 == i0 + 2L && i3 == i0 + 3L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && o0.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && mergePoint(b, x0, x1, x2) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
 
            // match: (OR <t> o0:(OR <t> x0:(MOVHZload [i0] {s} p mem) s0:(SLWconst x1:(MOVBZload [i2] {s} p mem) [16])) s1:(SLWconst x2:(MOVBZload [i3] {s} p mem) [24]))
            // cond: !config.BigEndian     && i2 == i0+2     && i3 == i0+3     && x0.Uses ==1 && x1.Uses == 1 && x2.Uses == 1     && o0.Uses == 1     && s0.Uses == 1 && s1.Uses == 1     && mergePoint(b, x0, x1, x2) != nil     && clobber(x0) && clobber(x1) && clobber(x2)     && clobber(s0) && clobber(s1)     && clobber(o0)
            // result: @mergePoint(b,x0,x1,x2) (MOVWZload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o0 = v.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVHZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s0.AuxInt != 16L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = v.Args[1L];
                if (s1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                if (s1.AuxInt != 24L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i2 == i0 + 2L && i3 == i0 + 3L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && o0.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && mergePoint(b, x0, x1, x2) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(s0) && clobber(s1) && clobber(o0)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWZload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_20(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_30(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_40(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_50(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_60(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_70(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_80(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                var s = x7.Aux;
                _ = x7.Args[1L];
                var p = x7.Args[0L];
                var mem = x7.Args[1L];
                var o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]) o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                s6 = v.Args[0L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                s = x7.Aux;
                _ = x7.Args[1L];
                p = x7.Args[0L];
                mem = x7.Args[1L];
                o5 = v.Args[1L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_90(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                var s = x6.Aux;
                _ = x6.Args[1L];
                var p = x6.Args[0L];
                var mem = x6.Args[1L];
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_100(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                var s = x6.Aux;
                _ = x6.Args[1L];
                var p = x6.Args[0L];
                var mem = x6.Args[1L];
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_110(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                var s = x6.Aux;
                _ = x6.Args[1L];
                var p = x6.Args[0L];
                var mem = x6.Args[1L];
                var o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48]) o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]))) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                s5 = o5.Args[0L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                s = x6.Aux;
                _ = x6.Args[1L];
                p = x6.Args[0L];
                mem = x6.Args[1L];
                o4 = o5.Args[1L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_120(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                var s = x5.Aux;
                _ = x5.Args[1L];
                var p = x5.Args[0L];
                var mem = x5.Args[1L];
                var o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40]) o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]))) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                s4 = o4.Args[0L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                s = x5.Aux;
                _ = x5.Args[1L];
                p = x5.Args[0L];
                mem = x5.Args[1L];
                o3 = o4.Args[1L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_130(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                var s = x4.Aux;
                _ = x4.Args[1L];
                var p = x4.Args[0L];
                var mem = x4.Args[1L];
                var o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32]) o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]))) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                s3 = o3.Args[0L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                s = x4.Aux;
                _ = x4.Args[1L];
                p = x4.Args[0L];
                mem = x4.Args[1L];
                o2 = o3.Args[1L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                s = x3.Aux;
                _ = x3.Args[1L];
                p = x3.Args[0L];
                mem = x3.Args[1L];
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                s = x3.Aux;
                _ = x3.Args[1L];
                p = x3.Args[0L];
                mem = x3.Args[1L];
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64OR_140(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                var o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                var o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                var o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                var s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                var x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i3 = x3.AuxInt;
                var s = x3.Aux;
                _ = x3.Args[1L];
                var p = x3.Args[0L];
                var mem = x3.Args[1L];
                var o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                var o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                var s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                var x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                var x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                var s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                var x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                var s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                var x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                var s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                var x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                var s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                var x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                var s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                var x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                var i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24]) o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]))) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                s2 = o2.Args[0L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                s = x3.Aux;
                _ = x3.Args[1L];
                p = x3.Args[0L];
                mem = x3.Args[1L];
                o1 = o2.Args[1L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                s = x2.Aux;
                _ = x2.Args[1L];
                p = x2.Args[0L];
                mem = x2.Args[1L];
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16]) o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]))) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                s1 = o1.Args[0L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                s = x2.Aux;
                _ = x2.Args[1L];
                p = x2.Args[0L];
                mem = x2.Args[1L];
                o0 = o1.Args[1L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8]) x0:(MOVBZload [i0] {s} p mem)) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                s0 = o0.Args[0L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                s = x1.Aux;
                _ = x1.Args[1L];
                p = x1.Args[0L];
                mem = x1.Args[1L];
                x0 = o0.Args[1L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                if (x0.Aux != s)
                {
                    break;
                }
                _ = x0.Args[1L];
                if (p != x0.Args[0L])
                {
                    break;
                }
                if (mem != x0.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            } 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
 
            // match: (OR <t> o5:(OR <t> o4:(OR <t> o3:(OR <t> o2:(OR <t> o1:(OR <t> o0:(OR <t> x0:(MOVBZload [i0] {s} p mem) s0:(SLDconst x1:(MOVBZload [i1] {s} p mem) [8])) s1:(SLDconst x2:(MOVBZload [i2] {s} p mem) [16])) s2:(SLDconst x3:(MOVBZload [i3] {s} p mem) [24])) s3:(SLDconst x4:(MOVBZload [i4] {s} p mem) [32])) s4:(SLDconst x5:(MOVBZload [i5] {s} p mem) [40])) s5:(SLDconst x6:(MOVBZload [i6] {s} p mem) [48])) s6:(SLDconst x7:(MOVBZload [i7] {s} p mem) [56]))
            // cond: !config.BigEndian     && i0%4 == 0     && i1 == i0+1     && i2 == i0+2     && i3 == i0+3     && i4 == i0+4     && i5 == i0+5     && i6 == i0+6     && i7 == i0+7     && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && x3.Uses == 1 && x4.Uses == 1 && x5.Uses == 1 && x6.Uses ==1 && x7.Uses == 1     && o0.Uses == 1 && o1.Uses == 1 && o2.Uses == 1 && o3.Uses == 1 && o4.Uses == 1 && o5.Uses == 1     && s0.Uses == 1 && s1.Uses == 1 && s2.Uses == 1 && s3.Uses == 1 && s4.Uses == 1 && s5.Uses == 1 && s6.Uses == 1     && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != nil     && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7)     && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber (s6)     && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)
            // result: @mergePoint(b,x0,x1,x2,x3,x4,x5,x6,x7) (MOVDload <t> {s} [i0] p mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                o5 = v.Args[0L];
                if (o5.Op != OpPPC64OR)
                {
                    break;
                }
                if (o5.Type != t)
                {
                    break;
                }
                _ = o5.Args[1L];
                o4 = o5.Args[0L];
                if (o4.Op != OpPPC64OR)
                {
                    break;
                }
                if (o4.Type != t)
                {
                    break;
                }
                _ = o4.Args[1L];
                o3 = o4.Args[0L];
                if (o3.Op != OpPPC64OR)
                {
                    break;
                }
                if (o3.Type != t)
                {
                    break;
                }
                _ = o3.Args[1L];
                o2 = o3.Args[0L];
                if (o2.Op != OpPPC64OR)
                {
                    break;
                }
                if (o2.Type != t)
                {
                    break;
                }
                _ = o2.Args[1L];
                o1 = o2.Args[0L];
                if (o1.Op != OpPPC64OR)
                {
                    break;
                }
                if (o1.Type != t)
                {
                    break;
                }
                _ = o1.Args[1L];
                o0 = o1.Args[0L];
                if (o0.Op != OpPPC64OR)
                {
                    break;
                }
                if (o0.Type != t)
                {
                    break;
                }
                _ = o0.Args[1L];
                x0 = o0.Args[0L];
                if (x0.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i0 = x0.AuxInt;
                s = x0.Aux;
                _ = x0.Args[1L];
                p = x0.Args[0L];
                mem = x0.Args[1L];
                s0 = o0.Args[1L];
                if (s0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s0.AuxInt != 8L)
                {
                    break;
                }
                x1 = s0.Args[0L];
                if (x1.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i1 = x1.AuxInt;
                if (x1.Aux != s)
                {
                    break;
                }
                _ = x1.Args[1L];
                if (p != x1.Args[0L])
                {
                    break;
                }
                if (mem != x1.Args[1L])
                {
                    break;
                }
                s1 = o1.Args[1L];
                if (s1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s1.AuxInt != 16L)
                {
                    break;
                }
                x2 = s1.Args[0L];
                if (x2.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i2 = x2.AuxInt;
                if (x2.Aux != s)
                {
                    break;
                }
                _ = x2.Args[1L];
                if (p != x2.Args[0L])
                {
                    break;
                }
                if (mem != x2.Args[1L])
                {
                    break;
                }
                s2 = o2.Args[1L];
                if (s2.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s2.AuxInt != 24L)
                {
                    break;
                }
                x3 = s2.Args[0L];
                if (x3.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i3 = x3.AuxInt;
                if (x3.Aux != s)
                {
                    break;
                }
                _ = x3.Args[1L];
                if (p != x3.Args[0L])
                {
                    break;
                }
                if (mem != x3.Args[1L])
                {
                    break;
                }
                s3 = o3.Args[1L];
                if (s3.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s3.AuxInt != 32L)
                {
                    break;
                }
                x4 = s3.Args[0L];
                if (x4.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i4 = x4.AuxInt;
                if (x4.Aux != s)
                {
                    break;
                }
                _ = x4.Args[1L];
                if (p != x4.Args[0L])
                {
                    break;
                }
                if (mem != x4.Args[1L])
                {
                    break;
                }
                s4 = o4.Args[1L];
                if (s4.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s4.AuxInt != 40L)
                {
                    break;
                }
                x5 = s4.Args[0L];
                if (x5.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i5 = x5.AuxInt;
                if (x5.Aux != s)
                {
                    break;
                }
                _ = x5.Args[1L];
                if (p != x5.Args[0L])
                {
                    break;
                }
                if (mem != x5.Args[1L])
                {
                    break;
                }
                s5 = o5.Args[1L];
                if (s5.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s5.AuxInt != 48L)
                {
                    break;
                }
                x6 = s5.Args[0L];
                if (x6.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i6 = x6.AuxInt;
                if (x6.Aux != s)
                {
                    break;
                }
                _ = x6.Args[1L];
                if (p != x6.Args[0L])
                {
                    break;
                }
                if (mem != x6.Args[1L])
                {
                    break;
                }
                s6 = v.Args[1L];
                if (s6.Op != OpPPC64SLDconst)
                {
                    break;
                }
                if (s6.AuxInt != 56L)
                {
                    break;
                }
                x7 = s6.Args[0L];
                if (x7.Op != OpPPC64MOVBZload)
                {
                    break;
                }
                i7 = x7.AuxInt;
                if (x7.Aux != s)
                {
                    break;
                }
                _ = x7.Args[1L];
                if (p != x7.Args[0L])
                {
                    break;
                }
                if (mem != x7.Args[1L])
                {
                    break;
                }
                if (!(!config.BigEndian && i0 % 4L == 0L && i1 == i0 + 1L && i2 == i0 + 2L && i3 == i0 + 3L && i4 == i0 + 4L && i5 == i0 + 5L && i6 == i0 + 6L && i7 == i0 + 7L && x0.Uses == 1L && x1.Uses == 1L && x2.Uses == 1L && x3.Uses == 1L && x4.Uses == 1L && x5.Uses == 1L && x6.Uses == 1L && x7.Uses == 1L && o0.Uses == 1L && o1.Uses == 1L && o2.Uses == 1L && o3.Uses == 1L && o4.Uses == 1L && o5.Uses == 1L && s0.Uses == 1L && s1.Uses == 1L && s2.Uses == 1L && s3.Uses == 1L && s4.Uses == 1L && s5.Uses == 1L && s6.Uses == 1L && mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7) != null && clobber(x0) && clobber(x1) && clobber(x2) && clobber(x3) && clobber(x4) && clobber(x5) && clobber(x6) && clobber(x7) && clobber(s0) && clobber(s1) && clobber(s2) && clobber(s3) && clobber(s4) && clobber(s5) && clobber(s6) && clobber(o0) && clobber(o1) && clobber(o2) && clobber(o3) && clobber(o4) && clobber(o5)))
                {
                    break;
                }
                b = mergePoint(b, x0, x1, x2, x3, x4, x5, x6, x7);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDload, t);
                v.reset(OpCopy);
                v.AddArg(v0);
                v0.AuxInt = i0;
                v0.Aux = s;
                v0.AddArg(p);
                v0.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64ORN_0(ref Value v)
        { 
            // match: (ORN x (MOVDconst [-1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64ORconst_0(ref Value v)
        { 
            // match: (ORconst [c] (ORconst [d] x))
            // cond:
            // result: (ORconst [c|d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64ORconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpPPC64ORconst);
                v.AuxInt = c | d;
                v.AddArg(x);
                return true;
            } 
            // match: (ORconst [-1] _)
            // cond:
            // result: (MOVDconst [-1])
 
            // match: (ORconst [-1] _)
            // cond:
            // result: (MOVDconst [-1])
            while (true)
            {
                if (v.AuxInt != -1L)
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORconst [0] x)
            // cond:
            // result: x
 
            // match: (ORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64SUB_0(ref Value v)
        { 
            // match: (SUB x (MOVDconst [c]))
            // cond: is32Bit(-c)
            // result: (ADDconst [-c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(is32Bit(-c)))
                {
                    break;
                }
                v.reset(OpPPC64ADDconst);
                v.AuxInt = -c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64XOR_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (XOR (SLDconst x [c]) (SRDconst x [d]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v_0.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRDconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
 
            // match: (XOR (SRDconst x [d]) (SLDconst x [c]))
            // cond: d == 64-c
            // result: (ROTLconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 64L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (XOR (SLWconst x [c]) (SRWconst x [d]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
 
            // match: (XOR (SRWconst x [d]) (SLWconst x [c]))
            // cond: d == 32-c
            // result: (ROTLWconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(d == 32L - c))
                {
                    break;
                }
                v.reset(OpPPC64ROTLWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
 
            // match: (XOR (SLD x (ANDconst <typ.Int64> [63] y)) (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_0_1.AuxInt != 63L)
                {
                    break;
                }
                var y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
 
            // match: (XOR (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y))) (SLD x (ANDconst <typ.Int64> [63] y)))
            // cond:
            // result: (ROTL x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                var v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 64L)
                {
                    break;
                }
                var v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int64)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
 
            // match: (XOR (SLW x (ANDconst <typ.Int32> [31] y)) (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_0_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
 
            // match: (XOR (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y))) (SLW x (ANDconst <typ.Int32> [31] y)))
            // cond:
            // result: (ROTLW x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64SRW)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_0_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_0_1.Args[1L];
                v_0_1_0 = v_0_1.Args[0L];
                if (v_0_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_0_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_0_1_1 = v_0_1.Args[1L];
                if (v_0_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_0_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_0_1_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_0_1_1.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SLW)
                {
                    break;
                }
                _ = v_1.Args[1L];
                if (x != v_1.Args[0L])
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.Int32)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                if (y != v_1_1.Args[0L])
                {
                    break;
                }
                v.reset(OpPPC64ROTLW);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XOR (MOVDconst [c]) (MOVDconst [d]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                d = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (XOR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c^d])
 
            // match: (XOR (MOVDconst [d]) (MOVDconst [c]))
            // cond:
            // result: (MOVDconst [c^d])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = c ^ d;
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64XOR_10(ref Value v)
        { 
            // match: (XOR x (MOVDconst [c]))
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64XORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
 
            // match: (XOR (MOVDconst [c]) x)
            // cond: isU32Bit(c)
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isU32Bit(c)))
                {
                    break;
                }
                v.reset(OpPPC64XORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPPC64XORconst_0(ref Value v)
        { 
            // match: (XORconst [c] (XORconst [d] x))
            // cond:
            // result: (XORconst [c^d] x)
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpPPC64XORconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpPPC64XORconst);
                v.AuxInt = c ^ d;
                v.AddArg(x);
                return true;
            } 
            // match: (XORconst [0] x)
            // cond:
            // result: x
 
            // match: (XORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpPopCount16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PopCount16 x)
            // cond:
            // result: (POPCNTW (MOVHZreg x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTW);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVHZreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpPopCount32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PopCount32 x)
            // cond:
            // result: (POPCNTW (MOVWZreg x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTW);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVWZreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpPopCount64_0(ref Value v)
        { 
            // match: (PopCount64 x)
            // cond:
            // result: (POPCNTD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpPopCount8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (PopCount8 x)
            // cond:
            // result: (POPCNTB (MOVBreg x))
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64POPCNTB);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVBreg, typ.Int64);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRound32F_0(ref Value v)
        { 
            // match: (Round32F x)
            // cond:
            // result: (LoweredRound32F x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64LoweredRound32F);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRound64F_0(ref Value v)
        { 
            // match: (Round64F x)
            // cond:
            // result: (LoweredRound64F x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64LoweredRound64F);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux16 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux32 x (Const64 [c]))
            // cond: uint32(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
 
            // match: (Rsh16Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux32 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
 
            // match: (Rsh16Ux32 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (MOVDconst [0])
 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh16Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
 
            // match: (Rsh16Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SRWconst (ZeroExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux64 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
 
            // match: (Rsh16Ux64 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux8 x y)
            // cond:
            // result: (SRW  (ZeroExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x16 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x32 x (Const64 [c]))
            // cond: uint32(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
 
            // match: (Rsh16x32 x (MOVDconst [c]))
            // cond: uint32(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x32 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
 
            // match: (Rsh16x32 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (SRAWconst (SignExt16to32 x) [63])
 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (SRAWconst (SignExt16to32 x) [63])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = 63L;
                v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
 
            // match: (Rsh16x64 x (MOVDconst [c]))
            // cond: uint64(c) < 16
            // result: (SRAWconst (SignExt16to32 x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x64 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
 
            // match: (Rsh16x64 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x8 x y)
            // cond:
            // result: (SRAW (SignExt16to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-16] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -16L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux16 x y)
            // cond:
            // result: (SRW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux32 x (Const64 [c]))
            // cond: uint32(c) < 32
            // result: (SRWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SRWconst x [c])
 
            // match: (Rsh32Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SRWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux32 x y)
            // cond:
            // result: (SRW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
 
            // match: (Rsh32Ux32 x y)
            // cond:
            // result: (SRW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SRWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (MOVDconst [0])
 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh32Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SRWconst x [c])
 
            // match: (Rsh32Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SRWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SRW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Rsh32Ux64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SRW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SRW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Rsh32Ux64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SRW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x (ANDconst <typ.UInt> [31] y))
            // cond:
            // result: (SRW x (ANDconst <typ.UInt> [31] y))
 
            // match: (Rsh32Ux64 x (ANDconst <typ.UInt> [31] y))
            // cond:
            // result: (SRW x (ANDconst <typ.UInt> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_1_1.Args[0L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31]))))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31]))))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                y = v_1_1.Args[0L];
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 31L)
                {
                    break;
                }
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> (MOVDconst [31]) y)))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32Ux64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> (MOVDconst [31]) y)))
            // cond:
            // result: (SRW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_1_1.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32Ux64 x y)
            // cond:
            // result: (SRW  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
 
            // match: (Rsh32Ux64 x y)
            // cond:
            // result: (SRW  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux8 x y)
            // cond:
            // result: (SRW x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x16 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x32 x (Const64 [c]))
            // cond: uint32(c) < 32
            // result: (SRAWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SRAWconst x [c])
 
            // match: (Rsh32x32 x (MOVDconst [c]))
            // cond: uint32(c) < 32
            // result: (SRAWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x32 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
 
            // match: (Rsh32x32 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SRAWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (SRAWconst x [63])
 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (SRAWconst x [63])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SRAWconst x [c])
 
            // match: (Rsh32x64 x (MOVDconst [c]))
            // cond: uint64(c) < 32
            // result: (SRAWconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SRAW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Rsh32x64 x (AND y (MOVDconst [31])))
            // cond:
            // result: (SRAW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SRAW x (ANDconst <typ.Int32> [31] y))
 
            // match: (Rsh32x64 x (AND (MOVDconst [31]) y))
            // cond:
            // result: (SRAW x (ANDconst <typ.Int32> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int32);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x (ANDconst <typ.UInt> [31] y))
            // cond:
            // result: (SRAW x (ANDconst <typ.UInt> [31] y))
 
            // match: (Rsh32x64 x (ANDconst <typ.UInt> [31] y))
            // cond:
            // result: (SRAW x (ANDconst <typ.UInt> [31] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v0.AuxInt = 31L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1.AuxInt != 31L)
                {
                    break;
                }
                y = v_1_1.Args[0L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31]))))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> y (MOVDconst [31]))))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                y = v_1_1.Args[0L];
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 31L)
                {
                    break;
                }
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> (MOVDconst [31]) y)))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
 
            // match: (Rsh32x64 x (SUB <typ.UInt> (MOVDconst [32]) (AND <typ.UInt> (MOVDconst [31]) y)))
            // cond:
            // result: (SRAW x (SUB <typ.UInt> (MOVDconst [32]) (ANDconst <typ.UInt> [31] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 32L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 31L)
                {
                    break;
                }
                y = v_1_1.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 32L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 31L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh32x64 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
 
            // match: (Rsh32x64 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x8 x y)
            // cond:
            // result: (SRAW x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-32] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -32L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux16 x y)
            // cond:
            // result: (SRD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux32 x (Const64 [c]))
            // cond: uint32(c) < 64
            // result: (SRDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SRDconst x [c])
 
            // match: (Rsh64Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SRDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64Ux32 x y)
            // cond:
            // result: (SRD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
 
            // match: (Rsh64Ux32 x y)
            // cond:
            // result: (SRD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux64 x (Const64 [c]))
            // cond: uint64(c) < 64
            // result: (SRDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (MOVDconst [0])
 
            // match: (Rsh64Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 64L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh64Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SRDconst x [c])
 
            // match: (Rsh64Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SRDconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64Ux64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SRD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Rsh64Ux64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SRD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SRD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Rsh64Ux64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SRD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x (ANDconst <typ.UInt> [63] y))
            // cond:
            // result: (SRD x (ANDconst <typ.UInt> [63] y))
 
            // match: (Rsh64Ux64 x (ANDconst <typ.UInt> [63] y))
            // cond:
            // result: (SRD x (ANDconst <typ.UInt> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_1_1.Args[0L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63]))))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63]))))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                y = v_1_1.Args[0L];
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 63L)
                {
                    break;
                }
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> (MOVDconst [63]) y)))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64Ux64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> (MOVDconst [63]) y)))
            // cond:
            // result: (SRD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_1_1.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64Ux64 x y)
            // cond:
            // result: (SRD  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
 
            // match: (Rsh64Ux64 x y)
            // cond:
            // result: (SRD  x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64Ux8 x y)
            // cond:
            // result: (SRD x  (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x16 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x32 x (Const64 [c]))
            // cond: uint32(c) < 64
            // result: (SRADconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRADconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SRADconst x [c])
 
            // match: (Rsh64x32 x (MOVDconst [c]))
            // cond: uint32(c) < 64
            // result: (SRADconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRADconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x32 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
 
            // match: (Rsh64x32 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x64 x (Const64 [c]))
            // cond: uint64(c) < 64
            // result: (SRADconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRADconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x64 x (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (SRADconst x [63])
 
            // match: (Rsh64x64 x (Const64 [c]))
            // cond: uint64(c) >= 64
            // result: (SRADconst x [63])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRADconst);
                v.AuxInt = 63L;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SRADconst x [c])
 
            // match: (Rsh64x64 x (MOVDconst [c]))
            // cond: uint64(c) < 64
            // result: (SRADconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 64L))
                {
                    break;
                }
                v.reset(OpPPC64SRADconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh64x64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SRAD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Rsh64x64 x (AND y (MOVDconst [63])))
            // cond:
            // result: (SRAD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SRAD x (ANDconst <typ.Int64> [63] y))
 
            // match: (Rsh64x64 x (AND (MOVDconst [63]) y))
            // cond:
            // result: (SRAD x (ANDconst <typ.Int64> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64AND)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.Int64);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x (ANDconst <typ.UInt> [63] y))
            // cond:
            // result: (SRAD x (ANDconst <typ.UInt> [63] y))
 
            // match: (Rsh64x64 x (ANDconst <typ.UInt> [63] y))
            // cond:
            // result: (SRAD x (ANDconst <typ.UInt> [63] y))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v0.AuxInt = 63L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64ANDconst)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                if (v_1_1.AuxInt != 63L)
                {
                    break;
                }
                y = v_1_1.Args[0L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63]))))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> y (MOVDconst [63]))))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                y = v_1_1.Args[0L];
                var v_1_1_1 = v_1_1.Args[1L];
                if (v_1_1_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_1.AuxInt != 63L)
                {
                    break;
                }
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> (MOVDconst [63]) y)))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
 
            // match: (Rsh64x64 x (SUB <typ.UInt> (MOVDconst [64]) (AND <typ.UInt> (MOVDconst [63]) y)))
            // cond:
            // result: (SRAD x (SUB <typ.UInt> (MOVDconst [64]) (ANDconst <typ.UInt> [63] y)))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64SUB)
                {
                    break;
                }
                if (v_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1.Args[1L];
                v_1_0 = v_1.Args[0L];
                if (v_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_0.AuxInt != 64L)
                {
                    break;
                }
                v_1_1 = v_1.Args[1L];
                if (v_1_1.Op != OpPPC64AND)
                {
                    break;
                }
                if (v_1_1.Type != typ.UInt)
                {
                    break;
                }
                _ = v_1_1.Args[1L];
                var v_1_1_0 = v_1_1.Args[0L];
                if (v_1_1_0.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                if (v_1_1_0.AuxInt != 63L)
                {
                    break;
                }
                y = v_1_1.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64SUB, typ.UInt);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDconst, typ.Int64);
                v1.AuxInt = 64L;
                v0.AddArg(v1);
                v2 = b.NewValue0(v.Pos, OpPPC64ANDconst, typ.UInt);
                v2.AuxInt = 63L;
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh64x64 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
 
            // match: (Rsh64x64 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                y = v.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                v2.AddArg(y);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh64x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh64x8 x y)
            // cond:
            // result: (SRAD x (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-64] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAD);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v0.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v2 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v2.AuxInt = -64L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux16 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux32 x (Const64 [c]))
            // cond: uint32(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
 
            // match: (Rsh8Ux32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux32 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
 
            // match: (Rsh8Ux32 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (MOVDconst [0])
 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (MOVDconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Rsh8Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
 
            // match: (Rsh8Ux64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SRWconst (ZeroExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux64 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
 
            // match: (Rsh8Ux64 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux8 x y)
            // cond:
            // result: (SRW  (ZeroExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRW);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x16 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt16to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x32 x (Const64 [c]))
            // cond: uint32(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
 
            // match: (Rsh8x32 x (MOVDconst [c]))
            // cond: uint32(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint32(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x32 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
 
            // match: (Rsh8x32 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt32to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (SRAWconst (SignExt8to32  x) [63])
 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (SRAWconst (SignExt8to32  x) [63])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = 63L;
                v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
 
            // match: (Rsh8x64 x (MOVDconst [c]))
            // cond: uint64(c) < 8
            // result: (SRAWconst (SignExt8to32  x) [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpPPC64MOVDconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpPPC64SRAWconst);
                v.AuxInt = c;
                v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x64 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
 
            // match: (Rsh8x64 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] y))))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                v3.AddArg(y);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpRsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x8 x y)
            // cond:
            // result: (SRAW (SignExt8to32 x) (ORN y <typ.Int64> (MaskIfNotCarry (ADDconstForCarry [-8] (ZeroExt8to64 y)))))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SRAW);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpPPC64ORN, typ.Int64);
                v1.AddArg(y);
                var v2 = b.NewValue0(v.Pos, OpPPC64MaskIfNotCarry, typ.Int64);
                var v3 = b.NewValue0(v.Pos, OpPPC64ADDconstForCarry, types.TypeFlags);
                v3.AuxInt = -8L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64);
                v4.AddArg(y);
                v3.AddArg(v4);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt16to32_0(ref Value v)
        { 
            // match: (SignExt16to32 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt16to64_0(ref Value v)
        { 
            // match: (SignExt16to64 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt32to64_0(ref Value v)
        { 
            // match: (SignExt32to64 x)
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVWreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt8to16_0(ref Value v)
        { 
            // match: (SignExt8to16 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt8to32_0(ref Value v)
        { 
            // match: (SignExt8to32 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSignExt8to64_0(ref Value v)
        { 
            // match: (SignExt8to64 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSlicemask_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Slicemask <t> x)
            // cond:
            // result: (SRADconst (NEG <t> x) [63])
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpPPC64SRADconst);
                v.AuxInt = 63L;
                var v0 = b.NewValue0(v.Pos, OpPPC64NEG, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSqrt_0(ref Value v)
        { 
            // match: (Sqrt x)
            // cond:
            // result: (FSQRT x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FSQRT);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpStaticCall_0(ref Value v)
        { 
            // match: (StaticCall [argwid] {target} mem)
            // cond:
            // result: (CALLstatic [argwid] {target} mem)
            while (true)
            {
                var argwid = v.AuxInt;
                var target = v.Aux;
                var mem = v.Args[0L];
                v.reset(OpPPC64CALLstatic);
                v.AuxInt = argwid;
                v.Aux = target;
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpStore_0(ref Value v)
        { 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
            // result: (FMOVDstore ptr val mem)
            while (true)
            {
                var t = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && is64BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is32BitFloat(val.Type)
            // result: (FMOVDstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is32BitFloat(val.Type)
            // result: (FMOVDstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (FMOVSstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (FMOVSstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpPPC64FMOVSstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))
            // result: (MOVDstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && (is64BitInt(val.Type) || isPtr(val.Type))
            // result: (MOVDstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && (is64BitInt(val.Type) || isPtr(val.Type))))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitInt(val.Type)
            // result: (MOVWstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitInt(val.Type)
            // result: (MOVWstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && is32BitInt(val.Type)))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 2L))
                {
                    break;
                }
                v.reset(OpPPC64MOVHstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 1L))
                {
                    break;
                }
                v.reset(OpPPC64MOVBstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpSub16_0(ref Value v)
        { 
            // match: (Sub16 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSub32_0(ref Value v)
        { 
            // match: (Sub32 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSub32F_0(ref Value v)
        { 
            // match: (Sub32F x y)
            // cond:
            // result: (FSUBS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FSUBS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSub64_0(ref Value v)
        { 
            // match: (Sub64 x y)
            // cond:
            // result: (SUB  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSub64F_0(ref Value v)
        { 
            // match: (Sub64F x y)
            // cond:
            // result: (FSUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64FSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSub8_0(ref Value v)
        { 
            // match: (Sub8 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpSubPtr_0(ref Value v)
        { 
            // match: (SubPtr x y)
            // cond:
            // result: (SUB  x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64SUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc_0(ref Value v)
        { 
            // match: (Trunc x)
            // cond:
            // result: (FTRUNC x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64FTRUNC);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc16to8_0(ref Value v)
        { 
            // match: (Trunc16to8 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc32to16_0(ref Value v)
        { 
            // match: (Trunc32to16 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc32to8_0(ref Value v)
        { 
            // match: (Trunc32to8 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc64to16_0(ref Value v)
        { 
            // match: (Trunc64to16 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc64to32_0(ref Value v)
        { 
            // match: (Trunc64to32 x)
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVWreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpTrunc64to8_0(ref Value v)
        { 
            // match: (Trunc64to8 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpXor16_0(ref Value v)
        { 
            // match: (Xor16 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpXor32_0(ref Value v)
        { 
            // match: (Xor32 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpXor64_0(ref Value v)
        { 
            // match: (Xor64 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpXor8_0(ref Value v)
        { 
            // match: (Xor8 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpPPC64XOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZero_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Zero [0] _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[1L];
                var mem = v.Args[1L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstorezero destptr mem)
 
            // match: (Zero [1] destptr mem)
            // cond:
            // result: (MOVBstorezero destptr mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVBstorezero);
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVHstorezero destptr mem)
 
            // match: (Zero [2] destptr mem)
            // cond:
            // result: (MOVHstorezero destptr mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVHstorezero);
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstorezero [2] destptr         (MOVHstorezero destptr mem))
 
            // match: (Zero [3] destptr mem)
            // cond:
            // result: (MOVBstorezero [2] destptr         (MOVHstorezero destptr mem))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = 2L;
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVHstorezero, types.TypeMem);
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVWstorezero destptr mem)
 
            // match: (Zero [4] destptr mem)
            // cond:
            // result: (MOVWstorezero destptr mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVWstorezero);
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstorezero [4] destptr             (MOVWstorezero destptr mem))
 
            // match: (Zero [5] destptr mem)
            // cond:
            // result: (MOVBstorezero [4] destptr             (MOVWstorezero destptr mem))
            while (true)
            {
                if (v.AuxInt != 5L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = 4L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem);
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVHstorezero [4] destptr         (MOVWstorezero destptr mem))
 
            // match: (Zero [6] destptr mem)
            // cond:
            // result: (MOVHstorezero [4] destptr         (MOVWstorezero destptr mem))
            while (true)
            {
                if (v.AuxInt != 6L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVHstorezero);
                v.AuxInt = 4L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem);
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVBstorezero [6] destptr         (MOVHstorezero [4] destptr             (MOVWstorezero destptr mem)))
 
            // match: (Zero [7] destptr mem)
            // cond:
            // result: (MOVBstorezero [6] destptr         (MOVHstorezero [4] destptr             (MOVWstorezero destptr mem)))
            while (true)
            {
                if (v.AuxInt != 7L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVBstorezero);
                v.AuxInt = 6L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVHstorezero, types.TypeMem);
                v0.AuxInt = 4L;
                v0.AddArg(destptr);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem);
                v1.AddArg(destptr);
                v1.AddArg(mem);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [8] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero destptr mem)
 
            // match: (Zero [8] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero destptr mem)
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                var t = v.Aux;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AddArg(destptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVWstorezero [4] destptr                 (MOVWstorezero [0] destptr mem))
 
            // match: (Zero [8] destptr mem)
            // cond:
            // result: (MOVWstorezero [4] destptr                 (MOVWstorezero [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 8L)
                {
                    break;
                }
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64MOVWstorezero);
                v.AuxInt = 4L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVWstorezero, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValuePPC64_OpZero_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Zero [12] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVWstorezero [8] destptr                 (MOVDstorezero [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 12L)
                {
                    break;
                }
                var t = v.Aux;
                _ = v.Args[1L];
                var destptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVWstorezero);
                v.AuxInt = 8L;
                v.AddArg(destptr);
                var v0 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [16] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [8] destptr                 (MOVDstorezero [0] destptr mem))
 
            // match: (Zero [16] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [8] destptr                 (MOVDstorezero [0] destptr mem))
            while (true)
            {
                if (v.AuxInt != 16L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = 8L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v0.AuxInt = 0L;
                v0.AddArg(destptr);
                v0.AddArg(mem);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [24] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [16] destptr                (MOVDstorezero [8] destptr                        (MOVDstorezero [0] destptr mem)))
 
            // match: (Zero [24] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [16] destptr                (MOVDstorezero [8] destptr                        (MOVDstorezero [0] destptr mem)))
            while (true)
            {
                if (v.AuxInt != 24L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = 16L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v0.AuxInt = 8L;
                v0.AddArg(destptr);
                var v1 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(destptr);
                v1.AddArg(mem);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [32] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [24] destptr                (MOVDstorezero [16] destptr                        (MOVDstorezero [8] destptr                                (MOVDstorezero [0] destptr mem))))
 
            // match: (Zero [32] {t} destptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVDstorezero [24] destptr                (MOVDstorezero [16] destptr                        (MOVDstorezero [8] destptr                                (MOVDstorezero [0] destptr mem))))
            while (true)
            {
                if (v.AuxInt != 32L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[1L];
                destptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpPPC64MOVDstorezero);
                v.AuxInt = 24L;
                v.AddArg(destptr);
                v0 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v0.AuxInt = 16L;
                v0.AddArg(destptr);
                v1 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v1.AuxInt = 8L;
                v1.AddArg(destptr);
                var v2 = b.NewValue0(v.Pos, OpPPC64MOVDstorezero, types.TypeMem);
                v2.AuxInt = 0L;
                v2.AddArg(destptr);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Zero [s] ptr mem)
            // cond:
            // result: (LoweredZero [s] ptr mem)
 
            // match: (Zero [s] ptr mem)
            // cond:
            // result: (LoweredZero [s] ptr mem)
            while (true)
            {
                var s = v.AuxInt;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpPPC64LoweredZero);
                v.AuxInt = s;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt16to32_0(ref Value v)
        { 
            // match: (ZeroExt16to32 x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt16to64_0(ref Value v)
        { 
            // match: (ZeroExt16to64 x)
            // cond:
            // result: (MOVHZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVHZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt32to64_0(ref Value v)
        { 
            // match: (ZeroExt32to64 x)
            // cond:
            // result: (MOVWZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVWZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt8to16_0(ref Value v)
        { 
            // match: (ZeroExt8to16 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt8to32_0(ref Value v)
        { 
            // match: (ZeroExt8to32 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValuePPC64_OpZeroExt8to64_0(ref Value v)
        { 
            // match: (ZeroExt8to64 x)
            // cond:
            // result: (MOVBZreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpPPC64MOVBZreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteBlockPPC64(ref Block b)
        {
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref config.Types;
            _ = typ;

            if (b.Kind == BlockPPC64EQ) 
                // match: (EQ (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (EQ (ANDCCconst [c] x) yes no)
                while (true)
                {
                    var v = b.Control;
                    if (v.Op != OpPPC64CMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    var v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64ANDconst)
                    {
                        break;
                    }
                    var c = v_0.AuxInt;
                    var x = v_0.Args[0L];
                    b.Kind = BlockPPC64EQ;
                    var v0 = b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPWconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (EQ (ANDCCconst [c] x) yes no)
 
                // match: (EQ (CMPWconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (EQ (ANDCCconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64ANDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockPPC64EQ;
                    v0 = b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    var cmp = v.Args[0L];
                    b.Kind = BlockPPC64EQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockPPC64GE) 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockPPC64LE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockPPC64GT) 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockPPC64LT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockIf) 
                // match: (If (Equal cc) yes no)
                // cond:
                // result: (EQ cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64Equal)
                    {
                        break;
                    }
                    var cc = v.Args[0L];
                    b.Kind = BlockPPC64EQ;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (NotEqual cc) yes no)
                // cond:
                // result: (NE cc yes no)
 
                // match: (If (NotEqual cc) yes no)
                // cond:
                // result: (NE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64NotEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64NE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessThan cc) yes no)
                // cond:
                // result: (LT cc yes no)
 
                // match: (If (LessThan cc) yes no)
                // cond:
                // result: (LT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64LessThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64LT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessEqual cc) yes no)
                // cond:
                // result: (LE cc yes no)
 
                // match: (If (LessEqual cc) yes no)
                // cond:
                // result: (LE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64LessEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64LE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterThan cc) yes no)
                // cond:
                // result: (GT cc yes no)
 
                // match: (If (GreaterThan cc) yes no)
                // cond:
                // result: (GT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64GreaterThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64GT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterEqual cc) yes no)
                // cond:
                // result: (GE cc yes no)
 
                // match: (If (GreaterEqual cc) yes no)
                // cond:
                // result: (GE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64GreaterEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64GE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (FLessThan cc) yes no)
                // cond:
                // result: (FLT cc yes no)
 
                // match: (If (FLessThan cc) yes no)
                // cond:
                // result: (FLT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FLessThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64FLT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (FLessEqual cc) yes no)
                // cond:
                // result: (FLE cc yes no)
 
                // match: (If (FLessEqual cc) yes no)
                // cond:
                // result: (FLE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FLessEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64FLE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (FGreaterThan cc) yes no)
                // cond:
                // result: (FGT cc yes no)
 
                // match: (If (FGreaterThan cc) yes no)
                // cond:
                // result: (FGT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FGreaterThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64FGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (FGreaterEqual cc) yes no)
                // cond:
                // result: (FGE cc yes no)
 
                // match: (If (FGreaterEqual cc) yes no)
                // cond:
                // result: (FGE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FGreaterEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockPPC64FGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPWconst [0] cond) yes no)
 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPWconst [0] cond) yes no)
                while (true)
                {
                    v = b.Control;
                    _ = v;
                    var cond = b.Control;
                    b.Kind = BlockPPC64NE;
                    v0 = b.NewValue0(v.Pos, OpPPC64CMPWconst, types.TypeFlags);
                    v0.AuxInt = 0L;
                    v0.AddArg(cond);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockPPC64LE) 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockPPC64GE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockPPC64LT) 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockPPC64GT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockPPC64NE) 
                // match: (NE (CMPWconst [0] (Equal cc)) yes no)
                // cond:
                // result: (EQ cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64Equal)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64EQ;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (NotEqual cc)) yes no)
                // cond:
                // result: (NE cc yes no)
 
                // match: (NE (CMPWconst [0] (NotEqual cc)) yes no)
                // cond:
                // result: (NE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64NotEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64NE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (LessThan cc)) yes no)
                // cond:
                // result: (LT cc yes no)
 
                // match: (NE (CMPWconst [0] (LessThan cc)) yes no)
                // cond:
                // result: (LT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64LessThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64LT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (LessEqual cc)) yes no)
                // cond:
                // result: (LE cc yes no)
 
                // match: (NE (CMPWconst [0] (LessEqual cc)) yes no)
                // cond:
                // result: (LE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64LessEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64LE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (GreaterThan cc)) yes no)
                // cond:
                // result: (GT cc yes no)
 
                // match: (NE (CMPWconst [0] (GreaterThan cc)) yes no)
                // cond:
                // result: (GT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64GreaterThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64GT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (GreaterEqual cc)) yes no)
                // cond:
                // result: (GE cc yes no)
 
                // match: (NE (CMPWconst [0] (GreaterEqual cc)) yes no)
                // cond:
                // result: (GE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64GreaterEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64GE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (FLessThan cc)) yes no)
                // cond:
                // result: (FLT cc yes no)
 
                // match: (NE (CMPWconst [0] (FLessThan cc)) yes no)
                // cond:
                // result: (FLT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64FLessThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64FLT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (FLessEqual cc)) yes no)
                // cond:
                // result: (FLE cc yes no)
 
                // match: (NE (CMPWconst [0] (FLessEqual cc)) yes no)
                // cond:
                // result: (FLE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64FLessEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64FLE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (FGreaterThan cc)) yes no)
                // cond:
                // result: (FGT cc yes no)
 
                // match: (NE (CMPWconst [0] (FGreaterThan cc)) yes no)
                // cond:
                // result: (FGT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64FGreaterThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64FGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (FGreaterEqual cc)) yes no)
                // cond:
                // result: (FGE cc yes no)
 
                // match: (NE (CMPWconst [0] (FGreaterEqual cc)) yes no)
                // cond:
                // result: (FGE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64FGreaterEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockPPC64FGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (ANDCCconst [c] x) yes no)
 
                // match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (ANDCCconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64ANDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockPPC64NE;
                    v0 = b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPWconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (ANDCCconst [c] x) yes no)
 
                // match: (NE (CMPWconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (ANDCCconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64CMPWconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpPPC64ANDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockPPC64NE;
                    v0 = b.NewValue0(v.Pos, OpPPC64ANDCCconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (NE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagLT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64FlagGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpPPC64InvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockPPC64NE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
                        return false;
        }
    }
}}}}
