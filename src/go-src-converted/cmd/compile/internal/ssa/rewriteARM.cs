// Code generated from gen/ARM.rules; DO NOT EDIT.
// generated with: cd gen; go run *.go

// package ssa -- go2cs converted at 2020 August 29 09:05:50 UTC
// import "cmd/compile/internal/ssa" ==> using ssa = go.cmd.compile.@internal.ssa_package
// Original source: C:\Go\src\cmd\compile\internal\ssa\rewriteARM.go
using math = go.math_package;
using obj = go.cmd.@internal.obj_package;
using objabi = go.cmd.@internal.objabi_package;
using types = go.cmd.compile.@internal.types_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        private static var _ = math.MinInt8; // in case not otherwise used
        private static var _ = obj.ANOP; // in case not otherwise used
        private static var _ = objabi.GOROOT; // in case not otherwise used
        private static var _ = types.TypeMem; // in case not otherwise used

        private static bool rewriteValueARM(ref Value v)
        {

            if (v.Op == OpARMADC) 
                return rewriteValueARM_OpARMADC_0(v) || rewriteValueARM_OpARMADC_10(v) || rewriteValueARM_OpARMADC_20(v);
            else if (v.Op == OpARMADCconst) 
                return rewriteValueARM_OpARMADCconst_0(v);
            else if (v.Op == OpARMADCshiftLL) 
                return rewriteValueARM_OpARMADCshiftLL_0(v);
            else if (v.Op == OpARMADCshiftLLreg) 
                return rewriteValueARM_OpARMADCshiftLLreg_0(v);
            else if (v.Op == OpARMADCshiftRA) 
                return rewriteValueARM_OpARMADCshiftRA_0(v);
            else if (v.Op == OpARMADCshiftRAreg) 
                return rewriteValueARM_OpARMADCshiftRAreg_0(v);
            else if (v.Op == OpARMADCshiftRL) 
                return rewriteValueARM_OpARMADCshiftRL_0(v);
            else if (v.Op == OpARMADCshiftRLreg) 
                return rewriteValueARM_OpARMADCshiftRLreg_0(v);
            else if (v.Op == OpARMADD) 
                return rewriteValueARM_OpARMADD_0(v) || rewriteValueARM_OpARMADD_10(v);
            else if (v.Op == OpARMADDD) 
                return rewriteValueARM_OpARMADDD_0(v);
            else if (v.Op == OpARMADDF) 
                return rewriteValueARM_OpARMADDF_0(v);
            else if (v.Op == OpARMADDS) 
                return rewriteValueARM_OpARMADDS_0(v) || rewriteValueARM_OpARMADDS_10(v);
            else if (v.Op == OpARMADDSshiftLL) 
                return rewriteValueARM_OpARMADDSshiftLL_0(v);
            else if (v.Op == OpARMADDSshiftLLreg) 
                return rewriteValueARM_OpARMADDSshiftLLreg_0(v);
            else if (v.Op == OpARMADDSshiftRA) 
                return rewriteValueARM_OpARMADDSshiftRA_0(v);
            else if (v.Op == OpARMADDSshiftRAreg) 
                return rewriteValueARM_OpARMADDSshiftRAreg_0(v);
            else if (v.Op == OpARMADDSshiftRL) 
                return rewriteValueARM_OpARMADDSshiftRL_0(v);
            else if (v.Op == OpARMADDSshiftRLreg) 
                return rewriteValueARM_OpARMADDSshiftRLreg_0(v);
            else if (v.Op == OpARMADDconst) 
                return rewriteValueARM_OpARMADDconst_0(v);
            else if (v.Op == OpARMADDshiftLL) 
                return rewriteValueARM_OpARMADDshiftLL_0(v);
            else if (v.Op == OpARMADDshiftLLreg) 
                return rewriteValueARM_OpARMADDshiftLLreg_0(v);
            else if (v.Op == OpARMADDshiftRA) 
                return rewriteValueARM_OpARMADDshiftRA_0(v);
            else if (v.Op == OpARMADDshiftRAreg) 
                return rewriteValueARM_OpARMADDshiftRAreg_0(v);
            else if (v.Op == OpARMADDshiftRL) 
                return rewriteValueARM_OpARMADDshiftRL_0(v);
            else if (v.Op == OpARMADDshiftRLreg) 
                return rewriteValueARM_OpARMADDshiftRLreg_0(v);
            else if (v.Op == OpARMAND) 
                return rewriteValueARM_OpARMAND_0(v) || rewriteValueARM_OpARMAND_10(v) || rewriteValueARM_OpARMAND_20(v);
            else if (v.Op == OpARMANDconst) 
                return rewriteValueARM_OpARMANDconst_0(v);
            else if (v.Op == OpARMANDshiftLL) 
                return rewriteValueARM_OpARMANDshiftLL_0(v);
            else if (v.Op == OpARMANDshiftLLreg) 
                return rewriteValueARM_OpARMANDshiftLLreg_0(v);
            else if (v.Op == OpARMANDshiftRA) 
                return rewriteValueARM_OpARMANDshiftRA_0(v);
            else if (v.Op == OpARMANDshiftRAreg) 
                return rewriteValueARM_OpARMANDshiftRAreg_0(v);
            else if (v.Op == OpARMANDshiftRL) 
                return rewriteValueARM_OpARMANDshiftRL_0(v);
            else if (v.Op == OpARMANDshiftRLreg) 
                return rewriteValueARM_OpARMANDshiftRLreg_0(v);
            else if (v.Op == OpARMBFX) 
                return rewriteValueARM_OpARMBFX_0(v);
            else if (v.Op == OpARMBFXU) 
                return rewriteValueARM_OpARMBFXU_0(v);
            else if (v.Op == OpARMBIC) 
                return rewriteValueARM_OpARMBIC_0(v);
            else if (v.Op == OpARMBICconst) 
                return rewriteValueARM_OpARMBICconst_0(v);
            else if (v.Op == OpARMBICshiftLL) 
                return rewriteValueARM_OpARMBICshiftLL_0(v);
            else if (v.Op == OpARMBICshiftLLreg) 
                return rewriteValueARM_OpARMBICshiftLLreg_0(v);
            else if (v.Op == OpARMBICshiftRA) 
                return rewriteValueARM_OpARMBICshiftRA_0(v);
            else if (v.Op == OpARMBICshiftRAreg) 
                return rewriteValueARM_OpARMBICshiftRAreg_0(v);
            else if (v.Op == OpARMBICshiftRL) 
                return rewriteValueARM_OpARMBICshiftRL_0(v);
            else if (v.Op == OpARMBICshiftRLreg) 
                return rewriteValueARM_OpARMBICshiftRLreg_0(v);
            else if (v.Op == OpARMCMN) 
                return rewriteValueARM_OpARMCMN_0(v) || rewriteValueARM_OpARMCMN_10(v);
            else if (v.Op == OpARMCMNconst) 
                return rewriteValueARM_OpARMCMNconst_0(v);
            else if (v.Op == OpARMCMNshiftLL) 
                return rewriteValueARM_OpARMCMNshiftLL_0(v);
            else if (v.Op == OpARMCMNshiftLLreg) 
                return rewriteValueARM_OpARMCMNshiftLLreg_0(v);
            else if (v.Op == OpARMCMNshiftRA) 
                return rewriteValueARM_OpARMCMNshiftRA_0(v);
            else if (v.Op == OpARMCMNshiftRAreg) 
                return rewriteValueARM_OpARMCMNshiftRAreg_0(v);
            else if (v.Op == OpARMCMNshiftRL) 
                return rewriteValueARM_OpARMCMNshiftRL_0(v);
            else if (v.Op == OpARMCMNshiftRLreg) 
                return rewriteValueARM_OpARMCMNshiftRLreg_0(v);
            else if (v.Op == OpARMCMOVWHSconst) 
                return rewriteValueARM_OpARMCMOVWHSconst_0(v);
            else if (v.Op == OpARMCMOVWLSconst) 
                return rewriteValueARM_OpARMCMOVWLSconst_0(v);
            else if (v.Op == OpARMCMP) 
                return rewriteValueARM_OpARMCMP_0(v) || rewriteValueARM_OpARMCMP_10(v);
            else if (v.Op == OpARMCMPD) 
                return rewriteValueARM_OpARMCMPD_0(v);
            else if (v.Op == OpARMCMPF) 
                return rewriteValueARM_OpARMCMPF_0(v);
            else if (v.Op == OpARMCMPconst) 
                return rewriteValueARM_OpARMCMPconst_0(v);
            else if (v.Op == OpARMCMPshiftLL) 
                return rewriteValueARM_OpARMCMPshiftLL_0(v);
            else if (v.Op == OpARMCMPshiftLLreg) 
                return rewriteValueARM_OpARMCMPshiftLLreg_0(v);
            else if (v.Op == OpARMCMPshiftRA) 
                return rewriteValueARM_OpARMCMPshiftRA_0(v);
            else if (v.Op == OpARMCMPshiftRAreg) 
                return rewriteValueARM_OpARMCMPshiftRAreg_0(v);
            else if (v.Op == OpARMCMPshiftRL) 
                return rewriteValueARM_OpARMCMPshiftRL_0(v);
            else if (v.Op == OpARMCMPshiftRLreg) 
                return rewriteValueARM_OpARMCMPshiftRLreg_0(v);
            else if (v.Op == OpARMEqual) 
                return rewriteValueARM_OpARMEqual_0(v);
            else if (v.Op == OpARMGreaterEqual) 
                return rewriteValueARM_OpARMGreaterEqual_0(v);
            else if (v.Op == OpARMGreaterEqualU) 
                return rewriteValueARM_OpARMGreaterEqualU_0(v);
            else if (v.Op == OpARMGreaterThan) 
                return rewriteValueARM_OpARMGreaterThan_0(v);
            else if (v.Op == OpARMGreaterThanU) 
                return rewriteValueARM_OpARMGreaterThanU_0(v);
            else if (v.Op == OpARMLessEqual) 
                return rewriteValueARM_OpARMLessEqual_0(v);
            else if (v.Op == OpARMLessEqualU) 
                return rewriteValueARM_OpARMLessEqualU_0(v);
            else if (v.Op == OpARMLessThan) 
                return rewriteValueARM_OpARMLessThan_0(v);
            else if (v.Op == OpARMLessThanU) 
                return rewriteValueARM_OpARMLessThanU_0(v);
            else if (v.Op == OpARMMOVBUload) 
                return rewriteValueARM_OpARMMOVBUload_0(v);
            else if (v.Op == OpARMMOVBUloadidx) 
                return rewriteValueARM_OpARMMOVBUloadidx_0(v);
            else if (v.Op == OpARMMOVBUreg) 
                return rewriteValueARM_OpARMMOVBUreg_0(v);
            else if (v.Op == OpARMMOVBload) 
                return rewriteValueARM_OpARMMOVBload_0(v);
            else if (v.Op == OpARMMOVBloadidx) 
                return rewriteValueARM_OpARMMOVBloadidx_0(v);
            else if (v.Op == OpARMMOVBreg) 
                return rewriteValueARM_OpARMMOVBreg_0(v);
            else if (v.Op == OpARMMOVBstore) 
                return rewriteValueARM_OpARMMOVBstore_0(v);
            else if (v.Op == OpARMMOVBstoreidx) 
                return rewriteValueARM_OpARMMOVBstoreidx_0(v);
            else if (v.Op == OpARMMOVDload) 
                return rewriteValueARM_OpARMMOVDload_0(v);
            else if (v.Op == OpARMMOVDstore) 
                return rewriteValueARM_OpARMMOVDstore_0(v);
            else if (v.Op == OpARMMOVFload) 
                return rewriteValueARM_OpARMMOVFload_0(v);
            else if (v.Op == OpARMMOVFstore) 
                return rewriteValueARM_OpARMMOVFstore_0(v);
            else if (v.Op == OpARMMOVHUload) 
                return rewriteValueARM_OpARMMOVHUload_0(v);
            else if (v.Op == OpARMMOVHUloadidx) 
                return rewriteValueARM_OpARMMOVHUloadidx_0(v);
            else if (v.Op == OpARMMOVHUreg) 
                return rewriteValueARM_OpARMMOVHUreg_0(v);
            else if (v.Op == OpARMMOVHload) 
                return rewriteValueARM_OpARMMOVHload_0(v);
            else if (v.Op == OpARMMOVHloadidx) 
                return rewriteValueARM_OpARMMOVHloadidx_0(v);
            else if (v.Op == OpARMMOVHreg) 
                return rewriteValueARM_OpARMMOVHreg_0(v);
            else if (v.Op == OpARMMOVHstore) 
                return rewriteValueARM_OpARMMOVHstore_0(v);
            else if (v.Op == OpARMMOVHstoreidx) 
                return rewriteValueARM_OpARMMOVHstoreidx_0(v);
            else if (v.Op == OpARMMOVWload) 
                return rewriteValueARM_OpARMMOVWload_0(v);
            else if (v.Op == OpARMMOVWloadidx) 
                return rewriteValueARM_OpARMMOVWloadidx_0(v);
            else if (v.Op == OpARMMOVWloadshiftLL) 
                return rewriteValueARM_OpARMMOVWloadshiftLL_0(v);
            else if (v.Op == OpARMMOVWloadshiftRA) 
                return rewriteValueARM_OpARMMOVWloadshiftRA_0(v);
            else if (v.Op == OpARMMOVWloadshiftRL) 
                return rewriteValueARM_OpARMMOVWloadshiftRL_0(v);
            else if (v.Op == OpARMMOVWreg) 
                return rewriteValueARM_OpARMMOVWreg_0(v);
            else if (v.Op == OpARMMOVWstore) 
                return rewriteValueARM_OpARMMOVWstore_0(v);
            else if (v.Op == OpARMMOVWstoreidx) 
                return rewriteValueARM_OpARMMOVWstoreidx_0(v);
            else if (v.Op == OpARMMOVWstoreshiftLL) 
                return rewriteValueARM_OpARMMOVWstoreshiftLL_0(v);
            else if (v.Op == OpARMMOVWstoreshiftRA) 
                return rewriteValueARM_OpARMMOVWstoreshiftRA_0(v);
            else if (v.Op == OpARMMOVWstoreshiftRL) 
                return rewriteValueARM_OpARMMOVWstoreshiftRL_0(v);
            else if (v.Op == OpARMMUL) 
                return rewriteValueARM_OpARMMUL_0(v) || rewriteValueARM_OpARMMUL_10(v) || rewriteValueARM_OpARMMUL_20(v);
            else if (v.Op == OpARMMULA) 
                return rewriteValueARM_OpARMMULA_0(v) || rewriteValueARM_OpARMMULA_10(v) || rewriteValueARM_OpARMMULA_20(v);
            else if (v.Op == OpARMMULD) 
                return rewriteValueARM_OpARMMULD_0(v);
            else if (v.Op == OpARMMULF) 
                return rewriteValueARM_OpARMMULF_0(v);
            else if (v.Op == OpARMMULS) 
                return rewriteValueARM_OpARMMULS_0(v) || rewriteValueARM_OpARMMULS_10(v) || rewriteValueARM_OpARMMULS_20(v);
            else if (v.Op == OpARMMVN) 
                return rewriteValueARM_OpARMMVN_0(v);
            else if (v.Op == OpARMMVNshiftLL) 
                return rewriteValueARM_OpARMMVNshiftLL_0(v);
            else if (v.Op == OpARMMVNshiftLLreg) 
                return rewriteValueARM_OpARMMVNshiftLLreg_0(v);
            else if (v.Op == OpARMMVNshiftRA) 
                return rewriteValueARM_OpARMMVNshiftRA_0(v);
            else if (v.Op == OpARMMVNshiftRAreg) 
                return rewriteValueARM_OpARMMVNshiftRAreg_0(v);
            else if (v.Op == OpARMMVNshiftRL) 
                return rewriteValueARM_OpARMMVNshiftRL_0(v);
            else if (v.Op == OpARMMVNshiftRLreg) 
                return rewriteValueARM_OpARMMVNshiftRLreg_0(v);
            else if (v.Op == OpARMNEGD) 
                return rewriteValueARM_OpARMNEGD_0(v);
            else if (v.Op == OpARMNEGF) 
                return rewriteValueARM_OpARMNEGF_0(v);
            else if (v.Op == OpARMNMULD) 
                return rewriteValueARM_OpARMNMULD_0(v);
            else if (v.Op == OpARMNMULF) 
                return rewriteValueARM_OpARMNMULF_0(v);
            else if (v.Op == OpARMNotEqual) 
                return rewriteValueARM_OpARMNotEqual_0(v);
            else if (v.Op == OpARMOR) 
                return rewriteValueARM_OpARMOR_0(v) || rewriteValueARM_OpARMOR_10(v);
            else if (v.Op == OpARMORconst) 
                return rewriteValueARM_OpARMORconst_0(v);
            else if (v.Op == OpARMORshiftLL) 
                return rewriteValueARM_OpARMORshiftLL_0(v);
            else if (v.Op == OpARMORshiftLLreg) 
                return rewriteValueARM_OpARMORshiftLLreg_0(v);
            else if (v.Op == OpARMORshiftRA) 
                return rewriteValueARM_OpARMORshiftRA_0(v);
            else if (v.Op == OpARMORshiftRAreg) 
                return rewriteValueARM_OpARMORshiftRAreg_0(v);
            else if (v.Op == OpARMORshiftRL) 
                return rewriteValueARM_OpARMORshiftRL_0(v);
            else if (v.Op == OpARMORshiftRLreg) 
                return rewriteValueARM_OpARMORshiftRLreg_0(v);
            else if (v.Op == OpARMRSB) 
                return rewriteValueARM_OpARMRSB_0(v) || rewriteValueARM_OpARMRSB_10(v);
            else if (v.Op == OpARMRSBSshiftLL) 
                return rewriteValueARM_OpARMRSBSshiftLL_0(v);
            else if (v.Op == OpARMRSBSshiftLLreg) 
                return rewriteValueARM_OpARMRSBSshiftLLreg_0(v);
            else if (v.Op == OpARMRSBSshiftRA) 
                return rewriteValueARM_OpARMRSBSshiftRA_0(v);
            else if (v.Op == OpARMRSBSshiftRAreg) 
                return rewriteValueARM_OpARMRSBSshiftRAreg_0(v);
            else if (v.Op == OpARMRSBSshiftRL) 
                return rewriteValueARM_OpARMRSBSshiftRL_0(v);
            else if (v.Op == OpARMRSBSshiftRLreg) 
                return rewriteValueARM_OpARMRSBSshiftRLreg_0(v);
            else if (v.Op == OpARMRSBconst) 
                return rewriteValueARM_OpARMRSBconst_0(v);
            else if (v.Op == OpARMRSBshiftLL) 
                return rewriteValueARM_OpARMRSBshiftLL_0(v);
            else if (v.Op == OpARMRSBshiftLLreg) 
                return rewriteValueARM_OpARMRSBshiftLLreg_0(v);
            else if (v.Op == OpARMRSBshiftRA) 
                return rewriteValueARM_OpARMRSBshiftRA_0(v);
            else if (v.Op == OpARMRSBshiftRAreg) 
                return rewriteValueARM_OpARMRSBshiftRAreg_0(v);
            else if (v.Op == OpARMRSBshiftRL) 
                return rewriteValueARM_OpARMRSBshiftRL_0(v);
            else if (v.Op == OpARMRSBshiftRLreg) 
                return rewriteValueARM_OpARMRSBshiftRLreg_0(v);
            else if (v.Op == OpARMRSCconst) 
                return rewriteValueARM_OpARMRSCconst_0(v);
            else if (v.Op == OpARMRSCshiftLL) 
                return rewriteValueARM_OpARMRSCshiftLL_0(v);
            else if (v.Op == OpARMRSCshiftLLreg) 
                return rewriteValueARM_OpARMRSCshiftLLreg_0(v);
            else if (v.Op == OpARMRSCshiftRA) 
                return rewriteValueARM_OpARMRSCshiftRA_0(v);
            else if (v.Op == OpARMRSCshiftRAreg) 
                return rewriteValueARM_OpARMRSCshiftRAreg_0(v);
            else if (v.Op == OpARMRSCshiftRL) 
                return rewriteValueARM_OpARMRSCshiftRL_0(v);
            else if (v.Op == OpARMRSCshiftRLreg) 
                return rewriteValueARM_OpARMRSCshiftRLreg_0(v);
            else if (v.Op == OpARMSBC) 
                return rewriteValueARM_OpARMSBC_0(v) || rewriteValueARM_OpARMSBC_10(v);
            else if (v.Op == OpARMSBCconst) 
                return rewriteValueARM_OpARMSBCconst_0(v);
            else if (v.Op == OpARMSBCshiftLL) 
                return rewriteValueARM_OpARMSBCshiftLL_0(v);
            else if (v.Op == OpARMSBCshiftLLreg) 
                return rewriteValueARM_OpARMSBCshiftLLreg_0(v);
            else if (v.Op == OpARMSBCshiftRA) 
                return rewriteValueARM_OpARMSBCshiftRA_0(v);
            else if (v.Op == OpARMSBCshiftRAreg) 
                return rewriteValueARM_OpARMSBCshiftRAreg_0(v);
            else if (v.Op == OpARMSBCshiftRL) 
                return rewriteValueARM_OpARMSBCshiftRL_0(v);
            else if (v.Op == OpARMSBCshiftRLreg) 
                return rewriteValueARM_OpARMSBCshiftRLreg_0(v);
            else if (v.Op == OpARMSLL) 
                return rewriteValueARM_OpARMSLL_0(v);
            else if (v.Op == OpARMSLLconst) 
                return rewriteValueARM_OpARMSLLconst_0(v);
            else if (v.Op == OpARMSRA) 
                return rewriteValueARM_OpARMSRA_0(v);
            else if (v.Op == OpARMSRAcond) 
                return rewriteValueARM_OpARMSRAcond_0(v);
            else if (v.Op == OpARMSRAconst) 
                return rewriteValueARM_OpARMSRAconst_0(v);
            else if (v.Op == OpARMSRL) 
                return rewriteValueARM_OpARMSRL_0(v);
            else if (v.Op == OpARMSRLconst) 
                return rewriteValueARM_OpARMSRLconst_0(v);
            else if (v.Op == OpARMSUB) 
                return rewriteValueARM_OpARMSUB_0(v) || rewriteValueARM_OpARMSUB_10(v);
            else if (v.Op == OpARMSUBD) 
                return rewriteValueARM_OpARMSUBD_0(v);
            else if (v.Op == OpARMSUBF) 
                return rewriteValueARM_OpARMSUBF_0(v);
            else if (v.Op == OpARMSUBS) 
                return rewriteValueARM_OpARMSUBS_0(v) || rewriteValueARM_OpARMSUBS_10(v);
            else if (v.Op == OpARMSUBSshiftLL) 
                return rewriteValueARM_OpARMSUBSshiftLL_0(v);
            else if (v.Op == OpARMSUBSshiftLLreg) 
                return rewriteValueARM_OpARMSUBSshiftLLreg_0(v);
            else if (v.Op == OpARMSUBSshiftRA) 
                return rewriteValueARM_OpARMSUBSshiftRA_0(v);
            else if (v.Op == OpARMSUBSshiftRAreg) 
                return rewriteValueARM_OpARMSUBSshiftRAreg_0(v);
            else if (v.Op == OpARMSUBSshiftRL) 
                return rewriteValueARM_OpARMSUBSshiftRL_0(v);
            else if (v.Op == OpARMSUBSshiftRLreg) 
                return rewriteValueARM_OpARMSUBSshiftRLreg_0(v);
            else if (v.Op == OpARMSUBconst) 
                return rewriteValueARM_OpARMSUBconst_0(v);
            else if (v.Op == OpARMSUBshiftLL) 
                return rewriteValueARM_OpARMSUBshiftLL_0(v);
            else if (v.Op == OpARMSUBshiftLLreg) 
                return rewriteValueARM_OpARMSUBshiftLLreg_0(v);
            else if (v.Op == OpARMSUBshiftRA) 
                return rewriteValueARM_OpARMSUBshiftRA_0(v);
            else if (v.Op == OpARMSUBshiftRAreg) 
                return rewriteValueARM_OpARMSUBshiftRAreg_0(v);
            else if (v.Op == OpARMSUBshiftRL) 
                return rewriteValueARM_OpARMSUBshiftRL_0(v);
            else if (v.Op == OpARMSUBshiftRLreg) 
                return rewriteValueARM_OpARMSUBshiftRLreg_0(v);
            else if (v.Op == OpARMTEQ) 
                return rewriteValueARM_OpARMTEQ_0(v) || rewriteValueARM_OpARMTEQ_10(v);
            else if (v.Op == OpARMTEQconst) 
                return rewriteValueARM_OpARMTEQconst_0(v);
            else if (v.Op == OpARMTEQshiftLL) 
                return rewriteValueARM_OpARMTEQshiftLL_0(v);
            else if (v.Op == OpARMTEQshiftLLreg) 
                return rewriteValueARM_OpARMTEQshiftLLreg_0(v);
            else if (v.Op == OpARMTEQshiftRA) 
                return rewriteValueARM_OpARMTEQshiftRA_0(v);
            else if (v.Op == OpARMTEQshiftRAreg) 
                return rewriteValueARM_OpARMTEQshiftRAreg_0(v);
            else if (v.Op == OpARMTEQshiftRL) 
                return rewriteValueARM_OpARMTEQshiftRL_0(v);
            else if (v.Op == OpARMTEQshiftRLreg) 
                return rewriteValueARM_OpARMTEQshiftRLreg_0(v);
            else if (v.Op == OpARMTST) 
                return rewriteValueARM_OpARMTST_0(v) || rewriteValueARM_OpARMTST_10(v);
            else if (v.Op == OpARMTSTconst) 
                return rewriteValueARM_OpARMTSTconst_0(v);
            else if (v.Op == OpARMTSTshiftLL) 
                return rewriteValueARM_OpARMTSTshiftLL_0(v);
            else if (v.Op == OpARMTSTshiftLLreg) 
                return rewriteValueARM_OpARMTSTshiftLLreg_0(v);
            else if (v.Op == OpARMTSTshiftRA) 
                return rewriteValueARM_OpARMTSTshiftRA_0(v);
            else if (v.Op == OpARMTSTshiftRAreg) 
                return rewriteValueARM_OpARMTSTshiftRAreg_0(v);
            else if (v.Op == OpARMTSTshiftRL) 
                return rewriteValueARM_OpARMTSTshiftRL_0(v);
            else if (v.Op == OpARMTSTshiftRLreg) 
                return rewriteValueARM_OpARMTSTshiftRLreg_0(v);
            else if (v.Op == OpARMXOR) 
                return rewriteValueARM_OpARMXOR_0(v) || rewriteValueARM_OpARMXOR_10(v);
            else if (v.Op == OpARMXORconst) 
                return rewriteValueARM_OpARMXORconst_0(v);
            else if (v.Op == OpARMXORshiftLL) 
                return rewriteValueARM_OpARMXORshiftLL_0(v);
            else if (v.Op == OpARMXORshiftLLreg) 
                return rewriteValueARM_OpARMXORshiftLLreg_0(v);
            else if (v.Op == OpARMXORshiftRA) 
                return rewriteValueARM_OpARMXORshiftRA_0(v);
            else if (v.Op == OpARMXORshiftRAreg) 
                return rewriteValueARM_OpARMXORshiftRAreg_0(v);
            else if (v.Op == OpARMXORshiftRL) 
                return rewriteValueARM_OpARMXORshiftRL_0(v);
            else if (v.Op == OpARMXORshiftRLreg) 
                return rewriteValueARM_OpARMXORshiftRLreg_0(v);
            else if (v.Op == OpARMXORshiftRR) 
                return rewriteValueARM_OpARMXORshiftRR_0(v);
            else if (v.Op == OpAdd16) 
                return rewriteValueARM_OpAdd16_0(v);
            else if (v.Op == OpAdd32) 
                return rewriteValueARM_OpAdd32_0(v);
            else if (v.Op == OpAdd32F) 
                return rewriteValueARM_OpAdd32F_0(v);
            else if (v.Op == OpAdd32carry) 
                return rewriteValueARM_OpAdd32carry_0(v);
            else if (v.Op == OpAdd32withcarry) 
                return rewriteValueARM_OpAdd32withcarry_0(v);
            else if (v.Op == OpAdd64F) 
                return rewriteValueARM_OpAdd64F_0(v);
            else if (v.Op == OpAdd8) 
                return rewriteValueARM_OpAdd8_0(v);
            else if (v.Op == OpAddPtr) 
                return rewriteValueARM_OpAddPtr_0(v);
            else if (v.Op == OpAddr) 
                return rewriteValueARM_OpAddr_0(v);
            else if (v.Op == OpAnd16) 
                return rewriteValueARM_OpAnd16_0(v);
            else if (v.Op == OpAnd32) 
                return rewriteValueARM_OpAnd32_0(v);
            else if (v.Op == OpAnd8) 
                return rewriteValueARM_OpAnd8_0(v);
            else if (v.Op == OpAndB) 
                return rewriteValueARM_OpAndB_0(v);
            else if (v.Op == OpAvg32u) 
                return rewriteValueARM_OpAvg32u_0(v);
            else if (v.Op == OpBitLen32) 
                return rewriteValueARM_OpBitLen32_0(v);
            else if (v.Op == OpBswap32) 
                return rewriteValueARM_OpBswap32_0(v);
            else if (v.Op == OpClosureCall) 
                return rewriteValueARM_OpClosureCall_0(v);
            else if (v.Op == OpCom16) 
                return rewriteValueARM_OpCom16_0(v);
            else if (v.Op == OpCom32) 
                return rewriteValueARM_OpCom32_0(v);
            else if (v.Op == OpCom8) 
                return rewriteValueARM_OpCom8_0(v);
            else if (v.Op == OpConst16) 
                return rewriteValueARM_OpConst16_0(v);
            else if (v.Op == OpConst32) 
                return rewriteValueARM_OpConst32_0(v);
            else if (v.Op == OpConst32F) 
                return rewriteValueARM_OpConst32F_0(v);
            else if (v.Op == OpConst64F) 
                return rewriteValueARM_OpConst64F_0(v);
            else if (v.Op == OpConst8) 
                return rewriteValueARM_OpConst8_0(v);
            else if (v.Op == OpConstBool) 
                return rewriteValueARM_OpConstBool_0(v);
            else if (v.Op == OpConstNil) 
                return rewriteValueARM_OpConstNil_0(v);
            else if (v.Op == OpConvert) 
                return rewriteValueARM_OpConvert_0(v);
            else if (v.Op == OpCtz32) 
                return rewriteValueARM_OpCtz32_0(v);
            else if (v.Op == OpCvt32Fto32) 
                return rewriteValueARM_OpCvt32Fto32_0(v);
            else if (v.Op == OpCvt32Fto32U) 
                return rewriteValueARM_OpCvt32Fto32U_0(v);
            else if (v.Op == OpCvt32Fto64F) 
                return rewriteValueARM_OpCvt32Fto64F_0(v);
            else if (v.Op == OpCvt32Uto32F) 
                return rewriteValueARM_OpCvt32Uto32F_0(v);
            else if (v.Op == OpCvt32Uto64F) 
                return rewriteValueARM_OpCvt32Uto64F_0(v);
            else if (v.Op == OpCvt32to32F) 
                return rewriteValueARM_OpCvt32to32F_0(v);
            else if (v.Op == OpCvt32to64F) 
                return rewriteValueARM_OpCvt32to64F_0(v);
            else if (v.Op == OpCvt64Fto32) 
                return rewriteValueARM_OpCvt64Fto32_0(v);
            else if (v.Op == OpCvt64Fto32F) 
                return rewriteValueARM_OpCvt64Fto32F_0(v);
            else if (v.Op == OpCvt64Fto32U) 
                return rewriteValueARM_OpCvt64Fto32U_0(v);
            else if (v.Op == OpDiv16) 
                return rewriteValueARM_OpDiv16_0(v);
            else if (v.Op == OpDiv16u) 
                return rewriteValueARM_OpDiv16u_0(v);
            else if (v.Op == OpDiv32) 
                return rewriteValueARM_OpDiv32_0(v);
            else if (v.Op == OpDiv32F) 
                return rewriteValueARM_OpDiv32F_0(v);
            else if (v.Op == OpDiv32u) 
                return rewriteValueARM_OpDiv32u_0(v);
            else if (v.Op == OpDiv64F) 
                return rewriteValueARM_OpDiv64F_0(v);
            else if (v.Op == OpDiv8) 
                return rewriteValueARM_OpDiv8_0(v);
            else if (v.Op == OpDiv8u) 
                return rewriteValueARM_OpDiv8u_0(v);
            else if (v.Op == OpEq16) 
                return rewriteValueARM_OpEq16_0(v);
            else if (v.Op == OpEq32) 
                return rewriteValueARM_OpEq32_0(v);
            else if (v.Op == OpEq32F) 
                return rewriteValueARM_OpEq32F_0(v);
            else if (v.Op == OpEq64F) 
                return rewriteValueARM_OpEq64F_0(v);
            else if (v.Op == OpEq8) 
                return rewriteValueARM_OpEq8_0(v);
            else if (v.Op == OpEqB) 
                return rewriteValueARM_OpEqB_0(v);
            else if (v.Op == OpEqPtr) 
                return rewriteValueARM_OpEqPtr_0(v);
            else if (v.Op == OpGeq16) 
                return rewriteValueARM_OpGeq16_0(v);
            else if (v.Op == OpGeq16U) 
                return rewriteValueARM_OpGeq16U_0(v);
            else if (v.Op == OpGeq32) 
                return rewriteValueARM_OpGeq32_0(v);
            else if (v.Op == OpGeq32F) 
                return rewriteValueARM_OpGeq32F_0(v);
            else if (v.Op == OpGeq32U) 
                return rewriteValueARM_OpGeq32U_0(v);
            else if (v.Op == OpGeq64F) 
                return rewriteValueARM_OpGeq64F_0(v);
            else if (v.Op == OpGeq8) 
                return rewriteValueARM_OpGeq8_0(v);
            else if (v.Op == OpGeq8U) 
                return rewriteValueARM_OpGeq8U_0(v);
            else if (v.Op == OpGetCallerSP) 
                return rewriteValueARM_OpGetCallerSP_0(v);
            else if (v.Op == OpGetClosurePtr) 
                return rewriteValueARM_OpGetClosurePtr_0(v);
            else if (v.Op == OpGreater16) 
                return rewriteValueARM_OpGreater16_0(v);
            else if (v.Op == OpGreater16U) 
                return rewriteValueARM_OpGreater16U_0(v);
            else if (v.Op == OpGreater32) 
                return rewriteValueARM_OpGreater32_0(v);
            else if (v.Op == OpGreater32F) 
                return rewriteValueARM_OpGreater32F_0(v);
            else if (v.Op == OpGreater32U) 
                return rewriteValueARM_OpGreater32U_0(v);
            else if (v.Op == OpGreater64F) 
                return rewriteValueARM_OpGreater64F_0(v);
            else if (v.Op == OpGreater8) 
                return rewriteValueARM_OpGreater8_0(v);
            else if (v.Op == OpGreater8U) 
                return rewriteValueARM_OpGreater8U_0(v);
            else if (v.Op == OpHmul32) 
                return rewriteValueARM_OpHmul32_0(v);
            else if (v.Op == OpHmul32u) 
                return rewriteValueARM_OpHmul32u_0(v);
            else if (v.Op == OpInterCall) 
                return rewriteValueARM_OpInterCall_0(v);
            else if (v.Op == OpIsInBounds) 
                return rewriteValueARM_OpIsInBounds_0(v);
            else if (v.Op == OpIsNonNil) 
                return rewriteValueARM_OpIsNonNil_0(v);
            else if (v.Op == OpIsSliceInBounds) 
                return rewriteValueARM_OpIsSliceInBounds_0(v);
            else if (v.Op == OpLeq16) 
                return rewriteValueARM_OpLeq16_0(v);
            else if (v.Op == OpLeq16U) 
                return rewriteValueARM_OpLeq16U_0(v);
            else if (v.Op == OpLeq32) 
                return rewriteValueARM_OpLeq32_0(v);
            else if (v.Op == OpLeq32F) 
                return rewriteValueARM_OpLeq32F_0(v);
            else if (v.Op == OpLeq32U) 
                return rewriteValueARM_OpLeq32U_0(v);
            else if (v.Op == OpLeq64F) 
                return rewriteValueARM_OpLeq64F_0(v);
            else if (v.Op == OpLeq8) 
                return rewriteValueARM_OpLeq8_0(v);
            else if (v.Op == OpLeq8U) 
                return rewriteValueARM_OpLeq8U_0(v);
            else if (v.Op == OpLess16) 
                return rewriteValueARM_OpLess16_0(v);
            else if (v.Op == OpLess16U) 
                return rewriteValueARM_OpLess16U_0(v);
            else if (v.Op == OpLess32) 
                return rewriteValueARM_OpLess32_0(v);
            else if (v.Op == OpLess32F) 
                return rewriteValueARM_OpLess32F_0(v);
            else if (v.Op == OpLess32U) 
                return rewriteValueARM_OpLess32U_0(v);
            else if (v.Op == OpLess64F) 
                return rewriteValueARM_OpLess64F_0(v);
            else if (v.Op == OpLess8) 
                return rewriteValueARM_OpLess8_0(v);
            else if (v.Op == OpLess8U) 
                return rewriteValueARM_OpLess8U_0(v);
            else if (v.Op == OpLoad) 
                return rewriteValueARM_OpLoad_0(v);
            else if (v.Op == OpLsh16x16) 
                return rewriteValueARM_OpLsh16x16_0(v);
            else if (v.Op == OpLsh16x32) 
                return rewriteValueARM_OpLsh16x32_0(v);
            else if (v.Op == OpLsh16x64) 
                return rewriteValueARM_OpLsh16x64_0(v);
            else if (v.Op == OpLsh16x8) 
                return rewriteValueARM_OpLsh16x8_0(v);
            else if (v.Op == OpLsh32x16) 
                return rewriteValueARM_OpLsh32x16_0(v);
            else if (v.Op == OpLsh32x32) 
                return rewriteValueARM_OpLsh32x32_0(v);
            else if (v.Op == OpLsh32x64) 
                return rewriteValueARM_OpLsh32x64_0(v);
            else if (v.Op == OpLsh32x8) 
                return rewriteValueARM_OpLsh32x8_0(v);
            else if (v.Op == OpLsh8x16) 
                return rewriteValueARM_OpLsh8x16_0(v);
            else if (v.Op == OpLsh8x32) 
                return rewriteValueARM_OpLsh8x32_0(v);
            else if (v.Op == OpLsh8x64) 
                return rewriteValueARM_OpLsh8x64_0(v);
            else if (v.Op == OpLsh8x8) 
                return rewriteValueARM_OpLsh8x8_0(v);
            else if (v.Op == OpMod16) 
                return rewriteValueARM_OpMod16_0(v);
            else if (v.Op == OpMod16u) 
                return rewriteValueARM_OpMod16u_0(v);
            else if (v.Op == OpMod32) 
                return rewriteValueARM_OpMod32_0(v);
            else if (v.Op == OpMod32u) 
                return rewriteValueARM_OpMod32u_0(v);
            else if (v.Op == OpMod8) 
                return rewriteValueARM_OpMod8_0(v);
            else if (v.Op == OpMod8u) 
                return rewriteValueARM_OpMod8u_0(v);
            else if (v.Op == OpMove) 
                return rewriteValueARM_OpMove_0(v);
            else if (v.Op == OpMul16) 
                return rewriteValueARM_OpMul16_0(v);
            else if (v.Op == OpMul32) 
                return rewriteValueARM_OpMul32_0(v);
            else if (v.Op == OpMul32F) 
                return rewriteValueARM_OpMul32F_0(v);
            else if (v.Op == OpMul32uhilo) 
                return rewriteValueARM_OpMul32uhilo_0(v);
            else if (v.Op == OpMul64F) 
                return rewriteValueARM_OpMul64F_0(v);
            else if (v.Op == OpMul8) 
                return rewriteValueARM_OpMul8_0(v);
            else if (v.Op == OpNeg16) 
                return rewriteValueARM_OpNeg16_0(v);
            else if (v.Op == OpNeg32) 
                return rewriteValueARM_OpNeg32_0(v);
            else if (v.Op == OpNeg32F) 
                return rewriteValueARM_OpNeg32F_0(v);
            else if (v.Op == OpNeg64F) 
                return rewriteValueARM_OpNeg64F_0(v);
            else if (v.Op == OpNeg8) 
                return rewriteValueARM_OpNeg8_0(v);
            else if (v.Op == OpNeq16) 
                return rewriteValueARM_OpNeq16_0(v);
            else if (v.Op == OpNeq32) 
                return rewriteValueARM_OpNeq32_0(v);
            else if (v.Op == OpNeq32F) 
                return rewriteValueARM_OpNeq32F_0(v);
            else if (v.Op == OpNeq64F) 
                return rewriteValueARM_OpNeq64F_0(v);
            else if (v.Op == OpNeq8) 
                return rewriteValueARM_OpNeq8_0(v);
            else if (v.Op == OpNeqB) 
                return rewriteValueARM_OpNeqB_0(v);
            else if (v.Op == OpNeqPtr) 
                return rewriteValueARM_OpNeqPtr_0(v);
            else if (v.Op == OpNilCheck) 
                return rewriteValueARM_OpNilCheck_0(v);
            else if (v.Op == OpNot) 
                return rewriteValueARM_OpNot_0(v);
            else if (v.Op == OpOffPtr) 
                return rewriteValueARM_OpOffPtr_0(v);
            else if (v.Op == OpOr16) 
                return rewriteValueARM_OpOr16_0(v);
            else if (v.Op == OpOr32) 
                return rewriteValueARM_OpOr32_0(v);
            else if (v.Op == OpOr8) 
                return rewriteValueARM_OpOr8_0(v);
            else if (v.Op == OpOrB) 
                return rewriteValueARM_OpOrB_0(v);
            else if (v.Op == OpRound32F) 
                return rewriteValueARM_OpRound32F_0(v);
            else if (v.Op == OpRound64F) 
                return rewriteValueARM_OpRound64F_0(v);
            else if (v.Op == OpRsh16Ux16) 
                return rewriteValueARM_OpRsh16Ux16_0(v);
            else if (v.Op == OpRsh16Ux32) 
                return rewriteValueARM_OpRsh16Ux32_0(v);
            else if (v.Op == OpRsh16Ux64) 
                return rewriteValueARM_OpRsh16Ux64_0(v);
            else if (v.Op == OpRsh16Ux8) 
                return rewriteValueARM_OpRsh16Ux8_0(v);
            else if (v.Op == OpRsh16x16) 
                return rewriteValueARM_OpRsh16x16_0(v);
            else if (v.Op == OpRsh16x32) 
                return rewriteValueARM_OpRsh16x32_0(v);
            else if (v.Op == OpRsh16x64) 
                return rewriteValueARM_OpRsh16x64_0(v);
            else if (v.Op == OpRsh16x8) 
                return rewriteValueARM_OpRsh16x8_0(v);
            else if (v.Op == OpRsh32Ux16) 
                return rewriteValueARM_OpRsh32Ux16_0(v);
            else if (v.Op == OpRsh32Ux32) 
                return rewriteValueARM_OpRsh32Ux32_0(v);
            else if (v.Op == OpRsh32Ux64) 
                return rewriteValueARM_OpRsh32Ux64_0(v);
            else if (v.Op == OpRsh32Ux8) 
                return rewriteValueARM_OpRsh32Ux8_0(v);
            else if (v.Op == OpRsh32x16) 
                return rewriteValueARM_OpRsh32x16_0(v);
            else if (v.Op == OpRsh32x32) 
                return rewriteValueARM_OpRsh32x32_0(v);
            else if (v.Op == OpRsh32x64) 
                return rewriteValueARM_OpRsh32x64_0(v);
            else if (v.Op == OpRsh32x8) 
                return rewriteValueARM_OpRsh32x8_0(v);
            else if (v.Op == OpRsh8Ux16) 
                return rewriteValueARM_OpRsh8Ux16_0(v);
            else if (v.Op == OpRsh8Ux32) 
                return rewriteValueARM_OpRsh8Ux32_0(v);
            else if (v.Op == OpRsh8Ux64) 
                return rewriteValueARM_OpRsh8Ux64_0(v);
            else if (v.Op == OpRsh8Ux8) 
                return rewriteValueARM_OpRsh8Ux8_0(v);
            else if (v.Op == OpRsh8x16) 
                return rewriteValueARM_OpRsh8x16_0(v);
            else if (v.Op == OpRsh8x32) 
                return rewriteValueARM_OpRsh8x32_0(v);
            else if (v.Op == OpRsh8x64) 
                return rewriteValueARM_OpRsh8x64_0(v);
            else if (v.Op == OpRsh8x8) 
                return rewriteValueARM_OpRsh8x8_0(v);
            else if (v.Op == OpSelect0) 
                return rewriteValueARM_OpSelect0_0(v);
            else if (v.Op == OpSelect1) 
                return rewriteValueARM_OpSelect1_0(v);
            else if (v.Op == OpSignExt16to32) 
                return rewriteValueARM_OpSignExt16to32_0(v);
            else if (v.Op == OpSignExt8to16) 
                return rewriteValueARM_OpSignExt8to16_0(v);
            else if (v.Op == OpSignExt8to32) 
                return rewriteValueARM_OpSignExt8to32_0(v);
            else if (v.Op == OpSignmask) 
                return rewriteValueARM_OpSignmask_0(v);
            else if (v.Op == OpSlicemask) 
                return rewriteValueARM_OpSlicemask_0(v);
            else if (v.Op == OpSqrt) 
                return rewriteValueARM_OpSqrt_0(v);
            else if (v.Op == OpStaticCall) 
                return rewriteValueARM_OpStaticCall_0(v);
            else if (v.Op == OpStore) 
                return rewriteValueARM_OpStore_0(v);
            else if (v.Op == OpSub16) 
                return rewriteValueARM_OpSub16_0(v);
            else if (v.Op == OpSub32) 
                return rewriteValueARM_OpSub32_0(v);
            else if (v.Op == OpSub32F) 
                return rewriteValueARM_OpSub32F_0(v);
            else if (v.Op == OpSub32carry) 
                return rewriteValueARM_OpSub32carry_0(v);
            else if (v.Op == OpSub32withcarry) 
                return rewriteValueARM_OpSub32withcarry_0(v);
            else if (v.Op == OpSub64F) 
                return rewriteValueARM_OpSub64F_0(v);
            else if (v.Op == OpSub8) 
                return rewriteValueARM_OpSub8_0(v);
            else if (v.Op == OpSubPtr) 
                return rewriteValueARM_OpSubPtr_0(v);
            else if (v.Op == OpTrunc16to8) 
                return rewriteValueARM_OpTrunc16to8_0(v);
            else if (v.Op == OpTrunc32to16) 
                return rewriteValueARM_OpTrunc32to16_0(v);
            else if (v.Op == OpTrunc32to8) 
                return rewriteValueARM_OpTrunc32to8_0(v);
            else if (v.Op == OpXor16) 
                return rewriteValueARM_OpXor16_0(v);
            else if (v.Op == OpXor32) 
                return rewriteValueARM_OpXor32_0(v);
            else if (v.Op == OpXor8) 
                return rewriteValueARM_OpXor8_0(v);
            else if (v.Op == OpZero) 
                return rewriteValueARM_OpZero_0(v);
            else if (v.Op == OpZeroExt16to32) 
                return rewriteValueARM_OpZeroExt16to32_0(v);
            else if (v.Op == OpZeroExt8to16) 
                return rewriteValueARM_OpZeroExt8to16_0(v);
            else if (v.Op == OpZeroExt8to32) 
                return rewriteValueARM_OpZeroExt8to32_0(v);
            else if (v.Op == OpZeromask) 
                return rewriteValueARM_OpZeromask_0(v);
                        return false;
        }
        private static bool rewriteValueARM_OpARMADC_0(ref Value v)
        { 
            // match: (ADC (MOVWconst [c]) x flags)
            // cond:
            // result: (ADCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (MOVWconst [c]) flags)
            // cond:
            // result: (ADCconst [c] x flags)
 
            // match: (ADC x (MOVWconst [c]) flags)
            // cond:
            // result: (ADCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (MOVWconst [c]) flags)
            // cond:
            // result: (ADCconst [c] x flags)
 
            // match: (ADC x (MOVWconst [c]) flags)
            // cond:
            // result: (ADCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (MOVWconst [c]) x flags)
            // cond:
            // result: (ADCconst [c] x flags)
 
            // match: (ADC (MOVWconst [c]) x flags)
            // cond:
            // result: (ADCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SLLconst [c] y) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
 
            // match: (ADC x (SLLconst [c] y) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SLLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
 
            // match: (ADC (SLLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SLLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
 
            // match: (ADC (SLLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SLLconst [c] y) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
 
            // match: (ADC x (SLLconst [c] y) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRLconst [c] y) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
 
            // match: (ADC x (SRLconst [c] y) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
 
            // match: (ADC (SRLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADC_10(ref Value v)
        { 
            // match: (ADC (SRLconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var y = v_0.Args[0L];
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRLconst [c] y) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
 
            // match: (ADC x (SRLconst [c] y) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRAconst [c] y) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
 
            // match: (ADC x (SRAconst [c] y) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRAconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
 
            // match: (ADC (SRAconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRAconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
 
            // match: (ADC (SRAconst [c] y) x flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRAconst [c] y) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
 
            // match: (ADC x (SRAconst [c] y) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SLL y z) flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
 
            // match: (ADC x (SLL y z) flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SLL y z) x flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
 
            // match: (ADC (SLL y z) x flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SLL y z) x flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
 
            // match: (ADC (SLL y z) x flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SLL y z) flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
 
            // match: (ADC x (SLL y z) flags)
            // cond:
            // result: (ADCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADC_20(ref Value v)
        { 
            // match: (ADC x (SRL y z) flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRL y z) x flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
 
            // match: (ADC (SRL y z) x flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRL y z) x flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
 
            // match: (ADC (SRL y z) x flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRL y z) flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
 
            // match: (ADC x (SRL y z) flags)
            // cond:
            // result: (ADCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRA y z) flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
 
            // match: (ADC x (SRA y z) flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRA y z) x flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
 
            // match: (ADC (SRA y z) x flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC (SRA y z) x flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
 
            // match: (ADC (SRA y z) x flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADC x (SRA y z) flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
 
            // match: (ADC x (SRA y z) flags)
            // cond:
            // result: (ADCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMADCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCconst_0(ref Value v)
        { 
            // match: (ADCconst [c] (ADDconst [d] x) flags)
            // cond:
            // result: (ADCconst [int64(int32(c+d))] x flags)
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var flags = v.Args[1L];
                v.reset(OpARMADCconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (ADCconst [int64(int32(c-d))] x flags)
 
            // match: (ADCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (ADCconst [int64(int32(c-d))] x flags)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                flags = v.Args[1L];
                v.reset(OpARMADCconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftLL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (ADCconst [c] (SLLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
 
            // match: (ADCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftLLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (ADCconst [c] (SLL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
 
            // match: (ADCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMADCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftRA (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (ADCconst [c] (SRAconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(c)>>uint64(d))] flags)
 
            // match: (ADCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(c)>>uint64(d))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftRAreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (ADCconst [c] (SRA <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
 
            // match: (ADCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMADCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftRL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (ADCconst [c] (SRLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
 
            // match: (ADCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (ADCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMADCconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADCshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADCshiftRLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (ADCconst [c] (SRL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMADCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (ADCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
 
            // match: (ADCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (ADCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMADCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADD_0(ref Value v)
        { 
            // match: (ADD x (MOVWconst [c]))
            // cond:
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD (MOVWconst [c]) x)
            // cond:
            // result: (ADDconst [c] x)
 
            // match: (ADD (MOVWconst [c]) x)
            // cond:
            // result: (ADDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADD x (SLLconst [c] y))
            // cond:
            // result: (ADDshiftLL x y [c])
 
            // match: (ADD x (SLLconst [c] y))
            // cond:
            // result: (ADDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMADDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SLLconst [c] y) x)
            // cond:
            // result: (ADDshiftLL x y [c])
 
            // match: (ADD (SLLconst [c] y) x)
            // cond:
            // result: (ADDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD x (SRLconst [c] y))
            // cond:
            // result: (ADDshiftRL x y [c])
 
            // match: (ADD x (SRLconst [c] y))
            // cond:
            // result: (ADDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMADDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SRLconst [c] y) x)
            // cond:
            // result: (ADDshiftRL x y [c])
 
            // match: (ADD (SRLconst [c] y) x)
            // cond:
            // result: (ADDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD x (SRAconst [c] y))
            // cond:
            // result: (ADDshiftRA x y [c])
 
            // match: (ADD x (SRAconst [c] y))
            // cond:
            // result: (ADDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMADDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (SRAconst [c] y) x)
            // cond:
            // result: (ADDshiftRA x y [c])
 
            // match: (ADD (SRAconst [c] y) x)
            // cond:
            // result: (ADDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD x (SLL y z))
            // cond:
            // result: (ADDshiftLLreg x y z)
 
            // match: (ADD x (SLL y z))
            // cond:
            // result: (ADDshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMADDshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADD (SLL y z) x)
            // cond:
            // result: (ADDshiftLLreg x y z)
 
            // match: (ADD (SLL y z) x)
            // cond:
            // result: (ADDshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADD_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADD x (SRL y z))
            // cond:
            // result: (ADDshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMADDshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADD (SRL y z) x)
            // cond:
            // result: (ADDshiftRLreg x y z)
 
            // match: (ADD (SRL y z) x)
            // cond:
            // result: (ADDshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADD x (SRA y z))
            // cond:
            // result: (ADDshiftRAreg x y z)
 
            // match: (ADD x (SRA y z))
            // cond:
            // result: (ADDshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMADDshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADD (SRA y z) x)
            // cond:
            // result: (ADDshiftRAreg x y z)
 
            // match: (ADD (SRA y z) x)
            // cond:
            // result: (ADDshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADD x (RSBconst [0] y))
            // cond:
            // result: (SUB x y)
 
            // match: (ADD x (RSBconst [0] y))
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMRSBconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD (RSBconst [0] y) x)
            // cond:
            // result: (SUB x y)
 
            // match: (ADD (RSBconst [0] y) x)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADD <t> (RSBconst [c] x) (RSBconst [d] y))
            // cond:
            // result: (RSBconst [c+d] (ADD <t> x y))
 
            // match: (ADD <t> (RSBconst [c] x) (RSBconst [d] y))
            // cond:
            // result: (RSBconst [c+d] (ADD <t> x y))
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMRSBconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c + d;
                var v0 = b.NewValue0(v.Pos, OpARMADD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADD <t> (RSBconst [d] y) (RSBconst [c] x))
            // cond:
            // result: (RSBconst [c+d] (ADD <t> x y))
 
            // match: (ADD <t> (RSBconst [d] y) (RSBconst [c] x))
            // cond:
            // result: (RSBconst [c+d] (ADD <t> x y))
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                y = v_0.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMRSBconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                x = v_1.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c + d;
                v0 = b.NewValue0(v.Pos, OpARMADD, t);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADD (MUL x y) a)
            // cond:
            // result: (MULA x y a)
 
            // match: (ADD (MUL x y) a)
            // cond:
            // result: (MULA x y a)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                var a = v.Args[1L];
                v.reset(OpARMMULA);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(a);
                return true;
            } 
            // match: (ADD a (MUL x y))
            // cond:
            // result: (MULA x y a)
 
            // match: (ADD a (MUL x y))
            // cond:
            // result: (MULA x y a)
            while (true)
            {
                _ = v.Args[1L];
                a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMUL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                v.reset(OpARMMULA);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDD_0(ref Value v)
        { 
            // match: (ADDD a (MULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAD a x y)
            while (true)
            {
                _ = v.Args[1L];
                var a = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMULD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDD (MULD x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAD a x y)
 
            // match: (ADDD (MULD x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAD a x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMULD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                a = v.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDD a (NMULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSD a x y)
 
            // match: (ADDD a (NMULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSD a x y)
            while (true)
            {
                _ = v.Args[1L];
                a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMNMULD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDD (NMULD x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSD a x y)
 
            // match: (ADDD (NMULD x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSD a x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMNMULD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                a = v.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDF_0(ref Value v)
        { 
            // match: (ADDF a (MULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAF a x y)
            while (true)
            {
                _ = v.Args[1L];
                var a = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMULF)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDF (MULF x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAF a x y)
 
            // match: (ADDF (MULF x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAF a x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMULF)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                a = v.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDF a (NMULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSF a x y)
 
            // match: (ADDF a (NMULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSF a x y)
            while (true)
            {
                _ = v.Args[1L];
                a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMNMULF)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDF (NMULF x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSF a x y)
 
            // match: (ADDF (NMULF x y) a)
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSF a x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMNMULF)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                a = v.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDS_0(ref Value v)
        { 
            // match: (ADDS x (MOVWconst [c]))
            // cond:
            // result: (ADDSconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDS (MOVWconst [c]) x)
            // cond:
            // result: (ADDSconst [c] x)
 
            // match: (ADDS (MOVWconst [c]) x)
            // cond:
            // result: (ADDSconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDS x (SLLconst [c] y))
            // cond:
            // result: (ADDSshiftLL x y [c])
 
            // match: (ADDS x (SLLconst [c] y))
            // cond:
            // result: (ADDSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMADDSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS (SLLconst [c] y) x)
            // cond:
            // result: (ADDSshiftLL x y [c])
 
            // match: (ADDS (SLLconst [c] y) x)
            // cond:
            // result: (ADDSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS x (SRLconst [c] y))
            // cond:
            // result: (ADDSshiftRL x y [c])
 
            // match: (ADDS x (SRLconst [c] y))
            // cond:
            // result: (ADDSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMADDSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS (SRLconst [c] y) x)
            // cond:
            // result: (ADDSshiftRL x y [c])
 
            // match: (ADDS (SRLconst [c] y) x)
            // cond:
            // result: (ADDSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS x (SRAconst [c] y))
            // cond:
            // result: (ADDSshiftRA x y [c])
 
            // match: (ADDS x (SRAconst [c] y))
            // cond:
            // result: (ADDSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMADDSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS (SRAconst [c] y) x)
            // cond:
            // result: (ADDSshiftRA x y [c])
 
            // match: (ADDS (SRAconst [c] y) x)
            // cond:
            // result: (ADDSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (ADDS x (SLL y z))
            // cond:
            // result: (ADDSshiftLLreg x y z)
 
            // match: (ADDS x (SLL y z))
            // cond:
            // result: (ADDSshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMADDSshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADDS (SLL y z) x)
            // cond:
            // result: (ADDSshiftLLreg x y z)
 
            // match: (ADDS (SLL y z) x)
            // cond:
            // result: (ADDSshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDS_10(ref Value v)
        { 
            // match: (ADDS x (SRL y z))
            // cond:
            // result: (ADDSshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMADDSshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADDS (SRL y z) x)
            // cond:
            // result: (ADDSshiftRLreg x y z)
 
            // match: (ADDS (SRL y z) x)
            // cond:
            // result: (ADDSshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADDS x (SRA y z))
            // cond:
            // result: (ADDSshiftRAreg x y z)
 
            // match: (ADDS x (SRA y z))
            // cond:
            // result: (ADDSshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMADDSshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (ADDS (SRA y z) x)
            // cond:
            // result: (ADDSshiftRAreg x y z)
 
            // match: (ADDS (SRA y z) x)
            // cond:
            // result: (ADDSshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMADDSshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDSconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (ADDSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDSconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDSconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftLL x y [c])
 
            // match: (ADDSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDSconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(c)>>uint64(d))])
 
            // match: (ADDSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDSconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDSconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftRA x y [c])
 
            // match: (ADDSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDSconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (ADDSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDSconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDSconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDSshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDSshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDSconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftRL x y [c])
 
            // match: (ADDSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDconst_0(ref Value v)
        { 
            // match: (ADDconst [off1] (MOVWaddr [off2] {sym} ptr))
            // cond:
            // result: (MOVWaddr [off1+off2] {sym} ptr)
            while (true)
            {
                var off1 = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym = v_0.Aux;
                var ptr = v_0.Args[0L];
                v.reset(OpARMMOVWaddr);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                return true;
            } 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
 
            // match: (ADDconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))
            // result: (SUBconst [int64(int32(-c))] x)
 
            // match: (ADDconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))
            // result: (SUBconst [int64(int32(-c))] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(!isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))))
                {
                    break;
                }
                v.reset(OpARMSUBconst);
                v.AuxInt = int64(int32(-c));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(c+d))])
 
            // match: (ADDconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(c+d))])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(c + d));
                return true;
            } 
            // match: (ADDconst [c] (ADDconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c+d))] x)
 
            // match: (ADDconst [c] (ADDconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (SUBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c-d))] x)
 
            // match: (ADDconst [c] (SUBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c-d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDconst [c] (RSBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c+d))] x)
 
            // match: (ADDconst [c] (RSBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (ADDshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
 
            // match: (ADDshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = 32L - c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftLL x y [c])
 
            // match: (ADDshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(c)>>uint64(d))])
 
            // match: (ADDshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftRA x y [c])
 
            // match: (ADDshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (ADDconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (ADDshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ADDconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ADDshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
 
            // match: (ADDshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMADDshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ADDshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ADDconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMADDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ADDshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftRL x y [c])
 
            // match: (ADDshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ADDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMADDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMAND_0(ref Value v)
        { 
            // match: (AND x (MOVWconst [c]))
            // cond:
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND (MOVWconst [c]) x)
            // cond:
            // result: (ANDconst [c] x)
 
            // match: (AND (MOVWconst [c]) x)
            // cond:
            // result: (ANDconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (AND x (SLLconst [c] y))
            // cond:
            // result: (ANDshiftLL x y [c])
 
            // match: (AND x (SLLconst [c] y))
            // cond:
            // result: (ANDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMANDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (SLLconst [c] y) x)
            // cond:
            // result: (ANDshiftLL x y [c])
 
            // match: (AND (SLLconst [c] y) x)
            // cond:
            // result: (ANDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (SRLconst [c] y))
            // cond:
            // result: (ANDshiftRL x y [c])
 
            // match: (AND x (SRLconst [c] y))
            // cond:
            // result: (ANDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMANDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (SRLconst [c] y) x)
            // cond:
            // result: (ANDshiftRL x y [c])
 
            // match: (AND (SRLconst [c] y) x)
            // cond:
            // result: (ANDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (SRAconst [c] y))
            // cond:
            // result: (ANDshiftRA x y [c])
 
            // match: (AND x (SRAconst [c] y))
            // cond:
            // result: (ANDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMANDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (SRAconst [c] y) x)
            // cond:
            // result: (ANDshiftRA x y [c])
 
            // match: (AND (SRAconst [c] y) x)
            // cond:
            // result: (ANDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (SLL y z))
            // cond:
            // result: (ANDshiftLLreg x y z)
 
            // match: (AND x (SLL y z))
            // cond:
            // result: (ANDshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMANDshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (AND (SLL y z) x)
            // cond:
            // result: (ANDshiftLLreg x y z)
 
            // match: (AND (SLL y z) x)
            // cond:
            // result: (ANDshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMAND_10(ref Value v)
        { 
            // match: (AND x (SRL y z))
            // cond:
            // result: (ANDshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMANDshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (AND (SRL y z) x)
            // cond:
            // result: (ANDshiftRLreg x y z)
 
            // match: (AND (SRL y z) x)
            // cond:
            // result: (ANDshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (AND x (SRA y z))
            // cond:
            // result: (ANDshiftRAreg x y z)
 
            // match: (AND x (SRA y z))
            // cond:
            // result: (ANDshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMANDshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (AND (SRA y z) x)
            // cond:
            // result: (ANDshiftRAreg x y z)
 
            // match: (AND (SRA y z) x)
            // cond:
            // result: (ANDshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMANDshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (AND x x)
            // cond:
            // result: x
 
            // match: (AND x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (AND x (MVN y))
            // cond:
            // result: (BIC x y)
 
            // match: (AND x (MVN y))
            // cond:
            // result: (BIC x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMVN)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpARMBIC);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (MVN y) x)
            // cond:
            // result: (BIC x y)
 
            // match: (AND (MVN y) x)
            // cond:
            // result: (BIC x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMVN)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMBIC);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (MVNshiftLL y [c]))
            // cond:
            // result: (BICshiftLL x y [c])
 
            // match: (AND x (MVNshiftLL y [c]))
            // cond:
            // result: (BICshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMVNshiftLL)
                {
                    break;
                }
                var c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMBICshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (MVNshiftLL y [c]) x)
            // cond:
            // result: (BICshiftLL x y [c])
 
            // match: (AND (MVNshiftLL y [c]) x)
            // cond:
            // result: (BICshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMVNshiftLL)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMBICshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (MVNshiftRL y [c]))
            // cond:
            // result: (BICshiftRL x y [c])
 
            // match: (AND x (MVNshiftRL y [c]))
            // cond:
            // result: (BICshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMVNshiftRL)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMBICshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMAND_20(ref Value v)
        { 
            // match: (AND (MVNshiftRL y [c]) x)
            // cond:
            // result: (BICshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMVNshiftRL)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var y = v_0.Args[0L];
                var x = v.Args[1L];
                v.reset(OpARMBICshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND x (MVNshiftRA y [c]))
            // cond:
            // result: (BICshiftRA x y [c])
 
            // match: (AND x (MVNshiftRA y [c]))
            // cond:
            // result: (BICshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMVNshiftRA)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMBICshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (AND (MVNshiftRA y [c]) x)
            // cond:
            // result: (BICshiftRA x y [c])
 
            // match: (AND (MVNshiftRA y [c]) x)
            // cond:
            // result: (BICshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMVNshiftRA)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMBICshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDconst_0(ref Value v)
        { 
            // match: (ANDconst [0] _)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (ANDconst [c] x)
            // cond: int32(c)==-1
            // result: x
 
            // match: (ANDconst [c] x)
            // cond: int32(c)==-1
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                var x = v.Args[0L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(^uint32(c))
            // result: (BICconst [int64(int32(^uint32(c)))] x)
 
            // match: (ANDconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(^uint32(c))
            // result: (BICconst [int64(int32(^uint32(c)))] x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(!isARMImmRot(uint32(c)) && isARMImmRot(~uint32(c))))
                {
                    break;
                }
                v.reset(OpARMBICconst);
                v.AuxInt = int64(int32(~uint32(c)));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c&d])
 
            // match: (ANDconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c&d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = c & d;
                return true;
            } 
            // match: (ANDconst [c] (ANDconst [d] x))
            // cond:
            // result: (ANDconst [c&d] x)
 
            // match: (ANDconst [c] (ANDconst [d] x))
            // cond:
            // result: (ANDconst [c&d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMANDconst);
                v.AuxInt = c & d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (ANDconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (ANDshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMANDconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDshiftLL x y:(SLLconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ANDshiftLL x y:(SLLconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSLLconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ANDconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftLL x y [c])
 
            // match: (ANDshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMANDshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (ANDconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(c)>>uint64(d))])
 
            // match: (ANDshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMANDconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDshiftRA x y:(SRAconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ANDshiftRA x y:(SRAconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSRAconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (ANDconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftRA x y [c])
 
            // match: (ANDshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMANDshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (ANDconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (ANDshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ANDconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMANDconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ANDshiftRL x y:(SRLconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ANDshiftRL x y:(SRLconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSRLconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMANDshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ANDshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ANDconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMANDconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ANDshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftRL x y [c])
 
            // match: (ANDshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ANDshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMANDshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBFX_0(ref Value v)
        { 
            // match: (BFX [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(d)<<(32-uint32(c&0xff)-uint32(c>>8))>>(32-uint32(c>>8)))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(d) << (int)((32L - uint32(c & 0xffUL) - uint32(c >> (int)(8L)))) >> (int)((32L - uint32(c >> (int)(8L)))));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBFXU_0(ref Value v)
        { 
            // match: (BFXU [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(uint32(d)<<(32-uint32(c&0xff)-uint32(c>>8))>>(32-uint32(c>>8)))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint32(d) << (int)((32L - uint32(c & 0xffUL) - uint32(c >> (int)(8L)))) >> (int)((32L - uint32(c >> (int)(8L)))));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBIC_0(ref Value v)
        { 
            // match: (BIC x (MOVWconst [c]))
            // cond:
            // result: (BICconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMBICconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (BIC x (SLLconst [c] y))
            // cond:
            // result: (BICshiftLL x y [c])
 
            // match: (BIC x (SLLconst [c] y))
            // cond:
            // result: (BICshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMBICshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (BIC x (SRLconst [c] y))
            // cond:
            // result: (BICshiftRL x y [c])
 
            // match: (BIC x (SRLconst [c] y))
            // cond:
            // result: (BICshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMBICshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (BIC x (SRAconst [c] y))
            // cond:
            // result: (BICshiftRA x y [c])
 
            // match: (BIC x (SRAconst [c] y))
            // cond:
            // result: (BICshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMBICshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (BIC x (SLL y z))
            // cond:
            // result: (BICshiftLLreg x y z)
 
            // match: (BIC x (SLL y z))
            // cond:
            // result: (BICshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMBICshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (BIC x (SRL y z))
            // cond:
            // result: (BICshiftRLreg x y z)
 
            // match: (BIC x (SRL y z))
            // cond:
            // result: (BICshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMBICshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (BIC x (SRA y z))
            // cond:
            // result: (BICshiftRAreg x y z)
 
            // match: (BIC x (SRA y z))
            // cond:
            // result: (BICshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMBICshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (BIC x x)
            // cond:
            // result: (MOVWconst [0])
 
            // match: (BIC x x)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICconst_0(ref Value v)
        { 
            // match: (BICconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (BICconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVWconst [0])
 
            // match: (BICconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVWconst [0])
            while (true)
            {
                var c = v.AuxInt;
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (BICconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(^uint32(c))
            // result: (ANDconst [int64(int32(^uint32(c)))] x)
 
            // match: (BICconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(^uint32(c))
            // result: (ANDconst [int64(int32(^uint32(c)))] x)
            while (true)
            {
                c = v.AuxInt;
                x = v.Args[0L];
                if (!(!isARMImmRot(uint32(c)) && isARMImmRot(~uint32(c))))
                {
                    break;
                }
                v.reset(OpARMANDconst);
                v.AuxInt = int64(int32(~uint32(c)));
                v.AddArg(x);
                return true;
            } 
            // match: (BICconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [d&^c])
 
            // match: (BICconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [d&^c])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = d & ~c;
                return true;
            } 
            // match: (BICconst [c] (BICconst [d] x))
            // cond:
            // result: (BICconst [int64(int32(c|d))] x)
 
            // match: (BICconst [c] (BICconst [d] x))
            // cond:
            // result: (BICconst [int64(int32(c|d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMBICconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMBICconst);
                v.AuxInt = int64(int32(c | d));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftLL_0(ref Value v)
        { 
            // match: (BICshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (BICconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMBICconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (BICshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (BICshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftLLreg_0(ref Value v)
        { 
            // match: (BICshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (BICshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_2.AuxInt;
                v.reset(OpARMBICshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftRA_0(ref Value v)
        { 
            // match: (BICshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (BICconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMBICconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (BICshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (BICshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftRAreg_0(ref Value v)
        { 
            // match: (BICshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (BICshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_2.AuxInt;
                v.reset(OpARMBICshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftRL_0(ref Value v)
        { 
            // match: (BICshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (BICconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMBICconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (BICshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (BICshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMBICshiftRLreg_0(ref Value v)
        { 
            // match: (BICshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (BICshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_2.AuxInt;
                v.reset(OpARMBICshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMN_0(ref Value v)
        { 
            // match: (CMN x (MOVWconst [c]))
            // cond:
            // result: (CMNconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMN (MOVWconst [c]) x)
            // cond:
            // result: (CMNconst [c] x)
 
            // match: (CMN (MOVWconst [c]) x)
            // cond:
            // result: (CMNconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMN x (SLLconst [c] y))
            // cond:
            // result: (CMNshiftLL x y [c])
 
            // match: (CMN x (SLLconst [c] y))
            // cond:
            // result: (CMNshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMCMNshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN (SLLconst [c] y) x)
            // cond:
            // result: (CMNshiftLL x y [c])
 
            // match: (CMN (SLLconst [c] y) x)
            // cond:
            // result: (CMNshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN x (SRLconst [c] y))
            // cond:
            // result: (CMNshiftRL x y [c])
 
            // match: (CMN x (SRLconst [c] y))
            // cond:
            // result: (CMNshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMCMNshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN (SRLconst [c] y) x)
            // cond:
            // result: (CMNshiftRL x y [c])
 
            // match: (CMN (SRLconst [c] y) x)
            // cond:
            // result: (CMNshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN x (SRAconst [c] y))
            // cond:
            // result: (CMNshiftRA x y [c])
 
            // match: (CMN x (SRAconst [c] y))
            // cond:
            // result: (CMNshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMCMNshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN (SRAconst [c] y) x)
            // cond:
            // result: (CMNshiftRA x y [c])
 
            // match: (CMN (SRAconst [c] y) x)
            // cond:
            // result: (CMNshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN x (SLL y z))
            // cond:
            // result: (CMNshiftLLreg x y z)
 
            // match: (CMN x (SLL y z))
            // cond:
            // result: (CMNshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMCMNshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMN (SLL y z) x)
            // cond:
            // result: (CMNshiftLLreg x y z)
 
            // match: (CMN (SLL y z) x)
            // cond:
            // result: (CMNshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMN_10(ref Value v)
        { 
            // match: (CMN x (SRL y z))
            // cond:
            // result: (CMNshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMCMNshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMN (SRL y z) x)
            // cond:
            // result: (CMNshiftRLreg x y z)
 
            // match: (CMN (SRL y z) x)
            // cond:
            // result: (CMNshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMN x (SRA y z))
            // cond:
            // result: (CMNshiftRAreg x y z)
 
            // match: (CMN x (SRA y z))
            // cond:
            // result: (CMNshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMCMNshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMN (SRA y z) x)
            // cond:
            // result: (CMNshiftRAreg x y z)
 
            // match: (CMN (SRA y z) x)
            // cond:
            // result: (CMNshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMCMNshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMN x (RSBconst [0] y))
            // cond:
            // result: (CMP x y)
 
            // match: (CMN x (RSBconst [0] y))
            // cond:
            // result: (CMP x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMRSBconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpARMCMP);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMN (RSBconst [0] y) x)
            // cond:
            // result: (CMP x y)
 
            // match: (CMN (RSBconst [0] y) x)
            // cond:
            // result: (CMP x y)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMCMP);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNconst_0(ref Value v)
        { 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)==int32(-y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(-y)))
                {
                    break;
                }
                v.reset(OpARMFlagEQ);
                return true;
            } 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(-y) && uint32(x)<uint32(-y)
            // result: (FlagLT_ULT)
 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(-y) && uint32(x)<uint32(-y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(-y) && uint32(x) < uint32(-y)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            } 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(-y) && uint32(x)>uint32(-y)
            // result: (FlagLT_UGT)
 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(-y) && uint32(x)>uint32(-y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(-y) && uint32(x) > uint32(-y)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_UGT);
                return true;
            } 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(-y) && uint32(x)<uint32(-y)
            // result: (FlagGT_ULT)
 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(-y) && uint32(x)<uint32(-y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(-y) && uint32(x) < uint32(-y)))
                {
                    break;
                }
                v.reset(OpARMFlagGT_ULT);
                return true;
            } 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(-y) && uint32(x)>uint32(-y)
            // result: (FlagGT_UGT)
 
            // match: (CMNconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(-y) && uint32(x)>uint32(-y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(-y) && uint32(x) > uint32(-y)))
                {
                    break;
                }
                v.reset(OpARMFlagGT_UGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (CMNconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (CMNshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMNconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (CMNconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftLL x y [c])
 
            // match: (CMNshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMNshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (CMNconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(c)>>uint64(d))])
 
            // match: (CMNshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMNconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (CMNconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftRA x y [c])
 
            // match: (CMNshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMNshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (CMNconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (CMNshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMNconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMNconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMNshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMNshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (CMNconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMCMNconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMNshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftRL x y [c])
 
            // match: (CMNshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMNshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMNshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMOVWHSconst_0(ref Value v)
        { 
            // match: (CMOVWHSconst _ (FlagEQ) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[1L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWHSconst x (FlagLT_ULT))
            // cond:
            // result: x
 
            // match: (CMOVWHSconst x (FlagLT_ULT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (CMOVWHSconst _ (FlagLT_UGT) [c])
            // cond:
            // result: (MOVWconst [c])
 
            // match: (CMOVWHSconst _ (FlagLT_UGT) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWHSconst x (FlagGT_ULT))
            // cond:
            // result: x
 
            // match: (CMOVWHSconst x (FlagGT_ULT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (CMOVWHSconst _ (FlagGT_UGT) [c])
            // cond:
            // result: (MOVWconst [c])
 
            // match: (CMOVWHSconst _ (FlagGT_UGT) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWHSconst x (InvertFlags flags) [c])
            // cond:
            // result: (CMOVWLSconst x flags [c])
 
            // match: (CMOVWHSconst x (InvertFlags flags) [c])
            // cond:
            // result: (CMOVWLSconst x flags [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMInvertFlags)
                {
                    break;
                }
                var flags = v_1.Args[0L];
                v.reset(OpARMCMOVWLSconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMOVWLSconst_0(ref Value v)
        { 
            // match: (CMOVWLSconst _ (FlagEQ) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[1L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWLSconst _ (FlagLT_ULT) [c])
            // cond:
            // result: (MOVWconst [c])
 
            // match: (CMOVWLSconst _ (FlagLT_ULT) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWLSconst x (FlagLT_UGT))
            // cond:
            // result: x
 
            // match: (CMOVWLSconst x (FlagLT_UGT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (CMOVWLSconst _ (FlagGT_ULT) [c])
            // cond:
            // result: (MOVWconst [c])
 
            // match: (CMOVWLSconst _ (FlagGT_ULT) [c])
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            } 
            // match: (CMOVWLSconst x (FlagGT_UGT))
            // cond:
            // result: x
 
            // match: (CMOVWLSconst x (FlagGT_UGT))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (CMOVWLSconst x (InvertFlags flags) [c])
            // cond:
            // result: (CMOVWHSconst x flags [c])
 
            // match: (CMOVWLSconst x (InvertFlags flags) [c])
            // cond:
            // result: (CMOVWHSconst x flags [c])
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMInvertFlags)
                {
                    break;
                }
                var flags = v_1.Args[0L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMP_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMP x (MOVWconst [c]))
            // cond:
            // result: (CMPconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMCMPconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (CMP (MOVWconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPconst [c] x))
 
            // match: (CMP (MOVWconst [c]) x)
            // cond:
            // result: (InvertFlags (CMPconst [c] x))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (SLLconst [c] y))
            // cond:
            // result: (CMPshiftLL x y [c])
 
            // match: (CMP x (SLLconst [c] y))
            // cond:
            // result: (CMPshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMCMPshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMP (SLLconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftLL x y [c]))
 
            // match: (CMP (SLLconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftLL x y [c]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                v0 = b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (SRLconst [c] y))
            // cond:
            // result: (CMPshiftRL x y [c])
 
            // match: (CMP x (SRLconst [c] y))
            // cond:
            // result: (CMPshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMCMPshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMP (SRLconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftRL x y [c]))
 
            // match: (CMP (SRLconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftRL x y [c]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                v0 = b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (SRAconst [c] y))
            // cond:
            // result: (CMPshiftRA x y [c])
 
            // match: (CMP x (SRAconst [c] y))
            // cond:
            // result: (CMPshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMCMPshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (CMP (SRAconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftRA x y [c]))
 
            // match: (CMP (SRAconst [c] y) x)
            // cond:
            // result: (InvertFlags (CMPshiftRA x y [c]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                v0 = b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags);
                v0.AuxInt = c;
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (SLL y z))
            // cond:
            // result: (CMPshiftLLreg x y z)
 
            // match: (CMP x (SLL y z))
            // cond:
            // result: (CMPshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMCMPshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMP (SLL y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftLLreg x y z))
 
            // match: (CMP (SLL y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftLLreg x y z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                v0 = b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMP_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMP x (SRL y z))
            // cond:
            // result: (CMPshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMCMPshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMP (SRL y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftRLreg x y z))
 
            // match: (CMP (SRL y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftRLreg x y z))
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (SRA y z))
            // cond:
            // result: (CMPshiftRAreg x y z)
 
            // match: (CMP x (SRA y z))
            // cond:
            // result: (CMPshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMCMPshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (CMP (SRA y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftRAreg x y z))
 
            // match: (CMP (SRA y z) x)
            // cond:
            // result: (InvertFlags (CMPshiftRAreg x y z))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                v0 = b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v0.AddArg(z);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMP x (RSBconst [0] y))
            // cond:
            // result: (CMN x y)
 
            // match: (CMP x (RSBconst [0] y))
            // cond:
            // result: (CMN x y)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMRSBconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                y = v_1.Args[0L];
                v.reset(OpARMCMN);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPD_0(ref Value v)
        { 
            // match: (CMPD x (MOVDconst [0]))
            // cond:
            // result: (CMPD0 x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVDconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpARMCMPD0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPF_0(ref Value v)
        { 
            // match: (CMPF x (MOVFconst [0]))
            // cond:
            // result: (CMPF0 x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVFconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpARMCMPF0);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPconst_0(ref Value v)
        { 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)==int32(y)
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x) == int32(y)))
                {
                    break;
                }
                v.reset(OpARMFlagEQ);
                return true;
            } 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)<uint32(y)
            // result: (FlagLT_ULT)
 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)<uint32(y)
            // result: (FlagLT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y) && uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            } 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)>uint32(y)
            // result: (FlagLT_UGT)
 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)<int32(y) && uint32(x)>uint32(y)
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) < int32(y) && uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_UGT);
                return true;
            } 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)<uint32(y)
            // result: (FlagGT_ULT)
 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)<uint32(y)
            // result: (FlagGT_ULT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y) && uint32(x) < uint32(y)))
                {
                    break;
                }
                v.reset(OpARMFlagGT_ULT);
                return true;
            } 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)>uint32(y)
            // result: (FlagGT_UGT)
 
            // match: (CMPconst (MOVWconst [x]) [y])
            // cond: int32(x)>int32(y) && uint32(x)>uint32(y)
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x) > int32(y) && uint32(x) > uint32(y)))
                {
                    break;
                }
                v.reset(OpARMFlagGT_UGT);
                return true;
            } 
            // match: (CMPconst (MOVBUreg _) [c])
            // cond: 0xff < c
            // result: (FlagLT_ULT)
 
            // match: (CMPconst (MOVBUreg _) [c])
            // cond: 0xff < c
            // result: (FlagLT_ULT)
            while (true)
            {
                var c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVBUreg)
                {
                    break;
                }
                if (!(0xffUL < c))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            } 
            // match: (CMPconst (MOVHUreg _) [c])
            // cond: 0xffff < c
            // result: (FlagLT_ULT)
 
            // match: (CMPconst (MOVHUreg _) [c])
            // cond: 0xffff < c
            // result: (FlagLT_ULT)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVHUreg)
                {
                    break;
                }
                if (!(0xffffUL < c))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            } 
            // match: (CMPconst (ANDconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPconst (ANDconst _ [m]) [n])
            // cond: 0 <= int32(m) && int32(m) < int32(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                var n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                var m = v_0.AuxInt;
                if (!(0L <= int32(m) && int32(m) < int32(n)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            } 
            // match: (CMPconst (SRLconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint32(32-c)) <= uint32(n)
            // result: (FlagLT_ULT)
 
            // match: (CMPconst (SRLconst _ [c]) [n])
            // cond: 0 <= n && 0 < c && c <= 32 && (1<<uint32(32-c)) <= uint32(n)
            // result: (FlagLT_ULT)
            while (true)
            {
                n = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                if (!(0L <= n && 0L < c && c <= 32L && (1L << (int)(uint32(32L - c))) <= uint32(n)))
                {
                    break;
                }
                v.reset(OpARMFlagLT_ULT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (InvertFlags (CMPconst [c] (SLLconst <x.Type> x [d])))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v1.AuxInt = d;
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (CMPshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMPconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (InvertFlags (CMPconst [c] (SLL <x.Type> x y)))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftLL x y [c])
 
            // match: (CMPshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMPshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (InvertFlags (CMPconst [c] (SRAconst <x.Type> x [d])))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v1.AuxInt = d;
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(c)>>uint64(d))])
 
            // match: (CMPshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMPconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (InvertFlags (CMPconst [c] (SRA <x.Type> x y)))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftRA x y [c])
 
            // match: (CMPshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMPshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (InvertFlags (CMPconst [c] (SRLconst <x.Type> x [d])))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v1.AuxInt = d;
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (CMPshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (CMPconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMCMPconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMCMPshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (CMPshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (InvertFlags (CMPconst [c] (SRL <x.Type> x y)))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMInvertFlags);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = c;
                var v1 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (CMPshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftRL x y [c])
 
            // match: (CMPshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (CMPshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMCMPshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMEqual_0(ref Value v)
        { 
            // match: (Equal (FlagEQ))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (Equal (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (Equal (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (Equal (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (Equal (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (Equal (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Equal (InvertFlags x))
            // cond:
            // result: (Equal x)
 
            // match: (Equal (InvertFlags x))
            // cond:
            // result: (Equal x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMGreaterEqual_0(ref Value v)
        { 
            // match: (GreaterEqual (FlagEQ))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqual (InvertFlags x))
            // cond:
            // result: (LessEqual x)
 
            // match: (GreaterEqual (InvertFlags x))
            // cond:
            // result: (LessEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMLessEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMGreaterEqualU_0(ref Value v)
        { 
            // match: (GreaterEqualU (FlagEQ))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqualU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterEqualU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterEqualU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterEqualU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqualU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterEqualU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterEqualU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterEqualU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterEqualU (InvertFlags x))
            // cond:
            // result: (LessEqualU x)
 
            // match: (GreaterEqualU (InvertFlags x))
            // cond:
            // result: (LessEqualU x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMLessEqualU);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMGreaterThan_0(ref Value v)
        { 
            // match: (GreaterThan (FlagEQ))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThan (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterThan (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThan (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterThan (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThan (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterThan (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterThan (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterThan (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterThan (InvertFlags x))
            // cond:
            // result: (LessThan x)
 
            // match: (GreaterThan (InvertFlags x))
            // cond:
            // result: (LessThan x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMLessThan);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMGreaterThanU_0(ref Value v)
        { 
            // match: (GreaterThanU (FlagEQ))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThanU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterThanU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThanU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterThanU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterThanU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (GreaterThanU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (GreaterThanU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (GreaterThanU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (GreaterThanU (InvertFlags x))
            // cond:
            // result: (LessThanU x)
 
            // match: (GreaterThanU (InvertFlags x))
            // cond:
            // result: (LessThanU x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMLessThanU);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMLessEqual_0(ref Value v)
        { 
            // match: (LessEqual (FlagEQ))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessEqual (InvertFlags x))
            // cond:
            // result: (GreaterEqual x)
 
            // match: (LessEqual (InvertFlags x))
            // cond:
            // result: (GreaterEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMGreaterEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMLessEqualU_0(ref Value v)
        { 
            // match: (LessEqualU (FlagEQ))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqualU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessEqualU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqualU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessEqualU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessEqualU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessEqualU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessEqualU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessEqualU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessEqualU (InvertFlags x))
            // cond:
            // result: (GreaterEqualU x)
 
            // match: (LessEqualU (InvertFlags x))
            // cond:
            // result: (GreaterEqualU x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMGreaterEqualU);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMLessThan_0(ref Value v)
        { 
            // match: (LessThan (FlagEQ))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThan (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessThan (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessThan (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessThan (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessThan (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessThan (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThan (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessThan (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThan (InvertFlags x))
            // cond:
            // result: (GreaterThan x)
 
            // match: (LessThan (InvertFlags x))
            // cond:
            // result: (GreaterThan x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMGreaterThan);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMLessThanU_0(ref Value v)
        { 
            // match: (LessThanU (FlagEQ))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThanU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessThanU (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessThanU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessThanU (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThanU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (LessThanU (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (LessThanU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (LessThanU (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (LessThanU (InvertFlags x))
            // cond:
            // result: (GreaterThanU x)
 
            // match: (LessThanU (InvertFlags x))
            // cond:
            // result: (GreaterThanU x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMGreaterThanU);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBUload_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVBUload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVBUload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVBUload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBUload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVBUload [off1-off2] {sym} ptr mem)
 
            // match: (MOVBUload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVBUload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBUload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBUload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVBUload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVBUload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBUload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBUreg x)
 
            // match: (MOVBUload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBUreg x)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVBstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVBUreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBUload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBUloadidx ptr idx mem)
 
            // match: (MOVBUload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBUloadidx ptr idx mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVBUloadidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBUloadidx_0(ref Value v)
        { 
            // match: (MOVBUloadidx ptr idx (MOVBstoreidx ptr2 idx x _))
            // cond: isSamePtr(ptr, ptr2)
            // result: (MOVBUreg x)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVBstoreidx)
                {
                    break;
                }
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVBUreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBUloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVBUload [c] ptr mem)
 
            // match: (MOVBUloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVBUload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVBUload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBUloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVBUload [c] ptr mem)
 
            // match: (MOVBUloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVBUload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBUload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBUreg_0(ref Value v)
        { 
            // match: (MOVBUreg x:(MOVBUload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpARMMOVBUload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBUreg (ANDconst [c] x))
            // cond:
            // result: (ANDconst [c&0xff] x)
 
            // match: (MOVBUreg (ANDconst [c] x))
            // cond:
            // result: (ANDconst [c&0xff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMANDconst);
                v.AuxInt = c & 0xffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBUreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVBUreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBUreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBUreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(uint8(c))])
 
            // match: (MOVBUreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(uint8(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint8(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBload_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVBload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVBload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVBload [off1-off2] {sym} ptr mem)
 
            // match: (MOVBload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVBload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVBload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVBload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBreg x)
 
            // match: (MOVBload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVBreg x)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVBstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVBreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBloadidx ptr idx mem)
 
            // match: (MOVBload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBloadidx ptr idx mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVBloadidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBloadidx_0(ref Value v)
        { 
            // match: (MOVBloadidx ptr idx (MOVBstoreidx ptr2 idx x _))
            // cond: isSamePtr(ptr, ptr2)
            // result: (MOVBreg x)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVBstoreidx)
                {
                    break;
                }
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVBreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVBload [c] ptr mem)
 
            // match: (MOVBloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVBload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVBload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVBload [c] ptr mem)
 
            // match: (MOVBloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVBload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBreg_0(ref Value v)
        { 
            // match: (MOVBreg x:(MOVBload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpARMMOVBload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg (ANDconst [c] x))
            // cond: c & 0x80 == 0
            // result: (ANDconst [c&0x7f] x)
 
            // match: (MOVBreg (ANDconst [c] x))
            // cond: c & 0x80 == 0
            // result: (ANDconst [c&0x7f] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(c & 0x80UL == 0L))
                {
                    break;
                }
                v.reset(OpARMANDconst);
                v.AuxInt = c & 0x7fUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg x:(MOVBreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVBreg x:(MOVBreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVBreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int8(c))])
 
            // match: (MOVBreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int8(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int8(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBstore_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVBstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond:
            // result: (MOVBstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVBstore [off1-off2] {sym} ptr val mem)
 
            // match: (MOVBstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVBstore [off1-off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVBstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVBstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVBreg)
                {
                    break;
                }
                var x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVBUreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVBUreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVBUreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [off] {sym} ptr (MOVHUreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
 
            // match: (MOVBstore [off] {sym} ptr (MOVHUreg x) mem)
            // cond:
            // result: (MOVBstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHUreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBstoreidx ptr idx val mem)
 
            // match: (MOVBstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVBstoreidx ptr idx val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVBstoreidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVBstoreidx_0(ref Value v)
        { 
            // match: (MOVBstoreidx ptr (MOVWconst [c]) val mem)
            // cond:
            // result: (MOVBstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVBstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVBstore [c] ptr val mem)
 
            // match: (MOVBstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVBstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVDload_0(ref Value v)
        { 
            // match: (MOVDload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVDload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVDload [off1-off2] {sym} ptr mem)
 
            // match: (MOVDload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVDload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVDload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVDload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVDload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVDload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDload [off] {sym} ptr (MOVDstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
 
            // match: (MOVDload [off] {sym} ptr (MOVDstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVDstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVDstore_0(ref Value v)
        { 
            // match: (MOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond:
            // result: (MOVDstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVDstore [off1-off2] {sym} ptr val mem)
 
            // match: (MOVDstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVDstore [off1-off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVDstore);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVDstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVDstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVDstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVFload_0(ref Value v)
        { 
            // match: (MOVFload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVFload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVFload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVFload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVFload [off1-off2] {sym} ptr mem)
 
            // match: (MOVFload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVFload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVFload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVFload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVFload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVFload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVFload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVFload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVFload [off] {sym} ptr (MOVFstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
 
            // match: (MOVFload [off] {sym} ptr (MOVFstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVFstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVFstore_0(ref Value v)
        { 
            // match: (MOVFstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond:
            // result: (MOVFstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMMOVFstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVFstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVFstore [off1-off2] {sym} ptr val mem)
 
            // match: (MOVFstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVFstore [off1-off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVFstore);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVFstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVFstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVFstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVFstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVFstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHUload_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVHUload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVHUload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVHUload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHUload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVHUload [off1-off2] {sym} ptr mem)
 
            // match: (MOVHUload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVHUload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVHUload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHUload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVHUload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHUload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVHUload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHUload [off] {sym} ptr (MOVHstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVHUreg x)
 
            // match: (MOVHUload [off] {sym} ptr (MOVHstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVHUreg x)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVHUreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHUloadidx ptr idx mem)
 
            // match: (MOVHUload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHUloadidx ptr idx mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVHUloadidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHUloadidx_0(ref Value v)
        { 
            // match: (MOVHUloadidx ptr idx (MOVHstoreidx ptr2 idx x _))
            // cond: isSamePtr(ptr, ptr2)
            // result: (MOVHUreg x)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVHstoreidx)
                {
                    break;
                }
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVHUreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVHUload [c] ptr mem)
 
            // match: (MOVHUloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVHUload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVHUload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHUloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVHUload [c] ptr mem)
 
            // match: (MOVHUloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVHUload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVHUload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHUreg_0(ref Value v)
        { 
            // match: (MOVHUreg x:(MOVBUload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpARMMOVBUload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUreg x:(MOVHUload _ _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHUreg x:(MOVHUload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVHUload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUreg (ANDconst [c] x))
            // cond:
            // result: (ANDconst [c&0xffff] x)
 
            // match: (MOVHUreg (ANDconst [c] x))
            // cond:
            // result: (ANDconst [c&0xffff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMANDconst);
                v.AuxInt = c & 0xffffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHUreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBUreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUreg x:(MOVHUreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHUreg x:(MOVHUreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVHUreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHUreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(uint16(c))])
 
            // match: (MOVHUreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(uint16(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint16(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHload_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVHload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVHload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVHload [off1-off2] {sym} ptr mem)
 
            // match: (MOVHload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVHload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVHload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVHload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVHload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHload [off] {sym} ptr (MOVHstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVHreg x)
 
            // match: (MOVHload [off] {sym} ptr (MOVHstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: (MOVHreg x)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVHreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHloadidx ptr idx mem)
 
            // match: (MOVHload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHloadidx ptr idx mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVHloadidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHloadidx_0(ref Value v)
        { 
            // match: (MOVHloadidx ptr idx (MOVHstoreidx ptr2 idx x _))
            // cond: isSamePtr(ptr, ptr2)
            // result: (MOVHreg x)
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVHstoreidx)
                {
                    break;
                }
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpARMMOVHreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVHload [c] ptr mem)
 
            // match: (MOVHloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVHload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVHload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVHload [c] ptr mem)
 
            // match: (MOVHloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVHload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVHload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHreg_0(ref Value v)
        { 
            // match: (MOVHreg x:(MOVBload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                var x = v.Args[0L];
                if (x.Op != OpARMMOVBload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBUload _ _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHreg x:(MOVBUload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBUload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHreg x:(MOVHload _ _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVHload)
                {
                    break;
                }
                _ = x.Args[1L];
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg (ANDconst [c] x))
            // cond: c & 0x8000 == 0
            // result: (ANDconst [c&0x7fff] x)
 
            // match: (MOVHreg (ANDconst [c] x))
            // cond: c & 0x8000 == 0
            // result: (ANDconst [c&0x7fff] x)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMANDconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                x = v_0.Args[0L];
                if (!(c & 0x8000UL == 0L))
                {
                    break;
                }
                v.reset(OpARMANDconst);
                v.AuxInt = c & 0x7fffUL;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHreg x:(MOVBreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHreg x:(MOVBUreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVBUreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg x:(MOVHreg _))
            // cond:
            // result: (MOVWreg x)
 
            // match: (MOVHreg x:(MOVHreg _))
            // cond:
            // result: (MOVWreg x)
            while (true)
            {
                x = v.Args[0L];
                if (x.Op != OpARMMOVHreg)
                {
                    break;
                }
                v.reset(OpARMMOVWreg);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVHreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int16(c))])
 
            // match: (MOVHreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int16(c))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int16(c));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHstore_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVHstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond:
            // result: (MOVHstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVHstore [off1-off2] {sym} ptr val mem)
 
            // match: (MOVHstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVHstore [off1-off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVHstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHreg)
                {
                    break;
                }
                var x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [off] {sym} ptr (MOVHUreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
 
            // match: (MOVHstore [off] {sym} ptr (MOVHUreg x) mem)
            // cond:
            // result: (MOVHstore [off] {sym} ptr x mem)
            while (true)
            {
                off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVHUreg)
                {
                    break;
                }
                x = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = off;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHstoreidx ptr idx val mem)
 
            // match: (MOVHstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVHstoreidx ptr idx val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVHstoreidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVHstoreidx_0(ref Value v)
        { 
            // match: (MOVHstoreidx ptr (MOVWconst [c]) val mem)
            // cond:
            // result: (MOVHstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVHstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVHstore [c] ptr val mem)
 
            // match: (MOVHstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVHstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVHstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWload_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVWload [off1] {sym} (ADDconst [off2] ptr) mem)
            // cond:
            // result: (MOVWload [off1+off2] {sym} ptr mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVWload [off1-off2] {sym} ptr mem)
 
            // match: (MOVWload [off1] {sym} (SUBconst [off2] ptr) mem)
            // cond:
            // result: (MOVWload [off1-off2] {sym} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVWload);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
 
            // match: (MOVWload [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVWload [off1+off2] {mergeSym(sym1,sym2)} ptr mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                mem = v.Args[1L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVWload);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
 
            // match: (MOVWload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _))
            // cond: sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var off = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWstore)
                {
                    break;
                }
                off2 = v_1.AuxInt;
                sym2 = v_1.Aux;
                _ = v_1.Args[2L];
                var ptr2 = v_1.Args[0L];
                var x = v_1.Args[1L];
                if (!(sym == sym2 && off == off2 && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadidx ptr idx mem)
 
            // match: (MOVWload [0] {sym} (ADD ptr idx) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadidx ptr idx mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWloadidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [0] {sym} (ADDshiftLL ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftLL ptr idx [c] mem)
 
            // match: (MOVWload [0] {sym} (ADDshiftLL ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftLL ptr idx [c] mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftLL)
                {
                    break;
                }
                var c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWloadshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [0] {sym} (ADDshiftRL ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftRL ptr idx [c] mem)
 
            // match: (MOVWload [0] {sym} (ADDshiftRL ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftRL ptr idx [c] mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftRL)
                {
                    break;
                }
                c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWloadshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWload [0] {sym} (ADDshiftRA ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftRA ptr idx [c] mem)
 
            // match: (MOVWload [0] {sym} (ADDshiftRA ptr idx [c]) mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWloadshiftRA ptr idx [c] mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftRA)
                {
                    break;
                }
                c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                mem = v.Args[1L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWloadshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWloadidx_0(ref Value v)
        { 
            // match: (MOVWloadidx ptr idx (MOVWstoreidx ptr2 idx x _))
            // cond: isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWstoreidx)
                {
                    break;
                }
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVWload [c] ptr mem)
 
            // match: (MOVWloadidx ptr (MOVWconst [c]) mem)
            // cond:
            // result: (MOVWload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVWload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVWload [c] ptr mem)
 
            // match: (MOVWloadidx (MOVWconst [c]) ptr mem)
            // cond:
            // result: (MOVWload [c] ptr mem)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWload);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx ptr (SLLconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftLL ptr idx [c] mem)
 
            // match: (MOVWloadidx ptr (SLLconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftLL ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx (SLLconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftLL ptr idx [c] mem)
 
            // match: (MOVWloadidx (SLLconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftLL ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx ptr (SRLconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftRL ptr idx [c] mem)
 
            // match: (MOVWloadidx ptr (SRLconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftRL ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx (SRLconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftRL ptr idx [c] mem)
 
            // match: (MOVWloadidx (SRLconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftRL ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx ptr (SRAconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftRA ptr idx [c] mem)
 
            // match: (MOVWloadidx ptr (SRAconst idx [c]) mem)
            // cond:
            // result: (MOVWloadshiftRA ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWloadidx (SRAconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftRA ptr idx [c] mem)
 
            // match: (MOVWloadidx (SRAconst idx [c]) ptr mem)
            // cond:
            // result: (MOVWloadshiftRA ptr idx [c] mem)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWloadshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWloadshiftLL_0(ref Value v)
        { 
            // match: (MOVWloadshiftLL ptr idx [c] (MOVWstoreshiftLL ptr2 idx [d] x _))
            // cond: c==d && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWstoreshiftLL)
                {
                    break;
                }
                var d = v_2.AuxInt;
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(c == d && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWloadshiftLL ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(uint32(c)<<uint64(d))] ptr mem)
 
            // match: (MOVWloadshiftLL ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(uint32(c)<<uint64(d))] ptr mem)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVWload);
                v.AuxInt = int64(uint32(c) << (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWloadshiftRA_0(ref Value v)
        { 
            // match: (MOVWloadshiftRA ptr idx [c] (MOVWstoreshiftRA ptr2 idx [d] x _))
            // cond: c==d && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWstoreshiftRA)
                {
                    break;
                }
                var d = v_2.AuxInt;
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(c == d && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWloadshiftRA ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(int32(c)>>uint64(d))] ptr mem)
 
            // match: (MOVWloadshiftRA ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(int32(c)>>uint64(d))] ptr mem)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVWload);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWloadshiftRL_0(ref Value v)
        { 
            // match: (MOVWloadshiftRL ptr idx [c] (MOVWstoreshiftRL ptr2 idx [d] x _))
            // cond: c==d && isSamePtr(ptr, ptr2)
            // result: x
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var idx = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWstoreshiftRL)
                {
                    break;
                }
                var d = v_2.AuxInt;
                _ = v_2.Args[3L];
                var ptr2 = v_2.Args[0L];
                if (idx != v_2.Args[1L])
                {
                    break;
                }
                var x = v_2.Args[2L];
                if (!(c == d && isSamePtr(ptr, ptr2)))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWloadshiftRL ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(uint32(c)>>uint64(d))] ptr mem)
 
            // match: (MOVWloadshiftRL ptr (MOVWconst [c]) [d] mem)
            // cond:
            // result: (MOVWload [int64(uint32(c)>>uint64(d))] ptr mem)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var mem = v.Args[2L];
                v.reset(OpARMMOVWload);
                v.AuxInt = int64(uint32(c) >> (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWreg_0(ref Value v)
        { 
            // match: (MOVWreg x)
            // cond: x.Uses == 1
            // result: (MOVWnop x)
            while (true)
            {
                var x = v.Args[0L];
                if (!(x.Uses == 1L))
                {
                    break;
                }
                v.reset(OpARMMOVWnop);
                v.AddArg(x);
                return true;
            } 
            // match: (MOVWreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [c])
 
            // match: (MOVWreg (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = c;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWstore_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config; 
            // match: (MOVWstore [off1] {sym} (ADDconst [off2] ptr) val mem)
            // cond:
            // result: (MOVWstore [off1+off2] {sym} ptr val mem)
            while (true)
            {
                var off1 = v.AuxInt;
                var sym = v.Aux;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var ptr = v_0.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVWstore [off1-off2] {sym} ptr val mem)
 
            // match: (MOVWstore [off1] {sym} (SUBconst [off2] ptr) val mem)
            // cond:
            // result: (MOVWstore [off1-off2] {sym} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = off1 - off2;
                v.Aux = sym;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
 
            // match: (MOVWstore [off1] {sym1} (MOVWaddr [off2] {sym2} ptr) val mem)
            // cond: canMergeSym(sym1,sym2)
            // result: (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} ptr val mem)
            while (true)
            {
                off1 = v.AuxInt;
                var sym1 = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                off2 = v_0.AuxInt;
                var sym2 = v_0.Aux;
                ptr = v_0.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(canMergeSym(sym1, sym2)))
                {
                    break;
                }
                v.reset(OpARMMOVWstore);
                v.AuxInt = off1 + off2;
                v.Aux = mergeSym(sym1, sym2);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreidx ptr idx val mem)
 
            // match: (MOVWstore [0] {sym} (ADD ptr idx) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreidx ptr idx val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                var idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWstoreidx);
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [0] {sym} (ADDshiftLL ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
 
            // match: (MOVWstore [0] {sym} (ADDshiftLL ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftLL)
                {
                    break;
                }
                var c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWstoreshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [0] {sym} (ADDshiftRL ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
 
            // match: (MOVWstore [0] {sym} (ADDshiftRL ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftRL)
                {
                    break;
                }
                c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWstoreshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstore [0] {sym} (ADDshiftRA ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
 
            // match: (MOVWstore [0] {sym} (ADDshiftRA ptr idx [c]) val mem)
            // cond: sym == nil && !config.nacl
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                sym = v.Aux;
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDshiftRA)
                {
                    break;
                }
                c = v_0.AuxInt;
                _ = v_0.Args[1L];
                ptr = v_0.Args[0L];
                idx = v_0.Args[1L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(sym == null && !config.nacl))
                {
                    break;
                }
                v.reset(OpARMMOVWstoreshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWstoreidx_0(ref Value v)
        { 
            // match: (MOVWstoreidx ptr (MOVWconst [c]) val mem)
            // cond:
            // result: (MOVWstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVWstore [c] ptr val mem)
 
            // match: (MOVWstoreidx (MOVWconst [c]) ptr val mem)
            // cond:
            // result: (MOVWstore [c] ptr val mem)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx ptr (SLLconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
 
            // match: (MOVWstoreidx ptr (SLLconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx (SLLconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
 
            // match: (MOVWstoreidx (SLLconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftLL ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftLL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx ptr (SRLconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
 
            // match: (MOVWstoreidx ptr (SRLconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx (SRLconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
 
            // match: (MOVWstoreidx (SRLconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftRL ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftRL);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx ptr (SRAconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
 
            // match: (MOVWstoreidx ptr (SRAconst idx [c]) val mem)
            // cond:
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                ptr = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                idx = v_1.Args[0L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (MOVWstoreidx (SRAconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
 
            // match: (MOVWstoreidx (SRAconst idx [c]) ptr val mem)
            // cond:
            // result: (MOVWstoreshiftRA ptr idx [c] val mem)
            while (true)
            {
                _ = v.Args[3L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                idx = v_0.Args[0L];
                ptr = v.Args[1L];
                val = v.Args[2L];
                mem = v.Args[3L];
                v.reset(OpARMMOVWstoreshiftRA);
                v.AuxInt = c;
                v.AddArg(ptr);
                v.AddArg(idx);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWstoreshiftLL_0(ref Value v)
        { 
            // match: (MOVWstoreshiftLL ptr (MOVWconst [c]) [d] val mem)
            // cond:
            // result: (MOVWstore [int64(uint32(c)<<uint64(d))] ptr val mem)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = int64(uint32(c) << (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWstoreshiftRA_0(ref Value v)
        { 
            // match: (MOVWstoreshiftRA ptr (MOVWconst [c]) [d] val mem)
            // cond:
            // result: (MOVWstore [int64(int32(c)>>uint64(d))] ptr val mem)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMOVWstoreshiftRL_0(ref Value v)
        { 
            // match: (MOVWstoreshiftRL ptr (MOVWconst [c]) [d] val mem)
            // cond:
            // result: (MOVWstore [int64(uint32(c)>>uint64(d))] ptr val mem)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[3L];
                var ptr = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var val = v.Args[2L];
                var mem = v.Args[3L];
                v.reset(OpARMMOVWstore);
                v.AuxInt = int64(uint32(c) >> (int)(uint64(d)));
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMUL_0(ref Value v)
        { 
            // match: (MUL x (MOVWconst [c]))
            // cond: int32(c) == -1
            // result: (RSBconst [0] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMRSBconst);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: int32(c) == -1
            // result: (RSBconst [0] x)
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: int32(c) == -1
            // result: (RSBconst [0] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMRSBconst);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            } 
            // match: (MUL _ (MOVWconst [0]))
            // cond:
            // result: (MOVWconst [0])
 
            // match: (MUL _ (MOVWconst [0]))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (MUL (MOVWconst [0]) _)
            // cond:
            // result: (MOVWconst [0])
 
            // match: (MUL (MOVWconst [0]) _)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (MUL x (MOVWconst [1]))
            // cond:
            // result: x
 
            // match: (MUL x (MOVWconst [1]))
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MUL (MOVWconst [1]) x)
            // cond:
            // result: x
 
            // match: (MUL (MOVWconst [1]) x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[1L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: isPowerOfTwo(c)
            // result: (SLLconst [log2(c)] x)
 
            // match: (MUL x (MOVWconst [c]))
            // cond: isPowerOfTwo(c)
            // result: (SLLconst [log2(c)] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c);
                v.AddArg(x);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c)
            // result: (SLLconst [log2(c)] x)
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c)
            // result: (SLLconst [log2(c)] x)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c);
                v.AddArg(x);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADDshiftLL x x [log2(c-1)])
 
            // match: (MUL x (MOVWconst [c]))
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADDshiftLL x x [log2(c-1)])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMADDshiftLL);
                v.AuxInt = log2(c - 1L);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADDshiftLL x x [log2(c-1)])
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADDshiftLL x x [log2(c-1)])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMADDshiftLL);
                v.AuxInt = log2(c - 1L);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMUL_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MUL x (MOVWconst [c]))
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSBshiftLL x x [log2(c+1)])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMRSBshiftLL);
                v.AuxInt = log2(c + 1L);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSBshiftLL x x [log2(c+1)])
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSBshiftLL x x [log2(c+1)])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMRSBshiftLL);
                v.AuxInt = log2(c + 1L);
                v.AddArg(x);
                v.AddArg(x);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (SLLconst [log2(c/3)] (ADDshiftLL <x.Type> x x [1]))
 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (SLLconst [log2(c/3)] (ADDshiftLL <x.Type> x x [1]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 3L);
                var v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 1L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (SLLconst [log2(c/3)] (ADDshiftLL <x.Type> x x [1]))
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (SLLconst [log2(c/3)] (ADDshiftLL <x.Type> x x [1]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 3L);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 1L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (SLLconst [log2(c/5)] (ADDshiftLL <x.Type> x x [2]))
 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (SLLconst [log2(c/5)] (ADDshiftLL <x.Type> x x [2]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 5L);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 2L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (SLLconst [log2(c/5)] (ADDshiftLL <x.Type> x x [2]))
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (SLLconst [log2(c/5)] (ADDshiftLL <x.Type> x x [2]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 5L);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 2L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (SLLconst [log2(c/7)] (RSBshiftLL <x.Type> x x [3]))
 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (SLLconst [log2(c/7)] (RSBshiftLL <x.Type> x x [3]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 7L);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = 3L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (SLLconst [log2(c/7)] (RSBshiftLL <x.Type> x x [3]))
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (SLLconst [log2(c/7)] (RSBshiftLL <x.Type> x x [3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 7L);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = 3L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (SLLconst [log2(c/9)] (ADDshiftLL <x.Type> x x [3]))
 
            // match: (MUL x (MOVWconst [c]))
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (SLLconst [log2(c/9)] (ADDshiftLL <x.Type> x x [3]))
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 9L);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 3L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (SLLconst [log2(c/9)] (ADDshiftLL <x.Type> x x [3]))
 
            // match: (MUL (MOVWconst [c]) x)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (SLLconst [log2(c/9)] (ADDshiftLL <x.Type> x x [3]))
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = log2(c / 9L);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = 3L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMUL_20(ref Value v)
        { 
            // match: (MUL (MOVWconst [c]) (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(c * d));
                return true;
            } 
            // match: (MUL (MOVWconst [d]) (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int32(c*d))])
 
            // match: (MUL (MOVWconst [d]) (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [int64(int32(c*d))])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(c * d));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: int32(c) == -1
            // result: (SUB a x)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var a = v.Args[2L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMSUB);
                v.AddArg(a);
                v.AddArg(x);
                return true;
            } 
            // match: (MULA _ (MOVWconst [0]) a)
            // cond:
            // result: a
 
            // match: (MULA _ (MOVWconst [0]) a)
            // cond:
            // result: a
            while (true)
            {
                _ = v.Args[2L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpCopy);
                v.Type = a.Type;
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [1]) a)
            // cond:
            // result: (ADD x a)
 
            // match: (MULA x (MOVWconst [1]) a)
            // cond:
            // result: (ADD x a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c)
            // result: (ADD (SLLconst <x.Type> [log2(c)] x) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c)
            // result: (ADD (SLLconst <x.Type> [log2(c)] x) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADD (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADD (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (ADD (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (ADD (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 3L);
                var v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 1L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 5L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 2L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 7L);
                v1 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
 
            // match: (MULA x (MOVWconst [c]) a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 9L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULA_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: int32(c) == -1
            // result: (SUB a x)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var a = v.Args[2L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMSUB);
                v.AddArg(a);
                v.AddArg(x);
                return true;
            } 
            // match: (MULA (MOVWconst [0]) _ a)
            // cond:
            // result: a
 
            // match: (MULA (MOVWconst [0]) _ a)
            // cond:
            // result: a
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpCopy);
                v.Type = a.Type;
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [1]) x a)
            // cond:
            // result: (ADD x a)
 
            // match: (MULA (MOVWconst [1]) x a)
            // cond:
            // result: (ADD x a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[1L];
                a = v.Args[2L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c)
            // result: (ADD (SLLconst <x.Type> [log2(c)] x) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c)
            // result: (ADD (SLLconst <x.Type> [log2(c)] x) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADD (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (ADD (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (ADD (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (ADD (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 3L);
                var v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 1L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 5L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 2L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 7L);
                v1 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
 
            // match: (MULA (MOVWconst [c]) x a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (ADD (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMADD);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 9L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULA_20(ref Value v)
        { 
            // match: (MULA (MOVWconst [c]) (MOVWconst [d]) a)
            // cond:
            // result: (ADDconst [int64(int32(c*d))] a)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                var a = v.Args[2L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(c * d));
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULD_0(ref Value v)
        { 
            // match: (MULD (NEGD x) y)
            // cond: objabi.GOARM >= 6
            // result: (NMULD x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMNEGD)
                {
                    break;
                }
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MULD y (NEGD x))
            // cond: objabi.GOARM >= 6
            // result: (NMULD x y)
 
            // match: (MULD y (NEGD x))
            // cond: objabi.GOARM >= 6
            // result: (NMULD x y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMNEGD)
                {
                    break;
                }
                x = v_1.Args[0L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULF_0(ref Value v)
        { 
            // match: (MULF (NEGF x) y)
            // cond: objabi.GOARM >= 6
            // result: (NMULF x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMNEGF)
                {
                    break;
                }
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MULF y (NEGF x))
            // cond: objabi.GOARM >= 6
            // result: (NMULF x y)
 
            // match: (MULF y (NEGF x))
            // cond: objabi.GOARM >= 6
            // result: (NMULF x y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMNEGF)
                {
                    break;
                }
                x = v_1.Args[0L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULS_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: int32(c) == -1
            // result: (ADD a x)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                var a = v.Args[2L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v.AddArg(a);
                v.AddArg(x);
                return true;
            } 
            // match: (MULS _ (MOVWconst [0]) a)
            // cond:
            // result: a
 
            // match: (MULS _ (MOVWconst [0]) a)
            // cond:
            // result: a
            while (true)
            {
                _ = v.Args[2L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 0L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpCopy);
                v.Type = a.Type;
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [1]) a)
            // cond:
            // result: (RSB x a)
 
            // match: (MULS x (MOVWconst [1]) a)
            // cond:
            // result: (RSB x a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_1.AuxInt != 1L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpARMRSB);
                v.AddArg(x);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c)
            // result: (RSB (SLLconst <x.Type> [log2(c)] x) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c)
            // result: (RSB (SLLconst <x.Type> [log2(c)] x) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (RSB (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (RSB (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSB (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSB (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 3L);
                var v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 1L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 5L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 2L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 7L);
                v1 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
 
            // match: (MULS x (MOVWconst [c]) a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                a = v.Args[2L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 9L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULS_10(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: int32(c) == -1
            // result: (ADD a x)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var a = v.Args[2L];
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMADD);
                v.AddArg(a);
                v.AddArg(x);
                return true;
            } 
            // match: (MULS (MOVWconst [0]) _ a)
            // cond:
            // result: a
 
            // match: (MULS (MOVWconst [0]) _ a)
            // cond:
            // result: a
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 0L)
                {
                    break;
                }
                a = v.Args[2L];
                v.reset(OpCopy);
                v.Type = a.Type;
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [1]) x a)
            // cond:
            // result: (RSB x a)
 
            // match: (MULS (MOVWconst [1]) x a)
            // cond:
            // result: (RSB x a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0.AuxInt != 1L)
                {
                    break;
                }
                x = v.Args[1L];
                a = v.Args[2L];
                v.reset(OpARMRSB);
                v.AddArg(x);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c)
            // result: (RSB (SLLconst <x.Type> [log2(c)] x) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c)
            // result: (RSB (SLLconst <x.Type> [log2(c)] x) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (RSB (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c-1) && int32(c) >= 3
            // result: (RSB (ADDshiftLL <x.Type> x x [log2(c-1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c - 1L) && int32(c) >= 3L))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v0.AuxInt = log2(c - 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSB (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: isPowerOfTwo(c+1) && int32(c) >= 7
            // result: (RSB (RSBshiftLL <x.Type> x x [log2(c+1)]) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(isPowerOfTwo(c + 1L) && int32(c) >= 7L))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v0.AuxInt = log2(c + 1L);
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%3 == 0 && isPowerOfTwo(c/3) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/3)] (ADDshiftLL <x.Type> x x [1])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 3L == 0L && isPowerOfTwo(c / 3L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 3L);
                var v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 1L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%5 == 0 && isPowerOfTwo(c/5) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/5)] (ADDshiftLL <x.Type> x x [2])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 5L == 0L && isPowerOfTwo(c / 5L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 5L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 2L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%7 == 0 && isPowerOfTwo(c/7) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/7)] (RSBshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 7L == 0L && isPowerOfTwo(c / 7L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 7L);
                v1 = b.NewValue0(v.Pos, OpARMRSBshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            } 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
 
            // match: (MULS (MOVWconst [c]) x a)
            // cond: c%9 == 0 && isPowerOfTwo(c/9) && is32Bit(c)
            // result: (RSB (SLLconst <x.Type> [log2(c/9)] (ADDshiftLL <x.Type> x x [3])) a)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                a = v.Args[2L];
                if (!(c % 9L == 0L && isPowerOfTwo(c / 9L) && is32Bit(c)))
                {
                    break;
                }
                v.reset(OpARMRSB);
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = log2(c / 9L);
                v1 = b.NewValue0(v.Pos, OpARMADDshiftLL, x.Type);
                v1.AuxInt = 3L;
                v1.AddArg(x);
                v1.AddArg(x);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMULS_20(ref Value v)
        { 
            // match: (MULS (MOVWconst [c]) (MOVWconst [d]) a)
            // cond:
            // result: (SUBconst [int64(int32(c*d))] a)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_1.AuxInt;
                var a = v.Args[2L];
                v.reset(OpARMSUBconst);
                v.AuxInt = int64(int32(c * d));
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVN_0(ref Value v)
        { 
            // match: (MVN (MOVWconst [c]))
            // cond:
            // result: (MOVWconst [^c])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = ~c;
                return true;
            } 
            // match: (MVN (SLLconst [c] x))
            // cond:
            // result: (MVNshiftLL x [c])
 
            // match: (MVN (SLLconst [c] x))
            // cond:
            // result: (MVNshiftLL x [c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpARMMVNshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MVN (SRLconst [c] x))
            // cond:
            // result: (MVNshiftRL x [c])
 
            // match: (MVN (SRLconst [c] x))
            // cond:
            // result: (MVNshiftRL x [c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMMVNshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MVN (SRAconst [c] x))
            // cond:
            // result: (MVNshiftRA x [c])
 
            // match: (MVN (SRAconst [c] x))
            // cond:
            // result: (MVNshiftRA x [c])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMMVNshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (MVN (SLL x y))
            // cond:
            // result: (MVNshiftLLreg x y)
 
            // match: (MVN (SLL x y))
            // cond:
            // result: (MVNshiftLLreg x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                var y = v_0.Args[1L];
                v.reset(OpARMMVNshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MVN (SRL x y))
            // cond:
            // result: (MVNshiftRLreg x y)
 
            // match: (MVN (SRL x y))
            // cond:
            // result: (MVNshiftRLreg x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpARMMVNshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (MVN (SRA x y))
            // cond:
            // result: (MVNshiftRAreg x y)
 
            // match: (MVN (SRA x y))
            // cond:
            // result: (MVNshiftRAreg x y)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                v.reset(OpARMMVNshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftLL_0(ref Value v)
        { 
            // match: (MVNshiftLL (MOVWconst [c]) [d])
            // cond:
            // result: (MOVWconst [^int64(uint32(c)<<uint64(d))])
            while (true)
            {
                var d = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = ~int64(uint32(c) << (int)(uint64(d)));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftLLreg_0(ref Value v)
        { 
            // match: (MVNshiftLLreg x (MOVWconst [c]))
            // cond:
            // result: (MVNshiftLL x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMMVNshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftRA_0(ref Value v)
        { 
            // match: (MVNshiftRA (MOVWconst [c]) [d])
            // cond:
            // result: (MOVWconst [^int64(int32(c)>>uint64(d))])
            while (true)
            {
                var d = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = ~int64(int32(c) >> (int)(uint64(d)));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftRAreg_0(ref Value v)
        { 
            // match: (MVNshiftRAreg x (MOVWconst [c]))
            // cond:
            // result: (MVNshiftRA x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMMVNshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftRL_0(ref Value v)
        { 
            // match: (MVNshiftRL (MOVWconst [c]) [d])
            // cond:
            // result: (MOVWconst [^int64(uint32(c)>>uint64(d))])
            while (true)
            {
                var d = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = ~int64(uint32(c) >> (int)(uint64(d)));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMMVNshiftRLreg_0(ref Value v)
        { 
            // match: (MVNshiftRLreg x (MOVWconst [c]))
            // cond:
            // result: (MVNshiftRL x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMMVNshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMNEGD_0(ref Value v)
        { 
            // match: (NEGD (MULD x y))
            // cond: objabi.GOARM >= 6
            // result: (NMULD x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMULD)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMNEGF_0(ref Value v)
        { 
            // match: (NEGF (MULF x y))
            // cond: objabi.GOARM >= 6
            // result: (NMULF x y)
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMULF)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var y = v_0.Args[1L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMNMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMNMULD_0(ref Value v)
        { 
            // match: (NMULD (NEGD x) y)
            // cond:
            // result: (MULD x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMNEGD)
                {
                    break;
                }
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (NMULD y (NEGD x))
            // cond:
            // result: (MULD x y)
 
            // match: (NMULD y (NEGD x))
            // cond:
            // result: (MULD x y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMNEGD)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpARMMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMNMULF_0(ref Value v)
        { 
            // match: (NMULF (NEGF x) y)
            // cond:
            // result: (MULF x y)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMNEGF)
                {
                    break;
                }
                var x = v_0.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (NMULF y (NEGF x))
            // cond:
            // result: (MULF x y)
 
            // match: (NMULF y (NEGF x))
            // cond:
            // result: (MULF x y)
            while (true)
            {
                _ = v.Args[1L];
                y = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMNEGF)
                {
                    break;
                }
                x = v_1.Args[0L];
                v.reset(OpARMMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMNotEqual_0(ref Value v)
        { 
            // match: (NotEqual (FlagEQ))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (NotEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (NotEqual (FlagLT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (NotEqual (FlagLT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (NotEqual (FlagGT_ULT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
 
            // match: (NotEqual (FlagGT_UGT))
            // cond:
            // result: (MOVWconst [1])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 1L;
                return true;
            } 
            // match: (NotEqual (InvertFlags x))
            // cond:
            // result: (NotEqual x)
 
            // match: (NotEqual (InvertFlags x))
            // cond:
            // result: (NotEqual x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMInvertFlags)
                {
                    break;
                }
                var x = v_0.Args[0L];
                v.reset(OpARMNotEqual);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMOR_0(ref Value v)
        { 
            // match: (OR x (MOVWconst [c]))
            // cond:
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR (MOVWconst [c]) x)
            // cond:
            // result: (ORconst [c] x)
 
            // match: (OR (MOVWconst [c]) x)
            // cond:
            // result: (ORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (OR x (SLLconst [c] y))
            // cond:
            // result: (ORshiftLL x y [c])
 
            // match: (OR x (SLLconst [c] y))
            // cond:
            // result: (ORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SLLconst [c] y) x)
            // cond:
            // result: (ORshiftLL x y [c])
 
            // match: (OR (SLLconst [c] y) x)
            // cond:
            // result: (ORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR x (SRLconst [c] y))
            // cond:
            // result: (ORshiftRL x y [c])
 
            // match: (OR x (SRLconst [c] y))
            // cond:
            // result: (ORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SRLconst [c] y) x)
            // cond:
            // result: (ORshiftRL x y [c])
 
            // match: (OR (SRLconst [c] y) x)
            // cond:
            // result: (ORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR x (SRAconst [c] y))
            // cond:
            // result: (ORshiftRA x y [c])
 
            // match: (OR x (SRAconst [c] y))
            // cond:
            // result: (ORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR (SRAconst [c] y) x)
            // cond:
            // result: (ORshiftRA x y [c])
 
            // match: (OR (SRAconst [c] y) x)
            // cond:
            // result: (ORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (OR x (SLL y z))
            // cond:
            // result: (ORshiftLLreg x y z)
 
            // match: (OR x (SLL y z))
            // cond:
            // result: (ORshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMORshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (OR (SLL y z) x)
            // cond:
            // result: (ORshiftLLreg x y z)
 
            // match: (OR (SLL y z) x)
            // cond:
            // result: (ORshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMORshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMOR_10(ref Value v)
        { 
            // match: (OR x (SRL y z))
            // cond:
            // result: (ORshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMORshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (OR (SRL y z) x)
            // cond:
            // result: (ORshiftRLreg x y z)
 
            // match: (OR (SRL y z) x)
            // cond:
            // result: (ORshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMORshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (OR x (SRA y z))
            // cond:
            // result: (ORshiftRAreg x y z)
 
            // match: (OR x (SRA y z))
            // cond:
            // result: (ORshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMORshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (OR (SRA y z) x)
            // cond:
            // result: (ORshiftRAreg x y z)
 
            // match: (OR (SRA y z) x)
            // cond:
            // result: (ORshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMORshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (OR x x)
            // cond:
            // result: x
 
            // match: (OR x x)
            // cond:
            // result: x
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORconst_0(ref Value v)
        { 
            // match: (ORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (ORconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVWconst [-1])
 
            // match: (ORconst [c] _)
            // cond: int32(c)==-1
            // result: (MOVWconst [-1])
            while (true)
            {
                var c = v.AuxInt;
                if (!(int32(c) == -1L))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = -1L;
                return true;
            } 
            // match: (ORconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c|d])
 
            // match: (ORconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c|d])
            while (true)
            {
                c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = c | d;
                return true;
            } 
            // match: (ORconst [c] (ORconst [d] x))
            // cond:
            // result: (ORconst [c|d] x)
 
            // match: (ORconst [c] (ORconst [d] x))
            // cond:
            // result: (ORconst [c|d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMORconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMORconst);
                v.AuxInt = c | d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (ORconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (ORshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMORconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ORshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
 
            // match: (ORshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = 32L - c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORshiftLL x y:(SLLconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ORshiftLL x y:(SLLconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSLLconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ORconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftLL x y [c])
 
            // match: (ORshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (ORconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(c)>>uint64(d))])
 
            // match: (ORshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMORconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (ORshiftRA x y:(SRAconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ORshiftRA x y:(SRAconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSRAconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (ORconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftRA x y [c])
 
            // match: (ORshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (ORconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (ORshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (ORconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMORconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (ORshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
 
            // match: (ORshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (ORshiftRL x y:(SRLconst x [c]) [d])
            // cond: c==d
            // result: y
 
            // match: (ORshiftRL x y:(SRLconst x [c]) [d])
            // cond: c==d
            // result: y
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var y = v.Args[1L];
                if (y.Op != OpARMSRLconst)
                {
                    break;
                }
                c = y.AuxInt;
                if (x != y.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = y.Type;
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMORshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (ORshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (ORconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (ORshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftRL x y [c])
 
            // match: (ORshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (ORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSB_0(ref Value v)
        { 
            // match: (RSB (MOVWconst [c]) x)
            // cond:
            // result: (SUBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (RSB x (MOVWconst [c]))
            // cond:
            // result: (RSBconst [c] x)
 
            // match: (RSB x (MOVWconst [c]))
            // cond:
            // result: (RSBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (RSB x (SLLconst [c] y))
            // cond:
            // result: (RSBshiftLL x y [c])
 
            // match: (RSB x (SLLconst [c] y))
            // cond:
            // result: (RSBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMRSBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB (SLLconst [c] y) x)
            // cond:
            // result: (SUBshiftLL x y [c])
 
            // match: (RSB (SLLconst [c] y) x)
            // cond:
            // result: (SUBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB x (SRLconst [c] y))
            // cond:
            // result: (RSBshiftRL x y [c])
 
            // match: (RSB x (SRLconst [c] y))
            // cond:
            // result: (RSBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMRSBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB (SRLconst [c] y) x)
            // cond:
            // result: (SUBshiftRL x y [c])
 
            // match: (RSB (SRLconst [c] y) x)
            // cond:
            // result: (SUBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB x (SRAconst [c] y))
            // cond:
            // result: (RSBshiftRA x y [c])
 
            // match: (RSB x (SRAconst [c] y))
            // cond:
            // result: (RSBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMRSBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB (SRAconst [c] y) x)
            // cond:
            // result: (SUBshiftRA x y [c])
 
            // match: (RSB (SRAconst [c] y) x)
            // cond:
            // result: (SUBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (RSB x (SLL y z))
            // cond:
            // result: (RSBshiftLLreg x y z)
 
            // match: (RSB x (SLL y z))
            // cond:
            // result: (RSBshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMRSBshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (RSB (SLL y z) x)
            // cond:
            // result: (SUBshiftLLreg x y z)
 
            // match: (RSB (SLL y z) x)
            // cond:
            // result: (SUBshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSB_10(ref Value v)
        { 
            // match: (RSB x (SRL y z))
            // cond:
            // result: (RSBshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMRSBshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (RSB (SRL y z) x)
            // cond:
            // result: (SUBshiftRLreg x y z)
 
            // match: (RSB (SRL y z) x)
            // cond:
            // result: (SUBshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (RSB x (SRA y z))
            // cond:
            // result: (RSBshiftRAreg x y z)
 
            // match: (RSB x (SRA y z))
            // cond:
            // result: (RSBshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMRSBshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (RSB (SRA y z) x)
            // cond:
            // result: (SUBshiftRAreg x y z)
 
            // match: (RSB (SRA y z) x)
            // cond:
            // result: (SUBshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMSUBshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (RSB x x)
            // cond:
            // result: (MOVWconst [0])
 
            // match: (RSB x x)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (RSB (MUL x y) a)
            // cond: objabi.GOARM == 7
            // result: (MULS x y a)
 
            // match: (RSB (MUL x y) a)
            // cond: objabi.GOARM == 7
            // result: (MULS x y a)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMUL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                y = v_0.Args[1L];
                var a = v.Args[1L];
                if (!(objabi.GOARM == 7L))
                {
                    break;
                }
                v.reset(OpARMMULS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBSconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (RSBSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBSconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBSconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftLL x y [c])
 
            // match: (RSBSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBSconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(c)>>uint64(d))])
 
            // match: (RSBSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBSconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBSconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftRA x y [c])
 
            // match: (RSBSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBSconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (RSBSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBSconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBSconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBSshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBSshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBSconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftRL x y [c])
 
            // match: (RSBSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBconst_0(ref Value v)
        { 
            // match: (RSBconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(c-d))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(c - d));
                return true;
            } 
            // match: (RSBconst [c] (RSBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c-d))] x)
 
            // match: (RSBconst [c] (RSBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(c-d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                var x = v_0.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                return true;
            } 
            // match: (RSBconst [c] (ADDconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c-d))] x)
 
            // match: (RSBconst [c] (ADDconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c-d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                return true;
            } 
            // match: (RSBconst [c] (SUBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c+d))] x)
 
            // match: (RSBconst [c] (SUBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (RSBshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (RSBshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (RSBshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftLL x y [c])
 
            // match: (RSBshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(c)>>uint64(d))])
 
            // match: (RSBshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (RSBshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (RSBshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftRA x y [c])
 
            // match: (RSBshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (SUBconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (RSBshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (RSBconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (RSBshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (RSBshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSBshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSBshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (SUBconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (RSBshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftRL x y [c])
 
            // match: (RSBshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (RSBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMRSBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCconst_0(ref Value v)
        { 
            // match: (RSCconst [c] (ADDconst [d] x) flags)
            // cond:
            // result: (RSCconst [int64(int32(c-d))] x flags)
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var flags = v.Args[1L];
                v.reset(OpARMRSCconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (RSCconst [int64(int32(c+d))] x flags)
 
            // match: (RSCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (RSCconst [int64(int32(c+d))] x flags)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                flags = v.Args[1L];
                v.reset(OpARMRSCconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftLL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (SBCconst [c] (SLLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
 
            // match: (RSCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftLLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (SBCconst [c] (SLL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftLL x y [c] flags)
 
            // match: (RSCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMRSCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftRA (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (SBCconst [c] (SRAconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(c)>>uint64(d))] flags)
 
            // match: (RSCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(c)>>uint64(d))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftRAreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (SBCconst [c] (SRA <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftRA x y [c] flags)
 
            // match: (RSCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMRSCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftRL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (SBCconst [c] (SRLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
 
            // match: (RSCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (RSCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMRSCshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (RSCshiftRLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (SBCconst [c] (SRL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (RSCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftRL x y [c] flags)
 
            // match: (RSCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (RSCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMRSCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBC_0(ref Value v)
        { 
            // match: (SBC (MOVWconst [c]) x flags)
            // cond:
            // result: (RSCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (MOVWconst [c]) flags)
            // cond:
            // result: (SBCconst [c] x flags)
 
            // match: (SBC x (MOVWconst [c]) flags)
            // cond:
            // result: (SBCconst [c] x flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (SLLconst [c] y) flags)
            // cond:
            // result: (SBCshiftLL x y [c] flags)
 
            // match: (SBC x (SLLconst [c] y) flags)
            // cond:
            // result: (SBCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMSBCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SLLconst [c] y) x flags)
            // cond:
            // result: (RSCshiftLL x y [c] flags)
 
            // match: (SBC (SLLconst [c] y) x flags)
            // cond:
            // result: (RSCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (SRLconst [c] y) flags)
            // cond:
            // result: (SBCshiftRL x y [c] flags)
 
            // match: (SBC x (SRLconst [c] y) flags)
            // cond:
            // result: (SBCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMSBCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SRLconst [c] y) x flags)
            // cond:
            // result: (RSCshiftRL x y [c] flags)
 
            // match: (SBC (SRLconst [c] y) x flags)
            // cond:
            // result: (RSCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (SRAconst [c] y) flags)
            // cond:
            // result: (SBCshiftRA x y [c] flags)
 
            // match: (SBC x (SRAconst [c] y) flags)
            // cond:
            // result: (SBCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                flags = v.Args[2L];
                v.reset(OpARMSBCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SRAconst [c] y) x flags)
            // cond:
            // result: (RSCshiftRA x y [c] flags)
 
            // match: (SBC (SRAconst [c] y) x flags)
            // cond:
            // result: (RSCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (SLL y z) flags)
            // cond:
            // result: (SBCshiftLLreg x y z flags)
 
            // match: (SBC x (SLL y z) flags)
            // cond:
            // result: (SBCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMSBCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SLL y z) x flags)
            // cond:
            // result: (RSCshiftLLreg x y z flags)
 
            // match: (SBC (SLL y z) x flags)
            // cond:
            // result: (RSCshiftLLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBC_10(ref Value v)
        { 
            // match: (SBC x (SRL y z) flags)
            // cond:
            // result: (SBCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMSBCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SRL y z) x flags)
            // cond:
            // result: (RSCshiftRLreg x y z flags)
 
            // match: (SBC (SRL y z) x flags)
            // cond:
            // result: (RSCshiftRLreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC x (SRA y z) flags)
            // cond:
            // result: (SBCshiftRAreg x y z flags)
 
            // match: (SBC x (SRA y z) flags)
            // cond:
            // result: (SBCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMSBCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBC (SRA y z) x flags)
            // cond:
            // result: (RSCshiftRAreg x y z flags)
 
            // match: (SBC (SRA y z) x flags)
            // cond:
            // result: (RSCshiftRAreg x y z flags)
            while (true)
            {
                _ = v.Args[2L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                flags = v.Args[2L];
                v.reset(OpARMRSCshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCconst_0(ref Value v)
        { 
            // match: (SBCconst [c] (ADDconst [d] x) flags)
            // cond:
            // result: (SBCconst [int64(int32(c-d))] x flags)
            while (true)
            {
                var c = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                var x = v_0.Args[0L];
                var flags = v.Args[1L];
                v.reset(OpARMSBCconst);
                v.AuxInt = int64(int32(c - d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (SBCconst [int64(int32(c+d))] x flags)
 
            // match: (SBCconst [c] (SUBconst [d] x) flags)
            // cond:
            // result: (SBCconst [int64(int32(c+d))] x flags)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                flags = v.Args[1L];
                v.reset(OpARMSBCconst);
                v.AuxInt = int64(int32(c + d));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftLL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (RSCconst [c] (SLLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
 
            // match: (SBCshiftLL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(uint32(c)<<uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftLLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (RSCconst [c] (SLL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftLL x y [c] flags)
 
            // match: (SBCshiftLLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftLL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMSBCshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftRA (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (RSCconst [c] (SRAconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(c)>>uint64(d))] flags)
 
            // match: (SBCshiftRA x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(c)>>uint64(d))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftRAreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (RSCconst [c] (SRA <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftRA x y [c] flags)
 
            // match: (SBCshiftRAreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftRA x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMSBCshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftRL (MOVWconst [c]) x [d] flags)
            // cond:
            // result: (RSCconst [c] (SRLconst <x.Type> x [d]) flags)
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var flags = v.Args[2L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
 
            // match: (SBCshiftRL x (MOVWconst [c]) [d] flags)
            // cond:
            // result: (SBCconst x [int64(int32(uint32(c)>>uint64(d)))] flags)
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[2L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                flags = v.Args[2L];
                v.reset(OpARMSBCconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSBCshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SBCshiftRLreg (MOVWconst [c]) x y flags)
            // cond:
            // result: (RSCconst [c] (SRL <x.Type> x y) flags)
            while (true)
            {
                _ = v.Args[3L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                var flags = v.Args[3L];
                v.reset(OpARMRSCconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                v.AddArg(flags);
                return true;
            } 
            // match: (SBCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftRL x y [c] flags)
 
            // match: (SBCshiftRLreg x y (MOVWconst [c]) flags)
            // cond:
            // result: (SBCshiftRL x y [c] flags)
            while (true)
            {
                _ = v.Args[3L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                flags = v.Args[3L];
                v.reset(OpARMSBCshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(flags);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSLL_0(ref Value v)
        { 
            // match: (SLL x (MOVWconst [c]))
            // cond:
            // result: (SLLconst x [c&31])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMSLLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSLLconst_0(ref Value v)
        { 
            // match: (SLLconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(uint32(d)<<uint64(c))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint32(d) << (int)(uint64(c)));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSRA_0(ref Value v)
        { 
            // match: (SRA x (MOVWconst [c]))
            // cond:
            // result: (SRAconst x [c&31])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMSRAconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSRAcond_0(ref Value v)
        { 
            // match: (SRAcond x _ (FlagEQ))
            // cond:
            // result: (SRAconst x [31])
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMFlagEQ)
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRAcond x y (FlagLT_ULT))
            // cond:
            // result: (SRA x y)
 
            // match: (SRAcond x y (FlagLT_ULT))
            // cond:
            // result: (SRA x y)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                var y = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpARMFlagLT_ULT)
                {
                    break;
                }
                v.reset(OpARMSRA);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SRAcond x _ (FlagLT_UGT))
            // cond:
            // result: (SRAconst x [31])
 
            // match: (SRAcond x _ (FlagLT_UGT))
            // cond:
            // result: (SRAconst x [31])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpARMFlagLT_UGT)
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v.AddArg(x);
                return true;
            } 
            // match: (SRAcond x y (FlagGT_ULT))
            // cond:
            // result: (SRA x y)
 
            // match: (SRAcond x y (FlagGT_ULT))
            // cond:
            // result: (SRA x y)
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpARMFlagGT_ULT)
                {
                    break;
                }
                v.reset(OpARMSRA);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SRAcond x _ (FlagGT_UGT))
            // cond:
            // result: (SRAconst x [31])
 
            // match: (SRAcond x _ (FlagGT_UGT))
            // cond:
            // result: (SRAconst x [31])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                v_2 = v.Args[2L];
                if (v_2.Op != OpARMFlagGT_UGT)
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSRAconst_0(ref Value v)
        { 
            // match: (SRAconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(d)>>uint64(c))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(d) >> (int)(uint64(c)));
                return true;
            } 
            // match: (SRAconst (SLLconst x [c]) [d])
            // cond: objabi.GOARM==7 && uint64(d)>=uint64(c) && uint64(d)<=31
            // result: (BFX [(d-c)|(32-d)<<8] x)
 
            // match: (SRAconst (SLLconst x [c]) [d])
            // cond: objabi.GOARM==7 && uint64(d)>=uint64(c) && uint64(d)<=31
            // result: (BFX [(d-c)|(32-d)<<8] x)
            while (true)
            {
                d = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(objabi.GOARM == 7L && uint64(d) >= uint64(c) && uint64(d) <= 31L))
                {
                    break;
                }
                v.reset(OpARMBFX);
                v.AuxInt = (d - c) | (32L - d) << (int)(8L);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSRL_0(ref Value v)
        { 
            // match: (SRL x (MOVWconst [c]))
            // cond:
            // result: (SRLconst x [c&31])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMSRLconst);
                v.AuxInt = c & 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSRLconst_0(ref Value v)
        { 
            // match: (SRLconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(uint32(d)>>uint64(c))])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint32(d) >> (int)(uint64(c)));
                return true;
            } 
            // match: (SRLconst (SLLconst x [c]) [d])
            // cond: objabi.GOARM==7 && uint64(d)>=uint64(c) && uint64(d)<=31
            // result: (BFXU [(d-c)|(32-d)<<8] x)
 
            // match: (SRLconst (SLLconst x [c]) [d])
            // cond: objabi.GOARM==7 && uint64(d)>=uint64(c) && uint64(d)<=31
            // result: (BFXU [(d-c)|(32-d)<<8] x)
            while (true)
            {
                d = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                var x = v_0.Args[0L];
                if (!(objabi.GOARM == 7L && uint64(d) >= uint64(c) && uint64(d) <= 31L))
                {
                    break;
                }
                v.reset(OpARMBFXU);
                v.AuxInt = (d - c) | (32L - d) << (int)(8L);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUB_0(ref Value v)
        { 
            // match: (SUB (MOVWconst [c]) x)
            // cond:
            // result: (RSBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUB x (MOVWconst [c]))
            // cond:
            // result: (SUBconst [c] x)
 
            // match: (SUB x (MOVWconst [c]))
            // cond:
            // result: (SUBconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUB x (SLLconst [c] y))
            // cond:
            // result: (SUBshiftLL x y [c])
 
            // match: (SUB x (SLLconst [c] y))
            // cond:
            // result: (SUBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMSUBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB (SLLconst [c] y) x)
            // cond:
            // result: (RSBshiftLL x y [c])
 
            // match: (SUB (SLLconst [c] y) x)
            // cond:
            // result: (RSBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB x (SRLconst [c] y))
            // cond:
            // result: (SUBshiftRL x y [c])
 
            // match: (SUB x (SRLconst [c] y))
            // cond:
            // result: (SUBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMSUBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB (SRLconst [c] y) x)
            // cond:
            // result: (RSBshiftRL x y [c])
 
            // match: (SUB (SRLconst [c] y) x)
            // cond:
            // result: (RSBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB x (SRAconst [c] y))
            // cond:
            // result: (SUBshiftRA x y [c])
 
            // match: (SUB x (SRAconst [c] y))
            // cond:
            // result: (SUBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMSUBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB (SRAconst [c] y) x)
            // cond:
            // result: (RSBshiftRA x y [c])
 
            // match: (SUB (SRAconst [c] y) x)
            // cond:
            // result: (RSBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUB x (SLL y z))
            // cond:
            // result: (SUBshiftLLreg x y z)
 
            // match: (SUB x (SLL y z))
            // cond:
            // result: (SUBshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMSUBshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUB (SLL y z) x)
            // cond:
            // result: (RSBshiftLLreg x y z)
 
            // match: (SUB (SLL y z) x)
            // cond:
            // result: (RSBshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUB_10(ref Value v)
        { 
            // match: (SUB x (SRL y z))
            // cond:
            // result: (SUBshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMSUBshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUB (SRL y z) x)
            // cond:
            // result: (RSBshiftRLreg x y z)
 
            // match: (SUB (SRL y z) x)
            // cond:
            // result: (RSBshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUB x (SRA y z))
            // cond:
            // result: (SUBshiftRAreg x y z)
 
            // match: (SUB x (SRA y z))
            // cond:
            // result: (SUBshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMSUBshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUB (SRA y z) x)
            // cond:
            // result: (RSBshiftRAreg x y z)
 
            // match: (SUB (SRA y z) x)
            // cond:
            // result: (RSBshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMRSBshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUB x x)
            // cond:
            // result: (MOVWconst [0])
 
            // match: (SUB x x)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (SUB a (MUL x y))
            // cond: objabi.GOARM == 7
            // result: (MULS x y a)
 
            // match: (SUB a (MUL x y))
            // cond: objabi.GOARM == 7
            // result: (MULS x y a)
            while (true)
            {
                _ = v.Args[1L];
                var a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMMUL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                if (!(objabi.GOARM == 7L))
                {
                    break;
                }
                v.reset(OpARMMULS);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(a);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBD_0(ref Value v)
        { 
            // match: (SUBD a (MULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSD a x y)
            while (true)
            {
                _ = v.Args[1L];
                var a = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMULD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBD a (NMULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAD a x y)
 
            // match: (SUBD a (NMULD x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAD a x y)
            while (true)
            {
                _ = v.Args[1L];
                a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMNMULD)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAD);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBF_0(ref Value v)
        { 
            // match: (SUBF a (MULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULSF a x y)
            while (true)
            {
                _ = v.Args[1L];
                var a = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMULF)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var x = v_1.Args[0L];
                var y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULSF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBF a (NMULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAF a x y)
 
            // match: (SUBF a (NMULF x y))
            // cond: a.Uses == 1 && objabi.GOARM >= 6
            // result: (MULAF a x y)
            while (true)
            {
                _ = v.Args[1L];
                a = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMNMULF)
                {
                    break;
                }
                _ = v_1.Args[1L];
                x = v_1.Args[0L];
                y = v_1.Args[1L];
                if (!(a.Uses == 1L && objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMMULAF);
                v.AddArg(a);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBS_0(ref Value v)
        { 
            // match: (SUBS x (MOVWconst [c]))
            // cond:
            // result: (SUBSconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMSUBSconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBS x (SLLconst [c] y))
            // cond:
            // result: (SUBSshiftLL x y [c])
 
            // match: (SUBS x (SLLconst [c] y))
            // cond:
            // result: (SUBSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMSUBSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS (SLLconst [c] y) x)
            // cond:
            // result: (RSBSshiftLL x y [c])
 
            // match: (SUBS (SLLconst [c] y) x)
            // cond:
            // result: (RSBSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS x (SRLconst [c] y))
            // cond:
            // result: (SUBSshiftRL x y [c])
 
            // match: (SUBS x (SRLconst [c] y))
            // cond:
            // result: (SUBSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMSUBSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS (SRLconst [c] y) x)
            // cond:
            // result: (RSBSshiftRL x y [c])
 
            // match: (SUBS (SRLconst [c] y) x)
            // cond:
            // result: (RSBSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS x (SRAconst [c] y))
            // cond:
            // result: (SUBSshiftRA x y [c])
 
            // match: (SUBS x (SRAconst [c] y))
            // cond:
            // result: (SUBSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMSUBSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS (SRAconst [c] y) x)
            // cond:
            // result: (RSBSshiftRA x y [c])
 
            // match: (SUBS (SRAconst [c] y) x)
            // cond:
            // result: (RSBSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMRSBSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (SUBS x (SLL y z))
            // cond:
            // result: (SUBSshiftLLreg x y z)
 
            // match: (SUBS x (SLL y z))
            // cond:
            // result: (SUBSshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMSUBSshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUBS (SLL y z) x)
            // cond:
            // result: (RSBSshiftLLreg x y z)
 
            // match: (SUBS (SLL y z) x)
            // cond:
            // result: (RSBSshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMRSBSshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUBS x (SRL y z))
            // cond:
            // result: (SUBSshiftRLreg x y z)
 
            // match: (SUBS x (SRL y z))
            // cond:
            // result: (SUBSshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMSUBSshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBS_10(ref Value v)
        { 
            // match: (SUBS (SRL y z) x)
            // cond:
            // result: (RSBSshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var y = v_0.Args[0L];
                var z = v_0.Args[1L];
                var x = v.Args[1L];
                v.reset(OpARMRSBSshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUBS x (SRA y z))
            // cond:
            // result: (SUBSshiftRAreg x y z)
 
            // match: (SUBS x (SRA y z))
            // cond:
            // result: (SUBSshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMSUBSshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (SUBS (SRA y z) x)
            // cond:
            // result: (RSBSshiftRAreg x y z)
 
            // match: (SUBS (SRA y z) x)
            // cond:
            // result: (RSBSshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMRSBSshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBSconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (SUBSshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBSconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBSconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftLL x y [c])
 
            // match: (SUBSshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBSshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBSconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(c)>>uint64(d))])
 
            // match: (SUBSshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBSconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBSconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftRA x y [c])
 
            // match: (SUBSshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBSshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBSconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (SUBSshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBSconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBSconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBSshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBSshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBSconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBSconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftRL x y [c])
 
            // match: (SUBSshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBSshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBSshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBconst_0(ref Value v)
        { 
            // match: (SUBconst [off1] (MOVWaddr [off2] {sym} ptr))
            // cond:
            // result: (MOVWaddr [off2-off1] {sym} ptr)
            while (true)
            {
                var off1 = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWaddr)
                {
                    break;
                }
                var off2 = v_0.AuxInt;
                var sym = v_0.Aux;
                var ptr = v_0.Args[0L];
                v.reset(OpARMMOVWaddr);
                v.AuxInt = off2 - off1;
                v.Aux = sym;
                v.AddArg(ptr);
                return true;
            } 
            // match: (SUBconst [0] x)
            // cond:
            // result: x
 
            // match: (SUBconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))
            // result: (ADDconst [int64(int32(-c))] x)
 
            // match: (SUBconst [c] x)
            // cond: !isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))
            // result: (ADDconst [int64(int32(-c))] x)
            while (true)
            {
                var c = v.AuxInt;
                x = v.Args[0L];
                if (!(!isARMImmRot(uint32(c)) && isARMImmRot(uint32(-c))))
                {
                    break;
                }
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(-c));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(d-c))])
 
            // match: (SUBconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [int64(int32(d-c))])
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(int32(d - c));
                return true;
            } 
            // match: (SUBconst [c] (SUBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(-c-d))] x)
 
            // match: (SUBconst [c] (SUBconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(-c-d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSUBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(-c - d));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst [c] (ADDconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(-c+d))] x)
 
            // match: (SUBconst [c] (ADDconst [d] x))
            // cond:
            // result: (ADDconst [int64(int32(-c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMADDconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = int64(int32(-c + d));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBconst [c] (RSBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(-c+d))] x)
 
            // match: (SUBconst [c] (RSBconst [d] x))
            // cond:
            // result: (RSBconst [int64(int32(-c+d))] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMRSBconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = int64(int32(-c + d));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (SUBshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (SUBshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftLL x y [c])
 
            // match: (SUBshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(c)>>uint64(d))])
 
            // match: (SUBshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (SUBshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftRA x y [c])
 
            // match: (SUBshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (RSBconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (SUBshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (SUBconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMSUBconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (SUBshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (SUBshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMSUBshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (SUBshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (RSBconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMRSBconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (SUBshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftRL x y [c])
 
            // match: (SUBshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (SUBshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMSUBshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQ_0(ref Value v)
        { 
            // match: (TEQ x (MOVWconst [c]))
            // cond:
            // result: (TEQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TEQ (MOVWconst [c]) x)
            // cond:
            // result: (TEQconst [c] x)
 
            // match: (TEQ (MOVWconst [c]) x)
            // cond:
            // result: (TEQconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TEQ x (SLLconst [c] y))
            // cond:
            // result: (TEQshiftLL x y [c])
 
            // match: (TEQ x (SLLconst [c] y))
            // cond:
            // result: (TEQshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMTEQshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ (SLLconst [c] y) x)
            // cond:
            // result: (TEQshiftLL x y [c])
 
            // match: (TEQ (SLLconst [c] y) x)
            // cond:
            // result: (TEQshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ x (SRLconst [c] y))
            // cond:
            // result: (TEQshiftRL x y [c])
 
            // match: (TEQ x (SRLconst [c] y))
            // cond:
            // result: (TEQshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMTEQshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ (SRLconst [c] y) x)
            // cond:
            // result: (TEQshiftRL x y [c])
 
            // match: (TEQ (SRLconst [c] y) x)
            // cond:
            // result: (TEQshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ x (SRAconst [c] y))
            // cond:
            // result: (TEQshiftRA x y [c])
 
            // match: (TEQ x (SRAconst [c] y))
            // cond:
            // result: (TEQshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMTEQshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ (SRAconst [c] y) x)
            // cond:
            // result: (TEQshiftRA x y [c])
 
            // match: (TEQ (SRAconst [c] y) x)
            // cond:
            // result: (TEQshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TEQ x (SLL y z))
            // cond:
            // result: (TEQshiftLLreg x y z)
 
            // match: (TEQ x (SLL y z))
            // cond:
            // result: (TEQshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMTEQshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TEQ (SLL y z) x)
            // cond:
            // result: (TEQshiftLLreg x y z)
 
            // match: (TEQ (SLL y z) x)
            // cond:
            // result: (TEQshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQ_10(ref Value v)
        { 
            // match: (TEQ x (SRL y z))
            // cond:
            // result: (TEQshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMTEQshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TEQ (SRL y z) x)
            // cond:
            // result: (TEQshiftRLreg x y z)
 
            // match: (TEQ (SRL y z) x)
            // cond:
            // result: (TEQshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TEQ x (SRA y z))
            // cond:
            // result: (TEQshiftRAreg x y z)
 
            // match: (TEQ x (SRA y z))
            // cond:
            // result: (TEQshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMTEQshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TEQ (SRA y z) x)
            // cond:
            // result: (TEQshiftRAreg x y z)
 
            // match: (TEQ (SRA y z) x)
            // cond:
            // result: (TEQshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTEQshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQconst_0(ref Value v)
        { 
            // match: (TEQconst (MOVWconst [x]) [y])
            // cond: int32(x^y)==0
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x ^ y) == 0L))
                {
                    break;
                }
                v.reset(OpARMFlagEQ);
                return true;
            } 
            // match: (TEQconst (MOVWconst [x]) [y])
            // cond: int32(x^y)<0
            // result: (FlagLT_UGT)
 
            // match: (TEQconst (MOVWconst [x]) [y])
            // cond: int32(x^y)<0
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x ^ y) < 0L))
                {
                    break;
                }
                v.reset(OpARMFlagLT_UGT);
                return true;
            } 
            // match: (TEQconst (MOVWconst [x]) [y])
            // cond: int32(x^y)>0
            // result: (FlagGT_UGT)
 
            // match: (TEQconst (MOVWconst [x]) [y])
            // cond: int32(x^y)>0
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x ^ y) > 0L))
                {
                    break;
                }
                v.reset(OpARMFlagGT_UGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (TEQconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (TEQshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTEQconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (TEQconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftLL x y [c])
 
            // match: (TEQshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTEQshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (TEQconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(c)>>uint64(d))])
 
            // match: (TEQshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTEQconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (TEQconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftRA x y [c])
 
            // match: (TEQshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTEQshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (TEQconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (TEQshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (TEQconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTEQconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTEQshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TEQshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (TEQconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTEQconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TEQshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftRL x y [c])
 
            // match: (TEQshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (TEQshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTEQshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTST_0(ref Value v)
        { 
            // match: (TST x (MOVWconst [c]))
            // cond:
            // result: (TSTconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TST (MOVWconst [c]) x)
            // cond:
            // result: (TSTconst [c] x)
 
            // match: (TST (MOVWconst [c]) x)
            // cond:
            // result: (TSTconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (TST x (SLLconst [c] y))
            // cond:
            // result: (TSTshiftLL x y [c])
 
            // match: (TST x (SLLconst [c] y))
            // cond:
            // result: (TSTshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMTSTshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST (SLLconst [c] y) x)
            // cond:
            // result: (TSTshiftLL x y [c])
 
            // match: (TST (SLLconst [c] y) x)
            // cond:
            // result: (TSTshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST x (SRLconst [c] y))
            // cond:
            // result: (TSTshiftRL x y [c])
 
            // match: (TST x (SRLconst [c] y))
            // cond:
            // result: (TSTshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMTSTshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST (SRLconst [c] y) x)
            // cond:
            // result: (TSTshiftRL x y [c])
 
            // match: (TST (SRLconst [c] y) x)
            // cond:
            // result: (TSTshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST x (SRAconst [c] y))
            // cond:
            // result: (TSTshiftRA x y [c])
 
            // match: (TST x (SRAconst [c] y))
            // cond:
            // result: (TSTshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMTSTshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST (SRAconst [c] y) x)
            // cond:
            // result: (TSTshiftRA x y [c])
 
            // match: (TST (SRAconst [c] y) x)
            // cond:
            // result: (TSTshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (TST x (SLL y z))
            // cond:
            // result: (TSTshiftLLreg x y z)
 
            // match: (TST x (SLL y z))
            // cond:
            // result: (TSTshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMTSTshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TST (SLL y z) x)
            // cond:
            // result: (TSTshiftLLreg x y z)
 
            // match: (TST (SLL y z) x)
            // cond:
            // result: (TSTshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTST_10(ref Value v)
        { 
            // match: (TST x (SRL y z))
            // cond:
            // result: (TSTshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMTSTshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TST (SRL y z) x)
            // cond:
            // result: (TSTshiftRLreg x y z)
 
            // match: (TST (SRL y z) x)
            // cond:
            // result: (TSTshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TST x (SRA y z))
            // cond:
            // result: (TSTshiftRAreg x y z)
 
            // match: (TST x (SRA y z))
            // cond:
            // result: (TSTshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMTSTshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (TST (SRA y z) x)
            // cond:
            // result: (TSTshiftRAreg x y z)
 
            // match: (TST (SRA y z) x)
            // cond:
            // result: (TSTshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMTSTshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTconst_0(ref Value v)
        { 
            // match: (TSTconst (MOVWconst [x]) [y])
            // cond: int32(x&y)==0
            // result: (FlagEQ)
            while (true)
            {
                var y = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var x = v_0.AuxInt;
                if (!(int32(x & y) == 0L))
                {
                    break;
                }
                v.reset(OpARMFlagEQ);
                return true;
            } 
            // match: (TSTconst (MOVWconst [x]) [y])
            // cond: int32(x&y)<0
            // result: (FlagLT_UGT)
 
            // match: (TSTconst (MOVWconst [x]) [y])
            // cond: int32(x&y)<0
            // result: (FlagLT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x & y) < 0L))
                {
                    break;
                }
                v.reset(OpARMFlagLT_UGT);
                return true;
            } 
            // match: (TSTconst (MOVWconst [x]) [y])
            // cond: int32(x&y)>0
            // result: (FlagGT_UGT)
 
            // match: (TSTconst (MOVWconst [x]) [y])
            // cond: int32(x&y)>0
            // result: (FlagGT_UGT)
            while (true)
            {
                y = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                x = v_0.AuxInt;
                if (!(int32(x & y) > 0L))
                {
                    break;
                }
                v.reset(OpARMFlagGT_UGT);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (TSTconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (TSTshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTSTconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (TSTconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftLL x y [c])
 
            // match: (TSTshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTSTshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (TSTconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(c)>>uint64(d))])
 
            // match: (TSTshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTSTconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (TSTconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftRA x y [c])
 
            // match: (TSTshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTSTshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (TSTconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (TSTshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (TSTconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMTSTconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMTSTshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (TSTshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (TSTconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMTSTconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (TSTshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftRL x y [c])
 
            // match: (TSTshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (TSTshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMTSTshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXOR_0(ref Value v)
        { 
            // match: (XOR x (MOVWconst [c]))
            // cond:
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_1.AuxInt;
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR (MOVWconst [c]) x)
            // cond:
            // result: (XORconst [c] x)
 
            // match: (XOR (MOVWconst [c]) x)
            // cond:
            // result: (XORconst [c] x)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                x = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XOR x (SLLconst [c] y))
            // cond:
            // result: (XORshiftLL x y [c])
 
            // match: (XOR x (SLLconst [c] y))
            // cond:
            // result: (XORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                var y = v_1.Args[0L];
                v.reset(OpARMXORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SLLconst [c] y) x)
            // cond:
            // result: (XORshiftLL x y [c])
 
            // match: (XOR (SLLconst [c] y) x)
            // cond:
            // result: (XORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR x (SRLconst [c] y))
            // cond:
            // result: (XORshiftRL x y [c])
 
            // match: (XOR x (SRLconst [c] y))
            // cond:
            // result: (XORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMXORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SRLconst [c] y) x)
            // cond:
            // result: (XORshiftRL x y [c])
 
            // match: (XOR (SRLconst [c] y) x)
            // cond:
            // result: (XORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR x (SRAconst [c] y))
            // cond:
            // result: (XORshiftRA x y [c])
 
            // match: (XOR x (SRAconst [c] y))
            // cond:
            // result: (XORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMXORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SRAconst [c] y) x)
            // cond:
            // result: (XORshiftRA x y [c])
 
            // match: (XOR (SRAconst [c] y) x)
            // cond:
            // result: (XORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR x (SRRconst [c] y))
            // cond:
            // result: (XORshiftRR x y [c])
 
            // match: (XOR x (SRRconst [c] y))
            // cond:
            // result: (XORshiftRR x y [c])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRRconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                y = v_1.Args[0L];
                v.reset(OpARMXORshiftRR);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            } 
            // match: (XOR (SRRconst [c] y) x)
            // cond:
            // result: (XORshiftRR x y [c])
 
            // match: (XOR (SRRconst [c] y) x)
            // cond:
            // result: (XORshiftRR x y [c])
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRRconst)
                {
                    break;
                }
                c = v_0.AuxInt;
                y = v_0.Args[0L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftRR);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXOR_10(ref Value v)
        { 
            // match: (XOR x (SLL y z))
            // cond:
            // result: (XORshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                var y = v_1.Args[0L];
                var z = v_1.Args[1L];
                v.reset(OpARMXORshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR (SLL y z) x)
            // cond:
            // result: (XORshiftLLreg x y z)
 
            // match: (XOR (SLL y z) x)
            // cond:
            // result: (XORshiftLLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftLLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR x (SRL y z))
            // cond:
            // result: (XORshiftRLreg x y z)
 
            // match: (XOR x (SRL y z))
            // cond:
            // result: (XORshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMXORshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR (SRL y z) x)
            // cond:
            // result: (XORshiftRLreg x y z)
 
            // match: (XOR (SRL y z) x)
            // cond:
            // result: (XORshiftRLreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRL)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftRLreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR x (SRA y z))
            // cond:
            // result: (XORshiftRAreg x y z)
 
            // match: (XOR x (SRA y z))
            // cond:
            // result: (XORshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_1.Args[1L];
                y = v_1.Args[0L];
                z = v_1.Args[1L];
                v.reset(OpARMXORshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR (SRA y z) x)
            // cond:
            // result: (XORshiftRAreg x y z)
 
            // match: (XOR (SRA y z) x)
            // cond:
            // result: (XORshiftRAreg x y z)
            while (true)
            {
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRA)
                {
                    break;
                }
                _ = v_0.Args[1L];
                y = v_0.Args[0L];
                z = v_0.Args[1L];
                x = v.Args[1L];
                v.reset(OpARMXORshiftRAreg);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(z);
                return true;
            } 
            // match: (XOR x x)
            // cond:
            // result: (MOVWconst [0])
 
            // match: (XOR x x)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORconst_0(ref Value v)
        { 
            // match: (XORconst [0] x)
            // cond:
            // result: x
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (XORconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c^d])
 
            // match: (XORconst [c] (MOVWconst [d]))
            // cond:
            // result: (MOVWconst [c^d])
            while (true)
            {
                var c = v.AuxInt;
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = c ^ d;
                return true;
            } 
            // match: (XORconst [c] (XORconst [d] x))
            // cond:
            // result: (XORconst [c^d] x)
 
            // match: (XORconst [c] (XORconst [d] x))
            // cond:
            // result: (XORconst [c^d] x)
            while (true)
            {
                c = v.AuxInt;
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMXORconst)
                {
                    break;
                }
                d = v_0.AuxInt;
                x = v_0.Args[0L];
                v.reset(OpARMXORconst);
                v.AuxInt = c ^ d;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftLL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftLL (MOVWconst [c]) x [d])
            // cond:
            // result: (XORconst [c] (SLLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)<<uint64(d)))])
 
            // match: (XORshiftLL x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)<<uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMXORconst);
                v.AuxInt = int64(int32(uint32(c) << (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (XORshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
 
            // match: (XORshiftLL [c] (SRLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [32-c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSRLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = 32L - c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (XORshiftLL x (SLLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSLLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftLLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftLLreg (MOVWconst [c]) x y)
            // cond:
            // result: (XORconst [c] (SLL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftLL x y [c])
 
            // match: (XORshiftLLreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftLL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMXORshiftLL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftRA_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftRA (MOVWconst [c]) x [d])
            // cond:
            // result: (XORconst [c] (SRAconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRAconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(c)>>uint64(d))])
 
            // match: (XORshiftRA x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(c)>>uint64(d))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMXORconst);
                v.AuxInt = int64(int32(c) >> (int)(uint64(d)));
                v.AddArg(x);
                return true;
            } 
            // match: (XORshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (XORshiftRA x (SRAconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRAconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftRAreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftRAreg (MOVWconst [c]) x y)
            // cond:
            // result: (XORconst [c] (SRA <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRA, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftRA x y [c])
 
            // match: (XORshiftRAreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftRA x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMXORshiftRA);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftRL_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftRL (MOVWconst [c]) x [d])
            // cond:
            // result: (XORconst [c] (SRLconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)>>uint64(d)))])
 
            // match: (XORshiftRL x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)>>uint64(d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMXORconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d))));
                v.AddArg(x);
                return true;
            } 
            // match: (XORshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
 
            // match: (XORshiftRL [c] (SLLconst x [32-c]) x)
            // cond:
            // result: (SRRconst [   c] x)
            while (true)
            {
                c = v.AuxInt;
                _ = v.Args[1L];
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMSLLconst)
                {
                    break;
                }
                if (v_0.AuxInt != 32L - c)
                {
                    break;
                }
                x = v_0.Args[0L];
                if (x != v.Args[1L])
                {
                    break;
                }
                v.reset(OpARMSRRconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (XORshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
 
            // match: (XORshiftRL x (SRLconst x [c]) [d])
            // cond: c==d
            // result: (MOVWconst [0])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpARMSRLconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (x != v_1.Args[0L])
                {
                    break;
                }
                if (!(c == d))
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftRLreg_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftRLreg (MOVWconst [c]) x y)
            // cond:
            // result: (XORconst [c] (SRL <x.Type> x y))
            while (true)
            {
                _ = v.Args[2L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                var y = v.Args[2L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftRL x y [c])
 
            // match: (XORshiftRLreg x y (MOVWconst [c]))
            // cond:
            // result: (XORshiftRL x y [c])
            while (true)
            {
                _ = v.Args[2L];
                x = v.Args[0L];
                y = v.Args[1L];
                var v_2 = v.Args[2L];
                if (v_2.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_2.AuxInt;
                v.reset(OpARMXORshiftRL);
                v.AuxInt = c;
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpARMXORshiftRR_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (XORshiftRR (MOVWconst [c]) x [d])
            // cond:
            // result: (XORconst [c] (SRRconst <x.Type> x [d]))
            while (true)
            {
                var d = v.AuxInt;
                _ = v.Args[1L];
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0.AuxInt;
                var x = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = c;
                var v0 = b.NewValue0(v.Pos, OpARMSRRconst, x.Type);
                v0.AuxInt = d;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (XORshiftRR x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)>>uint64(d)|uint32(c)<<uint64(32-d)))])
 
            // match: (XORshiftRR x (MOVWconst [c]) [d])
            // cond:
            // result: (XORconst x [int64(int32(uint32(c)>>uint64(d)|uint32(c)<<uint64(32-d)))])
            while (true)
            {
                d = v.AuxInt;
                _ = v.Args[1L];
                x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_1.AuxInt;
                v.reset(OpARMXORconst);
                v.AuxInt = int64(int32(uint32(c) >> (int)(uint64(d)) | uint32(c) << (int)(uint64(32L - d))));
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpAdd16_0(ref Value v)
        { 
            // match: (Add16 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd32_0(ref Value v)
        { 
            // match: (Add32 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd32F_0(ref Value v)
        { 
            // match: (Add32F x y)
            // cond:
            // result: (ADDF x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADDF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd32carry_0(ref Value v)
        { 
            // match: (Add32carry x y)
            // cond:
            // result: (ADDS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADDS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd32withcarry_0(ref Value v)
        { 
            // match: (Add32withcarry x y c)
            // cond:
            // result: (ADC x y c)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var c = v.Args[2L];
                v.reset(OpARMADC);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(c);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd64F_0(ref Value v)
        { 
            // match: (Add64F x y)
            // cond:
            // result: (ADDD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADDD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAdd8_0(ref Value v)
        { 
            // match: (Add8 x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAddPtr_0(ref Value v)
        { 
            // match: (AddPtr x y)
            // cond:
            // result: (ADD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAddr_0(ref Value v)
        { 
            // match: (Addr {sym} base)
            // cond:
            // result: (MOVWaddr {sym} base)
            while (true)
            {
                var sym = v.Aux;
                var @base = v.Args[0L];
                v.reset(OpARMMOVWaddr);
                v.Aux = sym;
                v.AddArg(base);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAnd16_0(ref Value v)
        { 
            // match: (And16 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMAND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAnd32_0(ref Value v)
        { 
            // match: (And32 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMAND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAnd8_0(ref Value v)
        { 
            // match: (And8 x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMAND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAndB_0(ref Value v)
        { 
            // match: (AndB x y)
            // cond:
            // result: (AND x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMAND);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpAvg32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Avg32u <t> x y)
            // cond:
            // result: (ADD (SRLconst <t> (SUB <t> x y) [1]) y)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMADD);
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, t);
                v0.AuxInt = 1L;
                var v1 = b.NewValue0(v.Pos, OpARMSUB, t);
                v1.AddArg(x);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpBitLen32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (BitLen32 <t> x)
            // cond:
            // result: (RSBconst [32] (CLZ <t> x))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = 32L;
                var v0 = b.NewValue0(v.Pos, OpARMCLZ, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpBswap32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Bswap32 <t> x)
            // cond: objabi.GOARM==5
            // result: (XOR <t>         (SRLconst <t> (BICconst <t> (XOR <t> x (SRRconst <t> [16] x)) [0xff0000]) [8])         (SRRconst <t> x [8]))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (!(objabi.GOARM == 5L))
                {
                    break;
                }
                v.reset(OpARMXOR);
                v.Type = t;
                var v0 = b.NewValue0(v.Pos, OpARMSRLconst, t);
                v0.AuxInt = 8L;
                var v1 = b.NewValue0(v.Pos, OpARMBICconst, t);
                v1.AuxInt = 0xff0000UL;
                var v2 = b.NewValue0(v.Pos, OpARMXOR, t);
                v2.AddArg(x);
                var v3 = b.NewValue0(v.Pos, OpARMSRRconst, t);
                v3.AuxInt = 16L;
                v3.AddArg(x);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v4 = b.NewValue0(v.Pos, OpARMSRRconst, t);
                v4.AuxInt = 8L;
                v4.AddArg(x);
                v.AddArg(v4);
                return true;
            } 
            // match: (Bswap32 x)
            // cond: objabi.GOARM>=6
            // result: (REV x)
 
            // match: (Bswap32 x)
            // cond: objabi.GOARM>=6
            // result: (REV x)
            while (true)
            {
                x = v.Args[0L];
                if (!(objabi.GOARM >= 6L))
                {
                    break;
                }
                v.reset(OpARMREV);
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpClosureCall_0(ref Value v)
        { 
            // match: (ClosureCall [argwid] entry closure mem)
            // cond:
            // result: (CALLclosure [argwid] entry closure mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[2L];
                var entry = v.Args[0L];
                var closure = v.Args[1L];
                var mem = v.Args[2L];
                v.reset(OpARMCALLclosure);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(closure);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCom16_0(ref Value v)
        { 
            // match: (Com16 x)
            // cond:
            // result: (MVN x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMVN);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCom32_0(ref Value v)
        { 
            // match: (Com32 x)
            // cond:
            // result: (MVN x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMVN);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCom8_0(ref Value v)
        { 
            // match: (Com8 x)
            // cond:
            // result: (MVN x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMVN);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpConst16_0(ref Value v)
        { 
            // match: (Const16 [val])
            // cond:
            // result: (MOVWconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConst32_0(ref Value v)
        { 
            // match: (Const32 [val])
            // cond:
            // result: (MOVWconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConst32F_0(ref Value v)
        { 
            // match: (Const32F [val])
            // cond:
            // result: (MOVFconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpARMMOVFconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConst64F_0(ref Value v)
        { 
            // match: (Const64F [val])
            // cond:
            // result: (MOVDconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpARMMOVDconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConst8_0(ref Value v)
        { 
            // match: (Const8 [val])
            // cond:
            // result: (MOVWconst [val])
            while (true)
            {
                var val = v.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = val;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConstBool_0(ref Value v)
        { 
            // match: (ConstBool [b])
            // cond:
            // result: (MOVWconst [b])
            while (true)
            {
                var b = v.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = b;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConstNil_0(ref Value v)
        { 
            // match: (ConstNil)
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            }

        }
        private static bool rewriteValueARM_OpConvert_0(ref Value v)
        { 
            // match: (Convert x mem)
            // cond:
            // result: (MOVWconvert x mem)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMMOVWconvert);
                v.AddArg(x);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCtz32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Ctz32 <t> x)
            // cond: objabi.GOARM<=6
            // result: (RSBconst [32] (CLZ <t> (SUBconst <t> (AND <t> x (RSBconst <t> [0] x)) [1])))
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                if (!(objabi.GOARM <= 6L))
                {
                    break;
                }
                v.reset(OpARMRSBconst);
                v.AuxInt = 32L;
                var v0 = b.NewValue0(v.Pos, OpARMCLZ, t);
                var v1 = b.NewValue0(v.Pos, OpARMSUBconst, t);
                v1.AuxInt = 1L;
                var v2 = b.NewValue0(v.Pos, OpARMAND, t);
                v2.AddArg(x);
                var v3 = b.NewValue0(v.Pos, OpARMRSBconst, t);
                v3.AuxInt = 0L;
                v3.AddArg(x);
                v2.AddArg(v3);
                v1.AddArg(v2);
                v0.AddArg(v1);
                v.AddArg(v0);
                return true;
            } 
            // match: (Ctz32 <t> x)
            // cond: objabi.GOARM==7
            // result: (CLZ <t> (RBIT <t> x))
 
            // match: (Ctz32 <t> x)
            // cond: objabi.GOARM==7
            // result: (CLZ <t> (RBIT <t> x))
            while (true)
            {
                t = v.Type;
                x = v.Args[0L];
                if (!(objabi.GOARM == 7L))
                {
                    break;
                }
                v.reset(OpARMCLZ);
                v.Type = t;
                v0 = b.NewValue0(v.Pos, OpARMRBIT, t);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpCvt32Fto32_0(ref Value v)
        { 
            // match: (Cvt32Fto32 x)
            // cond:
            // result: (MOVFW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVFW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32Fto32U_0(ref Value v)
        { 
            // match: (Cvt32Fto32U x)
            // cond:
            // result: (MOVFWU x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVFWU);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32Fto64F_0(ref Value v)
        { 
            // match: (Cvt32Fto64F x)
            // cond:
            // result: (MOVFD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVFD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32Uto32F_0(ref Value v)
        { 
            // match: (Cvt32Uto32F x)
            // cond:
            // result: (MOVWUF x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVWUF);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32Uto64F_0(ref Value v)
        { 
            // match: (Cvt32Uto64F x)
            // cond:
            // result: (MOVWUD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVWUD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32to32F_0(ref Value v)
        { 
            // match: (Cvt32to32F x)
            // cond:
            // result: (MOVWF x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVWF);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt32to64F_0(ref Value v)
        { 
            // match: (Cvt32to64F x)
            // cond:
            // result: (MOVWD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVWD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt64Fto32_0(ref Value v)
        { 
            // match: (Cvt64Fto32 x)
            // cond:
            // result: (MOVDW x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVDW);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt64Fto32F_0(ref Value v)
        { 
            // match: (Cvt64Fto32F x)
            // cond:
            // result: (MOVDF x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVDF);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpCvt64Fto32U_0(ref Value v)
        { 
            // match: (Cvt64Fto32U x)
            // cond:
            // result: (MOVDWU x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVDWU);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16 x y)
            // cond:
            // result: (Div32 (SignExt16to32 x) (SignExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpDiv32);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div16u x y)
            // cond:
            // result: (Div32u (ZeroExt16to32 x) (ZeroExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpDiv32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32 x y)
            // cond:
            // result: (SUB (XOR <typ.UInt32>         (Select0 <typ.UInt32> (CALLudiv             (SUB <typ.UInt32> (XOR x <typ.UInt32> (Signmask x)) (Signmask x))             (SUB <typ.UInt32> (XOR y <typ.UInt32> (Signmask y)) (Signmask y))))         (Signmask (XOR <typ.UInt32> x y))) (Signmask (XOR <typ.UInt32> x y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                var v0 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                var v1 = b.NewValue0(v.Pos, OpSelect0, typ.UInt32);
                var v2 = b.NewValue0(v.Pos, OpARMCALLudiv, types.NewTuple(typ.UInt32, typ.UInt32));
                var v3 = b.NewValue0(v.Pos, OpARMSUB, typ.UInt32);
                var v4 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v4.AddArg(x);
                var v5 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v5.AddArg(x);
                v4.AddArg(v5);
                v3.AddArg(v4);
                var v6 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v6.AddArg(x);
                v3.AddArg(v6);
                v2.AddArg(v3);
                var v7 = b.NewValue0(v.Pos, OpARMSUB, typ.UInt32);
                var v8 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v8.AddArg(y);
                var v9 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v9.AddArg(y);
                v8.AddArg(v9);
                v7.AddArg(v8);
                var v10 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v10.AddArg(y);
                v7.AddArg(v10);
                v2.AddArg(v7);
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v11 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                var v12 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v12.AddArg(x);
                v12.AddArg(y);
                v11.AddArg(v12);
                v0.AddArg(v11);
                v.AddArg(v0);
                var v13 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                var v14 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v14.AddArg(x);
                v14.AddArg(y);
                v13.AddArg(v14);
                v.AddArg(v13);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv32F_0(ref Value v)
        { 
            // match: (Div32F x y)
            // cond:
            // result: (DIVF x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMDIVF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div32u x y)
            // cond:
            // result: (Select0 <typ.UInt32> (CALLudiv x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect0);
                v.Type = typ.UInt32;
                var v0 = b.NewValue0(v.Pos, OpARMCALLudiv, types.NewTuple(typ.UInt32, typ.UInt32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv64F_0(ref Value v)
        { 
            // match: (Div64F x y)
            // cond:
            // result: (DIVD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMDIVD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8 x y)
            // cond:
            // result: (Div32 (SignExt8to32 x) (SignExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpDiv32);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpDiv8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Div8u x y)
            // cond:
            // result: (Div32u (ZeroExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpDiv32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq16 x y)
            // cond:
            // result: (Equal (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32 x y)
            // cond:
            // result: (Equal (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq32F x y)
            // cond:
            // result: (Equal (CMPF x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Eq64F x y)
            // cond:
            // result: (Equal (CMPD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Eq8 x y)
            // cond:
            // result: (Equal (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEqB_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (EqB x y)
            // cond:
            // result: (XORconst [1] (XOR <typ.Bool> x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMXORconst);
                v.AuxInt = 1L;
                var v0 = b.NewValue0(v.Pos, OpARMXOR, typ.Bool);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpEqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (EqPtr x y)
            // cond:
            // result: (Equal (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16 x y)
            // cond:
            // result: (GreaterEqual (CMP (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq16U x y)
            // cond:
            // result: (GreaterEqualU (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32 x y)
            // cond:
            // result: (GreaterEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32F x y)
            // cond:
            // result: (GreaterEqual (CMPF x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq32U x y)
            // cond:
            // result: (GreaterEqualU (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Geq64F x y)
            // cond:
            // result: (GreaterEqual (CMPD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8 x y)
            // cond:
            // result: (GreaterEqual (CMP (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Geq8U x y)
            // cond:
            // result: (GreaterEqualU (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGetCallerSP_0(ref Value v)
        { 
            // match: (GetCallerSP)
            // cond:
            // result: (LoweredGetCallerSP)
            while (true)
            {
                v.reset(OpARMLoweredGetCallerSP);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGetClosurePtr_0(ref Value v)
        { 
            // match: (GetClosurePtr)
            // cond:
            // result: (LoweredGetClosurePtr)
            while (true)
            {
                v.reset(OpARMLoweredGetClosurePtr);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16 x y)
            // cond:
            // result: (GreaterThan (CMP (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater16U x y)
            // cond:
            // result: (GreaterThanU (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32 x y)
            // cond:
            // result: (GreaterThan (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32F x y)
            // cond:
            // result: (GreaterThan (CMPF x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater32U x y)
            // cond:
            // result: (GreaterThanU (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Greater64F x y)
            // cond:
            // result: (GreaterThan (CMPD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8 x y)
            // cond:
            // result: (GreaterThan (CMP (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpGreater8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Greater8U x y)
            // cond:
            // result: (GreaterThanU (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpHmul32_0(ref Value v)
        { 
            // match: (Hmul32 x y)
            // cond:
            // result: (HMUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMHMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpHmul32u_0(ref Value v)
        { 
            // match: (Hmul32u x y)
            // cond:
            // result: (HMULU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMHMULU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpInterCall_0(ref Value v)
        { 
            // match: (InterCall [argwid] entry mem)
            // cond:
            // result: (CALLinter [argwid] entry mem)
            while (true)
            {
                var argwid = v.AuxInt;
                _ = v.Args[1L];
                var entry = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMCALLinter);
                v.AuxInt = argwid;
                v.AddArg(entry);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueARM_OpIsInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsInBounds idx len)
            // cond:
            // result: (LessThanU (CMP idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpARMLessThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpIsNonNil_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsNonNil ptr)
            // cond:
            // result: (NotEqual (CMPconst [0] ptr))
            while (true)
            {
                var ptr = v.Args[0L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = 0L;
                v0.AddArg(ptr);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpIsSliceInBounds_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (IsSliceInBounds idx len)
            // cond:
            // result: (LessEqualU (CMP idx len))
            while (true)
            {
                _ = v.Args[1L];
                var idx = v.Args[0L];
                var len = v.Args[1L];
                v.reset(OpARMLessEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(idx);
                v0.AddArg(len);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16 x y)
            // cond:
            // result: (LessEqual (CMP (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq16U x y)
            // cond:
            // result: (LessEqualU (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32 x y)
            // cond:
            // result: (LessEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32F x y)
            // cond:
            // result: (GreaterEqual (CMPF y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq32U x y)
            // cond:
            // result: (LessEqualU (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Leq64F x y)
            // cond:
            // result: (GreaterEqual (CMPD y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8 x y)
            // cond:
            // result: (LessEqual (CMP (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLeq8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Leq8U x y)
            // cond:
            // result: (LessEqualU (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessEqualU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16 x y)
            // cond:
            // result: (LessThan (CMP (SignExt16to32 x) (SignExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess16U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less16U x y)
            // cond:
            // result: (LessThanU (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32 x y)
            // cond:
            // result: (LessThan (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32F x y)
            // cond:
            // result: (GreaterThan (CMPF y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess32U_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less32U x y)
            // cond:
            // result: (LessThanU (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Less64F x y)
            // cond:
            // result: (GreaterThan (CMPD y x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMGreaterThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(y);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8 x y)
            // cond:
            // result: (LessThan (CMP (SignExt8to32 x) (SignExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThan);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLess8U_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Less8U x y)
            // cond:
            // result: (LessThanU (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMLessThanU);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLoad_0(ref Value v)
        { 
            // match: (Load <t> ptr mem)
            // cond: t.IsBoolean()
            // result: (MOVBUload ptr mem)
            while (true)
            {
                var t = v.Type;
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                if (!(t.IsBoolean()))
                {
                    break;
                }
                v.reset(OpARMMOVBUload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is8BitInt(t) && isSigned(t))
            // result: (MOVBload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is8BitInt(t) && isSigned(t))
            // result: (MOVBload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is8BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpARMMOVBload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is8BitInt(t) && !isSigned(t))
            // result: (MOVBUload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is8BitInt(t) && !isSigned(t))
            // result: (MOVBUload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is8BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpARMMOVBUload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is16BitInt(t) && isSigned(t))
            // result: (MOVHload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is16BitInt(t) && isSigned(t))
            // result: (MOVHload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && isSigned(t)))
                {
                    break;
                }
                v.reset(OpARMMOVHload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is16BitInt(t) && !isSigned(t))
            // result: (MOVHUload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is16BitInt(t) && !isSigned(t))
            // result: (MOVHUload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is16BitInt(t) && !isSigned(t)))
                {
                    break;
                }
                v.reset(OpARMMOVHUload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: (is32BitInt(t) || isPtr(t))
            // result: (MOVWload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: (is32BitInt(t) || isPtr(t))
            // result: (MOVWload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitInt(t) || isPtr(t)))
                {
                    break;
                }
                v.reset(OpARMMOVWload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (MOVFload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is32BitFloat(t)
            // result: (MOVFload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is32BitFloat(t)))
                {
                    break;
                }
                v.reset(OpARMMOVFload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            } 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (MOVDload ptr mem)
 
            // match: (Load <t> ptr mem)
            // cond: is64BitFloat(t)
            // result: (MOVDload ptr mem)
            while (true)
            {
                t = v.Type;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(is64BitFloat(t)))
                {
                    break;
                }
                v.reset(OpARMMOVDload);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpLsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x16 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh16x32 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh16x64_0(ref Value v)
        { 
            // match: (Lsh16x64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
 
            // match: (Lsh16x64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpLsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh16x8 x y)
            // cond:
            // result: (SLL x (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSLL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x16 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh32x32 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh32x64_0(ref Value v)
        { 
            // match: (Lsh32x64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
 
            // match: (Lsh32x64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpLsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh32x8 x y)
            // cond:
            // result: (SLL x (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSLL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x16 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Lsh8x32 x y)
            // cond:
            // result: (CMOVWHSconst (SLL <x.Type> x y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSLL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpLsh8x64_0(ref Value v)
        { 
            // match: (Lsh8x64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SLLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpARMSLLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8 [0])
 
            // match: (Lsh8x64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpLsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Lsh8x8 x y)
            // cond:
            // result: (SLL x (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSLL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16 x y)
            // cond:
            // result: (Mod32 (SignExt16to32 x) (SignExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod16u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod16u x y)
            // cond:
            // result: (Mod32u (ZeroExt16to32 x) (ZeroExt16to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32 x y)
            // cond:
            // result: (SUB (XOR <typ.UInt32>         (Select1 <typ.UInt32> (CALLudiv             (SUB <typ.UInt32> (XOR <typ.UInt32> x (Signmask x)) (Signmask x))             (SUB <typ.UInt32> (XOR <typ.UInt32> y (Signmask y)) (Signmask y))))         (Signmask x)) (Signmask x))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                var v0 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                var v1 = b.NewValue0(v.Pos, OpSelect1, typ.UInt32);
                var v2 = b.NewValue0(v.Pos, OpARMCALLudiv, types.NewTuple(typ.UInt32, typ.UInt32));
                var v3 = b.NewValue0(v.Pos, OpARMSUB, typ.UInt32);
                var v4 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v4.AddArg(x);
                var v5 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v5.AddArg(x);
                v4.AddArg(v5);
                v3.AddArg(v4);
                var v6 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v6.AddArg(x);
                v3.AddArg(v6);
                v2.AddArg(v3);
                var v7 = b.NewValue0(v.Pos, OpARMSUB, typ.UInt32);
                var v8 = b.NewValue0(v.Pos, OpARMXOR, typ.UInt32);
                v8.AddArg(y);
                var v9 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v9.AddArg(y);
                v8.AddArg(v9);
                v7.AddArg(v8);
                var v10 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v10.AddArg(y);
                v7.AddArg(v10);
                v2.AddArg(v7);
                v1.AddArg(v2);
                v0.AddArg(v1);
                var v11 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v11.AddArg(x);
                v0.AddArg(v11);
                v.AddArg(v0);
                var v12 = b.NewValue0(v.Pos, OpSignmask, typ.Int32);
                v12.AddArg(x);
                v.AddArg(v12);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod32u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod32u x y)
            // cond:
            // result: (Select1 <typ.UInt32> (CALLudiv x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpSelect1);
                v.Type = typ.UInt32;
                var v0 = b.NewValue0(v.Pos, OpARMCALLudiv, types.NewTuple(typ.UInt32, typ.UInt32));
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8 x y)
            // cond:
            // result: (Mod32 (SignExt8to32 x) (SignExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMod8u_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Mod8u x y)
            // cond:
            // result: (Mod32u (ZeroExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpMod32u);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMove_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Move [0] _ _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[2L];
                var mem = v.Args[2L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBUload src mem) mem)
 
            // match: (Move [1] dst src mem)
            // cond:
            // result: (MOVBstore dst (MOVBUload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[2L];
                var dst = v.Args[0L];
                var src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AddArg(dst);
                var v0 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [2] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore dst (MOVHUload src mem) mem)
 
            // match: (Move [2] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore dst (MOVHUload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                var t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Alignment() % 2L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVHUload, typ.UInt16);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVBstore [1] dst (MOVBUload [1] src mem)         (MOVBstore dst (MOVBUload src mem) mem))
 
            // match: (Move [2] dst src mem)
            // cond:
            // result: (MOVBstore [1] dst (MOVBUload [1] src mem)         (MOVBstore dst (MOVBUload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 1L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v0.AuxInt = 1L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AddArg(dst);
                var v2 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [4] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVWstore dst (MOVWload src mem) mem)
 
            // match: (Move [4] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVWstore dst (MOVWload src mem) mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVWstore);
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVWload, typ.UInt32);
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [4] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore [2] dst (MOVHUload [2] src mem)         (MOVHstore dst (MOVHUload src mem) mem))
 
            // match: (Move [4] {t} dst src mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore [2] dst (MOVHUload [2] src mem)         (MOVHstore dst (MOVHUload src mem) mem))
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Alignment() % 2L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AuxInt = 2L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVHUload, typ.UInt16);
                v0.AuxInt = 2L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVHstore, types.TypeMem);
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpARMMOVHUload, typ.UInt16);
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVBstore [3] dst (MOVBUload [3] src mem)         (MOVBstore [2] dst (MOVBUload [2] src mem)             (MOVBstore [1] dst (MOVBUload [1] src mem)                 (MOVBstore dst (MOVBUload src mem) mem))))
 
            // match: (Move [4] dst src mem)
            // cond:
            // result: (MOVBstore [3] dst (MOVBUload [3] src mem)         (MOVBstore [2] dst (MOVBUload [2] src mem)             (MOVBstore [1] dst (MOVBUload [1] src mem)                 (MOVBstore dst (MOVBUload src mem) mem))))
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 3L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v0.AuxInt = 3L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AuxInt = 2L;
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v2.AuxInt = 2L;
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v3.AuxInt = 1L;
                v3.AddArg(dst);
                var v4 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v4.AuxInt = 1L;
                v4.AddArg(src);
                v4.AddArg(mem);
                v3.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v5.AddArg(dst);
                var v6 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v6.AddArg(src);
                v6.AddArg(mem);
                v5.AddArg(v6);
                v5.AddArg(mem);
                v3.AddArg(v5);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBUload [2] src mem)         (MOVBstore [1] dst (MOVBUload [1] src mem)             (MOVBstore dst (MOVBUload src mem) mem)))
 
            // match: (Move [3] dst src mem)
            // cond:
            // result: (MOVBstore [2] dst (MOVBUload [2] src mem)         (MOVBstore [1] dst (MOVBUload [1] src mem)             (MOVBstore dst (MOVBUload src mem) mem)))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 2L;
                v.AddArg(dst);
                v0 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v0.AuxInt = 2L;
                v0.AddArg(src);
                v0.AddArg(mem);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AuxInt = 1L;
                v1.AddArg(dst);
                v2 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v2.AuxInt = 1L;
                v2.AddArg(src);
                v2.AddArg(mem);
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v3.AddArg(dst);
                v4 = b.NewValue0(v.Pos, OpARMMOVBUload, typ.UInt8);
                v4.AddArg(src);
                v4.AddArg(mem);
                v3.AddArg(v4);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Move [s] {t} dst src mem)
            // cond: s%4 == 0 && s > 4 && s <= 512     && t.(*types.Type).Alignment()%4 == 0 && !config.noDuffDevice
            // result: (DUFFCOPY [8 * (128 - int64(s/4))] dst src mem)
 
            // match: (Move [s] {t} dst src mem)
            // cond: s%4 == 0 && s > 4 && s <= 512     && t.(*types.Type).Alignment()%4 == 0 && !config.noDuffDevice
            // result: (DUFFCOPY [8 * (128 - int64(s/4))] dst src mem)
            while (true)
            {
                var s = v.AuxInt;
                t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!(s % 4L == 0L && s > 4L && s <= 512L && t._<ref types.Type>().Alignment() % 4L == 0L && !config.noDuffDevice))
                {
                    break;
                }
                v.reset(OpARMDUFFCOPY);
                v.AuxInt = 8L * (128L - int64(s / 4L));
                v.AddArg(dst);
                v.AddArg(src);
                v.AddArg(mem);
                return true;
            } 
            // match: (Move [s] {t} dst src mem)
            // cond: (s > 512 || config.noDuffDevice) || t.(*types.Type).Alignment()%4 != 0
            // result: (LoweredMove [t.(*types.Type).Alignment()]         dst         src         (ADDconst <src.Type> src [s-moveSize(t.(*types.Type).Alignment(), config)])         mem)
 
            // match: (Move [s] {t} dst src mem)
            // cond: (s > 512 || config.noDuffDevice) || t.(*types.Type).Alignment()%4 != 0
            // result: (LoweredMove [t.(*types.Type).Alignment()]         dst         src         (ADDconst <src.Type> src [s-moveSize(t.(*types.Type).Alignment(), config)])         mem)
            while (true)
            {
                s = v.AuxInt;
                t = v.Aux;
                _ = v.Args[2L];
                dst = v.Args[0L];
                src = v.Args[1L];
                mem = v.Args[2L];
                if (!((s > 512L || config.noDuffDevice) || t._<ref types.Type>().Alignment() % 4L != 0L))
                {
                    break;
                }
                v.reset(OpARMLoweredMove);
                v.AuxInt = t._<ref types.Type>().Alignment();
                v.AddArg(dst);
                v.AddArg(src);
                v0 = b.NewValue0(v.Pos, OpARMADDconst, src.Type);
                v0.AuxInt = s - moveSize(t._<ref types.Type>().Alignment(), config);
                v0.AddArg(src);
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpMul16_0(ref Value v)
        { 
            // match: (Mul16 x y)
            // cond:
            // result: (MUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMul32_0(ref Value v)
        { 
            // match: (Mul32 x y)
            // cond:
            // result: (MUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMul32F_0(ref Value v)
        { 
            // match: (Mul32F x y)
            // cond:
            // result: (MULF x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMULF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMul32uhilo_0(ref Value v)
        { 
            // match: (Mul32uhilo x y)
            // cond:
            // result: (MULLU x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMULLU);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMul64F_0(ref Value v)
        { 
            // match: (Mul64F x y)
            // cond:
            // result: (MULD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMULD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpMul8_0(ref Value v)
        { 
            // match: (Mul8 x y)
            // cond:
            // result: (MUL x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMMUL);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeg16_0(ref Value v)
        { 
            // match: (Neg16 x)
            // cond:
            // result: (RSBconst [0] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeg32_0(ref Value v)
        { 
            // match: (Neg32 x)
            // cond:
            // result: (RSBconst [0] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeg32F_0(ref Value v)
        { 
            // match: (Neg32F x)
            // cond:
            // result: (NEGF x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMNEGF);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeg64F_0(ref Value v)
        { 
            // match: (Neg64F x)
            // cond:
            // result: (NEGD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMNEGD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeg8_0(ref Value v)
        { 
            // match: (Neg8 x)
            // cond:
            // result: (RSBconst [0] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMRSBconst);
                v.AuxInt = 0L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeq16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq16 x y)
            // cond:
            // result: (NotEqual (CMP (ZeroExt16to32 x) (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeq32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32 x y)
            // cond:
            // result: (NotEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeq32F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq32F x y)
            // cond:
            // result: (NotEqual (CMPF x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPF, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeq64F_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Neq64F x y)
            // cond:
            // result: (NotEqual (CMPD x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMPD, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeq8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Neq8 x y)
            // cond:
            // result: (NotEqual (CMP (ZeroExt8to32 x) (ZeroExt8to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeqB_0(ref Value v)
        { 
            // match: (NeqB x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMXOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNeqPtr_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (NeqPtr x y)
            // cond:
            // result: (NotEqual (CMP x y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMNotEqual);
                var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNilCheck_0(ref Value v)
        { 
            // match: (NilCheck ptr mem)
            // cond:
            // result: (LoweredNilCheck ptr mem)
            while (true)
            {
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                var mem = v.Args[1L];
                v.reset(OpARMLoweredNilCheck);
                v.AddArg(ptr);
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueARM_OpNot_0(ref Value v)
        { 
            // match: (Not x)
            // cond:
            // result: (XORconst [1] x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMXORconst);
                v.AuxInt = 1L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpOffPtr_0(ref Value v)
        { 
            // match: (OffPtr [off] ptr:(SP))
            // cond:
            // result: (MOVWaddr [off] ptr)
            while (true)
            {
                var off = v.AuxInt;
                var ptr = v.Args[0L];
                if (ptr.Op != OpSP)
                {
                    break;
                }
                v.reset(OpARMMOVWaddr);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            } 
            // match: (OffPtr [off] ptr)
            // cond:
            // result: (ADDconst [off] ptr)
 
            // match: (OffPtr [off] ptr)
            // cond:
            // result: (ADDconst [off] ptr)
            while (true)
            {
                off = v.AuxInt;
                ptr = v.Args[0L];
                v.reset(OpARMADDconst);
                v.AuxInt = off;
                v.AddArg(ptr);
                return true;
            }

        }
        private static bool rewriteValueARM_OpOr16_0(ref Value v)
        { 
            // match: (Or16 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpOr32_0(ref Value v)
        { 
            // match: (Or32 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpOr8_0(ref Value v)
        { 
            // match: (Or8 x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpOrB_0(ref Value v)
        { 
            // match: (OrB x y)
            // cond:
            // result: (OR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRound32F_0(ref Value v)
        { 
            // match: (Round32F x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRound64F_0(ref Value v)
        { 
            // match: (Round64F x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux16 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> (ZeroExt16to32 x) (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                var v3 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v3.AuxInt = 256L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v4.AddArg(y);
                v3.AddArg(v4);
                v.AddArg(v3);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux32 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> (ZeroExt16to32 x) y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SRLconst (SLLconst <typ.UInt32> x [16]) [c+16])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpARMSRLconst);
                v.AuxInt = c + 16L;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 16L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
 
            // match: (Rsh16Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (Const16 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpConst16);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh16Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16Ux8 x y)
            // cond:
            // result: (SRL (ZeroExt16to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRL);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x16 x y)
            // cond:
            // result: (SRAcond (SignExt16to32 x) (ZeroExt16to32 y) (CMPconst [256] (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x32 x y)
            // cond:
            // result: (SRAcond (SignExt16to32 x) y (CMPconst [256] y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh16x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) < 16
            // result: (SRAconst (SLLconst <typ.UInt32> x [16]) [c+16])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 16L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = c + 16L;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 16L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (SRAconst (SLLconst <typ.UInt32> x [16]) [31])
 
            // match: (Rsh16x64 x (Const64 [c]))
            // cond: uint64(c) >= 16
            // result: (SRAconst (SLLconst <typ.UInt32> x [16]) [31])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 16L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 16L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh16x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh16x8 x y)
            // cond:
            // result: (SRA (SignExt16to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRA);
                var v0 = b.NewValue0(v.Pos, OpSignExt16to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux16 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> x (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v0.AddArg(v1);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32Ux32 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> x y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                v0.AddArg(x);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32Ux64_0(ref Value v)
        { 
            // match: (Rsh32Ux64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SRLconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpARMSRLconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
 
            // match: (Rsh32Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (Const32 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpConst32);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh32Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32Ux8 x y)
            // cond:
            // result: (SRL x (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRL);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x16 x y)
            // cond:
            // result: (SRAcond x (ZeroExt16to32 y) (CMPconst [256] (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v1.AddArg(v2);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Rsh32x32 x y)
            // cond:
            // result: (SRAcond x y (CMPconst [256] y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                v.AddArg(x);
                v.AddArg(y);
                var v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v0.AuxInt = 256L;
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh32x64_0(ref Value v)
        { 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) < 32
            // result: (SRAconst x [c])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 32L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = c;
                v.AddArg(x);
                return true;
            } 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (SRAconst x [31])
 
            // match: (Rsh32x64 x (Const64 [c]))
            // cond: uint64(c) >= 32
            // result: (SRAconst x [31])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 32L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v.AddArg(x);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh32x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh32x8 x y)
            // cond:
            // result: (SRA x (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRA);
                v.AddArg(x);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(y);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8Ux16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux16 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> (ZeroExt8to32 x) (ZeroExt16to32 y)) (CMPconst [256] (ZeroExt16to32 y)) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v2.AddArg(y);
                v0.AddArg(v2);
                v.AddArg(v0);
                var v3 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v3.AuxInt = 256L;
                var v4 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v4.AddArg(y);
                v3.AddArg(v4);
                v.AddArg(v3);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8Ux32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux32 x y)
            // cond:
            // result: (CMOVWHSconst (SRL <x.Type> (ZeroExt8to32 x) y) (CMPconst [256] y) [0])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMCMOVWHSconst);
                v.AuxInt = 0L;
                var v0 = b.NewValue0(v.Pos, OpARMSRL, x.Type);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(x);
                v0.AddArg(v1);
                v0.AddArg(y);
                v.AddArg(v0);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                v2.AddArg(y);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8Ux64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SRLconst (SLLconst <typ.UInt32> x [24]) [c+24])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpARMSRLconst);
                v.AuxInt = c + 24L;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 24L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8 [0])
 
            // match: (Rsh8Ux64 _ (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (Const8 [0])
            while (true)
            {
                _ = v.Args[1L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpConst8);
                v.AuxInt = 0L;
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh8Ux8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8Ux8 x y)
            // cond:
            // result: (SRL (ZeroExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRL);
                var v0 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8x16_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x16 x y)
            // cond:
            // result: (SRAcond (SignExt8to32 x) (ZeroExt16to32 y) (CMPconst [256] (ZeroExt16to32 y)))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                var v2 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v2.AuxInt = 256L;
                var v3 = b.NewValue0(v.Pos, OpZeroExt16to32, typ.UInt32);
                v3.AddArg(y);
                v2.AddArg(v3);
                v.AddArg(v2);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8x32_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x32 x y)
            // cond:
            // result: (SRAcond (SignExt8to32 x) y (CMPconst [256] y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRAcond);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                v.AddArg(y);
                var v1 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                v1.AuxInt = 256L;
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpRsh8x64_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) < 8
            // result: (SRAconst (SLLconst <typ.UInt32> x [24]) [c+24])
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                var c = v_1.AuxInt;
                if (!(uint64(c) < 8L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = c + 24L;
                var v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 24L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            } 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (SRAconst (SLLconst <typ.UInt32> x [24]) [31])
 
            // match: (Rsh8x64 x (Const64 [c]))
            // cond: uint64(c) >= 8
            // result: (SRAconst (SLLconst <typ.UInt32> x [24]) [31])
            while (true)
            {
                _ = v.Args[1L];
                x = v.Args[0L];
                v_1 = v.Args[1L];
                if (v_1.Op != OpConst64)
                {
                    break;
                }
                c = v_1.AuxInt;
                if (!(uint64(c) >= 8L))
                {
                    break;
                }
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v0 = b.NewValue0(v.Pos, OpARMSLLconst, typ.UInt32);
                v0.AuxInt = 24L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpRsh8x8_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Rsh8x8 x y)
            // cond:
            // result: (SRA (SignExt8to32 x) (ZeroExt8to32 y))
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSRA);
                var v0 = b.NewValue0(v.Pos, OpSignExt8to32, typ.Int32);
                v0.AddArg(x);
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpZeroExt8to32, typ.UInt32);
                v1.AddArg(y);
                v.AddArg(v1);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSelect0_0(ref Value v)
        { 
            // match: (Select0 (CALLudiv x (MOVWconst [1])))
            // cond:
            // result: x
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            } 
            // match: (Select0 (CALLudiv x (MOVWconst [c])))
            // cond: isPowerOfTwo(c)
            // result: (SRLconst [log2(c)] x)
 
            // match: (Select0 (CALLudiv x (MOVWconst [c])))
            // cond: isPowerOfTwo(c)
            // result: (SRLconst [log2(c)] x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMSRLconst);
                v.AuxInt = log2(c);
                v.AddArg(x);
                return true;
            } 
            // match: (Select0 (CALLudiv (MOVWconst [c]) (MOVWconst [d])))
            // cond:
            // result: (MOVWconst [int64(uint32(c)/uint32(d))])
 
            // match: (Select0 (CALLudiv (MOVWconst [c]) (MOVWconst [d])))
            // cond:
            // result: (MOVWconst [int64(uint32(c)/uint32(d))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0_1.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint32(c) / uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpSelect1_0(ref Value v)
        { 
            // match: (Select1 (CALLudiv _ (MOVWconst [1])))
            // cond:
            // result: (MOVWconst [0])
            while (true)
            {
                var v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                if (v_0_1.AuxInt != 1L)
                {
                    break;
                }
                v.reset(OpARMMOVWconst);
                v.AuxInt = 0L;
                return true;
            } 
            // match: (Select1 (CALLudiv x (MOVWconst [c])))
            // cond: isPowerOfTwo(c)
            // result: (ANDconst [c-1] x)
 
            // match: (Select1 (CALLudiv x (MOVWconst [c])))
            // cond: isPowerOfTwo(c)
            // result: (ANDconst [c-1] x)
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var x = v_0.Args[0L];
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var c = v_0_1.AuxInt;
                if (!(isPowerOfTwo(c)))
                {
                    break;
                }
                v.reset(OpARMANDconst);
                v.AuxInt = c - 1L;
                v.AddArg(x);
                return true;
            } 
            // match: (Select1 (CALLudiv (MOVWconst [c]) (MOVWconst [d])))
            // cond:
            // result: (MOVWconst [int64(uint32(c)%uint32(d))])
 
            // match: (Select1 (CALLudiv (MOVWconst [c]) (MOVWconst [d])))
            // cond:
            // result: (MOVWconst [int64(uint32(c)%uint32(d))])
            while (true)
            {
                v_0 = v.Args[0L];
                if (v_0.Op != OpARMCALLudiv)
                {
                    break;
                }
                _ = v_0.Args[1L];
                var v_0_0 = v_0.Args[0L];
                if (v_0_0.Op != OpARMMOVWconst)
                {
                    break;
                }
                c = v_0_0.AuxInt;
                v_0_1 = v_0.Args[1L];
                if (v_0_1.Op != OpARMMOVWconst)
                {
                    break;
                }
                var d = v_0_1.AuxInt;
                v.reset(OpARMMOVWconst);
                v.AuxInt = int64(uint32(c) % uint32(d));
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpSignExt16to32_0(ref Value v)
        { 
            // match: (SignExt16to32 x)
            // cond:
            // result: (MOVHreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVHreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSignExt8to16_0(ref Value v)
        { 
            // match: (SignExt8to16 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSignExt8to32_0(ref Value v)
        { 
            // match: (SignExt8to32 x)
            // cond:
            // result: (MOVBreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVBreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSignmask_0(ref Value v)
        { 
            // match: (Signmask x)
            // cond:
            // result: (SRAconst x [31])
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSlicemask_0(ref Value v)
        {
            var b = v.Block;
            _ = b; 
            // match: (Slicemask <t> x)
            // cond:
            // result: (SRAconst (RSBconst <t> [0] x) [31])
            while (true)
            {
                var t = v.Type;
                var x = v.Args[0L];
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                var v0 = b.NewValue0(v.Pos, OpARMRSBconst, t);
                v0.AuxInt = 0L;
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSqrt_0(ref Value v)
        { 
            // match: (Sqrt x)
            // cond:
            // result: (SQRTD x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMSQRTD);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpStaticCall_0(ref Value v)
        { 
            // match: (StaticCall [argwid] {target} mem)
            // cond:
            // result: (CALLstatic [argwid] {target} mem)
            while (true)
            {
                var argwid = v.AuxInt;
                var target = v.Aux;
                var mem = v.Args[0L];
                v.reset(OpARMCALLstatic);
                v.AuxInt = argwid;
                v.Aux = target;
                v.AddArg(mem);
                return true;
            }

        }
        private static bool rewriteValueARM_OpStore_0(ref Value v)
        { 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 1
            // result: (MOVBstore ptr val mem)
            while (true)
            {
                var t = v.Aux;
                _ = v.Args[2L];
                var ptr = v.Args[0L];
                var val = v.Args[1L];
                var mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 1L))
                {
                    break;
                }
                v.reset(OpARMMOVBstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 2
            // result: (MOVHstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 2L))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && !is32BitFloat(val.Type)
            // result: (MOVWstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && !is32BitFloat(val.Type)
            // result: (MOVWstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && !is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpARMMOVWstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (MOVFstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 4 && is32BitFloat(val.Type)
            // result: (MOVFstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 4L && is32BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpARMMOVFstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            } 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
            // result: (MOVDstore ptr val mem)
 
            // match: (Store {t} ptr val mem)
            // cond: t.(*types.Type).Size() == 8 && is64BitFloat(val.Type)
            // result: (MOVDstore ptr val mem)
            while (true)
            {
                t = v.Aux;
                _ = v.Args[2L];
                ptr = v.Args[0L];
                val = v.Args[1L];
                mem = v.Args[2L];
                if (!(t._<ref types.Type>().Size() == 8L && is64BitFloat(val.Type)))
                {
                    break;
                }
                v.reset(OpARMMOVDstore);
                v.AddArg(ptr);
                v.AddArg(val);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpSub16_0(ref Value v)
        { 
            // match: (Sub16 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub32_0(ref Value v)
        { 
            // match: (Sub32 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub32F_0(ref Value v)
        { 
            // match: (Sub32F x y)
            // cond:
            // result: (SUBF x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUBF);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub32carry_0(ref Value v)
        { 
            // match: (Sub32carry x y)
            // cond:
            // result: (SUBS x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUBS);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub32withcarry_0(ref Value v)
        { 
            // match: (Sub32withcarry x y c)
            // cond:
            // result: (SBC x y c)
            while (true)
            {
                _ = v.Args[2L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                var c = v.Args[2L];
                v.reset(OpARMSBC);
                v.AddArg(x);
                v.AddArg(y);
                v.AddArg(c);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub64F_0(ref Value v)
        { 
            // match: (Sub64F x y)
            // cond:
            // result: (SUBD x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUBD);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSub8_0(ref Value v)
        { 
            // match: (Sub8 x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpSubPtr_0(ref Value v)
        { 
            // match: (SubPtr x y)
            // cond:
            // result: (SUB x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMSUB);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpTrunc16to8_0(ref Value v)
        { 
            // match: (Trunc16to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpTrunc32to16_0(ref Value v)
        { 
            // match: (Trunc32to16 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpTrunc32to8_0(ref Value v)
        { 
            // match: (Trunc32to8 x)
            // cond:
            // result: x
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpCopy);
                v.Type = x.Type;
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpXor16_0(ref Value v)
        { 
            // match: (Xor16 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMXOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpXor32_0(ref Value v)
        { 
            // match: (Xor32 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMXOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpXor8_0(ref Value v)
        { 
            // match: (Xor8 x y)
            // cond:
            // result: (XOR x y)
            while (true)
            {
                _ = v.Args[1L];
                var x = v.Args[0L];
                var y = v.Args[1L];
                v.reset(OpARMXOR);
                v.AddArg(x);
                v.AddArg(y);
                return true;
            }

        }
        private static bool rewriteValueARM_OpZero_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var config = b.Func.Config;
            _ = config;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Zero [0] _ mem)
            // cond:
            // result: mem
            while (true)
            {
                if (v.AuxInt != 0L)
                {
                    break;
                }
                _ = v.Args[1L];
                var mem = v.Args[1L];
                v.reset(OpCopy);
                v.Type = mem.Type;
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [1] ptr mem)
            // cond:
            // result: (MOVBstore ptr (MOVWconst [0]) mem)
 
            // match: (Zero [1] ptr mem)
            // cond:
            // result: (MOVBstore ptr (MOVWconst [0]) mem)
            while (true)
            {
                if (v.AuxInt != 1L)
                {
                    break;
                }
                _ = v.Args[1L];
                var ptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBstore);
                v.AddArg(ptr);
                var v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [2] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore ptr (MOVWconst [0]) mem)
 
            // match: (Zero [2] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore ptr (MOVWconst [0]) mem)
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                var t = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 2L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [2] ptr mem)
            // cond:
            // result: (MOVBstore [1] ptr (MOVWconst [0])         (MOVBstore [0] ptr (MOVWconst [0]) mem))
 
            // match: (Zero [2] ptr mem)
            // cond:
            // result: (MOVBstore [1] ptr (MOVWconst [0])         (MOVBstore [0] ptr (MOVWconst [0]) mem))
            while (true)
            {
                if (v.AuxInt != 2L)
                {
                    break;
                }
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 1L;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                var v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                var v2 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v2.AuxInt = 0L;
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [4] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVWstore ptr (MOVWconst [0]) mem)
 
            // match: (Zero [4] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%4 == 0
            // result: (MOVWstore ptr (MOVWconst [0]) mem)
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 4L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVWstore);
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [4] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore [2] ptr (MOVWconst [0])         (MOVHstore [0] ptr (MOVWconst [0]) mem))
 
            // match: (Zero [4] {t} ptr mem)
            // cond: t.(*types.Type).Alignment()%2 == 0
            // result: (MOVHstore [2] ptr (MOVWconst [0])         (MOVHstore [0] ptr (MOVWconst [0]) mem))
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                t = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(t._<ref types.Type>().Alignment() % 2L == 0L))
                {
                    break;
                }
                v.reset(OpARMMOVHstore);
                v.AuxInt = 2L;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVHstore, types.TypeMem);
                v1.AuxInt = 0L;
                v1.AddArg(ptr);
                v2 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v2.AuxInt = 0L;
                v1.AddArg(v2);
                v1.AddArg(mem);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [4] ptr mem)
            // cond:
            // result: (MOVBstore [3] ptr (MOVWconst [0])         (MOVBstore [2] ptr (MOVWconst [0])             (MOVBstore [1] ptr (MOVWconst [0])                 (MOVBstore [0] ptr (MOVWconst [0]) mem))))
 
            // match: (Zero [4] ptr mem)
            // cond:
            // result: (MOVBstore [3] ptr (MOVWconst [0])         (MOVBstore [2] ptr (MOVWconst [0])             (MOVBstore [1] ptr (MOVWconst [0])                 (MOVBstore [0] ptr (MOVWconst [0]) mem))))
            while (true)
            {
                if (v.AuxInt != 4L)
                {
                    break;
                }
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 3L;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AuxInt = 2L;
                v1.AddArg(ptr);
                v2 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v2.AuxInt = 0L;
                v1.AddArg(v2);
                var v3 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v3.AuxInt = 1L;
                v3.AddArg(ptr);
                var v4 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v4.AuxInt = 0L;
                v3.AddArg(v4);
                var v5 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v5.AuxInt = 0L;
                v5.AddArg(ptr);
                var v6 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v6.AuxInt = 0L;
                v5.AddArg(v6);
                v5.AddArg(mem);
                v3.AddArg(v5);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [3] ptr mem)
            // cond:
            // result: (MOVBstore [2] ptr (MOVWconst [0])         (MOVBstore [1] ptr (MOVWconst [0])             (MOVBstore [0] ptr (MOVWconst [0]) mem)))
 
            // match: (Zero [3] ptr mem)
            // cond:
            // result: (MOVBstore [2] ptr (MOVWconst [0])         (MOVBstore [1] ptr (MOVWconst [0])             (MOVBstore [0] ptr (MOVWconst [0]) mem)))
            while (true)
            {
                if (v.AuxInt != 3L)
                {
                    break;
                }
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                v.reset(OpARMMOVBstore);
                v.AuxInt = 2L;
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v1.AuxInt = 1L;
                v1.AddArg(ptr);
                v2 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v2.AuxInt = 0L;
                v1.AddArg(v2);
                v3 = b.NewValue0(v.Pos, OpARMMOVBstore, types.TypeMem);
                v3.AuxInt = 0L;
                v3.AddArg(ptr);
                v4 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v4.AuxInt = 0L;
                v3.AddArg(v4);
                v3.AddArg(mem);
                v1.AddArg(v3);
                v.AddArg(v1);
                return true;
            } 
            // match: (Zero [s] {t} ptr mem)
            // cond: s%4 == 0 && s > 4 && s <= 512     && t.(*types.Type).Alignment()%4 == 0 && !config.noDuffDevice
            // result: (DUFFZERO [4 * (128 - int64(s/4))] ptr (MOVWconst [0]) mem)
 
            // match: (Zero [s] {t} ptr mem)
            // cond: s%4 == 0 && s > 4 && s <= 512     && t.(*types.Type).Alignment()%4 == 0 && !config.noDuffDevice
            // result: (DUFFZERO [4 * (128 - int64(s/4))] ptr (MOVWconst [0]) mem)
            while (true)
            {
                var s = v.AuxInt;
                t = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!(s % 4L == 0L && s > 4L && s <= 512L && t._<ref types.Type>().Alignment() % 4L == 0L && !config.noDuffDevice))
                {
                    break;
                }
                v.reset(OpARMDUFFZERO);
                v.AuxInt = 4L * (128L - int64(s / 4L));
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v0.AuxInt = 0L;
                v.AddArg(v0);
                v.AddArg(mem);
                return true;
            } 
            // match: (Zero [s] {t} ptr mem)
            // cond: (s > 512 || config.noDuffDevice) || t.(*types.Type).Alignment()%4 != 0
            // result: (LoweredZero [t.(*types.Type).Alignment()]         ptr         (ADDconst <ptr.Type> ptr [s-moveSize(t.(*types.Type).Alignment(), config)])         (MOVWconst [0])         mem)
 
            // match: (Zero [s] {t} ptr mem)
            // cond: (s > 512 || config.noDuffDevice) || t.(*types.Type).Alignment()%4 != 0
            // result: (LoweredZero [t.(*types.Type).Alignment()]         ptr         (ADDconst <ptr.Type> ptr [s-moveSize(t.(*types.Type).Alignment(), config)])         (MOVWconst [0])         mem)
            while (true)
            {
                s = v.AuxInt;
                t = v.Aux;
                _ = v.Args[1L];
                ptr = v.Args[0L];
                mem = v.Args[1L];
                if (!((s > 512L || config.noDuffDevice) || t._<ref types.Type>().Alignment() % 4L != 0L))
                {
                    break;
                }
                v.reset(OpARMLoweredZero);
                v.AuxInt = t._<ref types.Type>().Alignment();
                v.AddArg(ptr);
                v0 = b.NewValue0(v.Pos, OpARMADDconst, ptr.Type);
                v0.AuxInt = s - moveSize(t._<ref types.Type>().Alignment(), config);
                v0.AddArg(ptr);
                v.AddArg(v0);
                v1 = b.NewValue0(v.Pos, OpARMMOVWconst, typ.UInt32);
                v1.AuxInt = 0L;
                v.AddArg(v1);
                v.AddArg(mem);
                return true;
            }

            return false;
        }
        private static bool rewriteValueARM_OpZeroExt16to32_0(ref Value v)
        { 
            // match: (ZeroExt16to32 x)
            // cond:
            // result: (MOVHUreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVHUreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpZeroExt8to16_0(ref Value v)
        { 
            // match: (ZeroExt8to16 x)
            // cond:
            // result: (MOVBUreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVBUreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpZeroExt8to32_0(ref Value v)
        { 
            // match: (ZeroExt8to32 x)
            // cond:
            // result: (MOVBUreg x)
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMMOVBUreg);
                v.AddArg(x);
                return true;
            }

        }
        private static bool rewriteValueARM_OpZeromask_0(ref Value v)
        {
            var b = v.Block;
            _ = b;
            var typ = ref b.Func.Config.Types;
            _ = typ; 
            // match: (Zeromask x)
            // cond:
            // result: (SRAconst (RSBshiftRL <typ.Int32> x x [1]) [31])
            while (true)
            {
                var x = v.Args[0L];
                v.reset(OpARMSRAconst);
                v.AuxInt = 31L;
                var v0 = b.NewValue0(v.Pos, OpARMRSBshiftRL, typ.Int32);
                v0.AuxInt = 1L;
                v0.AddArg(x);
                v0.AddArg(x);
                v.AddArg(v0);
                return true;
            }

        }
        private static bool rewriteBlockARM(ref Block b)
        {
            var config = b.Func.Config;
            _ = config;
            var fe = b.Func.fe;
            _ = fe;
            var typ = ref config.Types;
            _ = typ;

            if (b.Kind == BlockARMEQ) 
                // match: (EQ (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    var v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (EQ (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
 
                // match: (EQ (InvertFlags cmp) yes no)
                // cond:
                // result: (EQ cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    var cmp = v.Args[0L];
                    b.Kind = BlockARMEQ;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUB x y)) yes no)
                // cond:
                // result: (EQ (CMP x y) yes no)
 
                // match: (EQ (CMPconst [0] (SUB x y)) yes no)
                // cond:
                // result: (EQ (CMP x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    var v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUB)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    var x = v_0.Args[0L];
                    var y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    var v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBconst [c] x)) yes no)
                // cond:
                // result: (EQ (CMPconst [c] x) yes no)
 
                // match: (EQ (CMPconst [0] (SUBconst [c] x)) yes no)
                // cond:
                // result: (EQ (CMPconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBconst)
                    {
                        break;
                    }
                    var c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftLL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftRL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftRA x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (CMPshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftLLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    var z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftRLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (SUBshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftRAreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (SUBshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (CMPshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADD x y)) yes no)
                // cond:
                // result: (EQ (CMN x y) yes no)
 
                // match: (EQ (CMPconst [0] (ADD x y)) yes no)
                // cond:
                // result: (EQ (CMN x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADD)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDconst [c] x)) yes no)
                // cond:
                // result: (EQ (CMNconst [c] x) yes no)
 
                // match: (EQ (CMPconst [0] (ADDconst [c] x)) yes no)
                // cond:
                // result: (EQ (CMNconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftLL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftRL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftRA x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (CMNshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftLLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftRLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ADDshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftRAreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ADDshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (CMNshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (AND x y)) yes no)
                // cond:
                // result: (EQ (TST x y) yes no)
 
                // match: (EQ (CMPconst [0] (AND x y)) yes no)
                // cond:
                // result: (EQ (TST x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMAND)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTST, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (EQ (TSTconst [c] x) yes no)
 
                // match: (EQ (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (EQ (TSTconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftLL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftRL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftRA x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (TSTshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftLLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftRLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (ANDshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftRAreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (ANDshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (TSTshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XOR x y)) yes no)
                // cond:
                // result: (EQ (TEQ x y) yes no)
 
                // match: (EQ (CMPconst [0] (XOR x y)) yes no)
                // cond:
                // result: (EQ (TEQ x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXOR)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORconst [c] x)) yes no)
                // cond:
                // result: (EQ (TEQconst [c] x) yes no)
 
                // match: (EQ (CMPconst [0] (XORconst [c] x)) yes no)
                // cond:
                // result: (EQ (TEQconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftLL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftLL x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftRL x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftRL x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftRA x y [c]) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftRA x y [c])) yes no)
                // cond:
                // result: (EQ (TEQshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftLLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftLLreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftRLreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftRLreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (EQ (CMPconst [0] (XORshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftRAreg x y z) yes no)
 
                // match: (EQ (CMPconst [0] (XORshiftRAreg x y z)) yes no)
                // cond:
                // result: (EQ (TEQshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMEQ;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMGE) 
                // match: (GE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
 
                // match: (GE (InvertFlags cmp) yes no)
                // cond:
                // result: (LE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMLE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMGT) 
                // match: (GT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (GT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (GT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (GT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
 
                // match: (GT (InvertFlags cmp) yes no)
                // cond:
                // result: (LT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMLT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockIf) 
                // match: (If (Equal cc) yes no)
                // cond:
                // result: (EQ cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMEqual)
                    {
                        break;
                    }
                    var cc = v.Args[0L];
                    b.Kind = BlockARMEQ;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (NotEqual cc) yes no)
                // cond:
                // result: (NE cc yes no)
 
                // match: (If (NotEqual cc) yes no)
                // cond:
                // result: (NE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMNotEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMNE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessThan cc) yes no)
                // cond:
                // result: (LT cc yes no)
 
                // match: (If (LessThan cc) yes no)
                // cond:
                // result: (LT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMLessThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMLT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessThanU cc) yes no)
                // cond:
                // result: (ULT cc yes no)
 
                // match: (If (LessThanU cc) yes no)
                // cond:
                // result: (ULT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMLessThanU)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMULT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessEqual cc) yes no)
                // cond:
                // result: (LE cc yes no)
 
                // match: (If (LessEqual cc) yes no)
                // cond:
                // result: (LE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMLessEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMLE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (LessEqualU cc) yes no)
                // cond:
                // result: (ULE cc yes no)
 
                // match: (If (LessEqualU cc) yes no)
                // cond:
                // result: (ULE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMLessEqualU)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMULE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterThan cc) yes no)
                // cond:
                // result: (GT cc yes no)
 
                // match: (If (GreaterThan cc) yes no)
                // cond:
                // result: (GT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMGreaterThan)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterThanU cc) yes no)
                // cond:
                // result: (UGT cc yes no)
 
                // match: (If (GreaterThanU cc) yes no)
                // cond:
                // result: (UGT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMGreaterThanU)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMUGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterEqual cc) yes no)
                // cond:
                // result: (GE cc yes no)
 
                // match: (If (GreaterEqual cc) yes no)
                // cond:
                // result: (GE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMGreaterEqual)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If (GreaterEqualU cc) yes no)
                // cond:
                // result: (UGE cc yes no)
 
                // match: (If (GreaterEqualU cc) yes no)
                // cond:
                // result: (UGE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMGreaterEqualU)
                    {
                        break;
                    }
                    cc = v.Args[0L];
                    b.Kind = BlockARMUGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPconst [0] cond) yes no)
 
                // match: (If cond yes no)
                // cond:
                // result: (NE (CMPconst [0] cond) yes no)
                while (true)
                {
                    v = b.Control;
                    _ = v;
                    var cond = b.Control;
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                    v0.AuxInt = 0L;
                    v0.AddArg(cond);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMLE) 
                // match: (LE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
 
                // match: (LE (InvertFlags cmp) yes no)
                // cond:
                // result: (GE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMLT) 
                // match: (LT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (LT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (LT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (LT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
 
                // match: (LT (InvertFlags cmp) yes no)
                // cond:
                // result: (GT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMNE) 
                // match: (NE (CMPconst [0] (Equal cc)) yes no)
                // cond:
                // result: (EQ cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMEQ;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (NotEqual cc)) yes no)
                // cond:
                // result: (NE cc yes no)
 
                // match: (NE (CMPconst [0] (NotEqual cc)) yes no)
                // cond:
                // result: (NE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMNotEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMNE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (LessThan cc)) yes no)
                // cond:
                // result: (LT cc yes no)
 
                // match: (NE (CMPconst [0] (LessThan cc)) yes no)
                // cond:
                // result: (LT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMLessThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMLT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (LessThanU cc)) yes no)
                // cond:
                // result: (ULT cc yes no)
 
                // match: (NE (CMPconst [0] (LessThanU cc)) yes no)
                // cond:
                // result: (ULT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMLessThanU)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMULT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (LessEqual cc)) yes no)
                // cond:
                // result: (LE cc yes no)
 
                // match: (NE (CMPconst [0] (LessEqual cc)) yes no)
                // cond:
                // result: (LE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMLessEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMLE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (LessEqualU cc)) yes no)
                // cond:
                // result: (ULE cc yes no)
 
                // match: (NE (CMPconst [0] (LessEqualU cc)) yes no)
                // cond:
                // result: (ULE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMLessEqualU)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMULE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (GreaterThan cc)) yes no)
                // cond:
                // result: (GT cc yes no)
 
                // match: (NE (CMPconst [0] (GreaterThan cc)) yes no)
                // cond:
                // result: (GT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMGreaterThan)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (GreaterThanU cc)) yes no)
                // cond:
                // result: (UGT cc yes no)
 
                // match: (NE (CMPconst [0] (GreaterThanU cc)) yes no)
                // cond:
                // result: (UGT cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMGreaterThanU)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMUGT;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (GreaterEqual cc)) yes no)
                // cond:
                // result: (GE cc yes no)
 
                // match: (NE (CMPconst [0] (GreaterEqual cc)) yes no)
                // cond:
                // result: (GE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMGreaterEqual)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (GreaterEqualU cc)) yes no)
                // cond:
                // result: (UGE cc yes no)
 
                // match: (NE (CMPconst [0] (GreaterEqualU cc)) yes no)
                // cond:
                // result: (UGE cc yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMGreaterEqualU)
                    {
                        break;
                    }
                    cc = v_0.Args[0L];
                    b.Kind = BlockARMUGE;
                    b.SetControl(cc);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (NE (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (NE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (NE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
 
                // match: (NE (InvertFlags cmp) yes no)
                // cond:
                // result: (NE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMNE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUB x y)) yes no)
                // cond:
                // result: (NE (CMP x y) yes no)
 
                // match: (NE (CMPconst [0] (SUB x y)) yes no)
                // cond:
                // result: (NE (CMP x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUB)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMP, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBconst [c] x)) yes no)
                // cond:
                // result: (NE (CMPconst [c] x) yes no)
 
                // match: (NE (CMPconst [0] (SUBconst [c] x)) yes no)
                // cond:
                // result: (NE (CMPconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftLL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftRL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftRA x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (CMPshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftLLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftRLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (SUBshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftRAreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (SUBshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (CMPshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMSUBshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMPshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADD x y)) yes no)
                // cond:
                // result: (NE (CMN x y) yes no)
 
                // match: (NE (CMPconst [0] (ADD x y)) yes no)
                // cond:
                // result: (NE (CMN x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADD)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMN, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDconst [c] x)) yes no)
                // cond:
                // result: (NE (CMNconst [c] x) yes no)
 
                // match: (NE (CMPconst [0] (ADDconst [c] x)) yes no)
                // cond:
                // result: (NE (CMNconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftLL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftRL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftRA x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (CMNshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftLLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftRLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ADDshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftRAreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ADDshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (CMNshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMADDshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMCMNshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (AND x y)) yes no)
                // cond:
                // result: (NE (TST x y) yes no)
 
                // match: (NE (CMPconst [0] (AND x y)) yes no)
                // cond:
                // result: (NE (TST x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMAND)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTST, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (TSTconst [c] x) yes no)
 
                // match: (NE (CMPconst [0] (ANDconst [c] x)) yes no)
                // cond:
                // result: (NE (TSTconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftLL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftRL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftRA x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (TSTshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftLLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftRLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (ANDshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftRAreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (ANDshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (TSTshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMANDshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTSTshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XOR x y)) yes no)
                // cond:
                // result: (NE (TEQ x y) yes no)
 
                // match: (NE (CMPconst [0] (XOR x y)) yes no)
                // cond:
                // result: (NE (TEQ x y) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXOR)
                    {
                        break;
                    }
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQ, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORconst [c] x)) yes no)
                // cond:
                // result: (NE (TEQconst [c] x) yes no)
 
                // match: (NE (CMPconst [0] (XORconst [c] x)) yes no)
                // cond:
                // result: (NE (TEQconst [c] x) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORconst)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    x = v_0.Args[0L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQconst, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftLL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftLL x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftLL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftLL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftLL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftRL x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftRL x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftRL x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRL)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRL, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftRA x y [c]) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftRA x y [c])) yes no)
                // cond:
                // result: (NE (TEQshiftRA x y [c]) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRA)
                    {
                        break;
                    }
                    c = v_0.AuxInt;
                    _ = v_0.Args[1L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRA, types.TypeFlags);
                    v0.AuxInt = c;
                    v0.AddArg(x);
                    v0.AddArg(y);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftLLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftLLreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftLLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftLLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftLLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftRLreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftRLreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftRLreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRLreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRLreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                } 
                // match: (NE (CMPconst [0] (XORshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftRAreg x y z) yes no)
 
                // match: (NE (CMPconst [0] (XORshiftRAreg x y z)) yes no)
                // cond:
                // result: (NE (TEQshiftRAreg x y z) yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMCMPconst)
                    {
                        break;
                    }
                    if (v.AuxInt != 0L)
                    {
                        break;
                    }
                    v_0 = v.Args[0L];
                    if (v_0.Op != OpARMXORshiftRAreg)
                    {
                        break;
                    }
                    _ = v_0.Args[2L];
                    x = v_0.Args[0L];
                    y = v_0.Args[1L];
                    z = v_0.Args[2L];
                    b.Kind = BlockARMNE;
                    v0 = b.NewValue0(v.Pos, OpARMTEQshiftRAreg, types.TypeFlags);
                    v0.AddArg(x);
                    v0.AddArg(y);
                    v0.AddArg(z);
                    b.SetControl(v0);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMUGE) 
                // match: (UGE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGE (InvertFlags cmp) yes no)
                // cond:
                // result: (ULE cmp yes no)
 
                // match: (UGE (InvertFlags cmp) yes no)
                // cond:
                // result: (ULE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMULE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMUGT) 
                // match: (UGT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (UGT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (UGT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (UGT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (UGT (InvertFlags cmp) yes no)
                // cond:
                // result: (ULT cmp yes no)
 
                // match: (UGT (InvertFlags cmp) yes no)
                // cond:
                // result: (ULT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMULT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMULE) 
                // match: (ULE (FlagEQ) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULE (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULE (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULE (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULE (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULE (InvertFlags cmp) yes no)
                // cond:
                // result: (UGE cmp yes no)
 
                // match: (ULE (InvertFlags cmp) yes no)
                // cond:
                // result: (UGE cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMUGE;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
            else if (b.Kind == BlockARMULT) 
                // match: (ULT (FlagEQ) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagEQ)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULT (FlagLT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULT (FlagLT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagLT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
 
                // match: (ULT (FlagGT_ULT) yes no)
                // cond:
                // result: (First nil yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_ULT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    return true;
                } 
                // match: (ULT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
 
                // match: (ULT (FlagGT_UGT) yes no)
                // cond:
                // result: (First nil no yes)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMFlagGT_UGT)
                    {
                        break;
                    }
                    b.Kind = BlockFirst;
                    b.SetControl(null);
                    b.Aux = null;
                    b.swapSuccessors();
                    return true;
                } 
                // match: (ULT (InvertFlags cmp) yes no)
                // cond:
                // result: (UGT cmp yes no)
 
                // match: (ULT (InvertFlags cmp) yes no)
                // cond:
                // result: (UGT cmp yes no)
                while (true)
                {
                    v = b.Control;
                    if (v.Op != OpARMInvertFlags)
                    {
                        break;
                    }
                    cmp = v.Args[0L];
                    b.Kind = BlockARMUGT;
                    b.SetControl(cmp);
                    b.Aux = null;
                    return true;
                }
                        return false;
        }
    }
}}}}
