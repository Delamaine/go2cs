// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package ld -- go2cs converted at 2020 August 29 10:04:18 UTC
// import "cmd/link/internal/ld" ==> using ld = go.cmd.link.@internal.ld_package
// Original source: C:\Go\src\cmd\link\internal\ld\macho_combine_dwarf.go
using bytes = go.bytes_package;
using macho = go.debug.macho_package;
using binary = go.encoding.binary_package;
using fmt = go.fmt_package;
using io = go.io_package;
using os = go.os_package;
using reflect = go.reflect_package;
using @unsafe = go.@unsafe_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace link {
namespace @internal
{
    public static partial class ld_package
    {
        private static ref macho.Segment realdwarf = default;        private static ref macho.Segment linkseg = default;

        private static long dwarfstart = default;        private static long linkstart = default;

        private static long dwarfaddr = default;
        private static uint linkoffset = default;

        private static readonly long pageAlign = 12L; // 4096 = 1 << 12

        private partial struct loadCmd
        {
            public macho.LoadCmd Cmd;
            public uint Len;
        }

        private partial struct dyldInfoCmd
        {
            public macho.LoadCmd Cmd;
            public uint Len;
            public uint RebaseOff;
            public uint RebaseLen;
            public uint BindOff;
            public uint BindLen;
            public uint WeakBindOff;
            public uint WeakBindLen;
            public uint LazyBindOff;
            public uint LazyBindLen;
            public uint ExportOff;
            public uint ExportLen;
        }

        private partial struct linkEditDataCmd
        {
            public macho.LoadCmd Cmd;
            public uint Len;
            public uint DataOff;
            public uint DataLen;
        }

        private partial struct encryptionInfoCmd
        {
            public macho.LoadCmd Cmd;
            public uint Len;
            public uint CryptOff;
            public uint CryptLen;
            public uint CryptId;
        }

        private partial struct loadCmdReader
        {
            public long offset;
            public long next;
            public ptr<os.File> f;
            public binary.ByteOrder order;
        }

        private static (loadCmd, error) Next(this ref loadCmdReader r)
        {
            r.offset = r.next;
            _, err = r.f.Seek(r.offset, 0L);

            if (err != null)
            {
                return;
            }
            err = binary.Read(r.f, r.order, ref cmd);

            if (err != null)
            {
                return;
            }
            r.next = r.offset + int64(cmd.Len);
            return;
        }

        private static error ReadAt(this loadCmdReader r, long offset, object data)
        {
            {
                var (_, err) = r.f.Seek(r.offset + offset, 0L);

                if (err != null)
                {
                    return error.As(err);
                }

            }
            return error.As(binary.Read(r.f, r.order, data));
        }

        private static error WriteAt(this loadCmdReader r, long offset, object data)
        {
            {
                var (_, err) = r.f.Seek(r.offset + offset, 0L);

                if (err != null)
                {
                    return error.As(err);
                }

            }
            return error.As(binary.Write(r.f, r.order, data));
        }

        // machoCombineDwarf merges dwarf info generated by dsymutil into a macho executable.
        // With internal linking, DWARF is embedded into the executable, this lets us do the
        // same for external linking.
        // inexe is the path to the executable with no DWARF. It must have enough room in the macho
        // header to add the DWARF sections. (Use ld's -headerpad option)
        // dsym is the path to the macho file containing DWARF from dsymutil.
        // outexe is the path where the combined executable should be saved.
        private static error machoCombineDwarf(@string inexe, @string dsym, @string outexe, BuildMode buildmode)
        {
            var (exef, err) = os.Open(inexe);
            if (err != null)
            {
                return error.As(err);
            }
            var (dwarff, err) = os.Open(dsym);
            if (err != null)
            {
                return error.As(err);
            }
            var (outf, err) = os.Create(outexe);
            if (err != null)
            {
                return error.As(err);
            }
            outf.Chmod(0755L);

            var (exem, err) = macho.NewFile(exef);
            if (err != null)
            {
                return error.As(err);
            }
            var (dwarfm, err) = macho.NewFile(dwarff);
            if (err != null)
            {
                return error.As(err);
            } 

            // The string table needs to be the last thing in the file
            // for code signing to work. So we'll need to move the
            // linkedit section, but all the others can be copied directly.
            linkseg = exem.Segment("__LINKEDIT");
            if (linkseg == null)
            {
                return error.As(fmt.Errorf("missing __LINKEDIT segment"));
            }
            _, err = exef.Seek(0L, 0L);

            if (err != null)
            {
                return error.As(err);
            }
            {
                var (_, err) = io.CopyN(outf, exef, int64(linkseg.Offset));

                if (err != null)
                {
                    return error.As(err);
                }

            }

            realdwarf = dwarfm.Segment("__DWARF");
            if (realdwarf == null)
            {
                return error.As(fmt.Errorf("missing __DWARF segment"));
            } 

            // Now copy the dwarf data into the output.
            // Kernel requires all loaded segments to be page-aligned in the file,
            // even though we mark this one as being 0 bytes of virtual address space.
            dwarfstart = machoCalcStart(realdwarf.Offset, linkseg.Offset, pageAlign);
            _, err = outf.Seek(dwarfstart, 0L);

            if (err != null)
            {
                return error.As(err);
            }
            dwarfaddr = int64((linkseg.Addr + linkseg.Memsz + 1L << (int)(pageAlign) - 1L) & ~(1L << (int)(pageAlign) - 1L));

            _, err = dwarff.Seek(int64(realdwarf.Offset), 0L);

            if (err != null)
            {
                return error.As(err);
            }
            {
                (_, err) = io.CopyN(outf, dwarff, int64(realdwarf.Filesz));

                if (err != null)
                {
                    return error.As(err);
                } 

                // And finally the linkedit section.

            } 

            // And finally the linkedit section.
            _, err = exef.Seek(int64(linkseg.Offset), 0L);

            if (err != null)
            {
                return error.As(err);
            }
            linkstart = machoCalcStart(linkseg.Offset, uint64(dwarfstart) + realdwarf.Filesz, pageAlign);
            linkoffset = uint32(linkstart - int64(linkseg.Offset));
            _, err = outf.Seek(linkstart, 0L);

            if (err != null)
            {
                return error.As(err);
            }
            {
                (_, err) = io.Copy(outf, exef);

                if (err != null)
                {
                    return error.As(err);
                } 

                // Now we need to update the headers.

            } 

            // Now we need to update the headers.
            var cmdOffset = @unsafe.Sizeof(exem.FileHeader);
            var is64bit = exem.Magic == macho.Magic64;
            if (is64bit)
            { 
                // mach_header_64 has one extra uint32.
                cmdOffset += @unsafe.Sizeof(exem.Magic);
            }
            var textsect = exem.Section("__text");
            if (linkseg == null)
            {
                return error.As(fmt.Errorf("missing __text section"));
            }
            var dwarfCmdOffset = int64(cmdOffset) + int64(exem.FileHeader.Cmdsz);
            var availablePadding = int64(textsect.Offset) - dwarfCmdOffset;
            if (availablePadding < int64(realdwarf.Len))
            {
                return error.As(fmt.Errorf("No room to add dwarf info. Need at least %d padding bytes, found %d", realdwarf.Len, availablePadding));
            } 
            // First, copy the dwarf load command into the header
            _, err = outf.Seek(dwarfCmdOffset, 0L);

            if (err != null)
            {
                return error.As(err);
            }
            {
                (_, err) = io.CopyN(outf, bytes.NewReader(realdwarf.Raw()), int64(realdwarf.Len));

                if (err != null)
                {
                    return error.As(err);
                }

            }

            _, err = outf.Seek(int64(@unsafe.Offsetof(exem.FileHeader.Ncmd)), 0L);

            if (err != null)
            {
                return error.As(err);
            }
            err = binary.Write(outf, exem.ByteOrder, exem.Ncmd + 1L);

            if (err != null)
            {
                return error.As(err);
            }
            err = binary.Write(outf, exem.ByteOrder, exem.Cmdsz + realdwarf.Len);

            if (err != null)
            {
                return error.As(err);
            }
            loadCmdReader reader = new loadCmdReader(next:int64(cmdOffset),f:outf,order:exem.ByteOrder);
            for (var i = uint32(0L); i < exem.Ncmd; i++)
            {
                var (cmd, err) = reader.Next();
                if (err != null)
                {
                    return error.As(err);
                }

                if (cmd.Cmd == macho.LoadCmdSegment64) 
                    err = machoUpdateSegment(reader, ref new macho.Segment64(), ref new macho.Section64());
                else if (cmd.Cmd == macho.LoadCmdSegment) 
                    err = machoUpdateSegment(reader, ref new macho.Segment32(), ref new macho.Section32());
                else if (cmd.Cmd == LC_DYLD_INFO || cmd.Cmd == LC_DYLD_INFO_ONLY) 
                    err = machoUpdateLoadCommand(reader, ref new dyldInfoCmd(), "RebaseOff", "BindOff", "WeakBindOff", "LazyBindOff", "ExportOff");
                else if (cmd.Cmd == macho.LoadCmdSymtab) 
                    err = machoUpdateLoadCommand(reader, ref new macho.SymtabCmd(), "Symoff", "Stroff");
                else if (cmd.Cmd == macho.LoadCmdDysymtab) 
                    err = machoUpdateLoadCommand(reader, ref new macho.DysymtabCmd(), "Tocoffset", "Modtaboff", "Extrefsymoff", "Indirectsymoff", "Extreloff", "Locreloff");
                else if (cmd.Cmd == LC_CODE_SIGNATURE || cmd.Cmd == LC_SEGMENT_SPLIT_INFO || cmd.Cmd == LC_FUNCTION_STARTS || cmd.Cmd == LC_DATA_IN_CODE || cmd.Cmd == LC_DYLIB_CODE_SIGN_DRS) 
                    err = machoUpdateLoadCommand(reader, ref new linkEditDataCmd(), "DataOff");
                else if (cmd.Cmd == LC_ENCRYPTION_INFO || cmd.Cmd == LC_ENCRYPTION_INFO_64) 
                    err = machoUpdateLoadCommand(reader, ref new encryptionInfoCmd(), "CryptOff");
                else if (cmd.Cmd == macho.LoadCmdDylib || cmd.Cmd == macho.LoadCmdThread || cmd.Cmd == macho.LoadCmdUnixThread || cmd.Cmd == LC_PREBOUND_DYLIB || cmd.Cmd == LC_UUID || cmd.Cmd == LC_VERSION_MIN_MACOSX || cmd.Cmd == LC_VERSION_MIN_IPHONEOS || cmd.Cmd == LC_SOURCE_VERSION || cmd.Cmd == LC_MAIN || cmd.Cmd == LC_LOAD_DYLINKER || cmd.Cmd == LC_LOAD_WEAK_DYLIB || cmd.Cmd == LC_REEXPORT_DYLIB || cmd.Cmd == LC_RPATH || cmd.Cmd == LC_ID_DYLIB)                 else 
                    err = fmt.Errorf("Unknown load command 0x%x (%s)\n", int(cmd.Cmd), cmd.Cmd);
                                if (err != null)
                {
                    return error.As(err);
                }
            }

            return error.As(machoUpdateDwarfHeader(ref reader, buildmode));
        }

        // machoUpdateSegment updates the load command for a moved segment.
        // Only the linkedit segment should move, and it should have 0 sections.
        // seg should be a macho.Segment32 or macho.Segment64 as appropriate.
        // sect should be a macho.Section32 or macho.Section64 as appropriate.
        private static error machoUpdateSegment(loadCmdReader r, object seg, object sect)
        {
            {
                var err__prev1 = err;

                var err = r.ReadAt(0L, seg);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            var segValue = reflect.ValueOf(seg);
            var offset = reflect.Indirect(segValue).FieldByName("Offset"); 

            // Only the linkedit segment moved, any thing before that is fine.
            if (offset.Uint() < linkseg.Offset)
            {
                return error.As(null);
            }
            offset.SetUint(offset.Uint() + uint64(linkoffset));
            {
                var err__prev1 = err;

                err = r.WriteAt(0L, seg);

                if (err != null)
                {
                    return error.As(err);
                } 
                // There shouldn't be any sections, but just to make sure...

                err = err__prev1;

            } 
            // There shouldn't be any sections, but just to make sure...
            return error.As(machoUpdateSections(r, segValue, reflect.ValueOf(sect), uint64(linkoffset), 0L));
        }

        private static error machoUpdateSections(loadCmdReader r, reflect.Value seg, reflect.Value sect, ulong deltaOffset, ulong deltaAddr)
        {
            var iseg = reflect.Indirect(seg);
            var nsect = iseg.FieldByName("Nsect").Uint();
            if (nsect == 0L)
            {
                return error.As(null);
            }
            var sectOffset = int64(iseg.Type().Size());

            var isect = reflect.Indirect(sect);
            var offsetField = isect.FieldByName("Offset");
            var reloffField = isect.FieldByName("Reloff");
            var addrField = isect.FieldByName("Addr");
            var sectSize = int64(isect.Type().Size());
            for (var i = uint64(0L); i < nsect; i++)
            {
                {
                    var err__prev1 = err;

                    var err = r.ReadAt(sectOffset, sect.Interface());

                    if (err != null)
                    {
                        return error.As(err);
                    }

                    err = err__prev1;

                }
                if (offsetField.Uint() != 0L)
                {
                    offsetField.SetUint(offsetField.Uint() + deltaOffset);
                }
                if (reloffField.Uint() != 0L)
                {
                    reloffField.SetUint(reloffField.Uint() + deltaOffset);
                }
                if (addrField.Uint() != 0L)
                {
                    addrField.SetUint(addrField.Uint() + deltaAddr);
                }
                {
                    var err__prev1 = err;

                    err = r.WriteAt(sectOffset, sect.Interface());

                    if (err != null)
                    {
                        return error.As(err);
                    }

                    err = err__prev1;

                }
                sectOffset += sectSize;
            }

            return error.As(null);
        }

        // machoUpdateDwarfHeader updates the DWARF segment load command.
        private static error machoUpdateDwarfHeader(ref loadCmdReader r, BuildMode buildmode)
        {
            var seg = default;            var sect = default;

            var (cmd, err) = r.Next();
            if (err != null)
            {
                return error.As(err);
            }
            if (cmd.Cmd == macho.LoadCmdSegment64)
            {
                seg = @new<macho.Segment64>();
                sect = @new<macho.Section64>();
            }
            else
            {
                seg = @new<macho.Segment32>();
                sect = @new<macho.Section32>();
            }
            {
                var err__prev1 = err;

                var err = r.ReadAt(0L, seg);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            var segv = reflect.ValueOf(seg).Elem();

            segv.FieldByName("Offset").SetUint(uint64(dwarfstart));
            segv.FieldByName("Addr").SetUint(uint64(dwarfaddr));

            var deltaOffset = uint64(dwarfstart) - realdwarf.Offset;
            var deltaAddr = uint64(dwarfaddr) - realdwarf.Addr; 

            // If we set Memsz to 0 (and might as well set Addr too),
            // then the xnu kernel will bail out halfway through load_segment
            // and not apply further sanity checks that we might fail in the future.
            // We don't need the DWARF information actually available in memory.
            // But if we do this for buildmode=c-shared then the user-space
            // dynamic loader complains about memsz < filesz. Sigh.
            if (buildmode != BuildModeCShared)
            {
                segv.FieldByName("Addr").SetUint(0L);
                segv.FieldByName("Memsz").SetUint(0L);
                deltaAddr = 0L;
            }
            {
                var err__prev1 = err;

                err = r.WriteAt(0L, seg);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            return error.As(machoUpdateSections(r.Value, segv, reflect.ValueOf(sect), deltaOffset, deltaAddr));
        }

        private static error machoUpdateLoadCommand(loadCmdReader r, object cmd, params @string[] fields)
        {
            fields = fields.Clone();

            {
                var err__prev1 = err;

                var err = r.ReadAt(0L, cmd);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            var value = reflect.Indirect(reflect.ValueOf(cmd));

            foreach (var (_, name) in fields)
            {
                var field = value.FieldByName(name);
                var fieldval = field.Uint();
                if (fieldval >= linkseg.Offset)
                {
                    field.SetUint(fieldval + uint64(linkoffset));
                }
            }
            {
                var err__prev1 = err;

                err = r.WriteAt(0L, cmd);

                if (err != null)
                {
                    return error.As(err);
                }

                err = err__prev1;

            }
            return error.As(null);
        }

        private static long machoCalcStart(ulong origAddr, ulong newAddr, uint alignExp)
        {
            var align = uint64(1L << (int)(alignExp));
            if ((origAddr % align) == (newAddr % align))
            {
                return int64(newAddr);
            }
            var padding = (align - (newAddr % align));
            padding += origAddr % align;
            return int64(padding + newAddr);
        }
    }
}}}}
