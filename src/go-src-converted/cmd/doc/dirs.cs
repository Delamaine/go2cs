// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package main -- go2cs converted at 2020 August 29 10:00:02 UTC
// Original source: C:\Go\src\cmd\doc\dirs.go
using build = go.go.build_package;
using log = go.log_package;
using os = go.os_package;
using path = go.path_package;
using filepath = go.path.filepath_package;
using strings = go.strings_package;
using static go.builtin;
using System.Threading;

namespace go
{
    public static partial class main_package
    {
        // Dirs is a structure for scanning the directory tree.
        // Its Next method returns the next Go source directory it finds.
        // Although it can be used to scan the tree multiple times, it
        // only walks the tree once, caching the data it finds.
        public partial struct Dirs
        {
            public channel<@string> scan; // directories generated by walk.
            public slice<@string> paths; // Cache of known paths.
            public long offset; // Counter for Next.
        }

        private static Dirs dirs = default;

        private static void init()
        {
            dirs.paths = make_slice<@string>(0L, 1000L);
            dirs.scan = make_channel<@string>();
            go_(() => dirs.walk());
        }

        // Reset puts the scan back at the beginning.
        private static void Reset(this ref Dirs d)
        {
            d.offset = 0L;
        }

        // Next returns the next directory in the scan. The boolean
        // is false when the scan is done.
        private static (@string, bool) Next(this ref Dirs d)
        {
            if (d.offset < len(d.paths))
            {
                var path = d.paths[d.offset];
                d.offset++;
                return (path, true);
            }
            var (path, ok) = d.scan.Receive();
            if (!ok)
            {
                return ("", false);
            }
            d.paths = append(d.paths, path);
            d.offset++;
            return (path, ok);
        }

        // walk walks the trees in GOROOT and GOPATH.
        private static void walk(this ref Dirs d)
        {
            d.bfsWalkRoot(build.Default.GOROOT);
            foreach (var (_, root) in splitGopath())
            {
                d.bfsWalkRoot(root);
            }
            close(d.scan);
        }

        // bfsWalkRoot walks a single directory hierarchy in breadth-first lexical order.
        // Each Go source directory it finds is delivered on d.scan.
        private static void bfsWalkRoot(this ref Dirs d, @string root)
        {
            root = path.Join(root, "src"); 

            // this is the queue of directories to examine in this pass.
            @string @this = new slice<@string>(new @string[] {  }); 
            // next is the queue of directories to examine in the next pass.
            @string next = new slice<@string>(new @string[] { root });

            while (len(next) > 0L)
            {
                this = next;
                next = this[0L..0L];
                foreach (var (_, dir) in this)
                {
                    var (fd, err) = os.Open(dir);
                    if (err != null)
                    {
                        log.Print(err);
                        continue;
                    }
                    var (entries, err) = fd.Readdir(0L);
                    fd.Close();
                    if (err != null)
                    {
                        log.Print(err);
                        continue;
                    }
                    var hasGoFiles = false;
                    foreach (var (_, entry) in entries)
                    {
                        var name = entry.Name(); 
                        // For plain files, remember if this directory contains any .go
                        // source files, but ignore them otherwise.
                        if (!entry.IsDir())
                        {
                            if (!hasGoFiles && strings.HasSuffix(name, ".go"))
                            {
                                hasGoFiles = true;
                            }
                            continue;
                        } 
                        // Entry is a directory.
                        // No .git or other dot nonsense please.
                        if (strings.HasPrefix(name, "."))
                        {
                            continue;
                        } 
                        // Remember this (fully qualified) directory for the next pass.
                        next = append(next, filepath.Join(dir, name));
                    }
                    if (hasGoFiles)
                    { 
                        // It's a candidate.
                        d.scan.Send(dir);
                    }
                }
            }

        }
    }
}
