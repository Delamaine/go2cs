// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

// package windows -- go2cs converted at 2020 August 29 08:22:36 UTC
// import "internal/syscall/windows" ==> using windows = go.@internal.syscall.windows_package
// Original source: C:\Go\src\internal\syscall\windows\zsyscall_windows.go
using sysdll = go.@internal.syscall.windows.sysdll_package;
using syscall = go.syscall_package;
using @unsafe = go.@unsafe_package;
using static go.builtin;

namespace go {
namespace @internal {
namespace syscall
{
    public static partial class windows_package
    {
        private static unsafe.Pointer _ = default;

        // Do the interface allocations only once for common
        // Errno values.
        private static readonly long errnoERROR_IO_PENDING = 997L;

        private static error errERROR_IO_PENDING = error.As(syscall.Errno(errnoERROR_IO_PENDING));

        // errnoErr returns common boxed Errno values, to prevent
        // allocations at runtime.
        private static error errnoErr(syscall.Errno e)
        {

            if (e == 0L) 
                return error.As(null);
            else if (e == errnoERROR_IO_PENDING) 
                return error.As(errERROR_IO_PENDING);
            // TODO: add more here, after collecting data on the common
            // error values see on Windows. (perhaps when running
            // all.bat?)
            return error.As(e);
        }

        private static var modiphlpapi = syscall.NewLazyDLL(sysdll.Add("iphlpapi.dll"));        private static var modkernel32 = syscall.NewLazyDLL(sysdll.Add("kernel32.dll"));        private static var modws2_32 = syscall.NewLazyDLL(sysdll.Add("ws2_32.dll"));        private static var modnetapi32 = syscall.NewLazyDLL(sysdll.Add("netapi32.dll"));        private static var modadvapi32 = syscall.NewLazyDLL(sysdll.Add("advapi32.dll"));        private static var modpsapi = syscall.NewLazyDLL(sysdll.Add("psapi.dll"));        private static var procGetAdaptersAddresses = modiphlpapi.NewProc("GetAdaptersAddresses");        private static var procGetComputerNameExW = modkernel32.NewProc("GetComputerNameExW");        private static var procMoveFileExW = modkernel32.NewProc("MoveFileExW");        private static var procGetModuleFileNameW = modkernel32.NewProc("GetModuleFileNameW");        private static var procWSASocketW = modws2_32.NewProc("WSASocketW");        private static var procGetACP = modkernel32.NewProc("GetACP");        private static var procGetConsoleCP = modkernel32.NewProc("GetConsoleCP");        private static var procMultiByteToWideChar = modkernel32.NewProc("MultiByteToWideChar");        private static var procGetCurrentThread = modkernel32.NewProc("GetCurrentThread");        private static var procNetShareAdd = modnetapi32.NewProc("NetShareAdd");        private static var procNetShareDel = modnetapi32.NewProc("NetShareDel");        private static var procGetFinalPathNameByHandleW = modkernel32.NewProc("GetFinalPathNameByHandleW");        private static var procImpersonateSelf = modadvapi32.NewProc("ImpersonateSelf");        private static var procRevertToSelf = modadvapi32.NewProc("RevertToSelf");        private static var procOpenThreadToken = modadvapi32.NewProc("OpenThreadToken");        private static var procLookupPrivilegeValueW = modadvapi32.NewProc("LookupPrivilegeValueW");        private static var procAdjustTokenPrivileges = modadvapi32.NewProc("AdjustTokenPrivileges");        private static var procDuplicateTokenEx = modadvapi32.NewProc("DuplicateTokenEx");        private static var procSetTokenInformation = modadvapi32.NewProc("SetTokenInformation");        private static var procGetProcessMemoryInfo = modpsapi.NewProc("GetProcessMemoryInfo");

        public static error GetAdaptersAddresses(uint family, uint flags, System.UIntPtr reserved, ref IpAdapterAddresses adapterAddresses, ref uint sizePointer)
        {
            var (r0, _, _) = syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5L, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(@unsafe.Pointer(adapterAddresses)), uintptr(@unsafe.Pointer(sizePointer)), 0L);
            if (r0 != 0L)
            {
                errcode = syscall.Errno(r0);
            }
            return;
        }

        public static error GetComputerNameEx(uint nameformat, ref ushort buf, ref uint n)
        {
            var (r1, _, e1) = syscall.Syscall(procGetComputerNameExW.Addr(), 3L, uintptr(nameformat), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(n)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error MoveFileEx(ref ushort from, ref ushort to, uint flags)
        {
            var (r1, _, e1) = syscall.Syscall(procMoveFileExW.Addr(), 3L, uintptr(@unsafe.Pointer(from)), uintptr(@unsafe.Pointer(to)), uintptr(flags));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static (uint, error) GetModuleFileName(syscall.Handle module, ref ushort fn, uint len)
        {
            var (r0, _, e1) = syscall.Syscall(procGetModuleFileNameW.Addr(), 3L, uintptr(module), uintptr(@unsafe.Pointer(fn)), uintptr(len));
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static (syscall.Handle, error) WSASocket(int af, int typ, int protocol, ref syscall.WSAProtocolInfo protinfo, uint group, uint flags)
        {
            var (r0, _, e1) = syscall.Syscall6(procWSASocketW.Addr(), 6L, uintptr(af), uintptr(typ), uintptr(protocol), uintptr(@unsafe.Pointer(protinfo)), uintptr(group), uintptr(flags));
            handle = syscall.Handle(r0);
            if (handle == syscall.InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static uint GetACP()
        {
            var (r0, _, _) = syscall.Syscall(procGetACP.Addr(), 0L, 0L, 0L, 0L);
            acp = uint32(r0);
            return;
        }

        public static uint GetConsoleCP()
        {
            var (r0, _, _) = syscall.Syscall(procGetConsoleCP.Addr(), 0L, 0L, 0L, 0L);
            ccp = uint32(r0);
            return;
        }

        public static (int, error) MultiByteToWideChar(uint codePage, uint dwFlags, ref byte str, int nstr, ref ushort wchar, int nwchar)
        {
            var (r0, _, e1) = syscall.Syscall6(procMultiByteToWideChar.Addr(), 6L, uintptr(codePage), uintptr(dwFlags), uintptr(@unsafe.Pointer(str)), uintptr(nstr), uintptr(@unsafe.Pointer(wchar)), uintptr(nwchar));
            nwrite = int32(r0);
            if (nwrite == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static (syscall.Handle, error) GetCurrentThread()
        {
            var (r0, _, e1) = syscall.Syscall(procGetCurrentThread.Addr(), 0L, 0L, 0L, 0L);
            pseudoHandle = syscall.Handle(r0);
            if (pseudoHandle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error NetShareAdd(ref ushort serverName, uint level, ref byte buf, ref ushort parmErr)
        {
            var (r0, _, _) = syscall.Syscall6(procNetShareAdd.Addr(), 4L, uintptr(@unsafe.Pointer(serverName)), uintptr(level), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(parmErr)), 0L, 0L);
            if (r0 != 0L)
            {
                neterr = syscall.Errno(r0);
            }
            return;
        }

        public static error NetShareDel(ref ushort serverName, ref ushort netName, uint reserved)
        {
            var (r0, _, _) = syscall.Syscall(procNetShareDel.Addr(), 3L, uintptr(@unsafe.Pointer(serverName)), uintptr(@unsafe.Pointer(netName)), uintptr(reserved));
            if (r0 != 0L)
            {
                neterr = syscall.Errno(r0);
            }
            return;
        }

        public static (uint, error) GetFinalPathNameByHandle(syscall.Handle file, ref ushort filePath, uint filePathSize, uint flags)
        {
            var (r0, _, e1) = syscall.Syscall6(procGetFinalPathNameByHandleW.Addr(), 4L, uintptr(file), uintptr(@unsafe.Pointer(filePath)), uintptr(filePathSize), uintptr(flags), 0L, 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error ImpersonateSelf(uint impersonationlevel)
        {
            var (r1, _, e1) = syscall.Syscall(procImpersonateSelf.Addr(), 1L, uintptr(impersonationlevel), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error RevertToSelf()
        {
            var (r1, _, e1) = syscall.Syscall(procRevertToSelf.Addr(), 0L, 0L, 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error OpenThreadToken(syscall.Handle h, uint access, bool openasself, ref syscall.Token token)
        {
            uint _p0 = default;
            if (openasself)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }
            var (r1, _, e1) = syscall.Syscall6(procOpenThreadToken.Addr(), 4L, uintptr(h), uintptr(access), uintptr(_p0), uintptr(@unsafe.Pointer(token)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error LookupPrivilegeValue(ref ushort systemname, ref ushort name, ref LUID luid)
        {
            var (r1, _, e1) = syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3L, uintptr(@unsafe.Pointer(systemname)), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(luid)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        private static (uint, error) adjustTokenPrivileges(syscall.Token token, bool disableAllPrivileges, ref TOKEN_PRIVILEGES newstate, uint buflen, ref TOKEN_PRIVILEGES prevstate, ref uint returnlen)
        {
            uint _p0 = default;
            if (disableAllPrivileges)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }
            var (r0, _, e1) = syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6L, uintptr(token), uintptr(_p0), uintptr(@unsafe.Pointer(newstate)), uintptr(buflen), uintptr(@unsafe.Pointer(prevstate)), uintptr(@unsafe.Pointer(returnlen)));
            ret = uint32(r0);
            if (true)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error DuplicateTokenEx(syscall.Token hExistingToken, uint dwDesiredAccess, ref syscall.SecurityAttributes lpTokenAttributes, uint impersonationLevel, TokenType tokenType, ref syscall.Token phNewToken)
        {
            var (r1, _, e1) = syscall.Syscall6(procDuplicateTokenEx.Addr(), 6L, uintptr(hExistingToken), uintptr(dwDesiredAccess), uintptr(@unsafe.Pointer(lpTokenAttributes)), uintptr(impersonationLevel), uintptr(tokenType), uintptr(@unsafe.Pointer(phNewToken)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error SetTokenInformation(syscall.Token tokenHandle, uint tokenInformationClass, System.UIntPtr tokenInformation, uint tokenInformationLength)
        {
            var (r1, _, e1) = syscall.Syscall6(procSetTokenInformation.Addr(), 4L, uintptr(tokenHandle), uintptr(tokenInformationClass), uintptr(tokenInformation), uintptr(tokenInformationLength), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }

        public static error GetProcessMemoryInfo(syscall.Handle handle, ref PROCESS_MEMORY_COUNTERS memCounters, uint cb)
        {
            var (r1, _, e1) = syscall.Syscall(procGetProcessMemoryInfo.Addr(), 3L, uintptr(handle), uintptr(@unsafe.Pointer(memCounters)), uintptr(cb));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = syscall.EINVAL;
                }
            }
            return;
        }
    }
}}}
