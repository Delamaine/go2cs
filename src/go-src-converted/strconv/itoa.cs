// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package strconv -- go2cs converted at 2020 August 29 08:42:57 UTC
// import "strconv" ==> using strconv = go.strconv_package
// Original source: C:\Go\src\strconv\itoa.go

using static go.builtin;

namespace go
{
    public static partial class strconv_package
    {
        private static readonly var fastSmalls = true; // enable fast path for small integers

        // FormatUint returns the string representation of i in the given base,
        // for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
        // for digit values >= 10.
 // enable fast path for small integers

        // FormatUint returns the string representation of i in the given base,
        // for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
        // for digit values >= 10.
        public static @string FormatUint(ulong i, long @base)
        {
            if (fastSmalls && i < nSmalls && base == 10L)
            {
                return small(int(i));
            }
            var (_, s) = formatBits(null, i, base, false, false);
            return s;
        }

        // FormatInt returns the string representation of i in the given base,
        // for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
        // for digit values >= 10.
        public static @string FormatInt(long i, long @base)
        {
            if (fastSmalls && 0L <= i && i < nSmalls && base == 10L)
            {
                return small(int(i));
            }
            var (_, s) = formatBits(null, uint64(i), base, i < 0L, false);
            return s;
        }

        // Itoa is shorthand for FormatInt(int64(i), 10).
        public static @string Itoa(long i)
        {
            return FormatInt(int64(i), 10L);
        }

        // AppendInt appends the string form of the integer i,
        // as generated by FormatInt, to dst and returns the extended buffer.
        public static slice<byte> AppendInt(slice<byte> dst, long i, long @base)
        {
            if (fastSmalls && 0L <= i && i < nSmalls && base == 10L)
            {
                return append(dst, small(int(i)));
            }
            dst, _ = formatBits(dst, uint64(i), base, i < 0L, true);
            return dst;
        }

        // AppendUint appends the string form of the unsigned integer i,
        // as generated by FormatUint, to dst and returns the extended buffer.
        public static slice<byte> AppendUint(slice<byte> dst, ulong i, long @base)
        {
            if (fastSmalls && i < nSmalls && base == 10L)
            {
                return append(dst, small(int(i)));
            }
            dst, _ = formatBits(dst, i, base, false, true);
            return dst;
        }

        // small returns the string for an i with 0 <= i < nSmalls.
        private static @string small(long i)
        {
            long off = 0L;
            if (i < 10L)
            {
                off = 1L;
            }
            return smallsString[i * 2L + off..i * 2L + 2L];
        }

        private static readonly long nSmalls = 100L;



        private static readonly @string smallsString = "00010203040506070809" + "10111213141516171819" + "20212223242526272829" + "30313233343536373839" + "40414243444546474849" + "50515253545556575859" + "60616263646566676869" + "70717273747576777879" + "80818283848586878889" + "90919293949596979899";



        private static readonly var host32bit = ~uint(0L) >> (int)(32L) == 0L;



        private static readonly @string digits = "0123456789abcdefghijklmnopqrstuvwxyz";



        private static array<ulong> shifts = new array<ulong>(InitKeyedValues<ulong>(len(digits)+1, (1<<1, 1), (1<<2, 2), (1<<3, 3), (1<<4, 4), (1<<5, 5)));

        // formatBits computes the string representation of u in the given base.
        // If neg is set, u is treated as negative int64 value. If append_ is
        // set, the string is appended to dst and the resulting byte slice is
        // returned as the first result value; otherwise the string is returned
        // as the second result value.
        //
        private static (slice<byte>, @string) formatBits(slice<byte> dst, ulong u, long @base, bool neg, bool append_) => func((_, panic, __) =>
        {
            if (base < 2L || base > len(digits))
            {
                panic("strconv: illegal AppendInt/FormatInt base");
            } 
            // 2 <= base && base <= len(digits)
            array<byte> a = new array<byte>(64L + 1L); // +1 for sign of 64bit value in base 2
            var i = len(a);

            if (neg)
            {
                u = -u;
            } 

            // convert bits
            // We use uint values where we can because those will
            // fit into a single register even on a 32bit machine.
            if (base == 10L)
            { 
                // common case: use constants for / because
                // the compiler can optimize it into a multiply+shift

                if (host32bit)
                { 
                    // convert the lower digits using 32bit operations
                    while (u >= 1e9F)
                    { 
                        // Avoid using r = a%b in addition to q = a/b
                        // since 64bit division and modulo operations
                        // are calculated by runtime functions on 32bit machines.
                        var q = u / 1e9F;
                        var us = uint(u - q * 1e9F); // u % 1e9 fits into a uint
                        for (long j = 4L; j > 0L; j--)
                        {
                            var @is = us % 100L * 2L;
                            us /= 100L;
                            i -= 2L;
                            a[i + 1L] = smallsString[is + 1L];
                            a[i + 0L] = smallsString[is + 0L];
                        } 

                        // us < 10, since it contains the last digit
                        // from the initial 9-digit us.
 

                        // us < 10, since it contains the last digit
                        // from the initial 9-digit us.
                        i--;
                        a[i] = smallsString[us * 2L + 1L];

                        u = q;
                    } 
                    // u < 1e9
 
                    // u < 1e9
                } 

                // u guaranteed to fit into a uint
                us = uint(u);
                while (us >= 100L)
                {
                    @is = us % 100L * 2L;
                    us /= 100L;
                    i -= 2L;
                    a[i + 1L] = smallsString[is + 1L];
                    a[i + 0L] = smallsString[is + 0L];
                } 

                // us < 100
 

                // us < 100
                @is = us * 2L;
                i--;
                a[i] = smallsString[is + 1L];
                if (us >= 10L)
                {
                    i--;
                    a[i] = smallsString[is];
                }
            }            {
                var s = shifts[base];


                else if (s > 0L)
                { 
                    // base is power of 2: use shifts and masks instead of / and %
                    var b = uint64(base);
                    var m = uint(base) - 1L; // == 1<<s - 1
                    while (u >= b)
                    {
                        i--;
                        a[i] = digits[uint(u) & m];
                        u >>= s;
                    }
                else
 
                    // u < base
 
                    // u < base
                    i--;
                    a[i] = digits[uint(u)];
                }                { 
                    // general case
                    b = uint64(base);
                    while (u >= b)
                    {
                        i--; 
                        // Avoid using r = a%b in addition to q = a/b
                        // since 64bit division and modulo operations
                        // are calculated by runtime functions on 32bit machines.
                        q = u / b;
                        a[i] = digits[uint(u - q * b)];
                        u = q;
                    } 
                    // u < base
 
                    // u < base
                    i--;
                    a[i] = digits[uint(u)];
                } 

                // add sign, if any

            } 

            // add sign, if any
            if (neg)
            {
                i--;
                a[i] = '-';
            }
            if (append_)
            {
                d = append(dst, a[i..]);
                return;
            }
            s = string(a[i..]);
            return;
        });
    }
}
